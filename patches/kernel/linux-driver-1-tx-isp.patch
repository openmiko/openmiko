diff -Nura kernel-3.10.14/drivers/media/platform/Makefile kernel-3.10.14_mod/drivers/media/platform/Makefile
--- kernel-3.10.14/drivers/media/platform/Makefile	2018-09-21 16:40:46.000000000 +0200
+++ kernel-3.10.14_mod/drivers/media/platform/Makefile	2018-11-09 02:38:15.117932482 +0100
@@ -51,3 +51,5 @@
 obj-$(CONFIG_ARCH_OMAP)	+= omap/
 
 ccflags-y += -I$(srctree)/drivers/media/i2c
+
+obj-$(CONFIG_VIDEO_TX_ISP)		+= tx-isp/
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_calibrations.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_calibrations.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_calibrations.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_calibrations.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,528 @@
+/*-----------------------------------------------------------------------------
+     This confidential and proprietary software/information may be used only
+        as authorized by a licensing agreement from Apical Limited
+
+                   (C) COPYRIGHT 2011 - 2015 Apical Limited
+                          ALL RIGHTS RESERVED
+
+      The entire notice above must be reproduced on all authorized
+       copies and copies may only be made to the extent permitted
+             by a licensing agreement from Apical Limited.
+-----------------------------------------------------------------------------*/
+
+#include <apical-isp/apical.h>
+#include "apical_calibrations_init.h"
+#include <apical-isp/apical_firmware_config.h>
+#include "log.h"
+
+
+
+// declare all functions which will return isp and sensor settings
+extern uint32_t get_static_calibrations( ApicalCalibrations *) ;
+extern uint32_t get_dynamic_calibrations( ApicalCalibrations *) ;
+
+#if CALIBRATION_PREVIEW_SET_SUPPORT== 1
+extern uint32_t get_dynamic_calibrations_pr( ApicalCalibrations *) ;
+extern uint32_t get_static_calibrations_pr( ApicalCalibrations *) ;
+#endif
+
+// you can use as many calibrations set as you need
+uint32_t (*static_calibrations_func[])( ApicalCalibrations *) = {
+    get_static_calibrations
+#if CALIBRATION_PREVIEW_SET_SUPPORT == 1
+    ,get_static_calibrations_pr
+#endif
+    } ;
+
+
+uint32_t (*dynamic_calibrations_func[])( ApicalCalibrations *) = {
+    get_dynamic_calibrations
+#if CALIBRATION_PREVIEW_SET_SUPPORT == 1
+    ,get_dynamic_calibrations_pr
+#endif
+     } ;
+
+// current settings for sensor and isp
+ApicalCalibrations apicalCalibrations ;
+
+
+#if RESTRICTED_SOURCES==0
+    // use this array only for debug purposes
+    // to detect calibrations which are not initialized but
+    // used inside firmware.
+    // it should be disabled in the release version to save memory
+    char *s_calibrationID[] = {
+        "_CALIBRATION_LUTS_START_INDEX",
+        "_CALIBRATION_NOISE_PROFILE_LINEAR",
+        "_CALIBRATION_NOISE_PROFILE_FS_HDR",
+        "_CALIBRATION_NOISE_PROFILE_NATIVE",
+        "_CALIBRATION_NOISE_PROFILE_FS_LIN",
+        "_CALIBRATION_NOISE_PROFILE_STOP",
+        "_CALIBRATION_DEMOSAIC_LINEAR",
+        "_CALIBRATION_DEMOSAIC_FS_HDR",
+        "_CALIBRATION_DEMOSAIC_NATIVE",
+        "_CALIBRATION_DEMOSAIC_FS_LIN",
+        "_CALIBRATION_DEMOSAIC_STOP",
+        "_CALIBRATION_GAMMA_LINEAR",
+        "_CALIBRATION_GAMMA_FS_HDR",
+        "_CALIBRATION_GAMMA_NATIVE",
+        "_CALIBRATION_GAMMA_FS_LIN",
+        "_CALIBRATION_GAMMA_STOP",
+        "_CALIBRATION_GAMMA_BE_0_LINEAR",
+        "_CALIBRATION_GAMMA_BE_0_FS_HDR",
+        "_CALIBRATION_GAMMA_BE_0_NATIVE",
+        "_CALIBRATION_GAMMA_BE_0_FS_LIN",
+        "_CALIBRATION_GAMMA_BE_0_STOP",
+        "_CALIBRATION_GAMMA_BE_1_LINEAR",
+        "_CALIBRATION_GAMMA_BE_1_FS_HDR",
+        "_CALIBRATION_GAMMA_BE_1_NATIVE",
+        "_CALIBRATION_GAMMA_BE_1_FS_LIN",
+        "_CALIBRATION_GAMMA_BE_1_STOP",
+        "_CALIBRATION_GAMMA_FE_0_LINEAR",
+        "_CALIBRATION_GAMMA_FE_0_FS_HDR",
+        "_CALIBRATION_GAMMA_FE_0_NATIVE",
+        "_CALIBRATION_GAMMA_FE_0_FS_LIN",
+        "_CALIBRATION_GAMMA_FE_0_STOP",
+        "_CALIBRATION_GAMMA_FE_1_LINEAR",
+        "_CALIBRATION_GAMMA_FE_1_FS_HDR",
+        "_CALIBRATION_GAMMA_FE_1_NATIVE",
+        "_CALIBRATION_GAMMA_FE_1_FS_LIN",
+        "_CALIBRATION_GAMMA_FE_1_STOP",
+        "_CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR",
+        "_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR",
+        "_CALIBRATION_IRIDIX_EV_LIM_NO_STR_NATIVE",
+        "_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_LIN",
+        "_CALIBRATION_IRIDIX_EV_LIM_NO_STR_STOP",
+        "_CALIBRATION_AE_CORRECTION_LINEAR",
+        "_CALIBRATION_AE_CORRECTION_FS_HDR",
+        "_CALIBRATION_AE_CORRECTION_NATIVE",
+        "_CALIBRATION_AE_CORRECTION_FS_LIN",
+        "_CALIBRATION_AE_CORRECTION_STOP",
+        "_CALIBRATION_SINTER_STRENGTH_LINEAR",
+        "_CALIBRATION_SINTER_STRENGTH_FS_HDR",
+        "_CALIBRATION_SINTER_STRENGTH_NATIVE",
+        "_CALIBRATION_SINTER_STRENGTH_FS_LIN",
+        "_CALIBRATION_SINTER_STRENGTH_STOP",
+        "_CALIBRATION_SINTER_STRENGTH1_LINEAR",
+        "_CALIBRATION_SINTER_STRENGTH1_FS_HDR",
+        "_CALIBRATION_SINTER_STRENGTH1_NATIVE",
+        "_CALIBRATION_SINTER_STRENGTH1_FS_LIN",
+        "_CALIBRATION_SINTER_STRENGTH1_STOP",
+        "_CALIBRATION_SINTER_THRESH1_LINEAR",
+        "_CALIBRATION_SINTER_THRESH1_FS_HDR",
+        "_CALIBRATION_SINTER_THRESH1_NATIVE",
+        "_CALIBRATION_SINTER_THRESH1_FS_LIN",
+        "_CALIBRATION_SINTER_THRESH1_STOP",
+        "_CALIBRATION_SINTER_THRESH4_LINEAR",
+        "_CALIBRATION_SINTER_THRESH4_FS_HDR",
+        "_CALIBRATION_SINTER_THRESH4_NATIVE",
+        "_CALIBRATION_SINTER_THRESH4_FS_LIN",
+        "_CALIBRATION_SINTER_THRESH4_STOP",
+        "_CALIBRATION_SHARP_ALT_D_LINEAR",
+        "_CALIBRATION_SHARP_ALT_D_FS_HDR",
+        "_CALIBRATION_SHARP_ALT_D_NATIVE",
+        "_CALIBRATION_SHARP_ALT_D_FS_LIN",
+        "_CALIBRATION_SHARP_ALT_D_STOP",
+        "_CALIBRATION_SHARP_ALT_UD_LINEAR",
+        "_CALIBRATION_SHARP_ALT_UD_FS_HDR",
+        "_CALIBRATION_SHARP_ALT_UD_NATIVE",
+        "_CALIBRATION_SHARP_ALT_UD_FS_LIN",
+        "_CALIBRATION_SHARP_ALT_UD_STOP",
+        "_CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR",
+        "_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR",
+        "_CALIBRATION_DEMOSAIC_NP_OFFSET_NATIVE",
+        "_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_LIN",
+        "_CALIBRATION_DEMOSAIC_NP_OFFSET_STOP",
+        "_CALIBRATION_SATURATION_STRENGTH_LINEAR",
+        "_CALIBRATION_SATURATION_STRENGTH_FS_HDR",
+        "_CALIBRATION_SATURATION_STRENGTH_NATIVE",
+        "_CALIBRATION_SATURATION_STRENGTH_FS_LIN",
+        "_CALIBRATION_SATURATION_STRENGTH_STOP",
+        "_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR",
+        "_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR",
+        "_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM - INVALID",
+        "_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM - INVALID",
+        "_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_STOP",
+        "_CALIBRATION_SINTER_SAD_LINEAR",
+        "_CALIBRATION_SINTER_SAD_WDR",
+        "_CALIBRATION_SINTER_SAD - INVALID",
+        "_CALIBRATION_SINTER_SAD - INVALID",
+        "_CALIBRATION_SINTER_SAD_STOP",
+        "_CALIBRATION_SHARPEN_FR_LINEAR",
+        "_CALIBRATION_SHARPEN_FR_WDR",
+        "_CALIBRATION_SHARPEN_FR - INVALID",
+        "_CALIBRATION_SHARPEN_FR - INVALID",
+        "_CALIBRATION_SHARPEN_FR_STOP",
+        "_CALIBRATION_SHARPEN_DS1_LINEAR",
+        "_CALIBRATION_SHARPEN_DS1_WDR",
+        "_CALIBRATION_SHARPEN_DS1 - INVALID",
+        "_CALIBRATION_SHARPEN_DS1 - INVALID",
+        "_CALIBRATION_SHARPEN_DS1_STOP",
+        "_CALIBRATION_SHARPEN_DS2_LINEAR",
+        "_CALIBRATION_SHARPEN_DS2_WDR",
+        "_CALIBRATION_SHARPEN_DS2 - INVALID",
+        "_CALIBRATION_SHARPEN_DS2 - INVALID",
+        "_CALIBRATION_SHARPEN_DS2_STOP",
+        "_CALIBRATION_BLACK_LEVEL_R_LINEAR",
+        "_CALIBRATION_BLACK_LEVEL_R_FS_HDR",
+        "_CALIBRATION_BLACK_LEVEL_R_NATIVE",
+        "_CALIBRATION_BLACK_LEVEL_R_FS_LIN",
+        "_CALIBRATION_BLACK_LEVEL_R_STOP",
+        "_CALIBRATION_BLACK_LEVEL_B_LINEAR",
+        "_CALIBRATION_BLACK_LEVEL_B_FS_HDR",
+        "_CALIBRATION_BLACK_LEVEL_B_NATIVE",
+        "_CALIBRATION_BLACK_LEVEL_B_FS_LIN",
+        "_CALIBRATION_BLACK_LEVEL_B_STOP",
+        "_CALIBRATION_BLACK_LEVEL_GB_LINEAR",
+        "_CALIBRATION_BLACK_LEVEL_GB_FS_HDR",
+        "_CALIBRATION_BLACK_LEVEL_GB_NATIVE",
+        "_CALIBRATION_BLACK_LEVEL_GB_FS_LIN",
+        "_CALIBRATION_BLACK_LEVEL_GB_STOP",
+        "_CALIBRATION_BLACK_LEVEL_GR_LINEAR",
+        "_CALIBRATION_BLACK_LEVEL_GR_FS_HDR",
+        "_CALIBRATION_BLACK_LEVEL_GR_NATIVE",
+        "_CALIBRATION_BLACK_LEVEL_GR_FS_LIN",
+        "_CALIBRATION_BLACK_LEVEL_GR_STOP",
+        "_CALIBRATION_DP_SLOPE_LINEAR",
+        "_CALIBRATION_DP_SLOPE_FS_HDR",
+        "_CALIBRATION_DP_SLOPE_NATIVE",
+        "_CALIBRATION_DP_SLOPE_FS_LIN",
+        "_CALIBRATION_DP_SLOPE_FS_STOP",
+        "_CALIBRATION_DP_THRESHOLD_LINEAR",
+        "_CALIBRATION_DP_THRESHOLD_FS_HDR",
+        "_CALIBRATION_DP_THRESHOLD_NATIVE",
+        "_CALIBRATION_DP_THRESHOLD_FS_LIN",
+        "_CALIBRATION_DP_THRESHOLD_FS_STOP",
+        "_CALIBRATION_AE_BALANCED_LINEAR",
+        "_CALIBRATION_AE_BALANCED_WDR",
+        "_CALIBRATION_AE_BALANCED - INVALID",
+        "_CALIBRATION_AE_BALANCED - INVALID",
+        "_CALIBRATION_AE_BALANCED_STOP",
+        "_CALIBRATION_EVTOLUX_EV_LUT_LINEAR",
+        "_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR",
+        "_CALIBRATION_EVTOLUX_EV_LUT_NATIVE",
+        "_CALIBRATION_EVTOLUX_EV_LUT_FS_LIN",
+        "_CALIBRATION_EVTOLUX_EV_LUT_STOP",
+        "_CALIBRATION_STITCHING_ERROR_THRESH",
+        "_CALIBRATION_MESH_SHADING_STRENGTH",
+        "_CALIBRATION_IRIDIX_RGB2REC709",
+        "_CALIBRATION_IRIDIX_REC709TORGB",
+        "_CALIBRATION_TEMPER_STRENGTH",
+        "_CALIBRATION_AE_EXPOSURE_CORRECTION",
+        "_CALIBRATION_IRIDIX_ASYMMETRY",
+        "_CALIBRATION_IRIDIX_BLACK_PRC",
+        "_CALIBRATION_IRIDIX_GAIN_MAX",
+        "_CALIBRATION_IRIDIX_MIN_MAX_STR",
+        "_CALIBRATION_IRIDIX_EV_LIM_FULL_STR",
+        "_CALIBRATION_LUXLOW_LUT",
+        "_CALIBRATION_MT_ABSOLUTE_LS_A_CCM_LINEAR",
+        "_CALIBRATION_MESH_COLOR_TEMPERATURE",
+        "_CALIBRATION_RGHIGH_LUT_MIN",
+        "_CALIBRATION_CT30POS",
+        "_CALIBRATION_MESH_LS_WEIGHT",
+        "_CALIBRATION_AWB_WARMING_LS_D50",
+        "_CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_LINEAR",
+        "_CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_LINEAR",
+        "_CALIBRATION_CT65POS",
+        "_CALIBRATION_AUTO_WB",
+        "_CALIBRATION_SHADING_LS_TL84_G",
+        "_CALIBRATION_AWB_WARMING_LS_A",
+        "_CALIBRATION_SHADING_LS_A_G",
+        "_CALIBRATION_CT_RG_POS_CALC",
+        "_CALIBRATION_SHADING_LS_D65_R",
+        "_CALIBRATION_RGHIGH_LUT_MAX",
+        "_CALIBRATION_RG_POS",
+        "_CALIBRATION_LUXLOW_LUT_STEP",
+        "_CALIBRATION_CT_BG_POS_CALC",
+        "_CALIBRATION_SHADING_LS_D65_B",
+        "_CALIBRATION_RGLOW_LUT_STEP",
+        "_CALIBRATION_WB_STRENGTH",
+        "_CALIBRATION_LUXLOW_LUT_MIN",
+        "_CALIBRATION_SKIN_TONE_CCM",
+        "_CALIBRATION_STATIC_WB",
+        "_CALIBRATION_AWB_WARMING_LS_D40",
+        "_CALIBRATION_COLOR_TEMP",
+        "_CALIBRATION_RGLOW_LUT_MIN",
+        "_CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_HDR",
+        "_CALIBRATION_MESH_RGBG_WEIGHT",
+        "_CALIBRATION_LIGHT_SRC",
+        "_CALIBRATION_RGLOW_LUT_MAX",
+        "_CALIBRATION_SHADING_LS_A_R",
+        "_CALIBRATION_CT40POS",
+        "_CALIBRATION_MT_ABSOLUTE_LS_A_CCM_HDR",
+        "_CALIBRATION_EVTOLUX_LUX_LUT",
+        "_CALIBRATION_LUXHIGH_LUT_STEP",
+        "_CALIBRATION_SHADING_LS_TL84_B",
+        "_CALIBRATION_SHADING_LS_D65_G",
+        "_CALIBRATION_RGHIGH_LUT",
+        "_CALIBRATION_LUXLOW_LUT_MAX",
+        "_CALIBRATION_SHADING_LS_A_B",
+        "_CALIBRATION_SKY_LUX_TH",
+        "_CALIBRATION_RGLOW_LUT",
+        "_CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_HDR",
+        "_CALIBRATION_LUXHIGH_LUT_MIN",
+        "_CALIBRATION_BG_POS",
+        "_CALIBRATION_LUXHIGH_LUT_MAX",
+        "_CALIBRATION_SHADING_LS_TL84_R",
+        "_CALIBRATION_LUXHIGH_LUT",
+        "_CALIBRATION_RGHIGH_LUT_STEP",
+        "_CALIBRATION_AWB_SCENE_PRESETS",
+        "_CALIBRATION_CNR_UV_DELTA12_SLOPE",
+        "_CALIBRATION_AF_MIN_TABLE",
+        "_CALIBRATION_AF_MAX_TABLE",
+        "_CALIBRATION_AF_WINDOW_RESIZE_TABLE",
+        "_CALIBRATION_EXP_RATIO_TABLE",
+        "_CALIBRATION_IRIDIX_STRENGTH_TABLE",
+        "_CALIBRATION_AWB_AVG_COEF",
+        "_CALIBRATION_IRIDIX_AVG_COEF",
+        "_CALIBRATION_AE_EXPOSURE_AVG_COEF",
+        "_CALIBRATION_CCM_ONE_GAIN_THRESHOLD",
+        "_CALIBRATION_NP_LUT_MEAN",
+        "_CALIBRATION_EVTOLUX_PROBABILITY_ENABLE",
+        "_CALIBRATION_DEFECT_PIXELS",
+        "_CALIBRATION_FLASH_RG",
+        "_CALIBRATION_FLASH_BG",
+        "_CALIBRATION_AF_LMS",
+        "_CALIBRATION_SINTER_RADIAL_LUT",
+        "_CALIBRATION_SINTER_RADIAL_PARAMS",
+        "_CALIBRATION_GDC_CONFIG",
+        "_CALIBRATION_TOTAL_SIZE"
+    } ;
+#endif
+
+
+
+int32_t init_isp_set( uint32_t c_set )
+{
+    int32_t result = 0 ;
+    int32_t dynamic_set_num = sizeof( dynamic_calibrations_func ) / sizeof( dynamic_calibrations_func[0] ) ;
+    int32_t static_set_num = sizeof( static_calibrations_func ) / sizeof( static_calibrations_func[0] ) ;
+    LOG( LOG_DEBUG, "Switching calibrations for set %d ", (int)c_set ) ;
+    if ( c_set < dynamic_set_num && c_set < static_set_num ) {
+        // initialize default parameters
+        result = apical_calibrations_init( &apicalCalibrations ) ;
+        if ( result == 0 ) {
+            // apply a current isp set
+            result = dynamic_calibrations_func[ c_set ]( &apicalCalibrations ) ;
+            if ( result == 0 ) {
+                result = static_calibrations_func[ c_set ]( &apicalCalibrations ) ;
+                if ( result == 0 ) {
+                } else {
+                    LOG( LOG_CRIT, "Failed to get static calibration set. Fatal error" ) ;
+                }
+            } else {
+                LOG( LOG_CRIT, "Failed to get dynamic calibration set. Fatal error" ) ;
+            }
+        } else {
+            LOG( LOG_CRIT, "Failed to initialize an dynamic calibrations. Fatal error" ) ;
+        }
+
+    } else {
+        LOG( LOG_CRIT, "Failed to find calibrations. Unsupported %d set required", (int)c_set ) ;
+    }
+    return result ;
+}
+
+
+uint32_t preview_set_supported( void )
+{
+    return CALIBRATION_PREVIEW_SET_SUPPORT ;
+}
+
+
+ApicalCalibrations* get_current_set()
+{
+    return &apicalCalibrations ;
+}
+
+
+LookupTable* _GET_LOOKUP_PTR( uint32_t idx ) {
+  LookupTable* result = NULL ;
+  if ( idx < _CALIBRATION_TOTAL_SIZE ) {
+    result = get_current_set()->calibrations[ idx ] ;
+  } else {
+    result = NULL ;
+    LOG( LOG_CRIT, "Trying to access an isp lut with invalid index %d", (int)idx ) ;
+  }
+  return result ;
+}
+
+
+#if RESTRICTED_SOURCES
+const void* _GET_LUT_PTR( uint32_t idx ) {
+  const void* result = NULL ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+    result = lut->ptr ;
+  } else {
+    while ( 1 ) {
+      LOG( LOG_CRIT, "LUT %d is not initialized. Pointer is NULL. Going to the infinite loop", (int)idx ) ;
+    } ;
+  }
+  return result ;
+}
+
+// use fast version of lut access routines
+inline uint8_t* _GET_UCHAR_PTR( uint32_t idx ) {
+  uint8_t* result = (uint8_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+inline uint16_t* _GET_USHORT_PTR( uint32_t idx ) {
+  uint16_t* result = (uint16_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+inline uint32_t* _GET_UINT_PTR( uint32_t idx ) {
+  uint32_t* result = (uint32_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+#else
+// size control version
+const void* _GET_LUT_PTR( uint32_t idx ) {
+  const void* result = NULL ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+    result = lut->ptr ;
+  } else {
+    while ( 1 ) {
+      LOG( LOG_CRIT, "LUT %d - %s is not initialized. Pointer is NULL. Going to the infinite loop", (int)idx, s_calibrationID[ idx ] ) ;
+    } ;
+  }
+  return result ;
+}
+
+inline uint8_t* _GET_UCHAR_PTR( uint32_t idx ) {
+  LookupTable *lut =  _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+    if ( lut->width != sizeof( uint8_t ) ) {
+      while ( 1 ) { LOG( LOG_CRIT, "Trying to access %d byte lut as one byte.", (int)lut->width ) ; }
+    }
+  }
+  uint8_t* result = (uint8_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+inline uint16_t* _GET_USHORT_PTR( uint32_t idx ) {
+  LookupTable *lut =  _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+    if ( lut->width != sizeof( uint16_t ) ) {
+      while ( 1 ) { LOG( LOG_CRIT, "Trying to access %d byte lut as two bytes.", (int)lut->width ) ; }
+    }
+  }
+  uint16_t* result = (uint16_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+inline uint32_t* _GET_UINT_PTR( uint32_t idx ) {
+  LookupTable *lut =  _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+    if ( lut->width != sizeof( uint32_t ) ) {
+      while ( 1 ) { LOG( LOG_CRIT, "Trying to access %d byte lut as four bytes.", (int)lut->width ) ; }
+    }
+  }
+  uint32_t* result = (uint32_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+#endif
+
+inline modulation_entry_t* _GET_MOD_ENTRY16_PTR( uint32_t idx ) {
+  modulation_entry_t* result = (modulation_entry_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+inline modulation_entry_32_t* _GET_MOD_ENTRY32_PTR( uint32_t idx ) {
+  modulation_entry_32_t* result = (modulation_entry_32_t *) _GET_LUT_PTR( idx ) ;
+  return result ;
+}
+
+inline uint32_t _GET_ROWS( uint32_t idx ) {
+  uint32_t result = 0 ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+     result = lut->rows ;
+  }
+  return result ;
+}
+
+inline uint32_t _GET_COLS( uint32_t idx ) {
+  uint32_t result = 0 ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+     result = lut->cols ;
+  }
+  return result ;
+}
+
+inline uint32_t _GET_LEN( uint32_t idx ) {
+  uint32_t result = 0 ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+     result = lut->cols * lut->rows ;
+  }
+  return result ;
+}
+
+inline uint32_t _GET_WIDTH( uint32_t idx ) {
+  uint32_t result = 0 ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+     result = lut->width ;
+  }
+  return result ;
+}
+
+inline uint32_t _GET_SIZE( uint32_t idx ) {
+  uint32_t result = 0 ;
+  LookupTable *lut = _GET_LOOKUP_PTR( idx ) ;
+  if ( lut != NULL ) {
+     result = lut->cols * lut->rows * lut->width ;
+  }
+  return result ;
+}
+
+int32_t _GET_HDR_TABLE_INDEX( uint32_t start_idx, uint32_t mode ) {
+    uint32_t result = start_idx ;
+    // This function returns an index on a hdr lut table for the current wdr mode.
+    // There are two possible scenarious. First one when we should have a separate
+    // lut for every of four wdr modes i.e. for linear, fs_lin, native and fs_hdr.
+    // A second scenario when we have one lut for linear mode and one lut for all
+    // other modes. It is the main reason why we need this function. It should
+    // distinguish luts by start_idx parameter and return a valid index for the current
+    // wdr mode.
+    if ( start_idx < _CALIBRATION_TOTAL_SIZE ) {
+      switch ( start_idx ) {
+      case _CALIBRATION_SINTER_SAD_START :
+      case _CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_START :
+      case _CALIBRATION_SHARPEN_FR_START :
+      case _CALIBRATION_SHARPEN_DS1_START :
+      case _CALIBRATION_SHARPEN_DS2_START :
+      case _CALIBRATION_AE_BALANCED_START :
+      case _CALIBRATION_SHADING_LS_A_R_START :
+      case _CALIBRATION_SHADING_LS_A_G_START :
+      case _CALIBRATION_SHADING_LS_A_B_START :
+      case _CALIBRATION_SHADING_LS_TL84_R_START :
+      case _CALIBRATION_SHADING_LS_TL84_G_START :
+      case _CALIBRATION_SHADING_LS_TL84_B_START :
+      case _CALIBRATION_SHADING_LS_D65_R_START :
+      case _CALIBRATION_SHADING_LS_D65_G_START :
+      case _CALIBRATION_SHADING_LS_D65_B_START :
+        // we have only two luts for linear and all wdr modes.
+        if ( mode == WDR_MODE_LINEAR ) {
+          result = start_idx + WDR_MODE_LINEAR ;
+        } else {
+          result = start_idx + WDR_MODE_POSITION ;
+        }
+        break ;
+      default :
+        result = start_idx + mode ;
+        break ;
+      }
+    } else {
+      result = -1 ;
+    }
+
+    return result ;
+}
+
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,42 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+
+
+#include <apical-isp/apical.h>
+#include "apical_calibrations_init.h"
+#include "log.h"
+
+
+
+
+int32_t apical_calibrations_init( ApicalCalibrations *c )
+{
+	int32_t result = 0 ;
+	if ( c != 0 ) {
+		// first of all we have to guaruantee that ECalibrationID enum has unique numbers
+
+		// by default initialize the whole memory by zeros
+		// some pointers will remain NULL and they
+		// don't have to be used in firmware
+		memset( (void *)c, 0, sizeof( ApicalCalibrations ) ) ;
+
+		// set default set of ISP parameters for firmware.
+		// They can be changed later if neccessary.
+		// Please note that LUTs which will stay NULL MUST be
+		// initialized later before firmware runs
+
+	} else {
+		result = -1 ;
+	}
+	return result ;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_calibrations_init.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,39 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_CALIBRATIONS_INIT_H__
+#define __APICAL_CALIBRATIONS_INIT_H__
+
+#include <apical-isp/apical_calibrations_id.h>
+
+
+/**
+ *   Initialize a current set of settings for apical ISP.
+ *
+ *   This function MUST be called before applying a new set of ISP LUTS.
+ *   It initializes a memory by default LUTs values.
+ *
+ *   This LUTs may be initialized to NULL - it means that you have to set
+ *   corresponding values additionaly.
+ *
+ *   Also some default LUTs may be set - it means that it is not neccessary
+ *   to update them later.
+ *
+ *   @param ispSet - a pointer to ispCalibrations structure
+ *
+ *   @return SUCCESS - everything has been initialized properly
+ *           FAIL - failed initialization. Firmware cannot continue to run
+ */
+int32_t apical_calibrations_init( ApicalCalibrations *ispSet ) ;
+
+
+#endif /* __APICAL_CALIBRATIONS_INIT_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_cmd_interface.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_cmd_interface.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_cmd_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_cmd_interface.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,18 @@
+/*-----------------------------------------------------------------------------
+	 This confidential and proprietary software/information may be used only
+		as authorized by a licensing agreement from Apical Limited
+
+				   (C) COPYRIGHT 2011 - 2015 Apical Limited
+						  ALL RIGHTS RESERVED
+
+	  The entire notice above must be reproduced on all authorized
+	   copies and copies may only be made to the extent permitted
+			 by a licensing agreement from Apical Limited.
+-----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_CMD_INTERFACE_H__
+#define __APICAL_CMD_INTERFACE_H__
+
+void apical_cmd_process( void ) ;
+
+#endif /* __APICAL_CMD_INTERFACE_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_command_api.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_command_api.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_command_api.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_command_api.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,471 @@
+// ------------------------------------------------------------------------------ //
+//     This confidential and proprietary software/information may be used only    //
+//        as authorized by a licensing agreement from Apical Limited              //
+//                                                                                //
+//                   (C) COPYRIGHT 2014 Apical Limited                            //
+//                          ALL RIGHTS RESERVED                                   //
+//                                                                                //
+//      The entire notice above must be reproduced on all authorized              //
+//       copies and copies may only be made to the extent permitted               //
+//             by a licensing agreement from Apical Limited.                      //
+//                                                                                //
+// ------------------------------------------------------------------------------ //
+
+
+//--------------------------------------------------------------------------------//
+//----------------Generated by API compiler - do not edit-------------------------//
+//--------------------------------------------------------------------------------//
+
+
+#ifndef _APICAL_COMMAND_API_H_
+#define _APICAL_COMMAND_API_H_
+#include <apical-isp/apical_types.h>
+
+
+// ------------------------------------------------------------------------------ //
+//		COMMAND TYPE LIST
+// ------------------------------------------------------------------------------ //
+#define TSELFTEST                                         0x00000000
+#define TSYSTEM                                           0x00000001
+#define TIMAGE                                            0x00000002
+#define TALGORITHMS                                       0x00000003
+#define TSCENE_MODES                                      0x00000004
+#define TREGISTERS                                        0x00000005
+#define CALIBRATION                                       0x00000006
+
+
+// ------------------------------------------------------------------------------ //
+//		COMMAND LIST
+// ------------------------------------------------------------------------------ //
+#define SENSOR_ID                                         0x00000000
+#define SENSOR_INTERFACE                                  0x00000001
+#define ISP_INTERFACE                                     0x00000002
+#define LENS_INTERFACE                                    0x00000003
+#define ISP_REVISION                                      0x00000004
+#define FW_REVISION                                       0x00000005
+#define API_REVISION                                      0x00000006
+#define CALIBRATION_REVISION                              0x00000007
+#define BUFFER_DATA_TYPE                                  0x00000008
+#define ISP_SYSTEM_STATE                                  0x00000009
+#define TEST_PATTERN_ENABLE_ID                            0x0000000A
+#define TEST_PATTERN_MODE_ID                              0x0000000B
+#define SYSTEM_FREEZE_FIRMWARE                            0x0000000C
+#define SYSTEM_MANUAL_EXPOSURE                            0x0000000D
+#define SYSTEM_MANUAL_EXPOSURE_RATIO                      0x0000000E
+#define SYSTEM_MANUAL_INTEGRATION_TIME                    0x0000000F
+#define SYSTEM_MANUAL_SENSOR_ANALOG_GAIN                  0x00000010
+#define SYSTEM_MANUAL_SENSOR_DIGITAL_GAIN                 0x00000011
+#define SYSTEM_MANUAL_ISP_DIGITAL_GAIN                    0x00000012
+#define SYSTEM_MANUAL_DIRECTIONAL_SHARPENING              0x00000013
+#define SYSTEM_MANUAL_UN_DIRECTIONAL_SHARPENING           0x00000014
+#define SYSTEM_MANUAL_IRIDIX                              0x00000015
+#define SYSTEM_DIS_X                                      0x00000016
+#define SYSTEM_DIS_Y                                      0x00000017
+#define SYSTEM_MANUAL_SINTER                              0x00000018
+#define SYSTEM_MANUAL_TEMPER                              0x00000019
+#define SYSTEM_MANUAL_AWB                                 0x0000001A
+#define SYSTEM_SLOW_FRAME_RATE_ENABLE                     0x0000001B
+#define SYSTEM_MANUAL_SATURATION                          0x0000001C
+#define SYSTEM_MANUAL_EXPOSURE_TIME                       0x0000001D
+#define SYSTEM_EXPOSURE_DARK_TARGET                       0x0000001E
+#define SYSTEM_EXPOSURE_BRIGHT_TARGET                     0x0000001F
+#define SYSTEM_EXPOSURE_RATIO                             0x00000020
+#define SYSTEM_MAX_EXPOSURE_RATIO                         0x00000021
+#define SYSTEM_INTEGRATION_TIME                           0x00000022
+#define SYSTEM_MAX_INTEGRATION_TIME                       0x00000023
+#define SYSTEM_SENSOR_ANALOG_GAIN                         0x00000024
+#define SYSTEM_MAX_SENSOR_ANALOG_GAIN                     0x00000025
+#define SYSTEM_SENSOR_DIGITAL_GAIN                        0x00000026
+#define SYSTEM_MAX_SENSOR_DIGITAL_GAIN                    0x00000027
+#define SYSTEM_ISP_DIGITAL_GAIN                           0x00000028
+#define SYSTEM_MAX_ISP_DIGITAL_GAIN                       0x00000029
+#define SYSTEM_DIRECTIONAL_SHARPENING_TARGET              0x0000002A
+#define SYSTEM_MAXIMUM_DIRECTIONAL_SHARPENING             0x0000002B
+#define SYSTEM_MINIMUM_DIRECTIONAL_SHARPENING             0x0000002C
+#define SYSTEM_UN_DIRECTIONAL_SHARPENING_TARGET           0x0000002D
+#define SYSTEM_MAXIMUM_UN_DIRECTIONAL_SHARPENING          0x0000002E
+#define SYSTEM_MINIMUM_UN_DIRECTIONAL_SHARPENING          0x0000002F
+#define SYSTEM_IRIDIX_STRENGTH_TARGET                     0x00000030
+#define SYSTEM_MAXIMUM_IRIDIX_STRENGTH                    0x00000031
+#define SYSTEM_MINIMUM_IRIDIX_STRENGTH                    0x00000032
+#define SYSTEM_SINTER_THRESHOLD_TARGET                    0x00000033
+#define SYSTEM_MAXIMUM_SINTER_STRENGTH                    0x00000034
+#define SYSTEM_MINIMUM_SINTER_STRENGTH                    0x00000035
+#define SYSTEM_TEMPER_THRESHOLD_TARGET                    0x00000036
+#define SYSTEM_MAXIMUM_TEMPER_STRENGTH                    0x00000037
+#define SYSTEM_MINIMUM_TEMPER_STRENGTH                    0x00000038
+#define SYSTEM_AWB_RED_GAIN                               0x00000039
+#define SYSTEM_AWB_BLUE_GAIN                              0x0000003A
+#define SYSTEM_SATURATION_TARGET                          0x0000003B
+#define SYSTEM_ANTI_FLICKER_FREQUENCY                     0x0000003C
+#define SYSTEM_AE_COMPENSATION                            0x0000003D
+#define SYSTEM_CALIBRATE_BAD_PIXELS                       0x0000003E
+#define RESOLUTION_ACTIVE_IMAGE_ID                        0x0000003F
+#define SENSOR_FPS_MODE_ID                                0x00000040
+#define FR_PIPE_STATUS_ID                                 0x00000041
+#define DS1_PIPE_STATUS_ID                                0x00000042
+#define DS2_PIPE_STATUS_ID                                0x00000043
+#define FPS_MODE_ID                                       0x00000044
+#define WDR_MODE_ID                                       0x00000045
+#define DVI_OUTPUT_ID                                     0x00000046
+#define ORIENTATION_HFLIP_ID                              0x00000047
+#define ORIENTATION_VFLIP_ID                              0x00000048
+#define IMAGE_RESIZE_ENABLE_ID                            0x00000049
+#define IMAGE_RESIZE_WIDTH_ID                             0x0000004A
+#define IMAGE_RESIZE_HEIGHT_ID                            0x0000004B
+#define IMAGE_CROP_XOFFSET_ID                             0x0000004C
+#define IMAGE_CROP_YOFFSET_ID                             0x0000004D
+#define HISTOGRAM_LUM_CAPTURE_ID                          0x0000004E
+#define SD_CAPTURE_FRAMES_ID                              0x0000004F
+#define SD_CAPTURE_RUN_ID                                 0x00000050
+#define AF_MODE_ID                                        0x00000051
+#define AF_RANGE_LOW_ID                                   0x00000052
+#define AF_RANGE_HIGH_ID                                  0x00000053
+#define AF_ROI_ID                                         0x00000054
+#define AF_STATUS_ID                                      0x00000055
+#define AE_MODE_ID                                        0x00000056
+#define AE_SPLIT_PRESET_ID                                0x00000057
+#define AE_GAIN_ID                                        0x00000058
+#define AE_EXPOSURE_ID					  0x00000059
+#define AE_ROI_ID					  0x0000005A
+#define AE_COMPENSATION_ID				  0x0000005B
+#define AE_FREEZE_ID					  0x0000005C
+#define AE_INTEGRATOR_SET_ID				  0x0000005D
+#define ANTIFOG_MODE_ID					  0x0000005E
+#define ANTIFOG_PRESET_ID				  0x0000005F
+#define AWB_MODE_ID					  0x00000060
+#define AWB_RANGE_LOW_ID				  0x00000061
+#define AWB_RANGE_HIGH_ID				  0x00000062
+#define AWB_RGAIN_ID					  0x00000063
+#define AWB_BGAIN_ID					  0x00000064
+#define AWB_TEMPERATURE_ID				  0x00000065
+#define AWB_ROI_ID					  0x00000066
+#define AWB_FREEZE_ID					  0x00000067
+#define ANTIFLICKER_MODE_ID				  0x00000068
+#define IRIDIX_MODE_ID					  0x00000069
+#define IRIDIX_STRENGTH_ID				  0x0000006A
+#define DIS_MODE_ID					  0x0000006B
+#define SINTER_MODE_ID					  0x0000006C
+#define SINTER_STRENGTH_ID				  0x0000006D
+#define TEMPER_MODE_ID					  0x0000006E
+#define TEMPER_STRENGTH_ID				  0x0000006F
+#define DEFECT_PIXEL_CALIBRATE_ID			  0x00000070
+#define SCENE_MODE_ID					  0x00000071
+#define COLOR_MODE_ID					  0x00000072
+#define FR_OUTPUT_MODE_ID				  0x00000073
+#define DS1_OUTPUT_MODE_ID				  0x00000074
+#define DS2_OUTPUT_MODE_ID				  0x00000075
+#define SHARPENING_STRENGTH_ID				  0x00000076
+#define BRIGHTNESS_STRENGTH_ID				  0x00000077
+#define CONTRAST_STRENGTH_ID				  0x00000078
+#define SATURATION_STRENGTH_ID				  0x00000079
+#define LED_FLASH_MODE_ID				  0x0000007A
+#define LED_FLASH_TIMEE_ID				  0x0000007B
+#define REGISTERS_ADDRESS_ID				  0x0000007C
+#define REGISTERS_SIZE_ID				  0x0000007D
+#define REGISTERS_SOURCE_ID				  0x0000007E
+#define REGISTERS_VALUE_ID				  0x0000007F
+#define EXPOSURE_LOG2_ID				  0x00000080
+#define GAIN_LOG2_ID                                      0x00000081
+
+
+// ------------------------------------------------------------------------------ //
+//		VALUE LIST
+// ------------------------------------------------------------------------------ //
+#define PAUSE                                             0x00000000
+#define RUN                                               0x00000001
+#define ON                                                0x00000002
+#define OFF                                               0x00000003
+#define PREVIEW_RES_FPS_MAX                               0x00000004
+#define FULL_RES_FPS_MAX                                  0x00000005
+#define FPS5                                              0x00000006
+#define FPS15                                             0x00000007
+#define FPS25                                             0x00000008
+#define FPS30                                             0x00000009
+#define FPS50                                             0x0000000A
+#define FPS60                                             0x0000000B
+#define ENABLE                                            0x0000000C
+#define DISABLE                                           0x0000000D
+#define IMAGE_WDR_MODE_LINEAR                             0x0000000E
+#define IMAGE_WDR_MODE_FS_HDR                             0x0000000F
+#define DVI_OUTPUT_FR                                     0x00000010
+#define DVI_OUTPUT_DS                                     0x00000011
+#define DVI_OUTPUT_DS2                                    0x00000012
+#define CROP_FR                                           0x00000013
+#define CROP_DS                                           0x00000014
+#define SCALER                                            0x00000015
+#define CROP_DS2                                          0x00000016
+#define SCALER2                                           0x00000017
+#define DONE                                              0x00000018
+#define AF_AUTO_SINGLE                                    0x00000019
+#define AF_AUTO_CONTINUOUS                                0x0000001A
+#define AF_AUTO_SINGLE_MACRO                              0x0000001B
+#define AF_AUTO_CONTINUOUS_MACRO                          0x0000001C
+#define AF_HYPER_FOCAL                                    0x0000001D
+#define AF_INFINITY                                       0x0000001E
+#define AF_ABORT                                          0x0000001F
+#define AF_NOT_FOCUSED                                    0x00000020
+#define AF_SUCCESS                                        0x00000021
+#define AF_FAIL                                           0x00000022
+#define AF_LOCKED                                         0x00000023
+#define AF_RUNNING                                        0x00000024
+#define AE_AUTO                                           0x00000025
+#define AE_FULL_MANUAL                                    0x00000026
+#define AE_MANUAL_GAIN                                    0x00000027
+#define AE_MANUAL_EXPOSURE_TIME                           0x00000028
+#define AE_SPLIT_BALANCED                                 0x00000029
+#define AE_SPLIT_INTEGRATION_PRIORITY                     0x0000002A
+#define FREEZE                                            0x0000002B
+#define UNFREEZE					  0x0000002C
+#define ANTIFOG_DISABLE				          0x0000002D
+#define ANTIFOG_ENABLE					   0x0000002E
+#define ANTIFOG_STRONG					   0x0000002F
+#define ANTIFOG_MEDIUM					   0x00000030
+#define ANTIFOG_WEAK					   0x00000031
+#define AWB_AUTO					   0x00000032
+#define AWB_MANUAL					   0x00000033
+#define AWB_DAY_LIGHT					   0x00000034
+#define AWB_CLOUDY					   0x00000035
+#define AWB_INCANDESCENT				   0x00000036
+#define AWB_FLOURESCENT				   0x00000037
+#define AWB_TWILIGHT					   0x00000038
+#define AWB_SHADE					   0x00000039
+#define AWB_WARM_FLOURESCENT				   0x0000003A
+#define MANUAL						   0x0000003B
+#define UNLIMIT					   0x0000003C
+#define HIGH						   0x0000003D
+#define MEDIUM						   0x0000003E
+#define LOW						   0x0000003F
+#define AUTO						   0x00000040
+#define DARK_PIXELS					   0x00000041
+#define BRIGHT_PIXELS					   0x00000042
+#define PORTRAIT					   0x00000043
+#define LANDSCAPE					   0x00000044
+#define NIGHT						   0x00000045
+#define MOTION						   0x00000046
+#define INDOOR						   0x00000047
+#define BEACH_SNOW					   0x00000048
+#define SUNSET						   0x00000049
+#define DAWN						   0x0000004A
+#define FIREWORKS					   0x0000004B
+#define TEXT						   0x0000004C
+#define CANDLE						   0x0000004D
+#define NIGHT_PORTRAIT					   0x0000004E
+#define NORMAL						   0x0000004F
+#define BLACK_AND_WHITE				   0x00000050
+#define NEGATIVE					   0x00000051
+#define SEPIA						   0x00000052
+#define VIVID						   0x00000053
+#define RGB						   0x00000054
+#define YUV444						   0x00000055
+#define YUV422						   0x00000056
+#define YUV420						   0x00000057
+#define FLASH_DISABLE					   0x00000058
+#define FLASH_CONTINUOUS				   0x00000059
+#define FLASH_MODE1					   0x0000005A
+#define SENSOR						   0x0000005B
+#define LENS						   0x0000005C
+#define ISP                                               0x0000005D
+#define MIPI                                              0x0000005E
+
+
+// ------------------------------------------------------------------------------ //
+//		RETURN VALUES
+// ------------------------------------------------------------------------------ //
+#define SUCCESS                                           0x00000000
+#define NOT_IMPLEMENTED                                   0x00000001
+#define NOT_SUPPORTED                                     0x00000002
+#define NOT_PERMITTED                                     0x00000003
+#define NOT_EXISTS                                        0x00000004
+#define FAIL                                              0x00000005
+
+
+// ------------------------------------------------------------------------------ //
+//		ERROR REASONS
+// ------------------------------------------------------------------------------ //
+#define ERR_UNKNOWN                                       0x00000000
+#define ERR_BAD_ARGUMENT                                  0x00000001
+#define ERR_WRONG_SIZE                                    0x00000002
+
+
+// ------------------------------------------------------------------------------ //
+//		CALIBRATION VALUES
+// ------------------------------------------------------------------------------ //
+#define CALIBRATION_LIGHT_SRC                             0x00000000
+#define CALIBRATION_RG_POS                                0x00000001
+#define CALIBRATION_BG_POS                                0x00000002
+#define CALIBRATION_MESH_RGBG_WEIGHT                      0x00000003
+#define CALIBRATION_MESH_LS_WEIGHT                        0x00000004
+#define CALIBRATION_MESH_COLOR_TEMPERATURE                0x00000005
+#define CALIBRATION_LUXLOW_LUT_MIN                        0x00000006
+#define CALIBRATION_LUXLOW_LUT_MAX                        0x00000007
+#define CALIBRATION_LUXLOW_LUT_STEP                       0x00000008
+#define CALIBRATION_LUXLOW_LUT                            0x00000009
+#define CALIBRATION_LUXHIGH_LUT_MIN                       0x0000000A
+#define CALIBRATION_LUXHIGH_LUT_MAX                       0x0000000B
+#define CALIBRATION_LUXHIGH_LUT_STEP                      0x0000000C
+#define CALIBRATION_LUXHIGH_LUT                           0x0000000D
+#define CALIBRATION_RGLOW_LUT_MIN                         0x0000000E
+#define CALIBRATION_RGLOW_LUT_MAX                         0x0000000F
+#define CALIBRATION_RGLOW_LUT_STEP                        0x00000010
+#define CALIBRATION_RGLOW_LUT                             0x00000011
+#define CALIBRATION_RGHIGH_LUT_MIN                        0x00000012
+#define CALIBRATION_RGHIGH_LUT_MAX                        0x00000013
+#define CALIBRATION_RGHIGH_LUT_STEP                       0x00000014
+#define CALIBRATION_RGHIGH_LUT                            0x00000015
+#define CALIBRATION_WB_STRENGTH                           0x00000016
+#define CALIBRATION_SKY_LUX_TH                            0x00000017
+#define CALIBRATION_CT_RG_POS_CALC                        0x00000018
+#define CALIBRATION_CT_BG_POS_CALC                        0x00000019
+#define CALIBRATION_COLOR_TEMP                            0x0000001A
+#define CALIBRATION_CT65POS                               0x0000001B
+#define CALIBRATION_CT40POS                               0x0000001C
+#define CALIBRATION_CT30POS                               0x0000001D
+#define CALIBRATION_EVTOLUX_EV_LUT_LINEAR                 0x0000001E
+#define CALIBRATION_EVTOLUX_EV_LUT_FS_HDR                 0x0000001F
+#define CALIBRATION_EVTOLUX_LUX_LUT                       0x00000020
+#define CALIBRATION_BLACK_LEVEL_R_LINEAR                  0x00000021
+#define CALIBRATION_BLACK_LEVEL_GR_LINEAR                 0x00000022
+#define CALIBRATION_BLACK_LEVEL_GB_LINEAR                 0x00000023
+#define CALIBRATION_BLACK_LEVEL_B_LINEAR                  0x00000024
+#define CALIBRATION_STATIC_WB                             0x00000025
+#define CALIBRATION_AUTO_WB                               0x00000026
+#define CALIBRATION_SKIN_TONE_CCM                         0x00000027
+#define CALIBRATION_MT_ABSOLUTE_LS_A_CCM_LINEAR           0x00000028
+#define CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_LINEAR         0x00000029
+#define CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_LINEAR         0x0000002A
+#define CALIBRATION_MT_ABSOLUTE_LS_A_CCM_HDR              0x0000002B
+#define CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_HDR            0x0000002C
+#define CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_HDR            0x0000002D
+#define CALIBRATION_SHADING_LS_A_R_LINEAR                 0x0000002E
+#define CALIBRATION_SHADING_LS_A_G_LINEAR                 0x0000002F
+#define CALIBRATION_SHADING_LS_A_B_LINEAR                 0x00000030
+#define CALIBRATION_SHADING_LS_TL84_R_LINEAR              0x00000031
+#define CALIBRATION_SHADING_LS_TL84_G_LINEAR              0x00000032
+#define CALIBRATION_SHADING_LS_TL84_B_LINEAR              0x00000033
+#define CALIBRATION_SHADING_LS_D65_R_LINEAR               0x00000034
+#define CALIBRATION_SHADING_LS_D65_G_LINEAR               0x00000035
+#define CALIBRATION_SHADING_LS_D65_B_LINEAR               0x00000036
+#define CALIBRATION_SHADING_LS_A_R_WDR                    0x00000037
+#define CALIBRATION_SHADING_LS_A_G_WDR                    0x00000038
+#define CALIBRATION_SHADING_LS_A_B_WDR                    0x00000039
+#define CALIBRATION_SHADING_LS_TL84_R_WDR                 0x0000003A
+#define CALIBRATION_SHADING_LS_TL84_G_WDR                 0x0000003B
+#define CALIBRATION_SHADING_LS_TL84_B_WDR                 0x0000003C
+#define CALIBRATION_SHADING_LS_D65_R_WDR                  0x0000003D
+#define CALIBRATION_SHADING_LS_D65_G_WDR                  0x0000003E
+#define CALIBRATION_SHADING_LS_D65_B_WDR                  0x0000003F
+#define CALIBRATION_AWB_WARMING_LS_A                      0x00000040
+#define CALIBRATION_AWB_WARMING_LS_D40                    0x00000041
+#define CALIBRATION_AWB_WARMING_LS_D50                    0x00000042
+#define CALIBRATION_NOISE_PROFILE_LINEAR                  0x00000043
+#define CALIBRATION_DEMOSAIC_LINEAR                       0x00000044
+#define CALIBRATION_NOISE_PROFILE_FS_HDR                  0x00000045
+#define CALIBRATION_DEMOSAIC_FS_HDR                       0x00000046
+#define CALIBRATION_GAMMA_FE_0_FS_HDR                     0x00000047
+#define CALIBRATION_GAMMA_FE_1_FS_HDR                     0x00000048
+#define CALIBRATION_BLACK_LEVEL_R_FS_HDR                  0x00000049
+#define CALIBRATION_BLACK_LEVEL_GR_FS_HDR                 0x0000004A
+#define CALIBRATION_BLACK_LEVEL_GB_FS_HDR                 0x0000004B
+#define CALIBRATION_BLACK_LEVEL_B_FS_HDR                  0x0000004C
+#define CALIBRATION_GAMMA_LINEAR                          0x0000004D
+#define CALIBRATION_GAMMA_FS_HDR                          0x0000004E
+#define CALIBRATION_IRIDIX_RGB2REC709                     0x0000004F
+#define CALIBRATION_IRIDIX_REC709TORGB                    0x00000050
+#define CALIBRATION_IRIDIX_ASYMMETRY                      0x00000051
+#define CALIBRATION_DEFECT_PIXELS                         0x00000052
+//------------------ISP CALIBRATIONS-------------------
+#define CALIBRATION_DP_SLOPE_LINEAR                       0x00000053
+#define CALIBRATION_DP_SLOPE_FS_HDR                       0x00000054
+#define CALIBRATION_DP_THRESHOLD_LINEAR                   0x00000055
+#define CALIBRATION_DP_THRESHOLD_FS_HDR                   0x00000056
+#define CALIBRATION_STITCHING_ERROR_THRESH                0x00000057
+#define CALIBRATION_EVTOLUX_PROBABILITY_ENABLE            0x00000058
+#define CALIBRATION_NP_LUT_MEAN                           0x00000059
+#define CALIBRATION_AWB_AVG_COEF                          0x0000005A
+#define CALIBRATION_IRIDIX_AVG_COEF                       0x0000005B
+#define CALIBRATION_AE_EXPOSURE_AVG_COEF                  0x0000005C
+#define CALIBRATION_CNR_UV_DELTA12_SLOPE                  0x0000005D
+#define CALIBRATION_AF_MIN_TABLE                          0x0000005E
+#define CALIBRATION_AF_MAX_TABLE                          0x0000005F
+#define CALIBRATION_AF_WINDOW_RESIZE_TABLE                0x00000060
+#define CALIBRATION_EXP_RATIO_TABLE                       0x00000061
+#define CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR        0x00000062
+#define CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR           0x00000063
+#define CALIBRATION_IRIDIX_BLACK_PRC                      0x00000064
+#define CALIBRATION_IRIDIX_GAIN_MAX                       0x00000065
+#define CALIBRATION_IRIDIX_MIN_MAX_STR                    0x00000066
+#define CALIBRATION_IRIDIX_EV_LIM_FULL_STR                0x00000067
+#define CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR           0x00000068
+#define CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR           0x00000069
+#define CALIBRATION_AE_CORRECTION_LINEAR                  0x0000006A
+#define CALIBRATION_AE_CORRECTION_FS_HDR                  0x0000006B
+#define CALIBRATION_AE_EXPOSURE_CORRECTION                0x0000006C
+#define CALIBRATION_SINTER_STRENGTH_LINEAR                0x0000006D
+#define CALIBRATION_SINTER_STRENGTH_FS_HDR                0x0000006E
+#define CALIBRATION_SINTER_STRENGTH1_LINEAR               0x0000006F
+#define CALIBRATION_SINTER_STRENGTH1_FS_HDR               0x00000070
+#define CALIBRATION_SINTER_THRESH1_LINEAR                 0x00000071
+#define CALIBRATION_SINTER_THRESH1_FS_HDR                 0x00000072
+#define CALIBRATION_SINTER_THRESH4_LINEAR                 0x00000073
+#define CALIBRATION_SINTER_THRESH4_FS_HDR                 0x00000074
+#define CALIBRATION_SHARP_ALT_D_LINEAR                    0x00000075
+#define CALIBRATION_SHARP_ALT_D_FS_HDR                    0x00000076
+#define CALIBRATION_SHARP_ALT_UD_LINEAR                   0x00000077
+#define CALIBRATION_SHARP_ALT_UD_FS_HDR                   0x00000078
+#define CALIBRATION_SHARPEN_FR_LINEAR                     0x00000079
+#define CALIBRATION_SHARPEN_FR_WDR                        0x0000007A
+#define CALIBRATION_SHARPEN_DS1_LINEAR                    0x0000007B
+#define CALIBRATION_SHARPEN_DS1_WDR                       0x0000007C
+#define CALIBRATION_SHARPEN_DS2_LINEAR                    0x0000007D
+#define CALIBRATION_SHARPEN_DS2_WDR                       0x0000007E
+#define CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR             0x0000007F
+#define CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR             0x00000080
+#define CALIBRATION_MESH_SHADING_STRENGTH                 0x00000081
+#define CALIBRATION_SATURATION_STRENGTH_LINEAR            0x00000082
+#define CALIBRATION_SATURATION_STRENGTH_FS_HDR            0x00000083
+#define CALIBRATION_TEMPER_STRENGTH                       0x00000084
+#define CALIBRATION_FLASH_RG                              0x00000085
+#define CALIBRATION_FLASH_BG                              0x00000086
+#define CALIBRATION_CCM_ONE_GAIN_THRESHOLD                0x00000087
+#define CALIBRATION_AE_BALANCED_LINEAR                    0x00000088
+#define CALIBRATION_AE_BALANCED_WDR                       0x00000089
+#define CALIBRATION_IRIDIX_STRENGTH_TABLE                 0x0000008A
+#define CALIBRATION_RGB2YUV_CONVERSION                    0x0000008B
+
+#define API2FRM_SIZE 140
+uint16_t* GET_API2FRM_IDX(void);
+void apical_api_init_idx_array(void) ;
+
+
+
+// ------------------------------------------------------------------------------ //
+//		DIRECTION VALUES
+// ------------------------------------------------------------------------------ //
+#define COMMAND_SET                                       0x00000000
+#define COMMAND_GET                                       0x00000001
+#define API_VERSION                                       0x00000064
+
+typedef struct {
+	uint8_t type;
+	uint8_t id;
+	uint8_t dir;
+	uint32_t value;
+	uint32_t data_size;
+} apical_api_control_t;
+
+// ------------------------------------------------------------------------------ //
+//		SET/GET FUNCTION
+// ------------------------------------------------------------------------------ //
+//set command: ret = apical_command(instance, TALGORITHMS, AF_MODE, AF_AUTO, COMMAND_SET, &RET_VALUE);
+//get command: ret = apical_command(instance, TALGORITHMS, AF_MODE, AF_AUTO, COMMAND_GET, &RET_VALUE);
+uint8_t apical_command(uint8_t command_type, uint8_t command, uint32_t value, uint8_t direction, uint32_t *ret_value);
+
+#define APICAL_API_BUFFER_MAX_SIZE		1024
+uint8_t* get_apical_api_buffer(void);
+extern uint32_t apical_api_buffer_data_size;
+uint32_t apical_api_read_buffer(uint8_t* buf);
+
+uint8_t apical_api_calibration(uint8_t type, uint8_t direction, void* data, uint32_t data_size, uint32_t* ret_value);
+
+#endif//_APICAL_COMMAND_API_H_
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,210 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_custom_initialization.h"
+#include <apical-isp/apical_isp_config.h>
+#include "tx-isp-load-parameters.h"
+#include "apical_command_api.h"
+#include "../tx-isp-debug.h"
+#include "isp_config_seq.h"
+#include "tx-isp-core.h"
+
+
+static TXispPrivCustomerParamer *customer = NULL;
+
+// this is a pointer to initialization sequence for isp
+// it will be requested by firmware at initialization stage
+// it is possible to return NULL pointer instead of valid sequence
+// in this case no initialization will be made
+static uint8_t p_isp_data[] = SENSOR_ISP_SEQUENCE_DEFAULT;
+
+void apical_custom_initialization(void)
+{
+#if 1
+	// this function is called in the end of
+	// firmware initialization.
+	// it can be used to make customer related
+	// tuning of Apical ISP.
+	apical_api_control_t api;
+	unsigned int reason = 0;
+	unsigned int status = 0;
+	unsigned int tmp = 0;
+	APICAL_WRITE_32(0x40, APICAL_ISP_TOP_CONTROL_LOW_REG_DEFAULT);
+	APICAL_WRITE_32(0x44, APICAL_ISP_TOP_CONTROL_HIGH_REG_DEFAULT);
+	if(customer){
+		/* enable the isp modules */
+		tmp = APICAL_READ_32(0x40);
+		tmp = (tmp | 0x0c02da6c) & (~(customer->top));
+		if(TX_ISP_EXIST_FR_CHANNEL == 0)
+			tmp |= 0x00fc0000;
+		APICAL_WRITE_32(0x40, tmp);
+		/* if it is T20,the FR is corresponding to DS2 in bin file. */
+		if ((customer->top) & (1 << 19)){
+#if TX_ISP_EXIST_FR_CHANNEL
+			apical_isp_top_bypass_fr_gamma_rgb_write(0);
+			apical_isp_fr_gamma_rgb_enable_write(1);
+#endif
+#ifdef TX_ISP_EXIST_DS2_CHANNEL
+			apical_isp_top_bypass_ds2_gamma_rgb_write(0);
+			apical_isp_ds2_gamma_rgb_enable_write(1);
+#endif
+		} else {
+#if TX_ISP_EXIST_FR_CHANNEL
+			apical_isp_top_bypass_fr_gamma_rgb_write(1);
+			apical_isp_fr_gamma_rgb_enable_write(0);
+#endif
+#ifdef TX_ISP_EXIST_DS2_CHANNEL
+			apical_isp_top_bypass_ds2_gamma_rgb_write(1);
+			apical_isp_ds2_gamma_rgb_enable_write(0);
+#endif
+		}
+
+		if ((customer->top) & (1 << 20)){
+#if TX_ISP_EXIST_FR_CHANNEL
+			apical_isp_top_bypass_fr_sharpen_write(0);
+			apical_isp_fr_sharpen_enable_write(1);
+#endif
+#if TX_ISP_EXIST_DS2_CHANNEL
+			apical_isp_top_bypass_ds2_sharpen_write(0);
+			apical_isp_ds2_sharpen_enable_write(1);
+#endif
+		} else {
+#if TX_ISP_EXIST_FR_CHANNEL
+			apical_isp_top_bypass_fr_sharpen_write(1);
+			apical_isp_fr_sharpen_enable_write(0);
+#endif
+#ifdef TX_ISP_EXIST_DS2_CHANNEL
+			apical_isp_top_bypass_ds2_sharpen_write(1);
+			apical_isp_ds2_sharpen_enable_write(0);
+#endif
+		}
+		if (customer->top & (1 << 27))
+			apical_isp_ds1_sharpen_enable_write(1);
+		else
+			apical_isp_ds1_sharpen_enable_write(0);
+
+		/* green equalization */
+		apical_isp_raw_frontend_ge_strength_write(customer->ge_strength);
+		apical_isp_raw_frontend_ge_threshold_write(customer->ge_threshold);
+		apical_isp_raw_frontend_ge_slope_write(customer->ge_slope);
+		apical_isp_raw_frontend_ge_sens_write(customer->ge_sensitivity);
+
+		/* dpc configuration	 */
+		apical_isp_raw_frontend_dp_enable_write(customer->dp_module);
+		apical_isp_raw_frontend_hpdev_threshold_write(customer->hpdev_threshold);
+		apical_isp_raw_frontend_line_thresh_write(customer->line_threshold);
+		apical_isp_raw_frontend_hp_blend_write(customer->hp_blend);
+
+		/* Demoasic */
+		apical_isp_demosaic_vh_slope_write(customer->dmsc_vh_slope);
+		apical_isp_demosaic_aa_slope_write(customer->dmsc_aa_slope);
+		apical_isp_demosaic_va_slope_write(customer->dmsc_va_slope);
+		apical_isp_demosaic_uu_slope_write(customer->dmsc_uu_slope);
+		apical_isp_demosaic_sat_slope_write(customer->dmsc_sat_slope);
+		apical_isp_demosaic_vh_thresh_write(customer->dmsc_vh_threshold);
+		apical_isp_demosaic_aa_thresh_write(customer->dmsc_aa_threshold);
+		apical_isp_demosaic_va_thresh_write(customer->dmsc_va_threshold);
+		apical_isp_demosaic_uu_thresh_write(customer->dmsc_uu_threshold);
+		apical_isp_demosaic_sat_thresh_write(customer->dmsc_sat_threshold);
+		apical_isp_demosaic_vh_offset_write(customer->dmsc_vh_offset);
+		apical_isp_demosaic_aa_offset_write(customer->dmsc_aa_offset);
+		apical_isp_demosaic_va_offset_write(customer->dmsc_va_offset);
+		apical_isp_demosaic_uu_offset_write(customer->dmsc_uu_offset);
+		apical_isp_demosaic_sat_offset_write(customer->dmsc_sat_offset);
+		apical_isp_demosaic_lum_thresh_write(customer->dmsc_luminance_thresh);
+		apical_isp_demosaic_np_offset_write(customer->dmsc_np_offset);
+		apical_isp_demosaic_dmsc_config_write(customer->dmsc_config);
+		apical_isp_demosaic_ac_thresh_write(customer->dmsc_ac_threshold);
+		apical_isp_demosaic_ac_slope_write(customer->dmsc_ac_slope);
+		apical_isp_demosaic_ac_offset_write(customer->dmsc_ac_offset);
+		apical_isp_demosaic_fc_slope_write(customer->dmsc_fc_slope);
+		apical_isp_demosaic_fc_alias_slope_write(customer->dmsc_fc_alias_slope);
+		apical_isp_demosaic_fc_alias_thresh_write(customer->dmsc_fc_alias_thresh);
+		apical_isp_demosaic_np_off_write(customer->dmsc_np_off);
+		apical_isp_demosaic_np_off_reflect_write(customer->dmsc_np_reflect);
+
+		/* Temper */
+		apical_isp_temper_recursion_limit_write(customer->temper_recursion_limit);
+		/* FS WDR */
+		apical_isp_frame_stitch_short_thresh_write(customer->wdr_short_thresh);
+		apical_isp_frame_stitch_long_thresh_write(customer->wdr_long_thresh);
+		apical_isp_frame_stitch_exposure_ratio_write(customer->wdr_expo_ratio_thresh);
+		apical_isp_frame_stitch_stitch_correct_write(customer->wdr_stitch_correct);
+		apical_isp_frame_stitch_stitch_error_thresh_write(customer->wdr_stitch_error_thresh);
+		apical_isp_frame_stitch_stitch_error_limit_write(customer->wdr_stitch_error_limit);
+		apical_isp_frame_stitch_black_level_out_write(customer->wdr_stitch_bl_output);
+		apical_isp_frame_stitch_black_level_short_write(customer->wdr_stitch_bl_short);
+		apical_isp_frame_stitch_black_level_long_write(customer->wdr_stitch_bl_long);
+
+		/* Max ISP Digital Gain */
+		api.type = TSYSTEM;
+		api.dir = COMMAND_SET;
+		api.value = customer->max_isp_dgain;
+		api.id = SYSTEM_MAX_ISP_DIGITAL_GAIN;
+
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if(status != ISP_SUCCESS) {
+			ISP_PRINT(ISP_WARNING_LEVEL,"Custom set max isp digital gain failure!reture value is %d,reason is %d\n",status,reason);
+		}
+
+		/* Max Sensor Analog Gain */
+		api.type = TSYSTEM;
+		api.dir = COMMAND_SET;
+		api.value = customer->max_sensor_again;
+		api.id = SYSTEM_MAX_SENSOR_ANALOG_GAIN;
+
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if(status != ISP_SUCCESS) {
+			ISP_PRINT(ISP_WARNING_LEVEL,"Custom set max isp digital gain failure!reture value is %d,reason is %d\n",status,reason);
+		}
+	}
+#if 0
+	/* Anti Flicker  */
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.value = 50;
+	api.id = ANTIFLICKER_MODE_ID;
+
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if(status != ISP_SUCCESS) {
+		ISP_PRINT(ISP_WARNING_LEVEL,"Custom set anti flicker frequency failure!reture value is %d,reason is %d\n",status,reason);
+	}
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_SET;
+	api.value = 1;
+	api.id = SYSTEM_ANTIFLICKER_ENABLE;
+
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if(status != ISP_SUCCESS) {
+		ISP_PRINT(ISP_WARNING_LEVEL,"Custom enable anti-flicker failure!reture value is %d,reason is %d\n",status,reason);
+	}
+#endif
+
+#else
+	int index = 0;
+	TXispPrivCustomParamType *ptr = custom.ptr;
+	for(index = 0; index < custom.rows; index++){
+		APICAL_WRITE_32(ptr[index].reg, ptr[index].value);
+	}
+#endif
+}
+
+void init_tx_isp_customer_parameter(TXispPrivCustomerParamer *m)
+{
+	customer = m;
+	return;
+}
+
+uint8_t* apical_custom_sequence(void) {
+	return p_isp_data ;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_custom_initialization.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,38 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_CUSTOM_INITIALIZATION_H__
+#define __APICAL_CUSTOM_INITIALIZATION_H__
+#include <apical-isp/apical_types.h>
+
+/**
+ *   Make a customer related initialization of Apical ISP
+ *
+ *   This function is called at the end of firmware initialization and
+ *   before any processing is being started.
+ *   You can update this function to make any initialization you need.
+ *
+ */
+void apical_custom_initialization(void) ;
+
+/**
+ *   Return Apical ISP initialization sequence
+ *
+ *   This function is called at initialization stage
+ *   before any processing is being started.
+ *   Customer has to provide a valid pointer to initialization sequence or
+ *   just return NULL pointer if no initialization should be made by firmware.
+ *
+ */
+uint8_t* apical_custom_sequence(void) ;
+
+#endif // __APICAL_CUSTOM_INITIALIZATION_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,31 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+#include "ApicalDefault.h"
+#include <apical-isp/apical_configuration.h>
+#include <apical-isp/apical_isp_config.h>
+#include "apical_sbus.h"
+#include "log.h"
+
+
+
+
+void init_sensor_interface(sensor_ApicalDefault_iface_ptr_t p_iface)
+{
+}
+
+void reset_sensor_interface(sensor_ApicalDefault_iface_ptr_t p_iface)
+{
+}
+
+void load_sensor_interface(sensor_ApicalDefault_iface_ptr_t p_iface, uint8_t mode)
+{
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/ApicalDefault.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,29 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICALDEFAULT_H__
+#define __APICALDEFAULT_H__
+
+//#include <stdint.h>
+#include "apical_sbus.h"
+
+typedef struct _sensor_ApicalDefault_iface_t
+{
+	apical_sbus_t mipi_i2c_bus;
+} sensor_ApicalDefault_iface_t;
+typedef sensor_ApicalDefault_iface_t *sensor_ApicalDefault_iface_ptr_t;
+
+void reset_sensor_interface(sensor_ApicalDefault_iface_ptr_t p_iface);
+void load_sensor_interface(sensor_ApicalDefault_iface_ptr_t p_iface, uint8_t mode);
+void mipi_auto_tune(sensor_ApicalDefault_iface_ptr_t p_iface, uint8_t mode, uint32_t refw, uint32_t refh);
+
+#endif /* __APICALDEFAULT_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_dynamic_calibrations.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_dynamic_calibrations.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_dynamic_calibrations.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_dynamic_calibrations.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,405 @@
+// ------------------------------------------------------------------------------ //
+//     This confidential and proprietary software/information may be used only    //
+//        as authorized by a licensing agreement from Apical Limited              //
+//                                                                                //
+//                   (C) COPYRIGHT 2014 Apical Limited                            //
+//                          ALL RIGHTS RESERVED                                   //
+//                                                                                //
+//      The entire notice above must be reproduced on all authorized              //
+//       copies and copies may only be made to the extent permitted               //
+//             by a licensing agreement from Apical Limited.                      //
+//                                                                                //
+// ------------------------------------------------------------------------------ //
+#include <apical-isp/apical_calibrations_id.h>
+
+
+// CALIBRATION_NP_LUT_MEAN
+static  uint16_t _calibration_np_lut_mean[ ]
+= { 53 } ;
+
+// CALIBRATION_NP_LUT_MEAN
+static  uint8_t _calibration_evtolux_probability_enable[ ]
+= { 0 } ;
+//jz
+// CALIBRATION_AWB_AVG_COEF
+static  uint8_t _calibration_awb_avg_coef[ ]
+= { 18 } ;
+//jz
+// CALIBRATION_AWB_AVG_COEF
+static  uint8_t _calibration_ae_exposure_avg_coef[ ]
+= { 13 } ;
+
+// CALIBRATION_AWB_AVG_COEF
+static  uint8_t _calibration_iridix_avg_coef[ ]
+= { 13 } ;
+
+// CALIBRATION_AWB_AVG_COEF
+static  uint16_t _calibration_af_min_table[ ][ 2 ]
+= {
+	{ 0 * 256, 0 }
+} ;
+
+// CALIBRATION_AWB_AVG_COEF
+static  uint16_t _calibration_af_max_table[ ][ 2 ]
+= {
+	{ 0 * 256, 0 }
+} ;
+
+// CALIBRATION_AWB_AVG_COEF
+static  uint16_t _calibration_af_window_resize_table[ ][ 2 ]
+= {
+	{ 0 * 256, 0 }
+} ;
+
+// CALIBRATION_AWB_AVG_COEF
+static  uint16_t _calibration_cnr_uv_delta12_slope[ ][ 2 ]
+= {
+	{ 0 * 256, 0 }
+} ;
+//useless
+// CALIBRATION_AWB_AVG_COEF
+static  uint16_t _calibration_exp_ratio_table[ ][ 2 ]
+= {
+	{ 0 * 256, 0}
+} ;
+
+// CALIBRATION_CCM_ONE_GAIN_THRESHOLD
+static  uint16_t _calibration_ccm_one_gain_threshold[ ]
+= { 255 } ;
+
+// CALIBRATION_FLASH_RG
+static  uint8_t _calibration_flash_rg[ 1 ]
+=  { 147 } ;
+
+// CALIBRATION_FLASH_BG
+static  uint8_t _calibration_flash_bg[ 1 ]
+=  { 210 } ;
+
+
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint8_t _calibration_iridix_strength_maximum_linear[ ]
+=  { 180} ;
+
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint8_t _calibration_iridix_strength_maximum_wdr[ ]
+=  { 180 } ;
+//jz same
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint16_t _calibration_iridix_black_prc[ ]
+=  { 30 } ;
+//jz 1000 in old version
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint16_t _calibration_iridix_gain_max[ ]
+=  { 2400 } ;
+
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint16_t _calibration_iridix_min_max_str[ ]
+=  { 0 } ;
+//jz
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint32_t _calibration_iridix_ev_lim_full_str[ ]
+=  {550000} ;//500000
+
+//jz
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint32_t _calibration_iridix_ev_lim_no_str_linear[ ]
+=  { 1000000 } ;//782000
+
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint32_t _calibration_iridix_ev_lim_no_str_fs_hdr[ ]
+=  { 1000000 } ;
+//jz lut_correction_linear
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint8_t _calibration_ae_correction_linear[ ]
+=  { 133,133,133,133,133,130,90,90,40,40 } ;
+
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint8_t _calibration_ae_correction_fs_hdr[ ]
+=  { 128,128,128,128,135,135,135,128,128 } ;
+
+//jz lut_exp
+// CALIBRATION_GAMMA_FE_1_FS_LIN
+static  uint32_t _calibration_ae_exposure_correction[ ]
+=  { 1000,2848, 26012, 64828, 168506, 334399, 412489, 2000000, 24119268, 221092671 } ;
+
+//jz
+static  uint16_t _calibration_sinter_strength_linear[ ][ 2 ]
+= {{0,10},{1*256,15},{2*256,25},{3*256,35},{4*256,40},{5*256,45},{6*256,52},{7*256,55},{8*256,79}} ;
+
+static  uint16_t _calibration_sinter_strength_fs_hdr[ ][ 2 ]
+= {{0,10},{1*256,20},{2*256,30},{3*256,52},{4*256,64},{5*256,66},{6*256,68},{7*256,69},{8*256,85}} ;
+
+//jz
+static  uint16_t _calibration_sinter_strength1_linear[ ][ 2 ]
+= {{0,255},{1*256,255},{2*256,255},{3*256,255},{4*256,200},{5*256,180}} ;
+
+static  uint16_t _calibration_sinter_strength1_fs_hdr[ ][ 2 ]
+= {{0,255},{1*256,255},{2*256,255},{3*256,255},{4*256,255}} ;
+
+static  uint16_t _calibration_sinter_thresh1_linear[ ][ 2 ]
+= {{0,0},{2*256,10},{3*256,15},{4*256,20},{5*256,20},{6*256,30}} ;
+
+static  uint16_t _calibration_sinter_thresh1_fs_hdr[ ][ 2 ]
+ = {
+	 {0,0},{3*256,15},{4*256,20},{5*256,24},{6*256,30}
+   } ;
+
+//jz
+static  uint16_t _calibration_sinter_thresh4_linear[ ][ 2 ]
+= {{0,0},{2*256,6},{3*256,10},{4*256,15},{5*256,16},{6*256,16},{7*256,16}} ;
+
+static  uint16_t _calibration_sinter_thresh4_fs_hdr[ ][ 2 ]
+= {{0,15},{1*256,15},{2*256,15},{3*256,25},{4*256,35}} ;
+
+//jz
+static  uint16_t _calibration_sharp_alt_d_linear[ ][ 2 ]
+= {{0,95},{1*256,95},{2*256,90},{3*256,75},{4*256,60},{5*256,45}} ;
+
+static  uint16_t _calibration_sharp_alt_d_fs_hdr[ ][ 2 ]
+= {{0,50},{4*256,35},{5*256,25},{6*256,15}} ;
+
+//jz
+static  uint16_t _calibration_sharp_alt_ud_linear[ ][ 2 ]
+= {{0,85},{1*256,80},{2*256,75},{3*256,60},{4*256,40},{5*256,30}} ;
+
+static  uint16_t _calibration_sharp_alt_ud_fs_hdr[ ][ 2 ]
+= {{0,55},{4*256,50},{5*256,35},{6*256,5}} ;
+
+static  uint16_t _calibration_sharpen_fr_linear[ ][ 2 ]
+= {{0,10}};
+
+static  uint16_t _calibration_sharpen_fr_hdr[ ][ 2 ]
+= {
+	{0,20}
+	/* {0,20},{1*256,20},{2*256,20},{3*256,20},{4*256,18},{5*256,15},{6*256,15},{7*256,10},{8*256,10} */
+} ;
+
+
+static  uint16_t _calibration_sharpen_ds1_linear[ ][ 2 ]
+= {{0,50},{1*256,50},{2*256,50},{3*256,50},{4*256,50},{5*256,50},{6*256,40},{7*256,25},{8*256,10}} ;
+
+static  uint16_t _calibration_sharpen_ds1_hdr[ ][ 2 ]
+= {
+	{0,50},{1*256,50},{2*256,50},{3*256,50},{4*256,50},{5*256,50},{6*256,40},{7*256,25},{8*256,10}
+} ;
+
+
+static  uint16_t _calibration_sharpen_ds2_linear[ ][ 2 ]
+= {{0,70},{1*256,70},{2*256,70},{3*256,70},{4*256,70},{5*256,50},{6*256,40},{7*256,25},{8*256,10}} ;
+
+static  uint16_t _calibration_sharpen_ds2_hdr[ ][ 2 ]
+= {
+	{0,70},{1*256,70},{2*256,70},{3*256,70},{4*256,70},{5*256,50},{6*256,40},{7*256,25},{8*256,10}
+} ;
+
+static  uint16_t _calibration_demosaic_np_offset_linear[ ][ 2 ]
+= {{0*256,0},{3*256,0},{4*256,8},{4*256,18},{5*256,22},{6*256,30}} ;
+/* = {{0*256,0},{3*256,0},{4*256,8},{4*256,18},{5*256,22},{6*256,30}} ; */
+
+static  uint16_t _calibration_demosaic_np_offset_fs_hdr[ ][ 2 ]
+= {{0*256,0},{3*256,0},{4*256,8},{4*256,18},{5*256,22},{6*256,30}} ;
+
+static  uint16_t _calibration_mesh_shading_strength[ ][ 2 ]
+= {
+	{ 3 * 256, 0x1000 },
+	{ 5 * 256, 0}
+} ;
+
+static  uint16_t _calibration_saturation_strength_linear[ ][ 2 ]
+= {{0*256,128},{1*256,128},{2*256,128},{3*256,118},{4*256,95},{5*256,72}} ;
+
+static  uint16_t _calibration_saturation_strength_fs_hdr[ ][ 2 ]
+= {{0*256,130}} ;
+
+static  uint16_t _calibration_temper_strength[ ][ 2 ]
+= {{0,80},{1*256,85},{2*256,93},{3*256,110},{4*256,100},{5*256,100}} ;
+
+
+
+static  uint16_t _calibration_stitching_error_thresh[ ][ 2 ]
+= { { 0 * 256, 64 },
+	{ 1 * 256, 64 },
+	{ 2 * 256, 64 },
+	{ 3 * 256, 64 },
+	{ 4 * 256, 64  },
+	{ 5 * 256, 64  }
+} ;
+
+
+
+static  uint16_t _calibration_dp_slope_linear[ ][ 2 ]
+ = {{ 0 * 256, 170 },
+	{ 3 * 256, 170 },
+	{ 4 * 256, 1023 },
+
+} ;
+
+static  uint16_t _calibration_dp_slope_fs_hdr[ ][ 2 ]
+= { { 0 * 256, 170 },
+    { 1 * 256, 170 },
+	{ 3 * 256, 170 },
+	{ 4 * 256, 170 },
+	{ 5 * 256, 300 }
+} ;
+
+
+static  uint16_t _calibration_dp_threshold_linear[ ][ 2 ]
+= {{ 0 * 256, 4095 },
+   { 1 * 256, 4095 },
+   { 2 * 256, 2600 },
+   { 3 * 256, 1023 },
+   { 4 * 256, 64 },
+   { 5 * 256, 64 }
+
+} ;
+
+static  uint16_t _calibration_dp_threshold_fs_hdr[ ][ 2 ]
+= {{ 0 * 256, 4095 },
+   { 1 * 256, 4095 },
+   { 2 * 256, 2600 },
+   { 3 * 256, 1023 },
+   { 4 * 256, 64 },
+   { 5 * 256, 64 }
+
+} ;
+// CALIBRATION_AE_BALANCED_LINEAR
+// AE_PI_COEFF,AE_TARGET_POINT,AE_TAIL_WEIGHT,AE_LONG_CLIP,AE_ER_AVG_COEFF
+static  uint32_t _calibration_ae_balanced_linear[ ]
+=  { 10, 60, 0, 0, 0, 0, ANALOG_GAIN_ACCURACY};
+
+// CALIBRATION_AE_BALANCED_LINEAR
+// AE_PI_COEFF,AE_TARGET_POINT,AE_TAIL_WEIGHT,AE_LONG_CLIP,AE_ER_AVG_COEFF
+static  uint32_t _calibration_ae_balanced_wdr[ ]
+=  { 10,  66, 0, 96, 5, 0, ANALOG_GAIN_ACCURACY} ;
+
+static  uint16_t _calibration_iridix_strength_table[ ][2]
+= { {1*64,8}
+	/* {2*64,65}, */
+	/* {4*64,115}, */
+	/* {8*64,165}, */
+	/* {16*64,255} */
+};
+static uint16_t _calibration_rgb2yuv_conversion[]={ 47,157,16,32794, 32855, 112, 112, 32870, 32778, 64, 512,512};
+static LookupTable calibration_dp_slope_linear = { .ptr = _calibration_dp_slope_linear, .rows = sizeof(_calibration_dp_slope_linear) / sizeof(_calibration_dp_slope_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_dp_slope_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_dp_slope_fs_hdr = { .ptr = _calibration_dp_slope_fs_hdr, .rows = sizeof(_calibration_dp_slope_fs_hdr) / sizeof(_calibration_dp_slope_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_dp_slope_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_dp_threshold_linear = { .ptr = _calibration_dp_threshold_linear, .rows = sizeof(_calibration_dp_threshold_linear) / sizeof(_calibration_dp_threshold_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_dp_threshold_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_dp_threshold_fs_hdr = { .ptr = _calibration_dp_threshold_fs_hdr, .rows = sizeof(_calibration_dp_threshold_fs_hdr) / sizeof(_calibration_dp_threshold_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_dp_threshold_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_stitching_error_thresh = { .ptr = _calibration_stitching_error_thresh, .rows = sizeof(_calibration_stitching_error_thresh) / sizeof(_calibration_stitching_error_thresh[ 0 ]), .cols = 2, .width = sizeof(_calibration_stitching_error_thresh[ 0 ][ 0 ]) } ;
+static LookupTable calibration_np_lut_mean = { .ptr = _calibration_np_lut_mean, .rows = 1, .cols = sizeof(_calibration_np_lut_mean) / sizeof(_calibration_np_lut_mean[ 0 ] ), .width = sizeof(_calibration_np_lut_mean[ 0 ]) } ;
+static LookupTable calibration_evtolux_probability_enable = { .ptr = _calibration_evtolux_probability_enable, .rows = 1, .cols = sizeof(_calibration_evtolux_probability_enable) / sizeof(_calibration_evtolux_probability_enable[ 0 ] ), .width = sizeof(_calibration_evtolux_probability_enable[ 0 ]) } ;
+static LookupTable calibration_cnr_uv_delta12_slope = { .ptr = _calibration_cnr_uv_delta12_slope, .rows = sizeof(_calibration_cnr_uv_delta12_slope) / sizeof(_calibration_cnr_uv_delta12_slope[ 0 ]), .cols = 2, .width = sizeof(_calibration_cnr_uv_delta12_slope [ 0 ][ 0 ]) } ;
+static LookupTable calibration_af_min_table = { .ptr = _calibration_af_min_table, .rows = sizeof(_calibration_af_min_table) / sizeof(_calibration_af_min_table[ 0 ]), .cols = 2, .width = sizeof(_calibration_af_min_table [ 0 ][ 0 ]) } ;
+static LookupTable calibration_af_max_table = { .ptr = _calibration_af_max_table, .rows = sizeof(_calibration_af_max_table) / sizeof(_calibration_af_max_table[ 0 ]), .cols = 2, .width = sizeof(_calibration_af_max_table [ 0 ][ 0 ]) } ;
+static LookupTable calibration_af_window_resize_table = { .ptr = _calibration_af_window_resize_table, .rows = sizeof(_calibration_af_window_resize_table) / sizeof(_calibration_af_window_resize_table[ 0 ]), .cols = 2, .width = sizeof(_calibration_af_window_resize_table [ 0 ][ 0 ]) } ;
+static LookupTable calibration_exp_ratio_table = { .ptr = _calibration_exp_ratio_table, .rows = sizeof(_calibration_exp_ratio_table) / sizeof(_calibration_exp_ratio_table[ 0 ]), .cols = 2, .width = sizeof(_calibration_exp_ratio_table [ 0 ][ 0 ]) } ;
+static LookupTable calibration_awb_avg_coef = { .ptr = _calibration_awb_avg_coef, .rows = 1, .cols = sizeof(_calibration_awb_avg_coef) / sizeof(uint8_t), .width = sizeof(_calibration_awb_avg_coef[ 0 ]) } ;
+static LookupTable calibration_iridix_avg_coef = { .ptr = _calibration_iridix_avg_coef, .rows = 1, .cols = sizeof(_calibration_iridix_avg_coef) / sizeof(uint8_t), .width = sizeof(_calibration_iridix_avg_coef[ 0 ]) } ;
+static LookupTable calibration_exposure_avg_coef = { .ptr = _calibration_ae_exposure_avg_coef, .rows = 1, .cols = sizeof(_calibration_ae_exposure_avg_coef) / sizeof(uint8_t), .width = sizeof(_calibration_ae_exposure_avg_coef[ 0 ]) } ;
+static LookupTable calibration_iridix_strength_maximum_linear = { .ptr = _calibration_iridix_strength_maximum_linear, .rows = 1, .cols = sizeof(_calibration_iridix_strength_maximum_linear) / sizeof(uint8_t), .width = sizeof(_calibration_iridix_strength_maximum_linear[ 0 ]) } ;
+static LookupTable calibration_iridix_strength_maximum_wdr = { .ptr = _calibration_iridix_strength_maximum_wdr, .rows = 1, .cols = sizeof(_calibration_iridix_strength_maximum_wdr) / sizeof(uint8_t), .width = sizeof(_calibration_iridix_strength_maximum_wdr[ 0 ]) } ;
+static LookupTable calibration_iridix_black_prc = { .ptr = _calibration_iridix_black_prc, .rows = 1, .cols = sizeof(_calibration_iridix_black_prc) / sizeof(uint16_t), .width = sizeof(_calibration_iridix_black_prc[ 0 ]) } ;
+static LookupTable calibration_iridix_gain_max = { .ptr = _calibration_iridix_gain_max, .rows = 1, .cols = sizeof(_calibration_iridix_gain_max) / sizeof(uint16_t), .width = sizeof(_calibration_iridix_gain_max[ 0 ]) } ;
+static LookupTable calibration_iridix_min_max_str = { .ptr =_calibration_iridix_min_max_str, .rows = 1, .cols = sizeof(_calibration_iridix_min_max_str) / sizeof(uint16_t), .width = sizeof(_calibration_iridix_min_max_str[ 0 ]) } ;
+static LookupTable calibration_iridix_ev_lim_full_str = { .ptr = _calibration_iridix_ev_lim_full_str, .rows = 1, .cols = sizeof(_calibration_iridix_ev_lim_full_str) / sizeof(uint32_t), .width = sizeof(_calibration_iridix_ev_lim_full_str[ 0 ]) } ;
+static LookupTable calibration_iridix_ev_lim_no_str_linear = { .ptr = _calibration_iridix_ev_lim_no_str_linear, .rows = 1, .cols = sizeof(_calibration_iridix_ev_lim_no_str_linear) / sizeof(uint32_t), .width = sizeof(_calibration_iridix_ev_lim_no_str_linear[ 0 ]) } ;
+static LookupTable calibration_iridix_ev_lim_no_str_fs_hdr = { .ptr = _calibration_iridix_ev_lim_no_str_fs_hdr, .rows = 1, .cols = sizeof(_calibration_iridix_ev_lim_no_str_fs_hdr) / sizeof(uint32_t), .width = sizeof(_calibration_iridix_ev_lim_no_str_fs_hdr[ 0 ]) } ;
+static LookupTable calibration_ae_correction_linear = { .ptr = _calibration_ae_correction_linear, .rows = 1, .cols = sizeof(_calibration_ae_correction_linear) / sizeof(uint8_t), .width = sizeof(_calibration_ae_correction_linear[ 0 ]) } ;
+static LookupTable calibration_ae_correction_fs_hdr = { .ptr = _calibration_ae_correction_fs_hdr, .rows = 1, .cols = sizeof(_calibration_ae_correction_fs_hdr) / sizeof(uint8_t), .width = sizeof(_calibration_ae_correction_fs_hdr[ 0 ]) } ;
+static LookupTable calibration_ae_exposure_correction = { .ptr = _calibration_ae_exposure_correction, .rows = 1, .cols = sizeof(_calibration_ae_exposure_correction) / sizeof(_calibration_ae_exposure_correction[ 0 ] ), .width = sizeof(_calibration_ae_exposure_correction[ 0 ]) } ;
+static LookupTable calibration_sinter_strength_linear = { .ptr = _calibration_sinter_strength_linear, .rows = sizeof(_calibration_sinter_strength_linear) / sizeof(_calibration_sinter_strength_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_strength_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_strength_fs_hdr = { .ptr = _calibration_sinter_strength_fs_hdr, .rows = sizeof(_calibration_sinter_strength_fs_hdr) / sizeof(_calibration_sinter_strength_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_strength_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_strength1_linear = { .ptr = _calibration_sinter_strength1_linear, .rows = sizeof(_calibration_sinter_strength1_linear) / sizeof(_calibration_sinter_strength1_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_strength1_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_strength1_fs_hdr = { .ptr = _calibration_sinter_strength1_fs_hdr, .rows = sizeof(_calibration_sinter_strength1_fs_hdr) / sizeof(_calibration_sinter_strength1_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_strength1_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_thresh1_linear = { .ptr = _calibration_sinter_thresh1_linear, .rows = sizeof(_calibration_sinter_thresh1_linear) / sizeof(_calibration_sinter_thresh1_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_thresh1_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_thresh1_fs_hdr = { .ptr = _calibration_sinter_thresh1_fs_hdr, .rows = sizeof(_calibration_sinter_thresh1_fs_hdr) / sizeof(_calibration_sinter_thresh1_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_thresh1_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_thresh4_linear = { .ptr = _calibration_sinter_thresh4_linear, .rows = sizeof(_calibration_sinter_thresh4_linear) / sizeof(_calibration_sinter_thresh4_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_thresh4_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sinter_thresh4_fs_hdr = { .ptr = _calibration_sinter_thresh4_fs_hdr, .rows = sizeof(_calibration_sinter_thresh4_fs_hdr) / sizeof(_calibration_sinter_thresh4_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sinter_thresh4_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharp_alt_d_linear = { .ptr = _calibration_sharp_alt_d_linear, .rows = sizeof(_calibration_sharp_alt_d_linear) / sizeof(_calibration_sharp_alt_d_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharp_alt_d_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharp_alt_d_fs_hdr = { .ptr = _calibration_sharp_alt_d_fs_hdr, .rows = sizeof(_calibration_sharp_alt_d_fs_hdr) / sizeof(_calibration_sharp_alt_d_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharp_alt_d_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharp_alt_ud_linear = { .ptr = _calibration_sharp_alt_ud_linear, .rows = sizeof(_calibration_sharp_alt_ud_linear) / sizeof(_calibration_sharp_alt_ud_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharp_alt_ud_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharp_alt_ud_fs_hdr = { .ptr = _calibration_sharp_alt_ud_fs_hdr, .rows = sizeof(_calibration_sharp_alt_ud_fs_hdr) / sizeof(_calibration_sharp_alt_ud_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharp_alt_ud_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharpen_fr_linear = { .ptr = _calibration_sharpen_fr_linear, .rows = sizeof(_calibration_sharpen_fr_linear) / sizeof(_calibration_sharpen_fr_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharpen_fr_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharpen_fr_hdr = { .ptr = _calibration_sharpen_fr_hdr, .rows = sizeof(_calibration_sharpen_fr_hdr) / sizeof(_calibration_sharpen_fr_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharpen_fr_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharpen_ds1_linear = { .ptr = _calibration_sharpen_ds1_linear, .rows = sizeof(_calibration_sharpen_ds1_linear) / sizeof(_calibration_sharpen_ds1_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharpen_ds1_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharpen_ds1_hdr = { .ptr = _calibration_sharpen_ds1_hdr, .rows = sizeof(_calibration_sharpen_ds1_hdr) / sizeof(_calibration_sharpen_ds1_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharpen_ds1_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharpen_ds2_linear = { .ptr = _calibration_sharpen_ds2_linear, .rows = sizeof(_calibration_sharpen_ds2_linear) / sizeof(_calibration_sharpen_ds2_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharpen_ds2_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_sharpen_ds2_hdr = { .ptr = _calibration_sharpen_ds2_hdr, .rows = sizeof(_calibration_sharpen_ds2_hdr) / sizeof(_calibration_sharpen_ds2_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_sharpen_ds2_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_demosaic_np_offset_linear = { .ptr = _calibration_demosaic_np_offset_linear, .rows = sizeof(_calibration_demosaic_np_offset_linear) / sizeof(_calibration_demosaic_np_offset_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_demosaic_np_offset_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_demosaic_np_offset_fs_hdr = { .ptr = _calibration_demosaic_np_offset_fs_hdr, .rows = sizeof(_calibration_demosaic_np_offset_fs_hdr) / sizeof(_calibration_demosaic_np_offset_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_demosaic_np_offset_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_mesh_shading_strength = { .ptr = _calibration_mesh_shading_strength, .rows = sizeof(_calibration_mesh_shading_strength) / sizeof(_calibration_mesh_shading_strength[ 0 ]), .cols = 2, .width = sizeof(_calibration_mesh_shading_strength[ 0 ][ 0 ]) } ;
+static LookupTable calibration_saturation_strength_linear = { .ptr = _calibration_saturation_strength_linear, .rows = sizeof(_calibration_saturation_strength_linear) / sizeof(_calibration_saturation_strength_linear[ 0 ]), .cols = 2, .width = sizeof(_calibration_saturation_strength_linear[ 0 ][ 0 ]) } ;
+static LookupTable calibration_saturation_strength_fs_hdr = { .ptr = _calibration_saturation_strength_fs_hdr, .rows = sizeof(_calibration_saturation_strength_fs_hdr) / sizeof(_calibration_saturation_strength_fs_hdr[ 0 ]), .cols = 2, .width = sizeof(_calibration_saturation_strength_fs_hdr[ 0 ][ 0 ]) } ;
+static LookupTable calibration_temper_strength = { .ptr = _calibration_temper_strength, .rows = sizeof(_calibration_temper_strength) / sizeof(_calibration_temper_strength[ 0 ]), .cols = 2, .width = sizeof(_calibration_temper_strength[ 0 ][ 0 ]) } ;
+static LookupTable calibration_ccm_one_gain_threshold = { .ptr = _calibration_ccm_one_gain_threshold, .cols = sizeof(_calibration_ccm_one_gain_threshold) / sizeof(_calibration_ccm_one_gain_threshold[ 0 ]), .rows = 1, .width = sizeof(_calibration_ccm_one_gain_threshold[ 0 ]) } ;
+static LookupTable calibration_flash_rg =  { .ptr = _calibration_flash_rg, .rows = 1, .cols = sizeof(_calibration_flash_rg) / sizeof(_calibration_flash_rg[ 0 ]), .width = sizeof(_calibration_flash_rg[0]) } ;
+static LookupTable calibration_flash_bg =  { .ptr = _calibration_flash_bg, .rows = 1, .cols = sizeof(_calibration_flash_bg) / sizeof(_calibration_flash_bg[ 0 ]), .width = sizeof(_calibration_flash_bg[0]) } ;
+static LookupTable calibration_ae_balanced_linear =  { .ptr = _calibration_ae_balanced_linear, .rows = 1, .cols = sizeof(_calibration_ae_balanced_linear) / sizeof(_calibration_ae_balanced_linear[ 0 ]), .width = sizeof(_calibration_ae_balanced_linear[0]) } ;
+static LookupTable calibration_ae_balanced_wdr =  { .ptr = _calibration_ae_balanced_wdr, .rows = 1, .cols = sizeof(_calibration_ae_balanced_wdr) / sizeof(_calibration_ae_balanced_wdr[ 0 ]), .width = sizeof(_calibration_ae_balanced_wdr[0]) } ;
+static LookupTable calibration_iridix_strength_table = { .ptr = _calibration_iridix_strength_table, .rows = sizeof(_calibration_iridix_strength_table) / sizeof(_calibration_iridix_strength_table[ 0 ]), .cols = 2, .width = sizeof(_calibration_iridix_strength_table[ 0 ][ 0 ]) } ;
+static LookupTable calibration_rgb2yuv_conversion =  { .ptr = _calibration_rgb2yuv_conversion, .rows = 1, .cols = sizeof(_calibration_rgb2yuv_conversion) / sizeof(_calibration_rgb2yuv_conversion[ 0 ]), .width = sizeof(_calibration_rgb2yuv_conversion[0]) } ; 
+
+ uint32_t get_dynamic_calibrations( ApicalCalibrations *c ) {
+	uint32_t result = 0 ;
+	if ( c != 0 ) {
+		c->calibrations[ _CALIBRATION_DP_SLOPE_LINEAR ] = &calibration_dp_slope_linear ;
+		c->calibrations[ _CALIBRATION_DP_SLOPE_FS_HDR ] = &calibration_dp_slope_fs_hdr ;
+		c->calibrations[ _CALIBRATION_DP_THRESHOLD_LINEAR ] = &calibration_dp_threshold_linear ;
+		c->calibrations[ _CALIBRATION_DP_THRESHOLD_FS_HDR ] = &calibration_dp_threshold_fs_hdr ;
+		c->calibrations[ _CALIBRATION_STITCHING_ERROR_THRESH ] = &calibration_stitching_error_thresh ;
+		c->calibrations[ _CALIBRATION_EVTOLUX_PROBABILITY_ENABLE ] = &calibration_evtolux_probability_enable ;
+		c->calibrations[ _CALIBRATION_NP_LUT_MEAN ] = &calibration_np_lut_mean ;
+		c->calibrations[ _CALIBRATION_AWB_AVG_COEF ] = &calibration_awb_avg_coef ;
+		c->calibrations[ _CALIBRATION_IRIDIX_AVG_COEF ] = &calibration_iridix_avg_coef ;
+		c->calibrations[ _CALIBRATION_AE_EXPOSURE_AVG_COEF ] = &calibration_exposure_avg_coef ;
+		c->calibrations[ _CALIBRATION_CNR_UV_DELTA12_SLOPE ] = &calibration_cnr_uv_delta12_slope ;
+		c->calibrations[ _CALIBRATION_AF_MIN_TABLE ] = &calibration_af_min_table ;
+		c->calibrations[ _CALIBRATION_AF_MAX_TABLE ] = &calibration_af_max_table ;
+		c->calibrations[ _CALIBRATION_AF_WINDOW_RESIZE_TABLE ] = &calibration_af_window_resize_table ;
+		c->calibrations[ _CALIBRATION_EXP_RATIO_TABLE ] = &calibration_exp_ratio_table ;
+		c->calibrations[ _CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR ] = &calibration_iridix_strength_maximum_linear ;
+		c->calibrations[ _CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR ] = &calibration_iridix_strength_maximum_wdr ;
+		c->calibrations[ _CALIBRATION_IRIDIX_BLACK_PRC ] = &calibration_iridix_black_prc ;
+		c->calibrations[ _CALIBRATION_IRIDIX_GAIN_MAX ] = &calibration_iridix_gain_max ;
+		c->calibrations[ _CALIBRATION_IRIDIX_MIN_MAX_STR ] = &calibration_iridix_min_max_str ;
+		c->calibrations[ _CALIBRATION_IRIDIX_EV_LIM_FULL_STR ] = &calibration_iridix_ev_lim_full_str ;
+		c->calibrations[ _CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR ] = &calibration_iridix_ev_lim_no_str_linear ;
+		c->calibrations[ _CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR ] = &calibration_iridix_ev_lim_no_str_fs_hdr ;
+		c->calibrations[ _CALIBRATION_AE_CORRECTION_LINEAR ] = &calibration_ae_correction_linear ;
+		c->calibrations[ _CALIBRATION_AE_CORRECTION_FS_HDR ] = &calibration_ae_correction_fs_hdr ;
+		c->calibrations[ _CALIBRATION_AE_EXPOSURE_CORRECTION ] = &calibration_ae_exposure_correction ;
+		c->calibrations[ _CALIBRATION_SINTER_STRENGTH_LINEAR ] = &calibration_sinter_strength_linear ;
+		c->calibrations[ _CALIBRATION_SINTER_STRENGTH_FS_HDR ] = &calibration_sinter_strength_fs_hdr ;
+		c->calibrations[ _CALIBRATION_SINTER_STRENGTH1_LINEAR ] = &calibration_sinter_strength1_linear ;
+		c->calibrations[ _CALIBRATION_SINTER_STRENGTH1_FS_HDR ] = &calibration_sinter_strength1_fs_hdr ;
+		c->calibrations[ _CALIBRATION_SINTER_THRESH1_LINEAR ] = &calibration_sinter_thresh1_linear ;
+		c->calibrations[ _CALIBRATION_SINTER_THRESH1_FS_HDR ] = &calibration_sinter_thresh1_fs_hdr ;
+		c->calibrations[ _CALIBRATION_SINTER_THRESH4_LINEAR ] = &calibration_sinter_thresh4_linear ;
+		c->calibrations[ _CALIBRATION_SINTER_THRESH4_FS_HDR ] = &calibration_sinter_thresh4_fs_hdr ;
+		c->calibrations[ _CALIBRATION_SHARP_ALT_D_LINEAR ] = &calibration_sharp_alt_d_linear ;
+		c->calibrations[ _CALIBRATION_SHARP_ALT_D_FS_HDR ] = &calibration_sharp_alt_d_fs_hdr ;
+		c->calibrations[ _CALIBRATION_SHARP_ALT_UD_LINEAR ] = &calibration_sharp_alt_ud_linear ;
+		c->calibrations[ _CALIBRATION_SHARP_ALT_UD_FS_HDR ] = &calibration_sharp_alt_ud_fs_hdr ;
+		c->calibrations[ _CALIBRATION_SHARPEN_FR_LINEAR ] = &calibration_sharpen_fr_linear ;
+		c->calibrations[ _CALIBRATION_SHARPEN_FR_WDR ] = &calibration_sharpen_fr_hdr ;
+		c->calibrations[ _CALIBRATION_SHARPEN_DS1_LINEAR ] = &calibration_sharpen_ds1_linear ;
+		c->calibrations[ _CALIBRATION_SHARPEN_DS1_WDR ] = &calibration_sharpen_ds1_hdr ;
+		c->calibrations[ _CALIBRATION_SHARPEN_DS2_LINEAR ] = &calibration_sharpen_ds2_linear ;
+		c->calibrations[ _CALIBRATION_SHARPEN_DS2_WDR ] = &calibration_sharpen_ds2_hdr ;
+		c->calibrations[ _CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR ] = &calibration_demosaic_np_offset_linear ;
+		c->calibrations[ _CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR ] = &calibration_demosaic_np_offset_fs_hdr ;
+		c->calibrations[ _CALIBRATION_MESH_SHADING_STRENGTH ] = &calibration_mesh_shading_strength ;
+		c->calibrations[ _CALIBRATION_SATURATION_STRENGTH_LINEAR ] = &calibration_saturation_strength_linear ;
+		c->calibrations[ _CALIBRATION_SATURATION_STRENGTH_FS_HDR ] = &calibration_saturation_strength_fs_hdr ;
+		c->calibrations[ _CALIBRATION_TEMPER_STRENGTH ] = &calibration_temper_strength ;
+		c->calibrations[ _CALIBRATION_FLASH_RG ] = &calibration_flash_rg ;
+		c->calibrations[ _CALIBRATION_FLASH_BG ] = &calibration_flash_bg ;
+		c->calibrations[ _CALIBRATION_CCM_ONE_GAIN_THRESHOLD ] = &calibration_ccm_one_gain_threshold ;
+		c->calibrations[ _CALIBRATION_AE_BALANCED_LINEAR ] = &calibration_ae_balanced_linear ;
+		c->calibrations[ _CALIBRATION_AE_BALANCED_WDR ] = &calibration_ae_balanced_wdr ;
+		c->calibrations[ _CALIBRATION_IRIDIX_STRENGTH_TABLE] = &calibration_iridix_strength_table;
+		c->calibrations[ _CALIBRATION_RGB2YUV_CONVERSION] = &calibration_rgb2yuv_conversion;
+	} else {
+		result = -1 ;
+	}
+	return result ;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_isp_io.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_isp_io.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_isp_io.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_isp_io.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,59 @@
+#include "apical_isp_io.h"
+#include "tx-isp-core.h"
+unsigned int watchaddr[50] = {
+	/*	0x00010, 0x00014, 0x00040, 0x00044,
+		0x00b00, 0x00b04, 0x009c0, 0x009c4,
+		0x00130, 0x00b1c, 0x00b20, 0x00b24,
+		0x00080, 0x00084, 0x00088, 0x0008c,
+		0x00090, 0x00094, 0x00098, 0x0009c,
+	 */	0x00b08, 0x00b0c, 0x00b10, 0x00b14,
+	0x00b18,
+	0,
+};
+static int trap_addr(unsigned int addr)
+{
+	int ret = 0;
+	int i = 0;
+	for(i = 0; i < 50; i++)
+	{
+		if(watchaddr[i] == 0){
+			break;
+		}
+		if(watchaddr[i] == addr){
+			ret = 1;
+			break;
+		}
+	}
+	return ret;
+}
+static void __iomem *apical_io_base;
+uint32_t APICAL_READ_32(uint32_t addr)
+{
+	return tx_isp_readl(apical_io_base, addr);
+}
+uint16_t APICAL_READ_16(uint32_t addr)
+{
+	return tx_isp_readw(apical_io_base, addr);
+}
+uint8_t APICAL_READ_8(uint32_t addr)
+{
+	return tx_isp_readb(apical_io_base, addr);
+}
+void APICAL_WRITE_32(uint32_t addr, uint32_t data)
+{
+	//	if(addr == 0x544)
+	//		dump_stack();
+	tx_isp_writel(apical_io_base, addr, data);
+}
+void APICAL_WRITE_16(uint32_t addr, uint16_t data)
+{
+	tx_isp_writew(apical_io_base, addr, data);
+}
+void APICAL_WRITE_8(uint32_t addr, uint8_t data)
+{
+	tx_isp_writeb(apical_io_base, addr, data);
+}
+void apical_iobase_init(void __iomem *base)
+{
+	apical_io_base = base;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_modulation.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_modulation.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_modulation.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_modulation.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,31 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_MODULATION_H__
+#define __APICAL_MODULATION_H__
+
+#include <apical-isp/apical.h>
+#include <apical-isp/apical_types.h>
+
+
+uint16_t calc_modulation_u16(uint16_t x,const modulation_entry_t *p_table,int table_len);
+uint32_t calc_modulation_u32(uint32_t x,const modulation_entry_32_t *p_table,int table_len);
+
+uint16_t calc_adjust_modulation_u16(uint16_t x,uint16_t target_min_y,uint16_t target_max_y,const modulation_entry_t *p_table,int table_len);
+uint16_t calc_scaled_modulation_u16(uint16_t x,uint16_t target_min_y,uint16_t target_max_y,const modulation_entry_t *p_table,int table_len);
+
+uint16_t calc_equidistant_modulation_u16(uint16_t x, const uint16_t *p_table, uint16_t table_len);
+uint32_t calc_equidistant_modulation_u32(uint32_t x, const uint32_t *p_table, uint32_t table_len);
+uint16_t calc_inv_equidistant_modulation_u16(uint16_t x, const uint16_t *p_table, uint16_t table_len);
+uint32_t calc_inv_equidistant_modulation_u32(uint32_t x, const uint32_t *p_table, uint32_t table_len);
+
+#endif /* __APICAL_MODULATION_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_sbus.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_sbus.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_sbus.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_sbus.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,51 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_SBUS_H__
+#define __APICAL_SBUS_H__
+
+#include <sensor-common.h>
+#include <apical-isp/apical.h>
+#include <apical-isp/apical_interface_config.h>
+
+typedef struct _apical_sbus_t apical_sbus_t;
+typedef struct _apical_sbus_t *apical_sbus_ptr_t;
+typedef const struct _apical_sbus_t *apical_sbus_const_ptr_t;
+
+struct _apical_sbus_t
+{
+	uint32_t mask;
+	uint8_t device;
+	uint32_t control;
+	void *p_control;
+	uint32_t (*read_sample)(apical_sbus_ptr_t p_bus, uint32_t addr, uint8_t sample_size);
+	void (*write_sample)(apical_sbus_ptr_t p_bus, uint32_t addr, uint32_t sample, uint8_t sample_size);
+};
+uint8_t apical_sbus_read_u8(apical_sbus_ptr_t p_bus, uint32_t addr);
+uint16_t apical_sbus_read_u16(apical_sbus_ptr_t p_bus, uint32_t addr);
+uint32_t apical_sbus_read_u32(apical_sbus_ptr_t p_bus, uint32_t addr);
+void apical_sbus_read_data_u8(apical_sbus_ptr_t p_bus, uint32_t addr, uint8_t *p_data, int n_count);
+void apical_sbus_read_data_u16(apical_sbus_ptr_t p_bus, uint32_t addr, uint16_t *p_data, int n_count);
+void apical_sbus_read_data_u32(apical_sbus_ptr_t p_bus, uint32_t addr, uint32_t *p_data, int n_count);
+void apical_sbus_write_u8(apical_sbus_ptr_t p_bus, uint32_t addr, uint8_t sample);
+void apical_sbus_write_u16(apical_sbus_ptr_t p_bus, uint32_t addr, uint16_t sample);
+void apical_sbus_write_u32(apical_sbus_ptr_t p_bus, uint32_t addr, uint32_t sample);
+void apical_sbus_write_data_u8(apical_sbus_ptr_t p_bus, uint32_t addr, uint8_t *p_data, int n_count);
+void apical_sbus_write_data_u16(apical_sbus_ptr_t p_bus, uint32_t addr, uint16_t *p_data, int n_count);
+void apical_sbus_write_data_u32(apical_sbus_ptr_t p_bus, uint32_t addr, uint32_t *p_data, int n_count);
+void apical_sbus_write_data(apical_sbus_ptr_t p_bus, uint32_t addr, void *p_data, int n_size);
+void apical_sbus_copy(apical_sbus_t *p_bus_to, uint32_t addr_to, apical_sbus_t *p_bus_from, uint32_t addr_from, int n_size);
+
+#include "apical_sbus_i2c.h"
+#include "apical_sbus_spi.h"
+
+#endif /* __APICAL_SBUS_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_sbus_i2c.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_sbus_i2c.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_sbus_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_sbus_i2c.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,22 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_SBUS_I2C_H__
+#define	__APICAL_SBUS_I2C_H__
+
+#include "apical_sbus.h"
+
+void apical_sbus_i2c_init(apical_sbus_t *p_bus);
+
+void i2c_init_access(void);
+
+#endif	/* __APICAL_SBUS_I2C_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_sbus_spi.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_sbus_spi.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_sbus_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_sbus_spi.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,20 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_SBUS_SPI_H__
+#define	__APICAL_SBUS_SPI_H__
+
+#include "apical_sbus.h"
+
+void apical_sbus_spi_init(apical_sbus_ptr_t p_sbus);
+
+#endif	/* __APICAL_SBUS_SPI_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_scaler_lut.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_scaler_lut.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_scaler_lut.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_scaler_lut.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,1060 @@
+#include "tx-isp-core.h"
+struct isp_reg_t apical_downscaler_lut[] =
+{
+	/* HFIL 00 */
+	{0x14000, 0x27F70200},
+	{0x14004, 0x0002F727},
+	{0x14008, 0x29F70200},
+	{0x1400C, 0x0002F824},
+	{0x14010, 0x2CF70200},
+	{0x14014, 0x0002F821},
+	{0x14018, 0x2EF70200},
+	{0x1401C, 0x0002F91E},
+	{0x14020, 0x30F70200},
+	{0x14024, 0x0002F91C},
+	{0x14028, 0x33F70200},
+	{0x1402C, 0x0001FA19},
+	{0x14030, 0x35F70200},
+	{0x14034, 0x0001FA17},
+	{0x14038, 0x37F70200},
+	{0x1403C, 0x0001FB14},
+	{0x14040, 0x39F70200},
+	{0x14044, 0x0001FC11},
+	{0x14048, 0x3AF80200},
+	{0x1404C, 0x0001FC0F},
+	{0x14050, 0x3BF90200},
+	{0x14054, 0x0001FD0C},
+	{0x14058, 0x3CFA0200},
+	{0x1405C, 0x0001FD0A},
+	{0x14060, 0x3EFB0100},
+	{0x14064, 0x0000FE08},
+	{0x14068, 0x3EFC0100},
+	{0x1406C, 0x0000FF06},
+	{0x14070, 0x3FFD0100},
+	{0x14074, 0x0000FF04},
+	{0x14078, 0x40FE0000},
+	{0x1407C, 0x00000002},
+	{0x14080, 0x40000000},
+	{0x14084, 0x00000000},
+	{0x14088, 0x40020000},
+	{0x1408C, 0x000000FE},
+	{0x14090, 0x3F04FF00},
+	{0x14094, 0x000001FD},
+	{0x14098, 0x3E06FF00},
+	{0x1409C, 0x000001FC},
+	{0x140A0, 0x3E08FE00},
+	{0x140A4, 0x000001FB},
+	{0x140A8, 0x3C0AFD01},
+	{0x140AC, 0x000002FA},
+	{0x140B0, 0x3B0CFD01},
+	{0x140B4, 0x000002F9},
+	{0x140B8, 0x3A0FFC01},
+	{0x140BC, 0x000002F8},
+	{0x140C0, 0x3911FC01},
+	{0x140C4, 0x000002F7},
+	{0x140C8, 0x3714FB01},
+	{0x140CC, 0x000002F7},
+	{0x140D0, 0x3517FA01},
+	{0x140D4, 0x000002F7},
+	{0x140D8, 0x3319FA01},
+	{0x140DC, 0x000002F7},
+	{0x140E0, 0x301CF902},
+	{0x140E4, 0x000002F7},
+	{0x140E8, 0x2E1EF902},
+	{0x140EC, 0x000002F7},
+	{0x140F0, 0x2C21F802},
+	{0x140F4, 0x000002F7},
+	{0x140F8, 0x2924F802},
+	{0x140FC, 0x000002F7},
+
+	/* HFIL 01 */
+	{0x14100, 0x25FDFB06},
+	{0x14104, 0x00FBFD25},
+	{0x14108,	0x26FEFA06},
+	{0x1410C,	0x00FBFD24},
+	{0x14110,	0x27FFFA06},
+	{0x14114,	0x00FCFC22},
+	{0x14118,	0x2900F905},
+	{0x1411C,	0x00FCFB22},
+	{0x14120,	0x2901F905},
+	{0x14124,	0x00FDFA21},
+	{0x14128,	0x2A02F805},
+	{0x1412C,	0x00FDFA20},
+	{0x14130,	0x2A04F805},
+	{0x14134,	0x00FEF91E},
+	{0x14138,	0x2A05F805},
+	{0x1413C,	0x00FEF91D},
+	{0x14140,	0x2C06F705},
+	{0x14144,	0x00FFF81B},
+	{0x14148,	0x2C07F705},
+	{0x1414C,	0x00FFF81A},
+	{0x14150,	0x2D08F704},
+	{0x14154,	0x0000F719},
+	{0x14158,	0x2D0AF704},
+	{0x1415C,	0x0000F717},
+	{0x14160,	0x2D0BF604},
+	{0x14164,	0x0001F716},
+	{0x14168,	0x2D0CF604},
+	{0x1416C,	0x0001F715},
+	{0x14170,	0x2E0EF603},
+	{0x14174,	0x0002F613},
+	{0x14178,	0x2E0FF603},
+	{0x1417C,	0x0002F612},
+	{0x14180,	0x2E11F602},
+	{0x14184,	0x0002F611},
+	{0x14188,	0x2E12F602},
+	{0x1418C,	0x0003F60F},
+	{0x14190,	0x2E13F602},
+	{0x14194,	0x0003F60E},
+	{0x14198,	0x2D15F701},
+	{0x1419C,	0x0004F60C},
+	{0x141A0,	0x2D16F701},
+	{0x141A4,	0x0004F60B},
+	{0x141A8,	0x2D17F700},
+	{0x141AC,	0x0004F70A},
+	{0x141B0,	0x2D19F700},
+	{0x141B4,	0x0004F708},
+	{0x141B8,	0x2C1AF8FF},
+	{0x141BC,	0x0005F707},
+	{0x141C0,	0x2C1BF8FF},
+	{0x141C4,	0x0005F706},
+	{0x141C8,	0x2A1DF9FE},
+	{0x141CC,	0x0005F805},
+	{0x141D0,	0x2A1EF9FE},
+	{0x141D4,	0x0005F804},
+	{0x141D8,	0x2A20FAFD},
+	{0x141DC,	0x0005F802},
+	{0x141E0,	0x2921FAFD},
+	{0x141E4,	0x0005F901},
+	{0x141E8,	0x2922FBFC},
+	{0x141EC,	0x0005F900},
+	{0x141F0,	0x2722FCFC},
+	{0x141F4,	0x0006FAFF},
+	{0x141F8,	0x2624FDFB},
+	{0x141FC,	0x0006FAFE},
+
+	/* HFIL 02 */
+	{0x14200,	0x1E0AFAFC},
+	{0x14204,	0x00FA0A1E},
+	{0x14208,	0x1E0BFAFC},
+	{0x1420C,	0x00FA091E},
+	{0x14210,	0x1E0CFBFB},
+	{0x14214,	0x00FA091D},
+	{0x14218,	0x1F0CFBFB},
+	{0x1421C,	0x00FA081D},
+	{0x14220,	0x200DFBFB},
+	{0x14224,	0x00F9071D},
+	{0x14228,	0x200EFBFB},
+	{0x1422C,	0x00F9071C},
+	{0x14230,	0x200EFCFB},
+	{0x14234,	0x00F9061C},
+	{0x14238,	0x210FFCFA},
+	{0x1423C,	0x00F9051C},
+	{0x14240,	0x2110FCFA},
+	{0x14244,	0x00F9051B},
+	{0x14248,	0x2111FDFA},
+	{0x1424C,	0x00F9041A},
+	{0x14250,	0x2211FDFA},
+	{0x14254,	0x00F9031A},
+	{0x14258,	0x2212FEFA},
+	{0x1425C,	0x00F90318},
+	{0x14260,	0x2213FEFA},
+	{0x14264,	0x00F90218},
+	{0x14268,	0x2213FFF9},
+	{0x1426C,	0x00F90218},
+	{0x14270,	0x2215FFF9},
+	{0x14274,	0x00F90117},
+	{0x14278,	0x2215FFF9},
+	{0x1427C,	0x00F90117},
+	{0x14280,	0x221600F9},
+	{0x14284,	0x00F90016},
+	{0x14288,	0x221701F9},
+	{0x1428C,	0x00F9FF15},
+	{0x14290,	0x221701F9},
+	{0x14294,	0x00F9FF15},
+	{0x14298,	0x221802F9},
+	{0x1429C,	0x00F9FF13},
+	{0x142A0,	0x221802F9},
+	{0x142A4,	0x00FAFE13},
+	{0x142A8,	0x221803F9},
+	{0x142AC,	0x00FAFE12},
+	{0x142B0,	0x221A03F9},
+	{0x142B4,	0x00FAFD11},
+	{0x142B8,	0x211A04F9},
+	{0x142BC,	0x00FAFD11},
+	{0x142C0,	0x211B05F9},
+	{0x142C4,	0x00FAFC10},
+	{0x142C8,	0x211C05F9},
+	{0x142CC,	0x00FAFC0F},
+	{0x142D0,	0x201C06F9},
+	{0x142D4,	0x00FBFC0E},
+	{0x142D8,	0x201C07F9},
+	{0x142DC,	0x00FBFB0E},
+	{0x142E0,	0x201D07F9},
+	{0x142E4,	0x00FBFB0D},
+	{0x142E8,	0x1F1D08FA},
+	{0x142EC,	0x00FBFB0C},
+	{0x142F0,	0x1E1D09FA},
+	{0x142F4,	0x00FBFB0C},
+	{0x142F8,	0x1E1E09FA},
+	{0x142FC,	0x00FCFA0B},
+
+	/* HFIL 03 */
+	{0x14300,	0x130C03FD},
+	{0x14304,	0x00020C13},
+	{0x14308,	0x130C03FD},
+	{0x1430C,	0x00020C13},
+	{0x14310,	0x130D03FD},
+	{0x14314,	0x00020B13},
+	{0x14318,	0x130D03FD},
+	{0x1431C,	0x00020B13},
+	{0x14320,	0x140D04FD},
+	{0x14324,	0x00010B12},
+	{0x14328,	0x140E04FD},
+	{0x1432C,	0x00010A12},
+	{0x14330,	0x140E04FD},
+	{0x14334,	0x00010A12},
+	{0x14338,	0x140E04FD},
+	{0x1433C,	0x00010A12},
+	{0x14340,	0x140E04FE},
+	{0x14344,	0x00010912},
+	{0x14348,	0x140E05FE},
+	{0x1434C,	0x00000912},
+	{0x14350,	0x140F05FE},
+	{0x14354,	0x00000911},
+	{0x14358,	0x140F06FE},
+	{0x1435C,	0x00000811},
+	{0x14360,	0x140F06FE},
+	{0x14364,	0x00000811},
+	{0x14368,	0x141006FE},
+	{0x1436C,	0x00FF0811},
+	{0x14370,	0x141006FF},
+	{0x14374,	0x00FF0810},
+	{0x14378,	0x141007FF},
+	{0x1437C,	0x00FF0710},
+	{0x14380,	0x141007FF},
+	{0x14384,	0x00FF0710},
+	{0x14388,	0x141007FF},
+	{0x1438C,	0x00FF0710},
+	{0x14390,	0x141008FF},
+	{0x14394,	0x00FF0610},
+	{0x14398,	0x141108FF},
+	{0x1439C,	0x00FE0610},
+	{0x143A0,	0x14110800},
+	{0x143A4,	0x00FE060F},
+	{0x143A8,	0x14110800},
+	{0x143AC,	0x00FE060F},
+	{0x143B0,	0x14110900},
+	{0x143B4,	0x00FE050F},
+	{0x143B8,	0x14120900},
+	{0x143BC,	0x00FE050E},
+	{0x143C0,	0x14120901},
+	{0x143C4,	0x00FE040E},
+	{0x143C8,	0x14120A01},
+	{0x143CC,	0x00FD040E},
+	{0x143D0,	0x14120A01},
+	{0x143D4,	0x00FD040E},
+	{0x143D8,	0x14120A01},
+	{0x143DC,	0x00FD040E},
+	{0x143E0,	0x14120B01},
+	{0x143E4,	0x00FD040D},
+	{0x143E8,	0x13130B02},
+	{0x143EC,	0x00FD030D},
+	{0x143F0,	0x13130B02},
+	{0x143F4,	0x00FD030D},
+	{0x143F8,	0x13130C02},
+	{0x143FC,	0x00FD030C},
+
+	/* HFIL 04 */
+	{0x18000, 0x27F70200},
+	{0x18004, 0x0002F727},
+	{0x18008, 0x29F70200},
+	{0x1800C, 0x0002F824},
+	{0x18010, 0x2CF70200},
+	{0x18014, 0x0002F821},
+	{0x18018, 0x2EF70200},
+	{0x1801C, 0x0002F91E},
+	{0x18020, 0x30F70200},
+	{0x18024, 0x0002F91C},
+	{0x18028, 0x33F70200},
+	{0x1802C, 0x0001FA19},
+	{0x18030, 0x35F70200},
+	{0x18034, 0x0001FA17},
+	{0x18038, 0x37F70200},
+	{0x1803C, 0x0001FB14},
+	{0x18040, 0x39F70200},
+	{0x18044, 0x0001FC11},
+	{0x18048, 0x3AF80200},
+	{0x1804C, 0x0001FC0F},
+	{0x18050, 0x3BF90200},
+	{0x18054, 0x0001FD0C},
+	{0x18058, 0x3CFA0200},
+	{0x1805C, 0x0001FD0A},
+	{0x18060, 0x3EFB0100},
+	{0x18064, 0x0000FE08},
+	{0x18068, 0x3EFC0100},
+	{0x1806C, 0x0000FF06},
+	{0x18070, 0x3FFD0100},
+	{0x18074, 0x0000FF04},
+	{0x18078, 0x40FE0000},
+	{0x1807C, 0x00000002},
+	{0x18080, 0x40000000},
+	{0x18084, 0x00000000},
+	{0x18088, 0x40020000},
+	{0x1808C, 0x000000FE},
+	{0x18090, 0x3F04FF00},
+	{0x18094, 0x000001FD},
+	{0x18098, 0x3E06FF00},
+	{0x1809C, 0x000001FC},
+	{0x180A0, 0x3E08FE00},
+	{0x180A4, 0x000001FB},
+	{0x180A8, 0x3C0AFD01},
+	{0x180AC, 0x000002FA},
+	{0x180B0, 0x3B0CFD01},
+	{0x180B4, 0x000002F9},
+	{0x180B8, 0x3A0FFC01},
+	{0x180BC, 0x000002F8},
+	{0x180C0, 0x3911FC01},
+	{0x180C4, 0x000002F7},
+	{0x180C8, 0x3714FB01},
+	{0x180CC, 0x000002F7},
+	{0x180D0, 0x3517FA01},
+	{0x180D4, 0x000002F7},
+	{0x180D8, 0x3319FA01},
+	{0x180DC, 0x000002F7},
+	{0x180E0, 0x301CF902},
+	{0x180E4, 0x000002F7},
+	{0x180E8, 0x2E1EF902},
+	{0x180EC, 0x000002F7},
+	{0x180F0, 0x2C21F802},
+	{0x180F4, 0x000002F7},
+	{0x180F8, 0x2924F802},
+	{0x180FC, 0x000002F7},
+
+	/* HFIL 01 */
+	{0x18100, 0x25FDFB06},
+	{0x18104, 0x00FBFD25},
+	{0x18108,	0x26FEFA06},
+	{0x1810C,	0x00FBFD24},
+	{0x18110,	0x27FFFA06},
+	{0x18114,	0x00FCFC22},
+	{0x18118,	0x2900F905},
+	{0x1811C,	0x00FCFB22},
+	{0x18120,	0x2901F905},
+	{0x18124,	0x00FDFA21},
+	{0x18128,	0x2A02F805},
+	{0x1812C,	0x00FDFA20},
+	{0x18130,	0x2A04F805},
+	{0x18134,	0x00FEF91E},
+	{0x18138,	0x2A05F805},
+	{0x1813C,	0x00FEF91D},
+	{0x18140,	0x2C06F705},
+	{0x18144,	0x00FFF81B},
+	{0x18148,	0x2C07F705},
+	{0x1814C,	0x00FFF81A},
+	{0x18150,	0x2D08F704},
+	{0x18154,	0x0000F719},
+	{0x18158,	0x2D0AF704},
+	{0x1815C,	0x0000F717},
+	{0x18160,	0x2D0BF604},
+	{0x18164,	0x0001F716},
+	{0x18168,	0x2D0CF604},
+	{0x1816C,	0x0001F715},
+	{0x18170,	0x2E0EF603},
+	{0x18174,	0x0002F613},
+	{0x18178,	0x2E0FF603},
+	{0x1817C,	0x0002F612},
+	{0x18180,	0x2E11F602},
+	{0x18184,	0x0002F611},
+	{0x18188,	0x2E12F602},
+	{0x1818C,	0x0003F60F},
+	{0x18190,	0x2E13F602},
+	{0x18194,	0x0003F60E},
+	{0x18198,	0x2D15F701},
+	{0x1819C,	0x0004F60C},
+	{0x181A0,	0x2D16F701},
+	{0x181A4,	0x0004F60B},
+	{0x181A8,	0x2D17F700},
+	{0x181AC,	0x0004F70A},
+	{0x181B0,	0x2D19F700},
+	{0x181B4,	0x0004F708},
+	{0x181B8,	0x2C1AF8FF},
+	{0x181BC,	0x0005F707},
+	{0x181C0,	0x2C1BF8FF},
+	{0x181C4,	0x0005F706},
+	{0x181C8,	0x2A1DF9FE},
+	{0x181CC,	0x0005F805},
+	{0x181D0,	0x2A1EF9FE},
+	{0x181D4,	0x0005F804},
+	{0x181D8,	0x2A20FAFD},
+	{0x181DC,	0x0005F802},
+	{0x181E0,	0x2921FAFD},
+	{0x181E4,	0x0005F901},
+	{0x181E8,	0x2922FBFC},
+	{0x181EC,	0x0005F900},
+	{0x181F0,	0x2722FCFC},
+	{0x181F4,	0x0006FAFF},
+	{0x181F8,	0x2624FDFB},
+	{0x181FC,	0x0006FAFE},
+
+	/* HFIL 02 */
+	{0x18200,	0x1E0AFAFC},
+	{0x18204,	0x00FA0A1E},
+	{0x18208,	0x1E0BFAFC},
+	{0x1820C,	0x00FA091E},
+	{0x18210,	0x1E0CFBFB},
+	{0x18214,	0x00FA091D},
+	{0x18218,	0x1F0CFBFB},
+	{0x1821C,	0x00FA081D},
+	{0x18220,	0x200DFBFB},
+	{0x18224,	0x00F9071D},
+	{0x18228,	0x200EFBFB},
+	{0x1822C,	0x00F9071C},
+	{0x18230,	0x200EFCFB},
+	{0x18234,	0x00F9061C},
+	{0x18238,	0x210FFCFA},
+	{0x1823C,	0x00F9051C},
+	{0x18240,	0x2110FCFA},
+	{0x18244,	0x00F9051B},
+	{0x18248,	0x2111FDFA},
+	{0x1824C,	0x00F9041A},
+	{0x18250,	0x2211FDFA},
+	{0x18254,	0x00F9031A},
+	{0x18258,	0x2212FEFA},
+	{0x1825C,	0x00F90318},
+	{0x18260,	0x2213FEFA},
+	{0x18264,	0x00F90218},
+	{0x18268,	0x2213FFF9},
+	{0x1826C,	0x00F90218},
+	{0x18270,	0x2215FFF9},
+	{0x18274,	0x00F90117},
+	{0x18278,	0x2215FFF9},
+	{0x1827C,	0x00F90117},
+	{0x18280,	0x221600F9},
+	{0x18284,	0x00F90016},
+	{0x18288,	0x221701F9},
+	{0x1828C,	0x00F9FF15},
+	{0x18290,	0x221701F9},
+	{0x18294,	0x00F9FF15},
+	{0x18298,	0x221802F9},
+	{0x1829C,	0x00F9FF13},
+	{0x182A0,	0x221802F9},
+	{0x182A4,	0x00FAFE13},
+	{0x182A8,	0x221803F9},
+	{0x182AC,	0x00FAFE12},
+	{0x182B0,	0x221A03F9},
+	{0x182B4,	0x00FAFD11},
+	{0x182B8,	0x211A04F9},
+	{0x182BC,	0x00FAFD11},
+	{0x182C0,	0x211B05F9},
+	{0x182C4,	0x00FAFC10},
+	{0x182C8,	0x211C05F9},
+	{0x182CC,	0x00FAFC0F},
+	{0x182D0,	0x201C06F9},
+	{0x182D4,	0x00FBFC0E},
+	{0x182D8,	0x201C07F9},
+	{0x182DC,	0x00FBFB0E},
+	{0x182E0,	0x201D07F9},
+	{0x182E4,	0x00FBFB0D},
+	{0x182E8,	0x1F1D08FA},
+	{0x182EC,	0x00FBFB0C},
+	{0x182F0,	0x1E1D09FA},
+	{0x182F4,	0x00FBFB0C},
+	{0x182F8,	0x1E1E09FA},
+	{0x182FC,	0x00FCFA0B},
+
+	/* HFIL 03 */
+	{0x18300,	0x130C03FD},
+	{0x18304,	0x00020C13},
+	{0x18308,	0x130C03FD},
+	{0x1830C,	0x00020C13},
+	{0x18310,	0x130D03FD},
+	{0x18314,	0x00020B13},
+	{0x18318,	0x130D03FD},
+	{0x1831C,	0x00020B13},
+	{0x18320,	0x140D04FD},
+	{0x18324,	0x00010B12},
+	{0x18328,	0x140E04FD},
+	{0x1832C,	0x00010A12},
+	{0x18330,	0x140E04FD},
+	{0x18334,	0x00010A12},
+	{0x18338,	0x140E04FD},
+	{0x1833C,	0x00010A12},
+	{0x18340,	0x140E04FE},
+	{0x18344,	0x00010912},
+	{0x18348,	0x140E05FE},
+	{0x1834C,	0x00000912},
+	{0x18350,	0x140F05FE},
+	{0x18354,	0x00000911},
+	{0x18358,	0x140F06FE},
+	{0x1835C,	0x00000811},
+	{0x18360,	0x140F06FE},
+	{0x18364,	0x00000811},
+	{0x18368,	0x141006FE},
+	{0x1836C,	0x00FF0811},
+	{0x18370,	0x141006FF},
+	{0x18374,	0x00FF0810},
+	{0x18378,	0x141007FF},
+	{0x1837C,	0x00FF0710},
+	{0x18380,	0x141007FF},
+	{0x18384,	0x00FF0710},
+	{0x18388,	0x141007FF},
+	{0x1838C,	0x00FF0710},
+	{0x18390,	0x141008FF},
+	{0x18394,	0x00FF0610},
+	{0x18398,	0x141108FF},
+	{0x1839C,	0x00FE0610},
+	{0x183A0,	0x14110800},
+	{0x183A4,	0x00FE060F},
+	{0x183A8,	0x14110800},
+	{0x183AC,	0x00FE060F},
+	{0x183B0,	0x14110900},
+	{0x183B4,	0x00FE050F},
+	{0x183B8,	0x14120900},
+	{0x183BC,	0x00FE050E},
+	{0x183C0,	0x14120901},
+	{0x183C4,	0x00FE040E},
+	{0x183C8,	0x14120A01},
+	{0x183CC,	0x00FD040E},
+	{0x183D0,	0x14120A01},
+	{0x183D4,	0x00FD040E},
+	{0x183D8,	0x14120A01},
+	{0x183DC,	0x00FD040E},
+	{0x183E0,	0x14120B01},
+	{0x183E4,	0x00FD040D},
+	{0x183E8,	0x13130B02},
+	{0x183EC,	0x00FD030D},
+	{0x183F0,	0x13130B02},
+	{0x183F4,	0x00FD030D},
+	{0x183F8,	0x13130C02},
+	{0x183FC,	0x00FD030C},
+
+	/* VFIL 00 */
+	{0x16000,	0x2727F702},
+	{0x16004,	0x000002F7},
+	{0x16008,	0x2924F802},
+	{0x1600C,	0x000002F7},
+	{0x16010,	0x2C21F802},
+	{0x16014,	0x000002F7},
+	{0x16018,	0x2E1EF902},
+	{0x1601C,	0x000002F7},
+	{0x16020,	0x301CF902},
+	{0x16024,	0x000002F7},
+	{0x16028,	0x3319FA01},
+	{0x1602C,	0x000002F7},
+	{0x16030,	0x3517FA01},
+	{0x16034,	0x000002F7},
+	{0x16038,	0x3714FB01},
+	{0x1603C,	0x000002F7},
+	{0x16040,	0x3911FC01},
+	{0x16044,	0x000002F7},
+	{0x16048,	0x3A0FFC01},
+	{0x1604C,	0x000002F8},
+	{0x16050,	0x3B0CFD01},
+	{0x16054,	0x000002F9},
+	{0x16058,	0x3C0AFD01},
+	{0x1605C,	0x000002FA},
+	{0x16060,	0x3E08FE00},
+	{0x16064,	0x000001FB},
+	{0x16068,	0x3E06FF00},
+	{0x1606C,	0x000001FC},
+	{0x16070,	0x3F04FF00},
+	{0x16074,	0x000001FD},
+	{0x16078,	0x40020000},
+	{0x1607C,	0x000000FE},
+	{0x16080,	0x40000000},
+	{0x16084,	0x00000000},
+	{0x16088,	0x40FE0000},
+	{0x1608C,	0x00000002},
+	{0x16090,	0x3FFD0100},
+	{0x16094,	0x0000FF04},
+	{0x16098,	0x3EFC0100},
+	{0x1609C,	0x0000FF06},
+	{0x160A0,	0x3EFB0100},
+	{0x160A4,	0x0000FE08},
+	{0x160A8,	0x3CFA0200},
+	{0x160AC,	0x0001FD0A},
+	{0x160B0,	0x3BF90200},
+	{0x160B4,	0x0001FD0C},
+	{0x160B8,	0x3AF80200},
+	{0x160BC,	0x0001FC0F},
+	{0x160C0,	0x39F70200},
+	{0x160C4,	0x0001FC11},
+	{0x160C8,	0x37F70200},
+	{0x160CC,	0x0001FB14},
+	{0x160D0,	0x35F70200},
+	{0x160D4,	0x0001FA17},
+	{0x160D8,	0x33F70200},
+	{0x160DC,	0x0001FA19},
+	{0x160E0,	0x30F70200},
+	{0x160E4,	0x0002F91C},
+	{0x160E8,	0x2EF70200},
+	{0x160EC,	0x0002F91E},
+	{0x160F0,	0x2CF70200},
+	{0x160F4,	0x0002F821},
+	{0x160F8,	0x29F70200},
+	{0x160FC,	0x0002F824},
+
+	/* VFIL 01 */
+	{0x16100,	0x2525FDFB},
+	{0x16104,	0x0006FBFD},
+	{0x16108,	0x2624FDFB},
+	{0x1610C,	0x0006FAFE},
+	{0x16110,	0x2722FCFC},
+	{0x16114,	0x0006FAFF},
+	{0x16118,	0x2922FBFC},
+	{0x1611C,	0x0005F900},
+	{0x16120,	0x2921FAFD},
+	{0x16124,	0x0005F901},
+	{0x16128,	0x2A20FAFD},
+	{0x1612C,	0x0005F802},
+	{0x16130,	0x2A1EF9FE},
+	{0x16134,	0x0005F804},
+	{0x16138,	0x2A1DF9FE},
+	{0x1613C,	0x0005F805},
+	{0x16140,	0x2C1BF8FF},
+	{0x16144,	0x0005F706},
+	{0x16148,	0x2C1AF8FF},
+	{0x1614C,	0x0005F707},
+	{0x16150,	0x2D19F700},
+	{0x16154,	0x0004F708},
+	{0x16158,	0x2D17F700},
+	{0x1615C,	0x0004F70A},
+	{0x16160,	0x2D16F701},
+	{0x16164,	0x0004F60B},
+	{0x16168,	0x2D15F701},
+	{0x1616C,	0x0004F60C},
+	{0x16170,	0x2E13F602},
+	{0x16174,	0x0003F60E},
+	{0x16178,	0x2E12F602},
+	{0x1617C,	0x0003F60F},
+	{0x16180,	0x2E11F602},
+	{0x16184,	0x0002F611},
+	{0x16188,	0x2E0FF603},
+	{0x1618C,	0x0002F612},
+	{0x16190,	0x2E0EF603},
+	{0x16194,	0x0002F613},
+	{0x16198,	0x2D0CF604},
+	{0x1619C,	0x0001F715},
+	{0x161A0,	0x2D0BF604},
+	{0x161A4,	0x0001F716},
+	{0x161A8,	0x2D0AF704},
+	{0x161AC,	0x0000F717},
+	{0x161B0,	0x2D08F704},
+	{0x161B4,	0x0000F719},
+	{0x161B8,	0x2C07F705},
+	{0x161BC,	0x00FFF81A},
+	{0x161C0,	0x2C06F705},
+	{0x161C4,	0x00FFF81B},
+	{0x161C8,	0x2A05F805},
+	{0x161CC,	0x00FEF91D},
+	{0x161D0,	0x2A04F805},
+	{0x161D4,	0x00FEF91E},
+	{0x161D8,	0x2A02F805},
+	{0x161DC,	0x00FDFA20},
+	{0x161E0,	0x2901F905},
+	{0x161E4,	0x00FDFA21},
+	{0x161E8,	0x2900F905},
+	{0x161EC,	0x00FCFB22},
+	{0x161F0,	0x27FFFA06},
+	{0x161F4,	0x00FCFC22},
+	{0x161F8,	0x26FEFA06},
+	{0x161FC,	0x00FBFD24},
+
+	/* VFIL 02 */
+	{0x16200,	0x1E1E0AFA},
+	{0x16204,	0x00FCFA0A},
+	{0x16208,	0x1E1E09FA},
+	{0x1620C,	0x00FCFA0B},
+	{0x16210,	0x1E1D09FA},
+	{0x16214,	0x00FBFB0C},
+	{0x16218,	0x1F1D08FA},
+	{0x1621C,	0x00FBFB0C},
+	{0x16220,	0x201D07F9},
+	{0x16224,	0x00FBFB0D},
+	{0x16228,	0x201C07F9},
+	{0x1622C,	0x00FBFB0E},
+	{0x16230,	0x201C06F9},
+	{0x16234,	0x00FBFC0E},
+	{0x16238,	0x211C05F9},
+	{0x1623C,	0x00FAFC0F},
+	{0x16240,	0x211B05F9},
+	{0x16244,	0x00FAFC10},
+	{0x16248,	0x211A04F9},
+	{0x1624C,	0x00FAFD11},
+	{0x16250,	0x221A03F9},
+	{0x16254,	0x00FAFD11},
+	{0x16258,	0x221803F9},
+	{0x1625C,	0x00FAFE12},
+	{0x16260,	0x221802F9},
+	{0x16264,	0x00FAFE13},
+	{0x16268,	0x221802F9},
+	{0x1626C,	0x00F9FF13},
+	{0x16270,	0x221701F9},
+	{0x16274,	0x00F9FF15},
+	{0x16278,	0x221701F9},
+	{0x1627C,	0x00F9FF15},
+	{0x16280,	0x221600F9},
+	{0x16284,	0x00F90016},
+	{0x16288,	0x2215FFF9},
+	{0x1628C,	0x00F90117},
+	{0x16290,	0x2215FFF9},
+	{0x16294,	0x00F90117},
+	{0x16298,	0x2213FFF9},
+	{0x1629C,	0x00F90218},
+	{0x162A0,	0x2213FEFA},
+	{0x162A4,	0x00F90218},
+	{0x162A8,	0x2212FEFA},
+	{0x162AC,	0x00F90318},
+	{0x162B0,	0x2211FDFA},
+	{0x162B4,	0x00F9031A},
+	{0x162B8,	0x2111FDFA},
+	{0x162BC,	0x00F9041A},
+	{0x162C0,	0x2110FCFA},
+	{0x162C4,	0x00F9051B},
+	{0x162C8,	0x210FFCFA},
+	{0x162CC,	0x00F9051C},
+	{0x162D0,	0x200EFCFB},
+	{0x162D4,	0x00F9061C},
+	{0x162D8,	0x200EFBFB},
+	{0x162DC,	0x00F9071C},
+	{0x162E0,	0x200DFBFB},
+	{0x162E4,	0x00F9071D},
+	{0x162E8,	0x1F0CFBFB},
+	{0x162EC,	0x00FA081D},
+	{0x162F0,	0x1E0CFBFB},
+	{0x162F4,	0x00FA091D},
+	{0x162F8,	0x1E0BFAFC},
+	{0x162FC,	0x00FA091E},
+
+	/* VFIL 03 */
+	{0x16300,	0x13130C02},
+	{0x16304,	0x00FD030C},
+	{0x16308,	0x13130C02},
+	{0x1630C,	0x00FD030C},
+	{0x16310,	0x13130B02},
+	{0x16314,	0x00FD030D},
+	{0x16318,	0x13130B02},
+	{0x1631C,	0x00FD030D},
+	{0x16320,	0x14120B01},
+	{0x16324,	0x00FD040D},
+	{0x16328,	0x14120A01},
+	{0x1632C,	0x00FD040E},
+	{0x16330,	0x14120A01},
+	{0x16334,	0x00FD040E},
+	{0x16338,	0x14120A01},
+	{0x1633C,	0x00FD040E},
+	{0x16340,	0x14120901},
+	{0x16344,	0x00FE040E},
+	{0x16348,	0x14120900},
+	{0x1634C,	0x00FE050E},
+	{0x16350,	0x14110900},
+	{0x16354,	0x00FE050F},
+	{0x16358,	0x14110800},
+	{0x1635C,	0x00FE060F},
+	{0x16360,	0x14110800},
+	{0x16364,	0x00FE060F},
+	{0x16368,	0x141108FF},
+	{0x1636C,	0x00FE0610},
+	{0x16370,	0x141008FF},
+	{0x16374,	0x00FF0610},
+	{0x16378,	0x141007FF},
+	{0x1637C,	0x00FF0710},
+	{0x16380,	0x141007FF},
+	{0x16384,	0x00FF0710},
+	{0x16388,	0x141007FF},
+	{0x1638C,	0x00FF0710},
+	{0x16390,	0x141006FF},
+	{0x16394,	0x00FF0810},
+	{0x16398,	0x141006FE},
+	{0x1639C,	0x00FF0811},
+	{0x163A0,	0x140F06FE},
+	{0x163A4,	0x00000811},
+	{0x163A8,	0x140F06FE},
+	{0x163AC,	0x00000811},
+	{0x163B0,	0x140F05FE},
+	{0x163B4,	0x00000911},
+	{0x163B8,	0x140E05FE},
+	{0x163BC,	0x00000912},
+	{0x163C0,	0x140E04FE},
+	{0x163C4,	0x00010912},
+	{0x163C8,	0x140E04FD},
+	{0x163CC,	0x00010A12},
+	{0x163D0,	0x140E04FD},
+	{0x163D4,	0x00010A12},
+	{0x163D8,	0x140E04FD},
+	{0x163DC,	0x00010A12},
+	{0x163E0,	0x140D04FD},
+	{0x163E4,	0x00010B12},
+	{0x163E8,	0x130D03FD},
+	{0x163EC,	0x00020B13},
+	{0x163F0,	0x130D03FD},
+	{0x163F4,	0x00020B13},
+	{0x163F8,	0x130C03FD},
+	{0x163FC,	0x00020C13},
+
+	/* VFIL 04 */
+	/* VFIL 00 */
+	{0x1A000,	0x2727F702},
+	{0x1A004,	0x000002F7},
+	{0x1A008,	0x2924F802},
+	{0x1A00C,	0x000002F7},
+	{0x1A010,	0x2C21F802},
+	{0x1A014,	0x000002F7},
+	{0x1A018,	0x2E1EF902},
+	{0x1A01C,	0x000002F7},
+	{0x1A020,	0x301CF902},
+	{0x1A024,	0x000002F7},
+	{0x1A028,	0x3319FA01},
+	{0x1A02C,	0x000002F7},
+	{0x1A030,	0x3517FA01},
+	{0x1A034,	0x000002F7},
+	{0x1A038,	0x3714FB01},
+	{0x1A03C,	0x000002F7},
+	{0x1A040,	0x3911FC01},
+	{0x1A044,	0x000002F7},
+	{0x1A048,	0x3A0FFC01},
+	{0x1A04C,	0x000002F8},
+	{0x1A050,	0x3B0CFD01},
+	{0x1A054,	0x000002F9},
+	{0x1A058,	0x3C0AFD01},
+	{0x1A05C,	0x000002FA},
+	{0x1A060,	0x3E08FE00},
+	{0x1A064,	0x000001FB},
+	{0x1A068,	0x3E06FF00},
+	{0x1A06C,	0x000001FC},
+	{0x1A070,	0x3F04FF00},
+	{0x1A074,	0x000001FD},
+	{0x1A078,	0x40020000},
+	{0x1A07C,	0x000000FE},
+	{0x1A080,	0x40000000},
+	{0x1A084,	0x00000000},
+	{0x1A088,	0x40FE0000},
+	{0x1A08C,	0x00000002},
+	{0x1A090,	0x3FFD0100},
+	{0x1A094,	0x0000FF04},
+	{0x1A098,	0x3EFC0100},
+	{0x1A09C,	0x0000FF06},
+	{0x1A0A0,	0x3EFB0100},
+	{0x1A0A4,	0x0000FE08},
+	{0x1A0A8,	0x3CFA0200},
+	{0x1A0AC,	0x0001FD0A},
+	{0x1A0B0,	0x3BF90200},
+	{0x1A0B4,	0x0001FD0C},
+	{0x1A0B8,	0x3AF80200},
+	{0x1A0BC,	0x0001FC0F},
+	{0x1A0C0,	0x39F70200},
+	{0x1A0C4,	0x0001FC11},
+	{0x1A0C8,	0x37F70200},
+	{0x1A0CC,	0x0001FB14},
+	{0x1A0D0,	0x35F70200},
+	{0x1A0D4,	0x0001FA17},
+	{0x1A0D8,	0x33F70200},
+	{0x1A0DC,	0x0001FA19},
+	{0x1A0E0,	0x30F70200},
+	{0x1A0E4,	0x0002F91C},
+	{0x1A0E8,	0x2EF70200},
+	{0x1A0EC,	0x0002F91E},
+	{0x1A0F0,	0x2CF70200},
+	{0x1A0F4,	0x0002F821},
+	{0x1A0F8,	0x29F70200},
+	{0x1A0FC,	0x0002F824},
+
+	/* VFIL 01 */
+	{0x1A100,	0x2525FDFB},
+	{0x1A104,	0x0006FBFD},
+	{0x1A108,	0x2624FDFB},
+	{0x1A10C,	0x0006FAFE},
+	{0x1A110,	0x2722FCFC},
+	{0x1A114,	0x0006FAFF},
+	{0x1A118,	0x2922FBFC},
+	{0x1A11C,	0x0005F900},
+	{0x1A120,	0x2921FAFD},
+	{0x1A124,	0x0005F901},
+	{0x1A128,	0x2A20FAFD},
+	{0x1A12C,	0x0005F802},
+	{0x1A130,	0x2A1EF9FE},
+	{0x1A134,	0x0005F804},
+	{0x1A138,	0x2A1DF9FE},
+	{0x1A13C,	0x0005F805},
+	{0x1A140,	0x2C1BF8FF},
+	{0x1A144,	0x0005F706},
+	{0x1A148,	0x2C1AF8FF},
+	{0x1A14C,	0x0005F707},
+	{0x1A150,	0x2D19F700},
+	{0x1A154,	0x0004F708},
+	{0x1A158,	0x2D17F700},
+	{0x1A15C,	0x0004F70A},
+	{0x1A160,	0x2D16F701},
+	{0x1A164,	0x0004F60B},
+	{0x1A168,	0x2D15F701},
+	{0x1A16C,	0x0004F60C},
+	{0x1A170,	0x2E13F602},
+	{0x1A174,	0x0003F60E},
+	{0x1A178,	0x2E12F602},
+	{0x1A17C,	0x0003F60F},
+	{0x1A180,	0x2E11F602},
+	{0x1A184,	0x0002F611},
+	{0x1A188,	0x2E0FF603},
+	{0x1A18C,	0x0002F612},
+	{0x1A190,	0x2E0EF603},
+	{0x1A194,	0x0002F613},
+	{0x1A198,	0x2D0CF604},
+	{0x1A19C,	0x0001F715},
+	{0x1A1A0,	0x2D0BF604},
+	{0x1A1A4,	0x0001F716},
+	{0x1A1A8,	0x2D0AF704},
+	{0x1A1AC,	0x0000F717},
+	{0x1A1B0,	0x2D08F704},
+	{0x1A1B4,	0x0000F719},
+	{0x1A1B8,	0x2C07F705},
+	{0x1A1BC,	0x00FFF81A},
+	{0x1A1C0,	0x2C06F705},
+	{0x1A1C4,	0x00FFF81B},
+	{0x1A1C8,	0x2A05F805},
+	{0x1A1CC,	0x00FEF91D},
+	{0x1A1D0,	0x2A04F805},
+	{0x1A1D4,	0x00FEF91E},
+	{0x1A1D8,	0x2A02F805},
+	{0x1A1DC,	0x00FDFA20},
+	{0x1A1E0,	0x2901F905},
+	{0x1A1E4,	0x00FDFA21},
+	{0x1A1E8,	0x2900F905},
+	{0x1A1EC,	0x00FCFB22},
+	{0x1A1F0,	0x27FFFA06},
+	{0x1A1F4,	0x00FCFC22},
+	{0x1A1F8,	0x26FEFA06},
+	{0x1A1FC,	0x00FBFD24},
+
+	/* VFIL 02 */
+	{0x1A200,	0x1E1E0AFA},
+	{0x1A204,	0x00FCFA0A},
+	{0x1A208,	0x1E1E09FA},
+	{0x1A20C,	0x00FCFA0B},
+	{0x1A210,	0x1E1D09FA},
+	{0x1A214,	0x00FBFB0C},
+	{0x1A218,	0x1F1D08FA},
+	{0x1A21C,	0x00FBFB0C},
+	{0x1A220,	0x201D07F9},
+	{0x1A224,	0x00FBFB0D},
+	{0x1A228,	0x201C07F9},
+	{0x1A22C,	0x00FBFB0E},
+	{0x1A230,	0x201C06F9},
+	{0x1A234,	0x00FBFC0E},
+	{0x1A238,	0x211C05F9},
+	{0x1A23C,	0x00FAFC0F},
+	{0x1A240,	0x211B05F9},
+	{0x1A244,	0x00FAFC10},
+	{0x1A248,	0x211A04F9},
+	{0x1A24C,	0x00FAFD11},
+	{0x1A250,	0x221A03F9},
+	{0x1A254,	0x00FAFD11},
+	{0x1A258,	0x221803F9},
+	{0x1A25C,	0x00FAFE12},
+	{0x1A260,	0x221802F9},
+	{0x1A264,	0x00FAFE13},
+	{0x1A268,	0x221802F9},
+	{0x1A26C,	0x00F9FF13},
+	{0x1A270,	0x221701F9},
+	{0x1A274,	0x00F9FF15},
+	{0x1A278,	0x221701F9},
+	{0x1A27C,	0x00F9FF15},
+	{0x1A280,	0x221600F9},
+	{0x1A284,	0x00F90016},
+	{0x1A288,	0x2215FFF9},
+	{0x1A28C,	0x00F90117},
+	{0x1A290,	0x2215FFF9},
+	{0x1A294,	0x00F90117},
+	{0x1A298,	0x2213FFF9},
+	{0x1A29C,	0x00F90218},
+	{0x1A2A0,	0x2213FEFA},
+	{0x1A2A4,	0x00F90218},
+	{0x1A2A8,	0x2212FEFA},
+	{0x1A2AC,	0x00F90318},
+	{0x1A2B0,	0x2211FDFA},
+	{0x1A2B4,	0x00F9031A},
+	{0x1A2B8,	0x2111FDFA},
+	{0x1A2BC,	0x00F9041A},
+	{0x1A2C0,	0x2110FCFA},
+	{0x1A2C4,	0x00F9051B},
+	{0x1A2C8,	0x210FFCFA},
+	{0x1A2CC,	0x00F9051C},
+	{0x1A2D0,	0x200EFCFB},
+	{0x1A2D4,	0x00F9061C},
+	{0x1A2D8,	0x200EFBFB},
+	{0x1A2DC,	0x00F9071C},
+	{0x1A2E0,	0x200DFBFB},
+	{0x1A2E4,	0x00F9071D},
+	{0x1A2E8,	0x1F0CFBFB},
+	{0x1A2EC,	0x00FA081D},
+	{0x1A2F0,	0x1E0CFBFB},
+	{0x1A2F4,	0x00FA091D},
+	{0x1A2F8,	0x1E0BFAFC},
+	{0x1A2FC,	0x00FA091E},
+
+	/* VFIL 03 */
+	{0x1A300,	0x13130C02},
+	{0x1A304,	0x00FD030C},
+	{0x1A308,	0x13130C02},
+	{0x1A30C,	0x00FD030C},
+	{0x1A310,	0x13130B02},
+	{0x1A314,	0x00FD030D},
+	{0x1A318,	0x13130B02},
+	{0x1A31C,	0x00FD030D},
+	{0x1A320,	0x14120B01},
+	{0x1A324,	0x00FD040D},
+	{0x1A328,	0x14120A01},
+	{0x1A32C,	0x00FD040E},
+	{0x1A330,	0x14120A01},
+	{0x1A334,	0x00FD040E},
+	{0x1A338,	0x14120A01},
+	{0x1A33C,	0x00FD040E},
+	{0x1A340,	0x14120901},
+	{0x1A344,	0x00FE040E},
+	{0x1A348,	0x14120900},
+	{0x1A34C,	0x00FE050E},
+	{0x1A350,	0x14110900},
+	{0x1A354,	0x00FE050F},
+	{0x1A358,	0x14110800},
+	{0x1A35C,	0x00FE060F},
+	{0x1A360,	0x14110800},
+	{0x1A364,	0x00FE060F},
+	{0x1A368,	0x141108FF},
+	{0x1A36C,	0x00FE0610},
+	{0x1A370,	0x141008FF},
+	{0x1A374,	0x00FF0610},
+	{0x1A378,	0x141007FF},
+	{0x1A37C,	0x00FF0710},
+	{0x1A380,	0x141007FF},
+	{0x1A384,	0x00FF0710},
+	{0x1A388,	0x141007FF},
+	{0x1A38C,	0x00FF0710},
+	{0x1A390,	0x141006FF},
+	{0x1A394,	0x00FF0810},
+	{0x1A398,	0x141006FE},
+	{0x1A39C,	0x00FF0811},
+	{0x1A3A0,	0x140F06FE},
+	{0x1A3A4,	0x00000811},
+	{0x1A3A8,	0x140F06FE},
+	{0x1A3AC,	0x00000811},
+	{0x1A3B0,	0x140F05FE},
+	{0x1A3B4,	0x00000911},
+	{0x1A3B8,	0x140E05FE},
+	{0x1A3BC,	0x00000912},
+	{0x1A3C0,	0x140E04FE},
+	{0x1A3C4,	0x00010912},
+	{0x1A3C8,	0x140E04FD},
+	{0x1A3CC,	0x00010A12},
+	{0x1A3D0,	0x140E04FD},
+	{0x1A3D4,	0x00010A12},
+	{0x1A3D8,	0x140E04FD},
+	{0x1A3DC,	0x00010A12},
+	{0x1A3E0,	0x140D04FD},
+	{0x1A3E4,	0x00010B12},
+	{0x1A3E8,	0x130D03FD},
+	{0x1A3EC,	0x00020B13},
+	{0x1A3F0,	0x130D03FD},
+	{0x1A3F4,	0x00020B13},
+	{0x1A3F8,	0x130C03FD},
+	{0x1A3FC,	0x00020C13},
+};
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_static_calibrations.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_static_calibrations.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/apical_static_calibrations.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/apical_static_calibrations.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,663 @@
+/**
+ *  This confidential and proprietary software/information may be used only
+ *        as authorized by a licensing agreement from Apical Limited
+ *
+ *                   (C) COPYRIGHT 2015 Apical Limited
+ *                          ALL RIGHTS RESERVED
+ *
+ *       The entire notice above must be reproduced on all authorized
+ *        copies and copies may only be made to the extent permitted
+ *              by a licensing agreement from Apical Limited.
+ *
+ */
+
+#include <apical-isp/apical_calibrations_id.h>
+
+// created from jov9712_calibration.json on 2015-10-20T12:50:05.923Z UTC
+
+// CALIBRATION_LIGHT_SRC
+static uint16_t _calibration_light_src[ ][2]
+ = {
+ {282,216}
+ };
+
+// CALIBRATION_RG_POS
+static uint16_t _calibration_rg_pos[ ]
+ = {170,185,210,234,256,283,308,332,357,381,406,430,455,479,523};
+
+// CALIBRATION_BG_POS
+static uint16_t _calibration_bg_pos[ ]
+ = {143,163,178,194,209,224,240,256,270,285,301,316,331,347,376};
+
+// CALIBRATION_MESH_RGBG_WEIGHT
+static uint16_t _calibration_mesh_rgbg_weight[ ][15]
+ =  {
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 4, 4, 21 },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 44, 256, 212, 256, 216 },
+  { 0, 0, 0, 0, 0, 0, 0, 1, 10, 70, 256, 256, 256, 107, 0 },
+  { 0, 0, 0, 0, 0, 1, 4, 18, 82, 256, 256, 176, 26, 1, 0 },
+  { 0, 0, 0, 0, 2, 14, 51, 126, 256, 256, 194, 47, 0, 0, 0 },
+  { 0, 0, 0, 8, 36, 114, 226, 256, 256, 174, 46, 6, 0, 0, 0 },
+  { 0, 0, 1, 57, 217, 256, 256, 246, 120, 33, 4, 0, 0, 0, 0 },
+  { 0, 0, 10, 168, 256, 256, 159, 60, 15, 2, 0, 0, 0, 0, 0 },
+  { 0, 1, 40, 256, 256, 103, 30, 7, 1, 0, 0, 0, 0, 0, 0 },
+  { 1, 8, 256, 256, 172, 12, 2, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 2, 46, 256, 256, 56, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 3, 73, 256, 158, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 3, 256, 256, 50, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 9, 256, 198, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 87, 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+};
+
+// CALIBRATION_MESH_LS_WEIGHT
+static uint16_t _calibration_mesh_ls_weight[ ][15]
+ =  {
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 0, 0, 3, 4, 25, 42, 53, 57, 53, 42, 25, 4, 3, 0, 0 },
+  { 0, 0, 4, 131, 157, 179, 193, 198, 193, 179, 157, 131, 4, 0, 0 },
+  { 0, 0, 25, 157, 188, 214, 232, 238, 232, 214, 188, 157, 25, 0, 0 },
+  { 0, 0, 42, 179, 214, 243, 255, 256, 255, 243, 214, 179, 42, 0, 0 },
+  { 0, 0, 53, 193, 232, 255, 256, 256, 256, 255, 232, 193, 53, 0, 0 },
+  { 0, 0, 57, 198, 238, 256, 256, 256, 256, 256, 238, 198, 57, 0, 0 },
+  { 0, 0, 53, 193, 232, 255, 256, 256, 256, 255, 232, 193, 53, 0, 0 },
+  { 0, 0, 42, 179, 214, 243, 255, 256, 255, 243, 214, 179, 42, 0, 0 },
+  { 0, 0, 25, 157, 188, 214, 232, 238, 232, 214, 188, 157, 25, 0, 0 },
+  { 0, 0, 4, 131, 157, 179, 193, 198, 193, 179, 157, 131, 4, 0, 0 },
+  { 0, 0, 3, 4, 25, 42, 53, 57, 53, 42, 25, 4, 3, 0, 0 },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
+  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+};
+
+// CALIBRATION_MESH_COLOR_TEMPERATURE
+static uint16_t _calibration_mesh_color_temperature[ ][15]
+ =  {
+  { 199, 199, 199, 208, 220, 235, 249, 278, 301, 336, 377, 386, 403, 420, 435 },
+  { 199, 199, 199, 205, 217, 231, 245, 267, 290, 317, 362, 384, 401, 418, 435 },
+  { 199, 199, 199, 202, 214, 228, 242, 255, 282, 305, 348, 379, 399, 416, 435 },
+  { 198, 199, 199, 199, 211, 225, 239, 252, 274, 296, 333, 366, 397, 414, 435 },
+  { 190, 196, 199, 199, 208, 222, 236, 249, 266, 288, 318, 355, 395, 412, 435 },
+  { 183, 188, 198, 199, 205, 219, 233, 246, 260, 280, 303, 348, 393, 410, 435 },
+  { 175, 180, 190, 198, 202, 216, 230, 243, 257, 272, 295, 332, 361, 408, 435 },
+  { 157, 172, 181, 190, 199, 213, 227, 240, 254, 264, 287, 317, 389, 405, 435 },
+  { 140, 156, 174, 183, 191, 210, 224, 237, 251, 261, 279, 302, 349, 404, 435 },
+  { 133, 138, 164, 176, 184, 208, 221, 234, 248, 261, 272, 294, 335, 402, 433 },
+  { 128, 133, 145, 167, 176, 186, 218, 231, 245, 258, 263, 285, 319, 400, 431 },
+  { 119, 123, 130, 152, 168, 178, 215, 228, 242, 255, 261, 278, 301, 349, 429 },
+  { 106, 111, 120, 127, 157, 170, 180, 225, 239, 252, 261, 270, 293, 334, 427 },
+  { 98, 103, 112, 116, 123, 166, 172, 222, 236, 249, 261, 261, 284, 319, 425 },
+  { 97, 97, 97, 106, 113, 115, 119, 125, 230, 243, 257, 261, 269, 291, 421 }
+};
+
+// CALIBRATION_LUXLOW_LUT_MIN
+static uint16_t _calibration_luxlow_lut_min[ ]
+ = {88};
+
+// CALIBRATION_LUXLOW_LUT_MAX
+static uint16_t _calibration_luxlow_lut_max[ ]
+ = {1483};
+
+// CALIBRATION_LUXLOW_LUT_STEP
+static uint16_t _calibration_luxlow_lut_step[ ]
+ = {12};
+
+// CALIBRATION_LUXLOW_LUT
+static uint16_t _calibration_luxlow_lut[ ]
+ = {253,251,248,243,237,229,219,207,193,179,166,154,146,141,141,146,154,166,179,193,207,219,229,237,243,248,251,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,251,242,233,224,215,207,199,191,183,175,168,161,154,147,140,134,128,122,116,110,105,100,95,90,85,81,76,72,68,65,61,57,54,51,48,45,43,40,37,35,33,31,29,27,25,24,22,21,19,18,17,15,14,13,12,11,11,10,9,8,8,7,7,6,6,5,5,4,4,4,3,3,3};
+
+// CALIBRATION_LUXHIGH_LUT_MIN
+static uint16_t _calibration_luxhigh_lut_min[ ]
+ = {1};
+
+// CALIBRATION_LUXHIGH_LUT_MAX
+static uint16_t _calibration_luxhigh_lut_max[ ]
+ = {1650};
+
+// CALIBRATION_LUXHIGH_LUT_STEP
+static uint16_t _calibration_luxhigh_lut_step[ ]
+ = {16};
+
+// CALIBRATION_LUXHIGH_LUT
+static uint16_t _calibration_luxhigh_lut[ ]
+ = {12,12,13,14,15,16,19,24,31,41,55,72,91,110,125,134,135,128,115,99,81,65,52,42,36,33,31,31,31,32,33,34,35,36,37,39,40,41,42,44,45,46,48,49,51,53,54,56,58,59,61,63,65,67,69,71,73,75,77,80,82,84,87,89,92,94,97,100,103,106,108,111,115,118,121,124,128,131,135,138,142,146,150,154,158,162,166,171,175,179,184,189,194,198,203,209,214,219,225,230,236,241,247,253};
+
+// CALIBRATION_RGLOW_LUT_MIN
+static uint16_t _calibration_rglow_lut_min[ ]
+ = {168};
+
+// CALIBRATION_RGLOW_LUT_MAX
+static uint16_t _calibration_rglow_lut_max[ ]
+ = {326};
+
+// CALIBRATION_RGLOW_LUT_STEP
+static uint16_t _calibration_rglow_lut_step[ ]
+ = {1};
+
+// CALIBRATION_RGLOW_LUT
+static uint16_t _calibration_rglow_lut[ ]
+ = {3,3,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,6,7,7,7,7,7,8,8,8,9,9,9,9,10,10,10,11,11,11,12,12,13,13,13,14,14,15,15,16,16,17,17,18,18,19,20,20,21,21,22,23,23,24,25,26,26,27,28,29,30,31,31,32,33,34,35,36,37,38,40,41,42,43,44,45,47,48,49,51,52,53,55,56,58,60,61,63,64,66,68,70,72,73,75,77,79,81,83,86,88,90,92,95,97,99,102,104,107,110,112,115,118,121,123,126,129,133,136,139,142,145,149,152,156,159,163,167,170,174,178,182,186,190,194,199,203,207,212,216,221,226,231,235,240,245,250,253};
+
+// CALIBRATION_RGHIGH_LUT_MIN
+static uint16_t _calibration_rghigh_lut_min[ ]
+ = {252};
+
+// CALIBRATION_RGHIGH_LUT_MAX
+static uint16_t _calibration_rghigh_lut_max[ ]
+ = {419};
+
+// CALIBRATION_RGHIGH_LUT_STEP
+static uint16_t _calibration_rghigh_lut_step[ ]
+ = {1};
+
+// CALIBRATION_RGHIGH_LUT
+static uint16_t _calibration_rghigh_lut[ ]
+ = {247,242,237,233,228,223,219,215,210,206,202,198,193,189,186,182,178,174,170,167,163,160,156,153,150,147,143,140,137,134,131,128,125,123,120,117,114,112,109,107,104,102,100,97,95,93,91,89,86,84,82,80,79,77,75,73,71,69,68,66,64,63,61,60,58,57,55,54,53,51,50,49,48,46,45,44,43,42,41,40,38,37,36,36,35,34,33,32,31,30,29,29,28,27,26,26,25,24,23,23,22,22,21,20,20,19,19,18,18,17,17,16,16,15,15,14,14,14,13,13,12,12,12,11,11,11,10,10,10,9,9,9,9,8,8,8,8,7,7,7,7,6,6,6,6,6,5,5,5,5,5,5,5,4,4,4,4,4,4};
+
+// RG, BG, MULT. final wb gain adjuster for a sky scene. devided by CALIBRATION_WB_STRENGTH_MULT in use
+static uint16_t _calibration_wb_strength[ ]
+ = {1000,1000,1000};
+
+// lux threshold for sky
+static uint16_t _calibration_sky_lux_th[ ]
+ = {10000};
+
+// 1D rg/bg readout from color_temp
+static uint16_t _calibration_ct_rg_pos_calc[ ]
+ = {186,202,212,227,256,357,395,413,433,504};
+
+// 1D rg/bg readout from color_temp
+static uint16_t _calibration_ct_bg_pos_calc[ ]
+ = {361,336,314,297,256,220,199,189,176,163};
+
+// CALIBRATION_COLOR_TEMP
+static uint16_t _calibration_color_temp[ ]
+ = {97,115,133,167,199,261,306,351,384,435};
+
+// CALIBRATION_CT65POS
+static uint16_t _calibration_ct65pos[ ]
+ = {3};
+
+// CALIBRATION_CT40POS
+static uint16_t _calibration_ct40pos[ ]
+ = {8};
+
+// CALIBRATION_CT30POS
+static uint16_t _calibration_ct30pos[ ]
+ = {7};
+
+// CALIBRATION_EVTOLUX_EV_LUT_LINEAR
+static uint32_t _calibration_evtolux_ev_lut_linear[ ]
+= {130525,152268,162370,173971,199210,215876,225028,280528,301454,364004,396231,431114,450880,468584,499812,548041,582323,624832};
+
+// CALIBRATION_EVTOLUX_EV_LUT_FS_HDR
+static uint32_t _calibration_evtolux_ev_lut_fs_hdr[ ]
+ = {0};
+
+// CALIBRATION_EVTOLUX_LUX_LUT
+static uint32_t _calibration_evtolux_lux_lut[ ]
+ = {25190,19900,17780,15850,12130,10020,8915,4990,4088,2069,1507,994,857,698,498,294,201,102};
+
+// CALIBRATION_BLACK_LEVEL_R_LINEAR
+static uint16_t _calibration_black_level_r_linear[ ][2]
+ =  {
+  { 0, 65 },
+  { 32, 70 },
+  { 64, 70 },
+  { 96, 74 },
+  { 128, 87 }
+};
+
+// CALIBRATION_BLACK_LEVEL_GR_LINEAR
+static uint16_t _calibration_black_level_gr_linear[ ][2]
+ =  {
+  { 0, 66 },
+  { 32, 67 },
+  { 64, 73 },
+  { 96, 76 },
+  { 128, 86 }
+};
+
+// CALIBRATION_BLACK_LEVEL_GB_LINEAR
+static uint16_t _calibration_black_level_gb_linear[ ][2]
+ =  {
+  { 0, 67 },
+  { 32, 67 },
+  { 64, 68 },
+  { 96, 71 },
+  { 128, 84 }
+};
+
+// CALIBRATION_BLACK_LEVEL_B_LINEAR
+static uint16_t _calibration_black_level_b_linear[ ][2]
+ =  {
+  { 0, 67 },
+  { 32, 70 },
+  { 64, 70 },
+  { 96, 70 },
+  { 128, 81 }
+};
+
+// CALIBRATION_STATIC_WB
+static uint16_t _calibration_static_wb[ ]
+ = {453,256,256,500};
+
+// P1 P2 Q1 A1 B1 C1
+static uint16_t _calibration_auto_wb[ ]
+ = {0,0,0,0,0,0};
+
+// RR, RG, RB, GR, GG, GB, BR, BG, BB
+static uint8_t _calibration_skin_tone_ccm[ ]
+ = {42,42,42,42,42,42,42,42,42};
+
+// RR RG RB GR GG GB BR BG BB
+static uint16_t _calibration_mt_absolute_ls_a_ccm_linear[ ]
+ = {398,32907,32771,32818,315,32777,32825,33139,684};
+
+// RR RG RB GR GG GB BR BG BB
+static uint16_t _calibration_mt_absolute_ls_d40_ccm_linear[ ]
+ = {412,32911,32781,32826,350,32804,32801,32997,518};
+
+// RR RG RB GR GG GB BR BG BB
+static uint16_t _calibration_mt_absolute_ls_d50_ccm_linear[ ]
+ = {557,33030,32807,32841,424,32863,32777,33029,526};
+
+// RR RG RB GR GG GB BR BG BB
+static uint16_t _calibration_mt_absolute_ls_a_ccm_hdr[ ]
+ = {472,32965,32787,32858,334,12,32833,33403,956};
+
+// RR RG RB GR GG GB BR BG BB
+static uint16_t _calibration_mt_absolute_ls_d40_ccm_hdr[ ]
+ = {475,32950,32805,32835,321,2,32774,33134,628};
+
+// RR RG RB GR GG GB BR BG BB
+static uint16_t _calibration_mt_absolute_ls_d50_ccm_hdr[ ]
+ = {447,32959,0,32814,332,32798,6,33030,512};
+
+
+// CALIBRATION_SHADING_LS_A_R
+static uint8_t _calibration_shading_ls_a_r[ ]
+ = {96,96,95,93,92,91,90,89,88,86,85,84,83,82,82,81,81,81,82,82,83,84,85,87,88,89,90,92,93,94,96,97,95,95,94,93,92,91,89,88,87,85,84,83,82,81,80,80,80,80,81,81,82,83,84,86,87,88,90,91,92,94,95,96,94,93,92,92,90,89,88,87,85,84,82,81,80,79,78,78,78,78,79,79,80,81,83,84,85,87,88,90,91,92,94,95,93,92,91,90,89,88,87,85,83,82,80,79,78,77,76,76,76,76,76,77,78,79,81,82,84,85,87,88,89,91,92,93,91,91,90,89,88,87,85,84,82,80,79,77,76,75,74,74,74,74,74,75,76,78,79,81,82,84,85,87,88,90,91,92,91,90,89,88,87,86,84,83,81,79,77,76,74,73,73,72,72,72,73,74,75,76,78,79,81,83,84,86,87,89,90,91,91,90,89,88,87,85,84,82,80,78,76,75,73,72,71,71,71,71,72,73,74,75,77,79,80,82,84,85,87,88,90,91,91,90,89,88,87,85,84,82,80,78,76,74,72,71,71,70,70,70,71,72,73,75,76,78,80,82,84,85,87,89,90,91,91,91,90,89,87,86,84,82,79,77,75,73,72,71,70,70,70,70,70,71,73,74,76,78,80,82,84,86,87,89,90,92,92,91,90,89,87,86,84,82,79,77,75,73,71,70,70,69,69,69,70,71,72,74,76,78,80,82,84,86,88,89,91,92,92,91,90,89,87,86,84,81,79,76,74,72,71,70,69,68,68,69,69,70,72,73,75,77,79,81,84,86,87,89,91,92,91,91,90,89,87,85,83,80,78,75,73,71,70,69,68,68,68,68,68,69,71,72,74,76,78,81,83,85,87,89,90,91,91,90,89,88,86,84,82,79,77,74,72,70,69,67,67,66,66,67,67,68,69,71,73,75,77,80,82,84,86,88,89,90,90,89,88,87,85,83,81,78,76,73,71,69,67,66,66,65,65,66,66,67,68,70,72,74,76,79,81,83,85,86,88,89,89,89,87,86,84,82,80,77,75,72,70,68,67,65,65,64,64,65,65,66,67,69,71,73,76,78,80,82,84,86,87,88,89,88,87,86,84,82,80,77,74,72,70,68,66,65,64,64,64,64,65,66,67,69,70,73,75,77,80,82,84,85,87,88,89,89,87,86,84,82,80,77,75,72,70,68,66,65,64,64,64,64,65,66,67,69,71,73,75,77,80,82,84,85,87,88,90,89,88,87,85,83,81,78,75,73,70,68,67,66,65,64,65,65,66,66,68,69,71,73,76,78,80,82,84,86,88,89,91,90,89,88,86,84,81,79,76,74,71,69,68,66,65,65,65,66,66,67,69,70,72,74,77,79,81,83,85,87,88,90,91,91,90,88,87,85,82,80,77,75,72,70,69,67,66,66,66,67,67,68,70,71,73,75,78,80,82,84,86,88,89,90,92,91,90,89,87,85,83,81,78,76,73,71,70,68,67,67,67,67,68,69,70,72,74,76,79,81,83,85,87,88,90,91,91,91,90,89,87,86,84,81,79,76,74,72,70,69,68,67,68,68,69,70,71,73,75,77,79,81,83,85,87,88,90,91,91,90,90,89,87,85,84,81,79,77,74,72,71,69,68,68,68,68,69,70,71,73,75,77,79,81,83,85,87,88,89,90,90,90,89,88,87,85,83,81,79,77,75,73,71,70,69,68,69,69,70,71,72,74,75,77,79,81,83,85,86,88,89,90,90,89,89,88,87,85,83,81,79,77,75,73,72,71,70,69,69,70,70,71,73,74,76,78,79,81,83,84,86,87,89,89,90,90,89,88,87,85,84,82,80,78,76,74,73,72,71,71,70,71,71,72,74,75,77,78,80,82,83,85,86,87,89,90,91,90,89,89,87,86,85,83,81,80,78,76,75,73,73,72,72,72,73,74,75,77,78,80,81,83,84,86,87,88,89,90,92,91,91,90,89,87,86,85,83,81,80,78,77,76,75,74,74,75,75,76,77,78,80,81,83,84,85,87,88,89,90,91,93,92,92,91,90,89,88,86,85,83,82,80,79,78,77,77,77,77,77,78,79,80,82,83,84,86,87,88,89,91,92,93,94,93,93,92,91,90,89,88,86,85,84,82,81,80,79,79,79,79,80,80,81,82,84,85,86,87,88,89,91,92,93,94,95,94,93,93,92,91,90,89,88,86,85,84,83,82,81,81,81,81,81,82,83,84,85,86,87,88,89,90,91,93,94,95,95,94,94,93,92,91,90,89,88,87,86,85,84,83,83,82,82,82,83,83,84,85,86,87,88,89,90,91,92,93,94,95};
+
+
+// CALIBRATION_SHADING_LS_A_G
+static uint8_t _calibration_shading_ls_a_g[ ]
+ = {92,91,91,90,90,89,88,87,86,85,84,83,82,82,81,81,81,81,81,82,82,83,84,85,86,87,88,89,90,91,92,92,91,90,90,89,89,88,87,86,85,84,83,82,81,80,80,79,79,79,80,80,81,82,82,83,84,85,86,87,88,89,90,91,89,89,88,88,87,86,85,84,83,82,81,80,79,78,77,77,77,77,77,78,79,79,80,81,83,84,85,86,87,87,88,89,88,88,87,86,86,85,84,83,81,80,79,78,77,76,75,75,75,75,75,76,76,77,78,80,81,82,83,84,85,86,87,87,87,87,86,85,85,84,83,81,80,79,77,76,75,74,73,73,73,73,73,74,75,76,77,78,79,81,82,83,84,85,86,86,86,86,86,85,84,83,82,80,79,77,76,75,73,72,72,71,71,71,72,72,73,74,76,77,78,80,81,82,83,84,85,85,86,86,86,85,84,83,81,80,78,77,75,74,72,71,71,70,70,70,71,71,72,73,75,76,78,79,80,82,83,84,85,85,87,87,86,85,84,83,82,80,78,76,75,73,72,71,70,70,70,70,70,71,72,73,74,76,78,79,81,82,83,84,85,86,88,87,87,86,85,83,82,80,78,76,75,73,72,71,70,69,69,69,70,71,72,73,74,76,78,79,81,82,84,85,86,86,88,88,87,86,85,84,82,80,78,76,74,73,71,70,70,69,69,69,70,70,71,73,74,76,78,79,81,82,84,85,86,87,88,88,87,86,85,84,82,80,78,76,74,72,71,70,69,69,68,69,69,70,71,72,74,75,77,79,81,82,84,85,86,87,88,87,87,86,84,83,81,79,77,75,73,71,70,69,68,68,68,68,68,69,70,71,73,75,76,78,80,82,83,85,86,86,87,86,86,85,83,82,80,78,76,74,72,70,69,68,67,66,66,67,67,68,69,70,72,73,75,77,79,81,82,84,85,85,86,85,85,84,82,81,79,77,75,73,71,69,67,66,66,65,65,66,66,67,68,69,71,72,74,76,78,80,81,83,84,84,85,85,84,83,82,80,78,76,74,72,70,68,67,66,65,65,64,65,65,66,67,68,70,71,74,76,77,79,80,82,83,83,85,84,84,83,81,80,78,76,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,78,80,81,82,83,85,85,84,83,81,80,78,76,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,79,80,81,82,83,86,85,84,83,82,80,78,76,74,72,70,68,67,66,65,64,64,65,65,66,67,68,70,72,74,76,77,79,81,82,83,84,87,86,85,84,83,81,79,77,75,73,71,69,68,66,65,65,65,66,66,67,68,69,71,73,74,76,78,80,81,83,84,84,87,87,86,85,84,82,80,78,76,74,72,70,68,67,66,66,66,66,67,68,69,70,72,73,75,77,79,81,82,84,85,85,87,87,86,85,84,83,81,79,77,74,72,71,69,68,67,66,67,67,68,68,69,71,72,74,76,78,80,81,83,84,85,85,87,87,86,85,84,83,81,79,77,75,73,71,70,68,67,67,67,67,68,69,70,71,73,74,76,78,80,81,83,84,85,85,86,86,85,85,84,82,81,79,77,75,73,71,70,68,68,67,67,68,68,69,70,71,73,74,76,78,79,81,82,83,84,85,86,85,85,84,83,82,80,79,77,75,73,71,70,69,68,68,68,68,68,69,70,71,73,74,76,78,79,80,82,83,83,84,85,85,84,84,83,82,80,79,77,75,73,72,70,69,68,68,68,68,69,69,70,72,73,75,76,77,79,80,81,82,83,83,85,85,84,84,83,82,80,79,77,76,74,73,71,70,69,69,69,69,70,70,71,72,74,75,76,78,79,80,81,82,83,83,86,85,85,84,83,82,81,80,78,77,75,74,73,72,71,70,70,70,71,72,72,74,75,76,77,78,80,81,82,83,83,84,87,86,86,85,84,83,82,81,80,78,77,76,74,73,73,72,72,72,73,73,74,75,76,78,79,80,81,82,83,84,84,85,88,87,87,86,85,85,84,83,81,80,79,77,76,75,75,74,74,74,75,75,76,77,78,79,80,81,82,83,84,85,85,86,88,88,88,87,86,86,85,84,83,82,80,79,78,77,77,76,76,76,77,77,78,79,80,81,82,82,83,84,85,86,87,87,89,89,88,88,87,87,86,85,84,83,82,81,80,79,79,78,78,78,79,79,80,80,81,82,83,84,84,85,86,87,88,88,89,89,89,88,88,87,86,86,85,84,83,82,81,81,80,80,79,80,80,80,81,81,82,83,84,84,85,86,87,87,88,89};
+
+
+// CALIBRATION_SHADING_LS_A_B
+static uint8_t _calibration_shading_ls_a_b[ ]
+ = {87,87,87,86,85,85,84,83,82,81,80,79,78,77,77,76,76,76,77,77,78,78,79,80,81,82,83,85,86,87,88,89,86,86,86,85,84,84,83,82,81,80,78,77,77,76,75,75,75,75,75,76,76,77,78,79,80,81,82,83,85,86,87,88,85,85,84,84,83,82,81,80,79,78,77,76,75,74,74,73,73,73,74,74,75,75,76,77,78,79,81,82,83,84,85,86,84,84,83,83,82,81,80,79,78,77,75,74,73,73,72,72,72,72,72,72,73,74,75,76,77,78,79,80,82,83,84,85,83,83,82,82,81,80,79,78,77,75,74,73,72,71,71,70,70,70,71,71,72,73,74,75,76,77,78,79,81,82,83,84,82,82,82,81,80,79,78,77,76,75,73,72,71,70,70,69,69,69,70,70,71,72,73,74,75,76,77,79,80,81,83,83,82,82,82,81,80,79,78,77,76,74,73,72,71,70,69,69,69,69,69,70,70,71,72,74,75,76,77,79,80,81,83,83,83,83,82,82,81,80,78,77,76,74,73,72,71,70,69,69,69,69,69,70,70,71,72,74,75,76,77,79,80,82,83,84,84,83,83,82,81,80,79,77,76,74,73,72,71,70,69,69,69,69,69,70,70,71,72,74,75,76,78,79,81,82,84,84,84,84,83,83,82,80,79,78,76,74,73,72,71,70,69,69,69,69,69,70,70,71,72,74,75,77,78,79,81,83,84,85,84,84,83,83,82,80,79,77,76,74,73,71,70,69,69,68,68,68,69,69,70,71,72,73,75,76,78,79,81,82,84,85,84,83,83,82,81,80,78,77,75,73,72,70,69,69,68,68,68,68,68,68,69,70,71,73,74,76,77,79,80,82,83,84,83,82,82,81,80,79,77,76,74,72,71,69,68,67,67,67,66,67,67,67,68,69,70,72,73,75,76,78,79,81,82,83,82,82,81,80,79,78,76,74,73,71,69,68,67,66,66,65,65,65,66,66,67,68,69,71,72,74,75,77,78,80,81,82,81,81,80,79,78,77,75,74,72,70,68,67,66,65,65,65,65,65,65,65,66,67,68,70,71,73,75,76,77,79,80,81,81,81,80,79,78,76,75,73,71,70,68,67,66,65,64,64,64,64,65,65,66,67,68,69,71,72,74,76,77,79,80,81,82,81,80,79,78,77,75,73,71,70,68,67,66,65,64,64,64,64,65,65,66,67,68,69,71,72,74,76,77,79,80,81,82,82,81,80,79,77,76,74,72,70,69,67,66,65,64,64,64,65,65,66,66,67,69,70,71,73,75,76,78,79,81,82,83,83,82,81,80,78,77,75,73,71,70,68,67,66,65,65,65,66,66,66,67,68,70,71,72,74,76,77,79,80,82,82,84,83,83,82,80,79,77,76,74,72,70,69,68,66,65,65,66,66,67,67,68,69,70,72,73,75,76,78,79,81,82,83,84,83,83,82,81,80,78,76,74,73,71,70,68,67,66,65,66,67,67,68,69,70,71,72,74,75,77,78,80,81,83,84,83,83,83,82,81,80,78,76,75,73,71,70,69,67,66,66,66,67,67,68,69,70,71,73,74,76,77,79,80,81,83,84,83,83,82,81,80,79,78,76,75,73,71,70,69,67,66,66,67,67,67,68,69,70,71,73,74,75,77,78,80,81,82,83,82,82,81,81,80,79,77,76,74,73,71,70,69,67,67,66,67,67,67,68,69,70,71,72,74,75,76,78,79,80,82,83,82,82,81,80,79,78,77,76,74,73,71,70,69,68,67,67,67,67,67,68,69,70,71,72,74,75,76,77,79,80,81,82,82,82,81,80,80,79,77,76,75,73,72,71,70,69,68,68,68,68,68,69,70,71,72,73,74,75,76,78,79,80,81,82,82,82,82,81,80,79,78,77,76,74,73,72,71,70,69,69,69,69,69,70,71,72,73,74,75,76,77,78,80,81,82,83,83,83,83,82,81,80,79,78,77,76,74,73,72,71,71,70,70,70,71,71,72,73,74,75,76,77,78,79,81,82,83,84,84,84,84,83,82,81,80,79,78,77,76,75,74,73,73,72,72,72,72,73,74,75,75,76,77,78,80,81,82,83,84,85,85,85,85,84,83,82,81,80,79,78,77,76,75,75,74,74,74,74,74,74,75,76,77,78,79,80,81,82,83,84,85,86,86,85,85,84,84,83,82,81,80,79,78,77,76,76,75,75,75,75,75,76,76,77,78,78,79,80,81,82,83,84,86,86,86,86,85,85,84,83,82,81,81,80,79,78,77,76,76,75,75,75,76,76,77,77,78,79,80,81,81,82,83,85,86,87};
+
+
+// CALIBRATION_SHADING_LS_TL84_R
+static uint8_t _calibration_shading_ls_tl84_r[ ]
+ = {91,90,89,88,87,86,85,84,83,82,81,80,79,78,78,77,77,77,78,78,79,80,81,82,83,84,85,86,87,88,89,90,90,89,88,87,86,86,84,83,82,81,80,79,78,77,77,76,76,76,77,77,78,79,80,81,83,84,85,86,87,88,89,90,90,89,88,87,86,85,84,83,82,80,79,78,77,76,75,75,75,75,76,76,77,78,79,81,82,83,84,85,86,87,88,89,89,89,88,87,86,85,83,82,81,79,78,77,76,75,74,74,74,74,74,75,76,77,78,80,81,82,84,85,86,87,88,89,89,88,87,86,85,84,83,82,80,79,77,76,75,74,73,73,73,73,73,74,75,76,77,79,80,82,83,84,85,87,88,88,89,88,87,86,85,84,83,81,79,78,76,75,73,72,72,71,71,72,72,73,74,75,77,78,80,81,83,84,85,86,87,88,89,88,87,86,85,83,82,80,79,77,75,73,72,71,71,70,70,70,71,72,73,74,76,77,79,80,82,83,84,86,87,88,88,87,86,85,84,83,81,80,78,76,74,72,71,70,69,69,69,69,70,71,72,73,75,76,78,80,81,83,84,85,86,87,88,87,86,85,84,82,81,79,77,75,73,71,70,69,68,68,68,68,69,69,70,72,74,75,77,79,80,82,83,85,86,87,87,87,86,84,83,82,80,78,76,74,72,70,69,68,67,67,67,67,68,68,69,71,72,74,76,78,80,81,83,84,85,86,87,86,85,84,83,81,79,77,75,73,71,69,68,67,66,66,66,66,67,67,69,70,72,73,75,77,79,81,82,84,85,86,87,86,85,84,82,81,79,77,74,72,70,69,67,66,65,65,65,65,66,67,68,69,71,73,75,77,79,80,82,83,85,85,87,86,85,84,82,80,78,76,74,72,70,68,67,66,65,65,65,65,65,66,67,69,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,80,78,76,74,71,69,68,66,65,65,64,64,65,65,66,67,68,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,80,78,76,74,71,69,67,66,65,64,64,64,64,65,66,67,68,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,81,78,76,74,71,69,67,66,65,64,64,64,64,65,66,67,68,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,81,78,76,74,71,69,67,66,65,64,64,64,64,65,66,67,68,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,81,78,76,74,71,69,67,66,65,64,64,64,64,65,66,67,68,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,81,79,76,74,71,69,68,66,65,65,64,64,64,65,66,67,68,70,72,74,76,78,80,82,83,84,85,87,86,85,84,82,81,79,76,74,72,70,68,67,66,65,64,64,65,65,66,67,69,70,72,74,76,78,80,82,83,84,85,87,86,85,84,83,81,79,77,75,72,70,68,67,66,65,65,65,65,66,67,68,69,71,73,75,77,79,80,82,83,84,85,87,86,85,84,83,81,80,77,75,73,71,69,68,67,66,66,65,66,66,67,68,70,72,73,75,77,79,80,82,83,84,85,87,86,85,84,83,82,80,78,76,74,72,70,69,68,67,66,66,67,67,68,69,71,72,74,76,78,79,81,82,84,85,85,87,87,86,85,84,82,81,79,77,75,73,71,70,69,68,67,67,68,68,69,70,72,73,75,77,79,80,82,83,84,85,86,87,87,86,85,84,83,82,80,78,76,74,72,71,70,69,69,69,69,69,70,71,73,75,76,78,79,81,82,83,85,86,86,88,87,86,86,85,84,82,81,79,77,75,74,72,71,70,70,70,70,71,72,73,74,76,77,79,80,82,83,84,85,86,87,88,88,87,86,85,84,83,82,80,78,77,75,74,73,72,71,71,72,72,73,74,75,77,78,80,81,82,83,84,85,86,87,88,88,87,86,85,85,84,82,81,79,78,76,75,74,73,73,73,73,73,74,75,77,78,79,80,82,83,84,85,86,87,87,88,88,87,86,86,85,84,83,82,80,79,77,76,75,75,74,74,74,75,76,76,78,79,80,81,82,83,84,85,86,87,88,88,88,87,86,86,85,84,83,82,81,80,79,77,77,76,76,75,76,76,77,78,79,80,81,82,83,84,84,85,86,87,88,89,88,87,87,86,85,85,84,83,82,81,80,79,78,77,77,77,77,77,78,79,80,81,81,82,83,84,85,86,86,87,88,89,88,87,87,86,86,85,84,83,82,81,80,80,79,78,78,78,78,78,79,79,80,81,82,83,83,84,85,86,87,88,88};
+
+
+// CALIBRATION_SHADING_LS_TL84_G
+static uint8_t _calibration_shading_ls_tl84_g[ ]
+ = {90,89,88,87,87,86,85,84,83,83,82,81,80,79,79,79,79,79,79,79,80,81,81,82,83,84,85,86,87,88,89,89,89,88,87,87,86,85,84,83,82,81,80,80,79,78,77,77,77,77,77,78,79,79,80,81,82,83,84,85,86,87,88,88,88,88,87,86,85,84,83,82,81,80,79,78,77,76,76,75,75,75,76,76,77,78,79,80,81,82,83,84,85,86,87,87,88,87,86,85,85,84,83,81,80,79,78,77,76,75,74,74,74,74,74,75,76,77,78,79,80,81,82,83,84,85,86,86,88,87,86,85,84,83,82,81,80,78,77,76,75,74,73,73,73,73,73,74,74,75,77,78,79,80,81,83,84,85,85,86,88,87,86,85,84,83,82,80,79,77,76,75,73,73,72,71,71,71,72,73,73,75,76,77,78,80,81,82,83,84,85,86,87,87,86,85,84,83,81,80,78,77,75,74,72,71,71,70,70,70,71,71,72,74,75,76,78,79,80,82,83,84,85,85,87,86,85,84,83,82,81,79,77,76,74,73,71,70,70,69,69,69,70,70,71,72,74,75,77,78,80,81,82,83,84,85,87,86,85,84,83,82,80,78,77,75,73,71,70,69,68,68,68,68,68,69,70,71,73,74,76,78,79,81,82,83,84,84,86,85,84,83,82,81,79,78,76,74,72,70,69,68,67,67,67,67,67,68,69,70,72,74,75,77,79,80,81,82,83,84,86,85,84,83,82,81,79,77,75,73,71,70,68,67,66,66,66,66,67,67,68,70,71,73,75,76,78,79,81,82,83,84,86,85,84,83,82,80,78,76,74,72,70,69,67,66,66,65,65,65,66,67,68,69,70,72,74,76,77,79,80,82,83,83,85,85,84,83,81,80,78,76,74,72,70,68,67,66,65,65,65,65,65,66,67,68,70,72,74,75,77,79,80,81,82,83,85,85,84,83,81,80,78,76,74,71,69,68,66,65,65,64,64,65,65,66,67,68,70,71,73,75,77,79,80,81,82,83,85,85,84,83,81,80,78,76,73,71,69,68,66,65,65,64,64,64,65,66,67,68,69,71,73,75,77,79,80,81,82,83,85,85,84,82,81,80,78,76,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,78,80,81,82,83,85,84,83,82,81,80,78,76,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,78,80,81,82,83,85,84,83,82,81,80,78,76,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,78,80,81,82,83,85,84,83,82,81,80,78,76,73,71,69,68,66,65,65,64,64,64,65,65,66,68,69,71,73,75,77,78,80,81,82,83,85,84,83,82,81,80,78,76,74,71,69,68,66,65,65,64,64,64,65,66,67,68,69,71,73,75,77,78,80,81,82,82,85,84,83,82,81,80,78,76,74,72,70,68,67,66,65,65,65,65,65,66,67,68,70,72,73,75,77,78,80,81,82,82,85,84,83,82,81,80,78,76,74,72,70,69,67,66,66,65,65,65,66,66,68,69,70,72,74,75,77,79,80,81,82,82,85,84,83,83,82,80,79,77,75,73,71,69,68,67,66,66,66,66,66,67,68,70,71,73,74,76,77,79,80,81,82,82,85,85,84,83,82,81,79,78,76,74,72,70,69,68,67,67,67,67,67,68,69,70,72,73,75,76,78,79,80,81,82,83,85,85,84,83,82,81,80,78,76,75,73,71,70,69,68,68,68,68,68,69,70,71,73,74,76,77,78,80,81,82,83,83,86,85,84,83,83,82,80,79,77,76,74,73,71,70,69,69,69,69,70,70,71,72,74,75,76,78,79,80,81,82,83,83,86,85,84,84,83,82,81,80,78,77,75,74,72,71,71,70,70,70,71,71,72,73,75,76,77,78,79,81,81,82,83,84,86,85,85,84,83,82,81,80,79,77,76,75,73,73,72,71,71,71,72,73,73,74,76,77,78,79,80,81,82,83,83,84,86,85,85,84,83,83,82,81,79,78,77,76,75,74,73,73,73,73,73,74,74,75,76,77,78,79,80,81,82,83,84,84,86,86,85,84,83,83,82,81,80,79,78,77,76,75,74,74,74,74,74,75,76,76,77,78,79,80,81,82,82,83,84,84,86,86,85,84,84,83,82,82,81,80,79,78,77,76,76,76,75,75,76,76,77,77,78,79,80,80,81,82,83,84,84,85,87,86,85,85,84,84,83,82,81,80,80,79,78,77,77,77,76,77,77,77,78,78,79,80,80,81,82,83,83,84,85,85};
+
+// CALIBRATION_SHADING_LS_TL84_B
+static uint8_t _calibration_shading_ls_tl84_b[ ]
+ = {86,85,84,83,82,82,81,80,79,78,77,76,75,75,74,74,74,74,74,75,75,76,77,78,78,79,80,81,82,84,85,86,86,85,84,83,82,81,80,79,78,77,76,75,74,74,73,73,73,73,73,74,74,75,76,77,78,79,80,81,82,83,84,85,85,84,83,82,81,80,79,78,77,76,75,74,73,73,72,72,72,72,72,72,73,74,75,76,77,78,79,80,81,82,83,84,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,71,71,71,71,72,72,73,74,75,76,77,78,79,80,82,83,84,85,84,83,82,81,80,79,78,76,75,74,73,72,71,71,70,70,70,70,71,72,73,74,75,76,77,78,79,80,81,83,84,84,84,82,82,81,80,78,77,76,75,73,72,71,70,70,69,69,69,70,70,71,72,73,74,75,77,78,79,80,81,83,83,84,83,82,81,80,79,78,77,75,74,73,71,70,70,69,69,69,69,69,70,70,71,72,74,75,76,77,79,80,81,82,83,84,83,82,81,80,79,78,76,75,73,72,71,70,69,68,68,68,68,68,69,69,70,72,73,74,75,77,78,79,81,82,83,84,83,82,80,79,78,77,76,74,72,71,70,69,68,67,67,67,67,67,68,69,69,71,72,73,75,76,78,79,80,81,82,83,82,81,80,79,78,76,75,73,72,70,69,68,67,67,66,66,66,67,67,68,69,70,71,73,74,76,77,78,80,81,82,83,82,81,80,78,77,76,74,72,71,69,68,67,66,66,66,65,66,66,66,67,68,69,70,72,73,75,76,78,79,81,81,83,82,81,79,78,77,75,74,72,70,69,68,67,66,65,65,65,65,65,66,67,67,69,70,71,73,75,76,77,79,80,81,82,82,80,79,78,77,75,73,72,70,68,67,66,65,65,65,65,65,65,66,66,67,68,70,71,73,74,76,77,79,80,81,82,82,80,79,78,76,75,73,71,70,68,67,66,65,65,64,64,65,65,65,66,67,68,69,71,73,74,76,77,79,80,81,82,81,80,79,78,76,75,73,71,69,68,67,66,65,65,64,64,64,65,65,66,67,68,69,71,73,74,76,77,79,80,81,82,81,80,79,78,76,75,73,71,69,68,66,66,65,64,64,64,64,65,65,66,67,68,69,71,73,74,76,77,79,80,81,82,81,80,79,78,76,75,73,71,69,68,66,66,65,64,64,64,64,65,65,66,67,68,69,71,72,74,76,77,78,80,81,82,81,80,79,78,76,75,73,71,69,68,66,65,65,64,64,64,64,64,65,66,67,68,69,71,72,74,75,77,78,80,81,82,81,80,79,78,76,75,73,71,69,68,66,66,65,64,64,64,64,64,65,66,67,68,69,71,72,74,75,77,78,80,81,82,81,80,79,78,76,75,73,71,69,68,67,66,65,64,64,64,64,65,65,66,67,68,69,71,72,74,75,77,78,79,80,82,81,80,79,78,76,75,73,71,70,68,67,66,65,65,64,64,64,65,65,66,67,68,69,71,72,74,75,77,78,79,80,82,81,80,79,78,77,75,74,72,70,68,67,66,65,65,65,65,65,65,66,66,67,68,70,71,73,74,76,77,78,80,81,82,81,80,79,78,77,76,74,72,71,69,68,67,66,66,65,65,65,66,66,67,68,69,70,72,73,75,76,77,79,80,81,83,82,81,80,79,78,76,75,73,72,70,69,68,67,66,66,66,66,66,67,68,69,70,71,73,74,75,77,78,79,80,81,83,82,81,80,79,78,77,75,74,72,71,70,68,68,67,67,67,67,67,68,69,70,71,72,73,75,76,77,78,80,81,82,83,82,81,80,80,79,77,76,75,73,72,71,69,69,68,68,68,68,68,69,70,71,72,73,74,75,76,78,79,80,81,82,83,83,82,81,80,79,78,77,75,74,73,71,70,69,69,69,68,69,69,70,70,71,72,74,75,76,77,78,79,80,81,82,84,83,82,81,80,79,78,77,76,75,73,72,71,70,70,69,69,69,70,70,71,72,73,74,75,76,77,78,79,81,82,82,84,83,82,81,80,79,78,77,76,75,74,73,72,71,71,70,70,70,71,71,72,73,74,75,76,77,78,79,80,81,82,83,84,83,82,81,80,79,79,78,77,76,75,74,73,72,72,71,71,71,71,72,73,73,74,75,76,77,78,79,80,81,82,83,84,83,82,81,80,80,79,78,77,76,75,74,73,73,72,72,72,72,72,73,73,74,75,75,76,77,78,79,80,81,82,83,84,83,82,81,80,80,79,78,77,76,76,75,74,73,73,72,72,72,73,73,74,74,75,76,76,77,78,79,80,81,82,83};
+
+// CALIBRATION_SHADING_LS_D65_R
+static uint8_t _calibration_shading_ls_d65_r[ ]
+ = {94,93,92,91,90,88,87,86,85,84,83,81,81,80,79,79,79,79,79,80,81,82,83,84,85,86,88,89,90,91,93,94,94,93,92,90,89,88,87,86,85,83,82,81,80,79,79,78,78,78,78,79,80,81,82,84,85,86,87,89,90,91,93,94,93,92,91,90,89,88,87,85,84,83,81,80,79,78,77,77,77,77,77,78,79,80,82,83,84,86,87,88,89,91,92,93,92,92,91,89,88,87,86,84,83,82,80,79,78,77,76,75,75,75,76,77,78,79,80,82,83,85,86,87,89,90,91,92,91,91,90,89,87,86,85,83,82,80,79,77,76,75,74,74,73,74,74,75,76,78,79,80,82,83,85,86,88,89,90,91,90,90,89,88,86,85,84,82,80,79,77,75,74,73,72,72,72,72,72,73,74,76,77,79,81,82,84,85,86,88,89,90,90,89,88,87,85,84,83,81,79,77,75,74,72,71,71,70,70,70,71,72,73,74,76,78,79,81,83,84,86,87,89,90,89,89,87,86,85,83,82,80,78,76,74,73,71,70,69,69,69,69,70,71,72,73,75,77,78,80,82,83,85,86,88,89,89,88,87,86,85,83,81,80,77,75,73,72,70,69,69,68,68,68,69,70,71,72,74,76,78,80,81,83,85,86,88,89,89,89,88,86,85,83,81,79,77,75,73,71,70,69,68,68,68,68,68,69,70,72,74,75,77,79,81,83,85,86,88,89,90,89,88,86,85,83,81,79,77,75,73,71,69,68,68,67,67,67,68,69,70,71,73,75,77,79,81,83,85,86,88,89,90,89,88,87,85,83,81,79,77,74,72,70,69,68,67,67,67,67,68,69,70,71,73,75,77,79,81,83,85,87,88,89,90,89,88,86,85,83,81,79,76,74,72,70,68,67,67,66,66,67,67,68,69,71,72,75,77,79,81,83,85,86,88,89,89,89,87,86,84,83,80,78,76,73,71,69,68,67,66,66,66,66,67,67,68,70,72,74,76,79,81,82,84,86,87,89,89,88,87,85,84,82,80,77,75,72,70,68,67,66,65,65,65,65,66,67,68,69,71,73,75,78,80,82,83,85,87,88,88,88,86,85,83,81,79,77,74,72,69,68,66,65,65,64,64,65,65,66,67,69,70,72,75,77,79,81,83,84,86,87,88,87,86,84,83,81,79,76,74,71,69,67,66,65,64,64,64,64,65,66,67,68,70,72,74,76,78,80,82,84,86,87,88,87,86,84,83,81,79,76,74,71,69,67,66,65,64,64,64,64,65,66,67,68,70,72,74,76,78,80,82,84,85,86,88,87,86,85,83,81,79,77,74,72,70,68,66,65,65,64,64,65,65,66,67,69,70,72,74,77,79,81,83,84,86,87,89,88,87,85,84,82,80,78,75,73,70,69,67,66,66,65,65,65,66,67,68,69,71,73,75,77,80,81,83,85,86,87,89,89,87,86,85,83,81,79,76,74,72,70,68,67,66,66,66,66,67,68,69,71,72,74,76,79,81,82,84,86,87,88,90,89,88,87,85,84,82,80,77,75,73,71,69,68,67,67,67,67,68,69,70,72,73,75,77,79,81,83,85,86,88,89,90,89,88,87,86,84,82,80,78,76,74,72,70,69,68,68,68,68,69,70,71,73,74,76,78,80,82,84,85,87,88,89,90,89,88,87,86,84,83,81,79,77,75,73,71,70,69,69,69,69,70,70,72,73,75,77,79,81,82,84,85,87,88,89,90,89,88,87,86,84,83,81,79,77,75,73,72,71,70,69,69,70,70,71,72,74,76,77,79,81,82,84,85,87,88,89,89,89,88,87,86,84,83,81,80,78,76,74,73,71,71,70,70,70,71,72,73,75,76,78,79,81,82,84,85,86,88,89,89,89,88,87,86,85,83,82,80,78,77,75,74,72,72,71,71,71,72,73,74,75,77,78,80,81,83,84,85,87,88,89,89,89,88,87,86,85,84,82,81,79,78,76,75,74,73,73,72,73,73,74,75,76,78,79,81,82,83,84,86,87,88,89,90,89,89,88,87,86,85,83,82,81,79,78,76,75,75,74,74,74,75,76,77,78,79,80,82,83,84,85,86,88,89,90,91,90,89,88,88,87,86,85,83,82,81,79,78,77,77,76,76,76,77,78,78,80,81,82,83,84,85,86,87,89,90,91,92,91,90,89,89,88,87,86,85,84,82,81,80,79,79,78,78,78,79,79,80,81,82,83,84,85,86,87,88,90,91,92,92,92,91,90,89,88,88,87,86,85,83,82,81,81,80,80,79,80,80,81,81,82,83,84,85,86,87,88,89,90,91,92};
+
+// CALIBRATION_SHADING_LS_D65_G
+static uint8_t _calibration_shading_ls_d65_g[ ]
+ = {91,90,90,89,88,88,87,86,85,84,83,82,82,81,80,80,80,80,80,81,81,82,83,84,85,86,87,88,88,89,90,91,90,90,89,88,88,87,86,85,84,83,82,81,81,80,79,79,79,79,79,80,80,81,82,83,84,85,86,87,88,89,90,90,90,89,89,88,87,86,86,85,83,82,81,80,79,78,78,77,77,77,77,78,79,80,81,82,83,84,85,86,87,88,89,89,89,89,88,87,87,86,85,84,82,81,80,78,77,76,76,75,75,75,76,76,77,78,79,81,82,83,84,85,86,87,88,88,88,88,87,86,86,85,84,82,81,79,78,77,76,75,74,74,73,73,74,75,75,77,78,79,80,82,83,84,85,86,87,87,88,87,86,86,85,84,82,81,80,78,76,75,74,73,72,72,72,72,72,73,74,75,76,78,79,80,82,83,84,85,86,86,87,86,86,85,84,83,81,80,78,77,75,73,72,71,71,70,70,70,71,71,72,73,75,76,78,79,81,82,83,84,85,85,86,86,85,84,83,82,81,79,77,76,74,72,71,70,69,69,69,69,69,70,71,72,74,75,77,78,80,81,83,84,85,85,87,86,85,84,83,82,80,79,77,75,73,72,70,69,69,68,68,68,69,69,70,72,73,75,76,78,80,81,82,84,84,85,87,86,86,85,83,82,80,79,77,75,73,71,70,69,68,68,68,68,68,69,70,71,73,74,76,78,80,81,83,84,85,85,87,87,86,85,84,82,81,79,76,74,72,71,70,69,68,67,67,68,68,69,70,71,73,74,76,78,80,81,83,84,85,86,88,87,86,85,84,82,81,79,76,74,72,71,69,68,67,67,67,67,68,68,69,71,72,74,76,78,80,81,83,84,85,86,88,87,86,85,84,82,80,78,76,74,72,70,69,68,67,67,67,67,67,68,69,70,72,74,76,78,80,81,83,84,85,86,87,87,86,85,83,82,80,78,75,73,71,69,68,67,66,66,66,66,67,67,68,70,71,73,75,77,79,81,82,84,85,85,86,86,85,84,83,81,79,77,74,72,70,69,67,66,66,65,65,65,66,67,68,69,70,72,74,77,78,80,82,83,84,85,86,85,84,83,82,80,78,76,74,71,69,68,66,66,65,65,64,65,65,66,67,68,70,72,74,76,78,79,81,82,83,84,85,85,84,83,81,80,78,75,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,79,80,82,83,83,85,84,84,83,81,80,78,75,73,71,69,67,66,65,64,64,64,64,65,65,66,68,69,71,73,75,77,78,80,81,82,83,85,85,84,83,82,80,78,76,73,71,69,68,66,65,65,64,64,65,65,66,67,68,70,71,73,75,77,79,80,82,83,83,86,85,84,83,82,81,79,76,74,72,70,68,67,66,65,65,65,65,66,66,68,69,70,72,74,76,78,79,81,82,83,84,86,86,85,84,83,81,80,77,75,73,71,69,68,67,66,66,66,66,67,67,68,70,71,73,75,77,79,80,82,83,84,84,87,86,86,85,84,82,80,78,76,74,72,70,69,68,67,67,67,67,67,68,69,71,72,74,76,78,79,81,82,83,84,85,87,87,86,85,84,83,81,79,77,75,73,71,70,69,68,68,68,68,68,69,70,71,73,75,76,78,80,81,83,84,85,85,87,86,86,85,84,83,81,79,77,75,73,72,70,69,69,68,68,68,69,70,71,72,73,75,77,78,80,81,83,84,84,85,86,86,85,84,84,82,81,79,78,76,74,72,71,70,69,69,69,69,69,70,71,72,74,75,77,78,80,81,82,83,84,85,86,85,85,84,83,82,81,79,78,76,74,73,72,71,70,69,69,69,70,71,72,73,74,76,77,78,80,81,82,83,84,84,86,85,84,84,83,82,81,80,78,76,75,73,72,71,71,70,70,70,71,71,72,73,75,76,77,78,80,81,82,83,83,84,86,85,85,84,83,82,81,80,79,77,76,74,73,72,72,71,71,71,72,72,73,74,76,77,78,79,80,81,82,83,84,84,86,86,85,84,84,83,82,81,80,78,77,76,75,74,73,73,73,73,73,74,75,76,77,78,79,80,81,82,83,83,84,85,87,86,86,85,85,84,83,82,81,80,79,78,77,76,75,75,75,75,75,76,76,77,78,79,80,81,82,83,84,84,85,85,88,87,87,86,86,85,84,83,83,82,81,80,79,78,77,77,77,77,77,78,78,79,80,81,82,82,83,84,85,85,86,87,88,88,87,87,86,86,85,84,84,83,82,81,80,79,79,79,79,79,79,79,80,80,81,82,83,83,84,85,86,86,87,88};
+
+// CALIBRATION_SHADING_LS_D65_B
+static uint8_t _calibration_shading_ls_d65_b[ ]
+ = {87,87,86,85,84,83,82,81,80,79,79,78,77,76,76,76,75,75,76,76,77,78,79,80,80,81,82,83,85,86,87,88,87,86,85,84,84,83,82,81,80,79,78,77,76,76,75,75,75,75,75,76,76,77,78,79,80,81,82,83,84,85,87,88,87,86,85,84,83,82,81,80,79,78,77,76,75,75,74,74,74,74,74,75,75,76,77,78,79,80,81,82,83,85,86,87,86,85,84,83,83,82,81,80,78,77,76,75,74,74,73,73,72,72,73,73,74,75,76,77,78,79,80,82,83,84,85,86,85,84,83,83,82,81,80,79,77,76,75,74,73,72,72,71,71,71,72,72,73,74,75,76,77,78,79,81,82,83,84,85,84,83,82,82,81,80,79,77,76,75,74,73,72,71,70,70,70,70,70,71,72,73,74,75,76,77,78,80,81,82,83,84,83,83,82,81,80,79,78,77,75,74,72,71,70,70,69,69,69,69,69,70,70,71,73,74,75,76,78,79,80,81,83,84,83,82,81,81,80,78,77,76,74,73,72,70,69,69,68,68,68,68,68,69,70,71,72,73,74,76,77,78,80,81,82,83,83,82,81,81,79,78,77,76,74,73,71,70,69,68,68,67,67,67,68,68,69,70,71,73,74,75,77,78,79,81,82,83,83,83,82,81,80,78,77,76,74,72,71,70,69,68,67,67,67,67,68,68,69,70,71,72,74,75,77,78,80,81,82,83,84,83,82,81,80,79,77,76,74,72,71,70,69,68,67,67,67,67,67,68,69,70,71,72,74,76,77,79,80,81,83,84,84,83,82,81,80,79,77,76,74,72,71,69,68,68,67,67,67,67,67,68,69,70,71,72,74,76,77,79,80,82,83,84,84,83,82,81,80,79,77,75,74,72,70,69,68,67,67,67,67,67,67,68,68,69,71,72,74,75,77,78,80,81,83,84,83,83,82,81,80,78,77,75,73,71,70,68,67,67,66,66,66,66,67,67,68,69,70,71,73,75,77,78,79,81,82,83,83,82,81,80,79,77,76,74,72,70,69,68,67,66,65,65,65,65,66,66,67,68,69,71,73,74,76,77,79,80,82,83,82,81,81,79,78,77,75,73,71,70,68,67,66,65,65,65,65,65,65,66,66,67,69,70,72,73,75,77,78,79,81,82,82,81,80,79,78,76,75,73,71,69,68,66,65,65,64,64,64,64,65,65,66,67,68,69,71,73,74,76,77,79,80,81,82,81,80,79,78,76,75,73,71,69,68,66,65,65,64,64,64,64,65,65,66,67,68,69,71,73,74,76,77,79,80,81,82,81,80,79,78,77,75,73,71,69,68,67,66,65,65,64,64,64,65,65,66,67,68,70,71,73,75,76,78,79,80,81,82,82,81,80,79,77,76,74,72,70,69,67,66,66,65,65,65,65,65,66,67,68,69,71,72,74,75,77,78,80,81,82,83,82,82,80,79,78,76,75,73,71,70,68,67,67,66,66,66,66,66,67,68,69,70,71,73,75,76,78,79,80,82,83,84,83,82,81,80,79,77,76,74,72,71,69,68,67,67,67,67,67,67,68,69,70,71,72,74,75,77,78,80,81,82,83,84,83,82,81,80,79,78,76,75,73,71,70,69,68,68,67,67,67,68,68,69,70,72,73,74,76,77,79,80,81,83,84,84,83,82,81,80,79,78,76,75,73,72,70,69,69,68,68,68,68,68,69,70,71,72,73,75,76,78,79,80,81,83,84,83,83,82,81,80,79,78,76,75,73,72,71,70,69,68,68,68,68,69,69,70,71,72,74,75,76,77,79,80,81,82,83,83,82,81,81,80,79,78,76,75,74,72,71,70,69,69,68,68,68,69,69,70,71,72,74,75,76,77,78,80,81,82,83,82,82,81,80,80,79,78,77,75,74,73,72,71,70,69,69,69,69,69,70,71,72,73,74,75,76,77,78,79,81,82,83,83,82,81,81,80,79,78,77,76,75,73,72,71,71,70,70,70,70,70,71,72,73,74,75,76,77,78,79,80,81,82,83,83,82,82,81,80,80,79,78,77,76,74,73,73,72,71,71,71,71,72,72,73,74,75,75,76,77,78,79,80,81,82,83,84,83,83,82,81,80,80,79,78,77,76,75,74,73,73,73,72,73,73,73,74,75,76,77,77,78,79,80,81,82,83,84,85,84,83,83,82,81,80,80,79,78,77,76,75,75,74,74,74,74,74,75,75,76,77,78,78,79,80,81,82,83,84,85,85,85,84,83,82,82,81,80,79,79,78,77,76,76,75,75,75,75,75,76,76,77,78,78,79,80,81,81,82,83,85,85};
+
+// CALIBRATION_SHADING_LS_A_R_WDR
+static uint8_t _calibration_shading_ls_a_r_wdr[ ]
+ = {113,111,108,106,104,102,101,99,97,95,93,91,89,88,87,87,87,87,88,89,91,93,95,97,100,102,105,107,109,112,114,116,112,110,107,105,103,101,99,97,95,93,91,89,87,86,85,85,85,85,86,87,89,91,93,96,98,101,103,106,108,111,113,115,110,108,106,104,102,100,97,95,93,91,88,86,84,83,82,82,82,82,83,84,86,88,91,93,96,99,102,104,107,109,112,114,108,106,104,102,100,98,95,93,90,88,85,83,81,80,79,79,79,79,80,81,83,85,88,91,94,97,100,102,105,108,110,112,107,105,103,100,98,96,93,91,88,85,83,80,79,77,76,76,76,76,77,79,80,83,85,88,92,95,98,101,103,106,109,110,106,104,101,99,97,94,91,88,86,83,80,78,76,75,74,73,73,74,75,76,78,80,83,86,90,93,96,99,102,105,107,109,105,103,101,98,96,93,90,87,84,81,78,76,74,73,72,71,71,72,73,74,76,78,81,84,88,91,95,98,101,104,107,108,105,103,100,98,95,92,89,86,82,79,76,74,72,71,70,70,70,70,71,72,74,77,80,83,87,90,94,97,101,104,106,108,105,103,100,97,95,91,88,85,81,78,75,73,71,70,69,69,69,69,70,71,73,76,79,82,86,89,93,97,100,104,106,108,105,103,100,97,94,91,87,84,80,77,74,72,70,69,68,68,68,68,69,70,72,75,78,81,85,89,93,97,100,104,106,108,105,103,100,97,94,91,87,83,80,76,74,71,70,68,68,67,67,68,68,70,71,74,77,80,84,88,93,97,100,104,107,108,105,103,100,97,94,90,86,82,79,75,73,70,69,68,67,67,67,67,68,69,71,73,76,80,84,88,92,96,100,103,106,108,104,102,99,96,93,89,85,82,78,74,72,70,68,67,66,66,66,66,67,68,70,72,75,79,83,87,91,95,99,103,106,108,103,101,98,95,92,88,85,81,77,74,71,69,67,66,65,65,65,66,66,67,69,71,74,78,82,86,90,95,98,102,105,107,103,101,98,95,91,88,84,80,76,73,70,68,67,65,65,64,65,65,66,67,68,70,73,77,81,85,90,94,98,101,104,106,102,100,97,94,91,87,83,79,76,72,70,68,66,65,64,64,64,65,65,66,68,70,73,77,81,85,89,93,97,101,104,106,102,100,97,94,91,87,83,79,76,72,70,68,66,65,64,64,64,65,65,66,68,70,73,77,81,85,89,93,97,101,104,106,103,101,98,95,91,87,84,80,76,73,70,68,67,66,65,65,65,65,66,67,68,70,73,77,81,85,90,94,98,101,104,106,103,101,98,95,92,88,84,81,77,74,71,69,67,66,66,65,65,66,66,67,69,71,74,78,82,86,91,95,99,102,105,107,104,102,99,96,93,89,86,82,78,75,72,70,68,67,67,66,66,67,67,68,70,72,76,79,83,88,92,96,100,103,106,108,105,103,100,98,94,91,87,83,79,76,73,71,69,68,67,67,67,67,68,69,71,74,77,81,85,89,93,97,101,104,107,109,106,104,101,98,95,92,88,84,80,77,74,72,70,69,68,68,68,68,69,70,72,75,78,82,86,90,94,98,102,105,108,110,106,104,101,99,96,92,89,85,81,78,75,73,71,70,69,69,69,69,70,71,73,76,79,83,87,91,95,99,102,106,108,110,106,104,101,99,96,93,89,86,82,79,76,74,72,71,70,69,70,70,71,72,75,77,80,84,88,92,96,99,103,106,108,110,106,104,101,99,96,93,90,86,83,80,77,75,73,72,71,70,70,71,72,74,76,78,82,85,89,93,96,100,103,106,108,110,106,104,101,99,97,94,91,87,84,81,79,76,75,73,72,72,72,72,74,75,77,80,83,86,90,94,97,101,103,106,109,110,106,104,102,100,97,95,92,89,86,83,81,78,76,75,74,74,74,74,75,77,79,82,85,88,91,95,98,101,104,107,109,111,107,106,103,101,99,96,94,91,88,85,83,81,79,77,76,76,76,77,78,79,82,84,87,90,94,97,100,103,105,108,111,112,109,107,104,102,100,98,96,93,90,88,85,83,81,80,79,79,79,79,81,82,84,87,90,93,96,99,102,104,107,110,112,114,110,108,106,104,102,100,98,95,93,90,88,86,84,83,82,82,82,82,83,85,87,90,92,95,98,101,104,106,109,111,114,116,112,110,107,105,103,101,99,97,95,93,90,88,87,86,85,84,84,85,86,88,90,92,95,98,100,103,105,108,110,113,115,117,112,110,108,106,104,102,100,98,96,94,92,90,89,87,86,86,86,87,88,90,92,94,96,99,101,104,106,109,111,114,116,118};
+
+// CALIBRATION_SHADING_LS_A_G_WDR
+static uint8_t _calibration_shading_ls_a_g_wdr[ ]
+ = {106,104,103,101,100,99,97,96,94,92,90,89,87,86,85,85,85,85,86,87,88,90,91,93,95,97,99,100,102,104,106,108,105,104,102,101,99,98,96,94,92,90,89,87,85,84,83,83,83,83,84,85,86,88,90,92,94,96,98,99,101,103,105,107,103,102,101,99,98,96,94,93,90,88,86,84,83,82,81,80,80,80,81,82,84,85,88,90,92,94,96,98,100,102,104,106,102,101,100,98,97,95,93,91,88,86,84,82,80,79,78,77,77,78,78,80,81,83,85,88,90,92,95,97,99,101,103,104,101,100,99,97,95,93,91,89,86,84,81,79,78,76,75,75,75,75,76,77,79,81,83,85,88,90,93,95,97,100,102,103,100,99,97,96,94,92,89,87,84,81,79,77,75,74,73,72,72,73,74,75,76,78,81,83,86,89,92,94,96,99,101,102,99,98,97,95,93,91,88,85,82,80,77,75,73,72,71,71,71,71,72,73,74,76,79,82,84,87,90,93,96,98,100,101,99,98,97,95,92,90,87,84,81,78,76,73,72,71,70,69,69,70,70,71,73,75,78,80,83,87,90,93,95,98,100,101,99,98,97,95,92,89,86,83,80,77,75,72,71,70,69,69,69,69,69,70,72,74,77,80,83,86,89,93,95,98,100,101,100,98,97,95,92,89,86,83,79,76,74,72,70,69,68,68,68,68,69,70,71,73,76,79,82,86,89,93,96,98,100,102,100,99,97,95,92,89,85,82,79,76,73,71,70,68,68,67,67,68,68,69,71,73,75,78,82,85,89,92,96,98,101,102,100,98,97,94,91,88,85,81,78,75,72,70,69,68,67,67,67,67,68,69,70,72,74,78,81,85,88,92,95,98,100,102,99,98,96,94,91,87,84,80,77,74,71,70,68,67,66,66,66,66,67,68,69,71,74,77,80,84,88,91,95,97,100,101,98,97,95,93,90,86,83,79,76,73,70,69,67,66,65,65,65,66,66,67,68,70,73,76,79,83,87,90,94,97,99,101,97,96,94,92,89,85,82,78,75,72,70,68,67,65,65,64,65,65,66,66,68,69,72,75,78,82,86,89,93,96,98,100,97,96,94,91,88,85,81,78,74,71,69,67,66,65,64,64,64,65,65,66,67,69,71,74,78,82,85,89,92,95,98,99,97,96,94,91,88,85,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,81,85,89,92,95,98,99,97,96,94,91,88,85,81,78,74,72,69,67,66,65,65,64,64,65,65,66,67,69,72,75,78,82,86,89,93,96,98,100,98,96,94,92,89,86,82,78,75,72,70,68,67,66,65,65,65,65,66,67,68,70,72,75,79,83,86,90,93,96,99,100,99,97,95,93,90,87,83,79,76,73,71,69,68,67,66,66,66,66,66,67,69,71,73,76,80,84,88,91,94,97,100,101,99,98,96,94,91,88,84,80,77,74,72,70,68,67,67,66,66,67,67,68,70,72,74,77,81,85,89,92,95,98,100,102,100,98,97,94,92,88,85,81,78,75,73,71,69,68,67,67,67,67,68,69,70,73,75,78,82,86,89,93,96,98,101,102,100,99,97,94,92,89,85,82,79,76,73,71,70,69,68,68,67,68,68,69,71,73,76,79,83,86,90,93,96,99,101,102,100,98,96,94,92,89,86,82,79,76,74,72,70,69,68,68,68,68,69,70,72,74,77,80,83,86,90,93,96,98,101,102,99,98,96,94,92,89,86,83,80,77,75,73,71,70,69,69,69,69,70,71,73,75,78,80,84,87,90,93,96,98,100,102,99,98,96,94,92,89,87,84,81,78,76,74,72,71,70,70,70,70,71,72,74,76,79,81,84,88,91,94,96,98,100,102,100,98,97,95,93,90,88,85,82,80,77,75,74,72,71,71,71,72,72,74,75,78,80,83,86,89,92,94,97,99,101,102,100,99,97,96,94,92,89,87,84,81,79,77,76,74,74,73,73,74,75,76,78,80,82,85,87,90,93,95,97,100,102,103,102,100,99,97,95,93,91,88,86,84,82,80,78,77,76,76,76,76,77,78,80,82,84,87,89,92,94,97,99,101,103,104,103,102,100,98,97,95,93,91,88,86,84,82,81,80,79,78,79,79,80,81,83,85,87,89,91,94,96,98,100,102,104,106,104,103,101,100,98,96,94,93,90,88,86,85,83,82,82,81,81,82,83,84,85,87,89,91,93,96,98,100,102,104,106,107,106,104,102,101,99,97,96,94,92,90,88,87,85,84,83,83,83,84,84,86,87,89,91,93,95,97,99,100,102,104,107,108};
+
+// CALIBRATION_SHADING_LS_A_B_WDR
+static uint8_t _calibration_shading_ls_a_b_wdr[ ]
+ = {102,99,97,94,92,91,89,87,86,84,82,80,79,78,77,76,76,76,77,78,79,81,83,85,87,89,91,94,96,99,102,104,100,97,95,93,91,89,87,86,84,82,80,78,77,76,75,74,74,74,75,76,77,79,81,83,85,87,89,92,94,97,100,102,98,95,93,91,89,87,86,84,82,80,78,76,75,74,73,72,72,72,73,74,75,77,79,81,83,85,87,90,92,95,98,100,96,94,91,89,88,86,84,82,80,78,76,74,73,72,71,70,70,71,71,72,73,75,77,79,81,83,86,88,91,93,96,98,94,92,90,88,86,84,82,80,78,76,74,72,71,70,69,69,69,69,70,71,72,73,75,77,80,82,84,87,89,92,94,97,93,91,88,86,85,83,81,79,76,74,72,71,69,68,68,67,67,68,68,69,70,72,74,76,78,80,83,85,88,90,93,95,92,90,88,86,84,82,80,77,75,73,71,70,68,67,67,67,67,67,67,68,69,71,73,75,77,79,82,84,87,89,92,94,92,90,87,85,83,81,79,76,74,72,70,69,68,67,66,66,66,67,67,68,69,70,72,74,76,79,81,84,86,89,92,94,92,90,87,85,83,81,78,76,74,72,70,68,67,67,66,66,67,67,67,68,69,70,72,74,76,79,81,84,86,89,92,94,92,90,88,85,83,80,78,76,73,71,70,68,67,67,67,67,67,67,67,68,68,70,71,73,76,79,81,84,87,89,92,94,92,90,88,85,83,80,78,75,73,71,69,68,67,67,67,67,67,67,67,68,68,69,71,73,76,78,81,84,87,90,92,94,92,90,87,85,82,80,77,75,72,70,69,68,67,67,66,66,67,67,67,68,68,69,71,73,75,78,81,84,86,89,92,94,91,89,87,84,82,79,76,74,71,70,68,67,67,66,66,66,66,67,67,67,68,69,70,72,75,77,80,83,86,89,92,93,91,88,86,83,81,78,75,73,71,69,68,67,66,65,65,65,66,66,66,67,67,68,70,72,74,76,79,82,85,88,91,93,90,88,85,82,80,77,75,72,70,68,67,66,66,65,64,64,65,66,66,66,67,68,69,71,73,76,79,81,84,87,90,92,89,87,84,82,79,77,74,72,70,68,67,66,65,65,64,64,65,65,65,66,66,67,68,70,73,75,78,81,84,87,89,91,89,87,84,82,79,77,74,72,69,68,67,66,65,65,64,64,65,65,65,66,66,67,68,70,73,75,78,81,84,87,89,91,90,87,85,82,79,77,74,72,70,68,67,66,66,65,65,65,65,65,66,66,66,67,69,71,73,76,79,81,84,87,90,92,90,88,85,83,80,78,75,73,71,69,68,67,66,66,66,66,66,66,66,67,67,68,69,71,74,77,79,82,85,88,91,93,91,89,86,84,81,79,76,74,71,70,68,68,67,67,67,67,67,67,67,67,68,69,70,72,75,78,80,83,86,89,92,94,92,90,87,85,82,80,77,75,72,70,69,68,68,68,67,67,67,67,67,68,68,69,71,73,76,78,81,84,87,90,93,95,93,91,88,86,83,80,78,75,73,71,70,69,68,68,68,68,68,68,68,68,69,70,72,74,76,79,82,85,88,91,93,95,93,91,88,86,83,81,78,76,74,72,70,69,69,68,68,68,68,68,68,68,69,71,72,74,77,80,82,85,88,91,94,96,93,91,88,86,83,81,79,76,74,72,71,70,69,68,68,68,68,68,68,69,69,71,73,75,77,80,83,85,88,91,94,96,93,91,88,86,84,81,79,77,75,73,71,70,69,68,68,68,68,68,68,69,70,71,73,75,78,80,83,86,88,91,94,96,93,91,88,86,84,82,80,77,75,73,72,70,69,68,68,68,68,68,69,70,71,72,74,76,78,81,83,86,88,91,94,96,94,92,89,87,85,83,81,78,76,74,73,71,70,69,69,69,69,69,70,71,72,73,75,77,79,82,84,87,89,91,94,97,95,93,90,88,86,84,82,80,78,76,74,73,72,71,70,70,70,70,71,72,74,75,77,79,81,83,85,87,90,92,95,98,97,95,92,90,88,86,84,82,80,78,76,75,74,73,72,72,72,72,73,74,75,77,79,81,83,85,87,89,91,94,96,99,99,96,94,91,90,88,86,84,82,80,79,77,76,75,74,74,74,74,75,76,78,79,81,83,85,87,89,91,93,95,98,100,101,98,95,93,91,89,87,86,84,82,81,79,78,77,76,76,76,76,77,78,80,81,83,85,87,89,91,93,95,97,99,101,102,99,96,94,92,90,89,87,85,83,82,80,79,78,77,77,77,77,78,80,81,83,85,86,88,90,92,94,96,98,100,102};
+
+// CALIBRATION_SHADING_LS_TL84_R_WDR
+static uint8_t _calibration_shading_ls_tl84_r_wdr[ ]
+ = {109,107,105,103,101,99,97,95,94,92,90,88,87,85,85,84,84,84,85,86,88,89,91,93,96,98,100,102,104,107,109,111,108,106,104,102,100,98,96,94,92,90,88,86,85,83,83,82,82,82,83,84,86,88,90,92,94,97,99,101,103,106,108,110,107,105,102,100,98,96,94,92,90,88,86,84,82,81,80,80,79,80,81,82,84,86,88,90,93,95,97,100,102,104,107,108,106,104,101,99,97,95,93,91,88,86,84,82,80,79,78,77,77,78,78,80,81,83,86,88,91,94,96,99,101,103,106,107,105,103,101,98,96,94,92,89,87,84,82,80,78,76,75,75,75,75,76,78,79,82,84,87,90,92,95,98,100,103,105,107,105,103,100,98,96,93,91,88,85,82,80,78,76,74,73,73,73,73,74,76,77,80,82,85,88,91,94,97,100,102,104,106,104,102,100,97,95,92,89,86,84,81,78,76,74,72,71,71,71,71,72,74,76,78,81,84,87,90,93,96,99,101,104,105,104,102,99,96,94,91,88,85,82,79,76,74,72,71,70,69,69,70,70,72,74,76,79,82,85,89,92,95,98,101,103,105,103,101,98,96,93,90,87,84,81,77,75,72,70,69,68,68,68,68,69,70,72,75,78,81,84,88,91,94,97,100,103,104,102,100,97,95,92,89,86,82,79,76,73,71,69,68,67,67,67,67,68,69,71,73,76,79,83,87,90,94,97,100,102,104,102,100,97,94,91,88,85,81,78,75,72,70,68,67,66,66,66,66,67,68,69,72,75,78,82,86,89,93,96,99,102,103,101,99,96,94,91,87,84,80,77,74,71,69,67,66,65,65,65,65,66,67,69,71,74,77,81,85,89,92,96,99,101,103,101,99,96,93,90,87,83,80,76,73,70,68,66,65,65,64,64,65,65,66,68,70,73,77,80,84,88,92,95,98,101,102,101,99,96,93,90,87,83,79,76,72,70,68,66,65,64,64,64,64,65,66,67,70,72,76,80,84,88,92,95,98,101,102,101,99,96,93,90,87,83,79,75,72,69,67,66,65,64,64,64,64,65,66,67,69,72,76,80,84,88,92,95,98,101,103,101,99,96,93,90,87,83,79,75,72,69,67,66,65,64,64,64,64,65,66,67,69,72,76,80,84,88,92,95,98,101,103,101,99,96,93,90,87,83,79,76,72,70,68,66,65,64,64,64,64,65,66,67,69,72,76,80,84,88,92,95,99,101,103,101,99,97,94,91,87,83,80,76,73,70,68,66,65,65,64,64,65,65,66,68,70,73,76,80,84,88,92,96,99,102,103,102,100,97,94,91,87,84,80,76,73,70,68,67,66,65,65,65,65,65,66,68,70,73,77,81,85,89,93,96,99,102,104,102,100,97,94,91,88,84,81,77,74,71,69,67,66,65,65,65,65,66,67,69,71,74,78,81,85,89,93,96,99,102,104,102,100,97,95,92,89,85,81,78,75,72,69,68,67,66,66,66,66,66,68,69,72,75,78,82,86,90,93,97,100,102,104,102,100,98,95,92,89,86,82,79,76,73,70,69,67,67,66,66,67,67,68,70,73,76,79,83,87,91,94,97,100,103,105,103,101,98,96,93,90,87,83,80,77,74,72,70,68,67,67,67,67,68,70,72,74,77,81,84,88,91,95,98,101,103,105,103,101,99,96,94,91,88,84,81,78,75,73,71,70,69,68,68,69,70,71,73,76,79,82,86,89,93,96,99,102,104,106,104,102,99,97,94,92,89,86,83,80,77,75,73,71,70,70,70,70,71,73,75,78,80,84,87,91,94,97,100,103,105,107,105,103,100,98,95,93,90,87,84,81,79,76,74,73,72,71,71,72,73,75,77,79,82,85,89,92,95,98,101,104,106,108,105,103,101,99,96,94,92,89,86,83,81,78,77,75,74,73,74,74,75,77,79,81,84,87,90,94,97,99,102,105,107,108,106,104,102,100,98,95,93,90,88,85,83,81,79,77,76,76,76,76,77,79,81,83,86,89,92,95,98,101,103,106,108,109,107,105,103,100,98,96,94,92,89,87,85,83,81,79,78,78,78,79,80,81,83,86,88,91,94,96,99,102,104,107,109,110,108,106,103,101,99,97,95,93,91,89,86,84,83,82,81,80,80,81,82,83,85,87,90,92,95,98,100,103,105,107,110,111,108,106,104,102,100,98,96,94,92,90,88,86,85,84,83,82,82,83,84,85,87,89,92,94,96,99,101,103,106,108,110,112,108,106,104,102,100,99,97,95,93,91,89,88,86,85,84,84,84,84,85,87,88,91,93,95,97,100,102,104,106,109,111,113};
+
+// CALIBRATION_SHADING_LS_TL84_G_WDR
+static uint8_t _calibration_shading_ls_tl84_g_wdr[ ]
+ = {105,103,102,100,99,97,96,94,93,91,89,88,86,85,85,84,84,84,85,86,87,89,90,92,94,96,98,99,101,103,105,107,103,102,101,99,98,96,95,93,91,89,88,86,84,83,82,82,82,82,83,84,85,87,89,91,93,95,96,98,100,102,104,106,102,101,100,98,97,95,93,91,89,87,85,83,82,81,80,79,79,79,80,81,83,85,87,89,91,93,95,97,99,101,103,105,102,101,99,97,96,94,92,90,88,85,83,81,79,78,77,77,77,77,78,79,81,83,85,87,89,92,94,96,98,100,103,104,101,100,98,97,95,93,91,88,86,83,81,79,77,76,75,74,74,75,76,77,78,80,83,85,88,91,93,95,98,100,102,103,101,99,98,96,94,92,90,87,84,81,79,77,75,74,73,72,72,73,74,75,76,79,81,84,87,89,92,95,97,99,101,103,100,99,97,95,93,91,88,86,83,80,77,75,73,72,71,71,71,71,72,73,75,77,79,82,85,88,91,94,96,99,101,102,100,98,97,95,92,90,87,84,81,78,75,73,72,70,70,69,69,70,70,71,73,75,78,81,84,87,90,93,96,98,100,102,99,98,96,94,92,89,86,83,79,76,74,72,70,69,68,68,68,68,69,70,71,74,76,79,82,86,89,92,95,98,100,101,98,97,95,93,91,88,85,81,78,75,73,71,69,68,67,67,67,67,68,69,70,72,75,78,81,85,88,92,95,97,100,101,98,97,95,92,90,87,84,80,77,74,71,69,68,67,66,66,66,66,67,68,69,71,74,77,80,84,87,91,94,97,99,101,98,96,94,92,89,86,83,79,76,73,70,69,67,66,66,65,65,65,66,67,68,70,73,76,79,83,87,90,93,96,99,100,97,96,94,91,89,85,82,78,75,72,70,68,67,66,65,65,65,65,65,66,68,69,72,75,78,82,86,90,93,96,98,100,97,96,94,91,88,85,81,78,74,72,69,67,66,65,65,64,64,65,65,66,67,69,71,74,78,82,86,89,93,96,98,100,97,96,94,91,88,85,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,85,89,93,96,98,100,97,96,94,91,88,85,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,85,89,93,96,98,100,97,96,94,91,88,85,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,86,89,93,96,98,100,97,96,94,91,88,85,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,86,89,93,96,98,100,97,96,94,91,88,85,81,78,74,71,69,67,66,65,65,64,64,65,65,66,67,69,72,75,78,82,86,90,93,96,99,100,97,96,94,91,89,85,82,78,75,72,69,68,66,65,65,64,64,65,65,66,68,69,72,75,79,83,86,90,93,96,99,100,97,96,94,92,89,86,82,78,75,72,70,68,67,66,65,65,65,65,66,67,68,70,73,76,79,83,87,90,94,96,99,100,98,96,94,92,89,86,83,79,76,73,71,69,67,66,66,65,65,66,66,67,69,71,73,77,80,84,87,91,94,97,99,101,98,97,95,92,90,87,83,80,77,74,72,70,68,67,66,66,66,66,67,68,69,72,74,78,81,85,88,91,94,97,99,101,98,97,95,93,90,87,84,81,78,75,73,71,69,68,67,67,67,67,68,69,71,73,76,79,82,86,89,92,95,98,100,101,99,97,95,93,91,88,85,82,79,76,74,72,70,69,68,68,68,68,69,70,72,74,77,80,83,87,90,93,96,98,101,102,99,98,96,94,92,89,86,84,81,78,75,73,72,70,70,69,69,70,71,72,74,76,79,82,85,88,91,94,97,99,101,103,100,99,97,95,93,90,88,85,82,80,77,75,73,72,71,71,71,72,72,74,76,78,80,83,86,89,92,95,97,100,102,103,101,99,97,95,93,91,89,86,84,81,79,77,75,74,73,73,73,73,74,76,77,80,82,85,88,91,93,96,98,100,103,104,101,100,98,96,94,92,90,88,86,83,81,79,77,76,76,75,75,76,76,78,80,82,84,87,89,92,94,97,99,101,103,105,102,101,99,97,95,93,91,89,87,85,83,81,80,79,78,77,77,78,79,80,82,84,86,88,91,93,95,97,100,102,104,106,103,101,99,98,96,94,92,91,89,87,85,83,82,81,80,80,80,80,81,82,84,86,88,90,92,94,96,98,100,103,105,106,103,102,100,98,97,95,93,92,90,88,86,85,83,82,82,81,81,82,83,84,85,87,89,91,93,95,97,99,101,103,105,107};
+
+// CALIBRATION_SHADING_LS_TL84_B_WDR
+static uint8_t _calibration_shading_ls_tl84_b_wdr[ ]
+ = {97,95,92,90,89,87,85,84,82,80,79,77,76,75,74,73,73,73,74,75,76,77,79,81,83,85,87,89,91,94,96,98,95,93,91,89,87,85,84,82,80,79,77,76,74,73,72,72,72,72,72,73,75,76,78,79,81,84,86,88,90,92,95,97,94,92,89,87,86,84,82,80,79,77,75,74,72,71,70,70,70,70,71,72,73,74,76,78,80,82,84,86,88,91,93,95,93,91,88,86,85,83,81,79,77,76,74,72,71,70,69,69,68,69,69,70,71,73,75,77,79,81,83,85,88,90,92,94,92,90,88,86,84,82,80,78,76,74,73,71,70,69,68,67,67,68,68,69,70,72,74,76,78,80,82,85,87,89,92,94,91,89,87,85,83,81,79,77,75,73,71,70,68,67,67,67,67,67,67,68,69,71,73,75,77,79,81,84,86,89,91,93,91,89,86,84,82,80,78,76,74,72,70,69,67,67,66,66,66,66,67,67,68,70,72,74,76,78,81,83,86,88,90,92,90,88,86,84,81,79,77,75,73,71,69,68,67,66,65,65,65,65,66,67,68,69,71,73,75,77,80,82,85,87,90,92,90,88,85,83,81,78,76,74,72,70,68,67,66,65,65,65,65,65,65,66,67,68,70,72,74,76,79,82,84,87,89,91,89,87,84,82,80,78,75,73,71,69,67,66,65,65,65,64,64,65,65,65,66,67,69,71,73,76,78,81,84,86,89,91,88,86,84,81,79,77,74,72,70,68,67,66,65,64,64,64,64,64,65,65,66,67,68,70,72,75,78,80,83,86,88,90,88,86,83,81,79,76,74,71,69,67,66,65,64,64,64,64,64,64,64,65,65,66,68,70,72,74,77,80,83,85,88,90,88,86,83,80,78,76,73,71,69,67,66,65,64,64,64,64,64,64,64,64,65,66,67,69,72,74,77,79,82,85,88,89,88,85,83,80,78,76,73,71,68,67,65,65,64,64,64,64,64,64,64,64,65,66,67,69,71,74,76,79,82,85,87,89,88,85,83,80,78,75,73,70,68,67,65,65,64,64,64,64,64,64,64,64,65,66,67,69,71,74,76,79,82,85,87,89,88,86,83,80,78,75,73,70,68,67,65,65,64,64,64,64,64,64,64,65,65,66,67,69,71,74,77,79,82,85,88,89,88,86,83,80,78,75,73,70,68,67,66,65,64,64,64,64,64,64,64,65,65,66,67,69,71,74,77,80,82,85,88,90,88,86,83,80,78,75,73,71,68,67,66,65,65,64,64,64,64,64,64,65,65,66,67,69,72,74,77,80,83,85,88,90,88,86,83,80,78,75,73,71,69,67,66,65,65,64,64,64,64,64,64,65,65,66,67,69,72,75,77,80,83,86,88,90,88,86,83,81,78,76,73,71,69,67,66,65,65,65,64,64,64,64,64,65,65,66,68,70,72,75,78,80,83,86,89,90,88,86,83,81,79,76,74,71,69,67,66,66,65,65,65,64,64,64,65,65,65,67,68,70,73,75,78,81,84,86,89,91,89,86,84,82,79,77,74,72,70,68,67,66,65,65,65,65,65,65,65,65,66,67,69,71,73,76,78,81,84,87,89,91,89,87,84,82,80,77,75,73,71,69,67,66,66,65,65,65,65,65,65,66,66,68,69,72,74,76,79,82,85,87,90,92,90,88,85,83,80,78,76,74,71,70,68,67,66,66,66,65,65,66,66,66,67,69,70,72,75,77,80,83,85,88,91,92,90,88,86,83,81,79,77,75,73,71,69,68,67,67,66,66,66,66,67,67,68,70,71,74,76,78,81,83,86,89,91,93,91,89,86,84,82,80,78,76,74,72,70,69,68,67,67,67,67,67,68,68,70,71,73,75,77,79,82,84,87,89,92,94,92,90,87,85,83,81,79,77,75,73,72,70,69,68,68,68,68,68,69,70,71,72,74,76,78,80,83,85,88,90,93,95,93,91,88,86,84,82,80,78,76,75,73,72,70,70,69,69,69,69,70,71,72,74,76,77,79,81,84,86,88,91,93,95,94,92,89,87,85,83,81,79,78,76,74,73,72,71,70,70,70,70,71,72,74,75,77,79,81,83,85,87,89,91,94,96,95,92,90,88,86,84,82,80,79,77,76,74,73,72,72,71,71,72,72,74,75,77,78,80,82,84,86,88,90,92,94,96,96,93,91,89,87,85,83,82,80,78,77,76,75,74,73,73,73,73,74,75,76,78,80,82,83,85,87,89,91,93,95,97,96,94,92,90,88,86,84,83,81,79,78,77,76,75,74,74,74,74,75,76,77,79,81,82,84,86,88,90,91,93,95,97};
+
+// CALIBRATION_SHADING_LS_D65_R_WDR
+static uint8_t _calibration_shading_ls_d65_r_wdr[ ]
+ = {107,105,102,100,98,97,95,93,91,89,87,86,84,83,82,82,82,82,83,84,86,88,90,92,94,97,99,101,104,107,109,111,106,104,101,99,97,95,94,92,90,88,86,84,83,81,81,80,80,81,81,83,84,86,88,90,93,95,98,100,103,106,108,110,104,102,100,98,96,94,92,90,88,86,84,82,80,79,78,78,78,78,79,80,82,84,86,89,91,94,96,99,101,104,107,109,103,101,99,97,95,93,91,88,86,84,82,80,78,77,76,75,76,76,77,78,80,82,84,87,89,92,95,97,100,103,106,108,102,100,98,96,94,91,89,87,84,82,80,78,76,75,74,73,73,74,75,76,78,80,83,85,88,91,94,96,99,102,105,107,102,100,97,95,93,90,88,85,83,80,78,76,74,73,72,71,72,72,73,74,76,78,81,84,87,90,92,95,98,101,104,106,101,99,96,94,92,89,87,84,81,79,76,74,72,71,70,70,70,70,71,73,74,77,79,82,85,88,92,95,98,101,103,105,100,98,96,93,91,88,86,83,80,77,75,73,71,70,69,68,68,69,70,71,73,75,78,81,84,87,91,94,97,100,103,104,100,98,95,93,90,87,85,82,79,76,73,71,69,68,68,67,67,68,68,70,71,74,77,80,83,86,90,93,96,99,102,104,99,97,95,92,90,87,84,81,77,75,72,70,68,67,67,66,66,67,67,69,70,73,75,78,82,85,89,92,96,99,102,103,99,97,94,92,89,86,83,80,76,73,71,69,67,66,66,66,66,66,67,68,69,72,74,77,81,85,88,92,95,98,101,103,99,97,94,91,88,85,82,79,76,73,70,68,67,66,65,65,65,65,66,67,68,71,73,77,80,84,87,91,95,98,101,103,98,96,94,91,88,85,82,78,75,72,70,68,66,65,65,65,65,65,65,66,68,70,73,76,79,83,87,91,94,98,101,103,98,96,93,91,88,85,81,78,74,72,69,67,66,65,64,64,64,65,65,66,67,69,72,75,79,83,87,90,94,97,100,102,98,96,93,90,88,84,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,72,75,79,83,86,90,94,97,100,102,98,96,93,90,87,84,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,72,75,79,83,86,90,94,97,100,102,98,96,93,90,88,84,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,72,75,79,83,87,90,94,97,100,102,99,96,93,91,88,85,81,78,74,71,69,67,66,65,65,64,64,65,65,66,67,70,72,76,79,83,87,91,94,98,101,103,99,97,94,91,88,85,82,78,75,72,70,68,66,65,65,65,65,65,66,66,68,70,73,76,80,84,88,91,95,98,101,103,99,97,94,91,89,86,82,79,76,73,70,68,67,66,65,65,65,65,66,67,69,71,74,77,81,84,88,92,95,99,101,103,100,98,95,92,90,86,83,80,77,74,71,69,68,67,66,66,66,66,67,68,69,72,75,78,81,85,89,93,96,99,102,104,100,98,96,93,90,87,84,81,78,75,72,70,68,67,67,66,66,67,67,69,70,73,76,79,82,86,90,93,97,100,103,104,101,99,96,94,91,88,85,82,79,76,73,71,69,68,67,67,67,68,68,70,71,74,77,80,83,87,91,94,97,100,103,105,101,99,97,94,91,89,86,83,80,77,75,72,71,69,69,68,68,69,69,71,73,75,78,81,85,88,92,95,98,101,104,106,102,100,97,95,92,90,87,84,81,78,76,74,72,71,70,69,69,70,71,72,74,77,80,83,86,89,93,96,99,102,105,107,102,100,98,95,93,91,88,85,83,80,77,75,74,72,71,71,71,71,73,74,76,78,81,84,87,91,94,97,100,103,106,107,103,101,99,96,94,92,89,87,84,81,79,77,75,74,73,73,73,73,74,76,78,80,83,86,89,92,95,98,101,104,106,108,104,102,100,97,95,93,91,88,86,83,81,79,77,76,75,75,75,75,76,78,80,82,85,88,91,93,96,99,102,105,107,109,105,103,101,98,96,94,92,90,87,85,83,81,79,78,77,77,77,77,78,80,82,84,87,90,92,95,98,100,103,106,108,110,106,104,102,99,97,95,93,91,89,87,85,83,81,80,79,79,79,79,81,82,84,86,89,91,94,97,99,102,104,107,109,111,107,105,102,100,98,97,95,93,91,89,87,85,83,82,81,81,81,81,82,84,86,88,90,93,95,98,101,103,105,108,110,112,107,105,103,101,99,97,96,94,92,90,88,86,85,83,83,82,82,83,84,85,87,89,92,94,97,99,101,104,106,108,111,113};
+
+// CALIBRATION_SHADING_LS_D65_G_WDR
+static uint8_t _calibration_shading_ls_d65_g_wdr[ ]
+ = {102,101,100,98,97,96,94,93,91,90,88,87,85,84,84,83,83,83,84,85,86,88,89,91,93,94,96,98,100,102,104,105,101,100,99,97,96,95,93,92,90,88,87,85,84,83,82,81,81,82,82,83,85,86,88,90,91,93,95,97,99,101,103,104,100,99,98,97,95,94,92,90,88,86,85,83,81,80,79,79,79,79,80,81,82,84,86,88,90,92,94,96,98,100,102,103,100,99,98,96,95,93,91,89,87,85,83,81,79,78,77,77,77,77,78,79,80,82,84,86,89,91,93,95,97,99,101,103,99,98,97,95,94,92,90,88,85,83,81,79,77,76,75,74,74,75,76,77,78,80,82,85,87,90,92,94,96,99,101,102,99,98,96,95,93,91,89,86,84,81,79,77,75,74,73,72,72,73,73,75,76,78,81,83,86,88,91,93,96,98,100,101,98,97,96,94,92,90,87,85,82,79,77,75,73,72,71,70,70,71,72,73,74,77,79,82,84,87,90,93,95,97,100,101,98,97,95,94,92,89,86,83,81,78,75,73,71,70,69,69,69,69,70,71,73,75,77,80,83,86,89,92,95,97,99,100,97,96,95,93,91,88,85,82,79,76,74,72,70,69,68,68,68,68,69,70,71,73,76,79,82,85,88,91,94,97,99,100,97,96,94,93,90,87,84,81,78,75,73,70,69,68,67,67,67,67,68,69,70,72,75,78,81,84,88,91,94,96,99,100,97,96,94,92,90,87,84,80,77,74,72,69,68,67,66,66,66,66,67,68,69,71,74,77,80,84,87,90,93,96,98,100,96,95,94,92,89,86,83,79,76,73,71,69,67,66,66,65,65,66,66,67,68,70,73,76,79,83,86,90,93,96,98,99,96,95,93,91,88,85,82,79,75,72,70,68,67,66,65,65,65,65,66,66,68,70,72,75,79,82,86,89,93,95,98,99,96,95,93,91,88,85,82,78,75,72,69,68,66,65,65,64,64,65,65,66,67,69,72,75,78,82,86,89,92,95,97,99,96,95,93,91,88,85,81,78,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,85,89,92,95,97,99,96,95,93,90,88,84,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,81,85,89,92,95,97,99,96,95,93,90,88,84,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,85,89,92,95,97,99,96,95,93,90,88,84,81,77,74,71,69,67,66,65,64,64,64,64,65,66,67,69,71,74,78,82,85,89,92,95,97,99,96,95,93,91,88,85,81,78,74,71,69,67,66,65,65,64,64,65,65,66,67,69,72,75,78,82,86,89,92,95,98,99,96,95,93,91,88,85,82,78,75,72,69,68,66,65,65,65,65,65,65,66,68,69,72,75,79,83,86,90,93,96,98,99,96,95,93,91,89,86,82,79,75,72,70,68,67,66,65,65,65,65,66,67,68,70,73,76,79,83,87,90,93,96,98,100,97,95,94,92,89,86,83,79,76,73,71,69,67,66,66,65,65,66,66,67,69,71,74,77,80,84,87,91,93,96,98,100,97,96,94,92,89,86,83,80,77,74,72,70,68,67,66,66,66,66,67,68,70,72,75,78,81,84,88,91,94,96,99,100,97,96,94,92,90,87,84,81,78,75,73,71,69,68,67,67,67,67,68,69,71,73,76,79,82,85,89,92,94,97,99,100,97,96,95,93,90,88,85,82,79,76,74,72,70,69,68,68,68,68,69,70,72,74,77,80,83,86,89,92,95,97,99,101,98,97,95,93,91,89,86,83,80,78,75,73,72,70,70,69,69,70,70,72,74,76,78,81,84,87,90,93,96,98,100,101,98,97,95,94,92,89,87,84,82,79,77,75,73,72,71,71,71,71,72,74,75,78,80,83,86,88,91,94,96,98,100,102,99,98,96,94,93,90,88,86,83,81,79,77,75,74,73,73,73,73,74,76,77,79,82,84,87,90,92,95,97,99,101,102,99,98,97,95,93,91,89,87,85,83,81,79,77,76,75,75,75,76,76,78,79,81,83,86,88,91,93,95,97,100,102,103,100,99,97,96,94,92,90,89,86,84,83,81,80,78,78,77,77,78,79,80,81,83,85,87,90,92,94,96,98,100,102,104,101,100,98,97,95,93,92,90,88,86,85,83,82,81,80,80,80,80,81,82,83,85,87,89,91,93,95,97,99,101,103,105,102,100,99,97,96,94,93,91,89,87,86,84,83,82,82,81,81,82,82,83,85,86,88,90,92,94,96,98,100,102,104,106};
+
+// CALIBRATION_SHADING_LS_D65_B_WDR
+static uint8_t _calibration_shading_ls_d65_b_wdr[ ]
+ = {98,96,94,92,90,89,87,86,84,83,81,80,78,77,76,76,76,76,77,78,79,80,82,83,85,87,89,91,93,96,98,100,96,94,92,90,89,87,86,84,83,81,79,78,77,75,75,74,74,74,75,76,77,79,80,82,84,86,88,90,92,95,97,99,95,93,91,89,87,86,84,83,81,79,77,76,74,73,72,72,72,72,73,74,75,77,78,80,82,84,86,88,91,93,96,97,94,92,90,88,86,85,83,81,79,78,76,74,73,71,71,70,70,70,71,72,73,75,77,79,81,83,85,87,90,92,94,96,93,91,89,87,86,84,82,80,78,76,74,72,71,70,69,69,68,69,70,71,72,74,76,78,80,82,84,86,89,91,93,95,92,90,88,86,85,83,81,79,77,75,73,71,69,68,68,67,67,68,68,69,71,72,74,76,79,81,83,86,88,90,93,94,92,90,88,86,84,82,80,78,76,73,71,69,68,67,67,66,66,67,67,68,69,71,73,75,78,80,82,85,87,90,92,94,91,89,87,85,83,81,79,77,74,72,70,68,67,66,66,66,66,66,66,67,68,70,72,74,77,79,82,84,87,89,92,93,91,89,87,85,83,81,78,76,73,71,69,68,66,66,65,65,65,65,66,66,68,69,71,73,76,78,81,84,86,89,91,93,90,89,86,84,82,80,77,75,72,70,68,67,66,65,65,65,65,65,65,66,67,68,70,72,75,78,81,83,86,89,91,92,90,88,86,84,82,79,77,74,71,69,67,66,65,65,65,65,65,65,65,66,66,68,69,72,74,77,80,83,86,88,91,92,90,88,86,83,81,79,76,73,71,68,67,66,65,65,64,64,64,65,65,65,66,67,69,71,74,77,79,82,85,88,90,92,89,88,85,83,81,78,75,73,70,68,66,65,65,64,64,64,64,64,65,65,66,67,68,71,73,76,79,82,85,88,90,92,89,87,85,83,80,78,75,72,70,68,66,65,65,64,64,64,64,64,65,65,66,67,68,70,73,76,79,82,85,87,90,91,89,87,85,82,80,77,75,72,69,67,66,65,64,64,64,64,64,64,64,65,65,66,68,70,73,76,79,82,84,87,90,91,89,87,84,82,80,77,74,72,69,67,66,65,64,64,64,64,64,64,64,65,65,66,68,70,73,76,79,82,84,87,90,91,89,87,85,82,80,77,74,72,69,67,66,65,65,64,64,64,64,64,64,65,65,66,68,70,73,76,79,82,84,87,90,92,89,87,85,82,80,77,74,72,69,67,66,65,65,64,64,64,64,64,65,65,65,66,68,70,73,76,79,82,85,88,90,92,89,87,85,83,80,78,75,72,70,68,66,65,65,65,64,64,64,64,65,65,66,67,68,71,73,76,79,82,85,88,90,92,90,88,85,83,81,78,75,73,70,68,67,66,65,65,65,65,65,65,65,65,66,67,69,71,74,77,80,83,86,88,91,92,90,88,86,84,81,79,76,73,71,69,67,66,66,65,65,65,65,65,65,66,66,67,69,72,74,77,80,83,86,89,91,93,90,88,86,84,82,79,76,74,71,69,68,67,66,66,65,65,65,65,65,66,67,68,70,72,75,78,81,84,87,89,91,93,91,89,86,84,82,80,77,75,72,70,68,67,66,66,66,66,66,66,66,66,67,69,71,73,76,79,82,84,87,90,92,94,91,89,87,85,82,80,78,75,73,71,69,68,67,66,66,66,66,66,66,67,68,70,72,74,77,79,82,85,88,90,92,94,92,90,87,85,83,81,79,76,74,72,70,69,68,67,66,66,66,67,67,68,69,71,73,75,78,80,83,86,88,91,93,95,92,90,88,86,84,82,80,77,75,73,71,70,68,68,67,67,67,68,68,69,70,72,74,76,79,81,84,86,89,91,94,95,93,91,88,86,85,83,81,79,77,75,73,71,70,69,68,68,68,69,69,70,72,74,76,78,80,82,85,87,89,92,94,96,94,92,89,87,86,84,82,80,78,76,74,73,71,70,70,70,70,70,71,72,74,75,77,79,81,83,86,88,90,92,95,97,95,93,90,88,86,85,83,81,79,78,76,74,73,72,71,71,71,72,72,74,75,77,79,81,83,85,87,89,91,93,95,97,96,94,91,89,87,86,84,82,81,79,78,76,75,74,73,73,73,73,74,75,77,79,80,82,84,86,88,90,92,94,96,98,97,95,92,90,88,87,85,84,82,81,79,78,77,76,75,75,75,75,76,77,78,80,82,84,86,87,89,91,93,95,97,98,97,95,93,91,89,87,86,85,83,82,80,79,78,77,76,76,76,76,77,78,79,81,83,85,86,88,90,92,93,95,97,99};
+
+// R G B
+static uint16_t _calibration_awb_warming_ls_a[ ]
+ = {256,256,256};
+
+// R G B
+static uint16_t _calibration_awb_warming_ls_d40[ ]
+ = {256,256,256};
+
+// R G B
+static uint16_t _calibration_awb_warming_ls_d50[ ]
+ = {256,256,256};
+
+// CALIBRATION_NOISE_PROFILE_LINEAR
+static uint8_t _calibration_noise_profile_linear[ ]
+ = {0,0,3,12,17,21,23,26,27,29,30,31,33,34,35,35,36,37,38,38,39,39,40,41,41,42,42,42,43,43,44,44,44,45,45,46,46,46,46,47,47,47,48,48,48,48,49,49,49,49,50,50,50,50,51,51,51,51,51,52,52,52,52,52,53,53,53,53,53,53,54,54,54,54,54,54,55,55,55,55,55,55,56,56,56,56,56,56,56,56,57,57,57,57,57,57,57,57,58,58,58,58,58,58,58,58,59,59,59,59,59,59,59,59,59,59,60,60,60,60,60,60,60,60,60,60,61,61};
+
+// CALIBRATION_DEMOSAIC_LINEAR
+static uint8_t _calibration_demosaic_linear[ ]
+ = {3,12,17,21,23,26,27,29,30,31,33,34,35,35,36,37,38,38,39,39,40,41,41,42,42,42,43,43,44,44,44,45,45,46,46,46,46,47,47,47,48,48,48,48,49,49,49,49,50,50,50,50,51,51,51,51,51,52,52,52,52,52,53,53,53,53,53,53,54,54,54,54,54,54,55,55,55,55,55,55,56,56,56,56,56,56,56,56,57,57,57,57,57,57,57,57,58,58,58,58,58,58,58,58,59,59,59,59,59,59,59,59,59,59,60,60,60,60,60,60,60,60,60,60,61,61,61,61};
+
+// CALIBRATION_NOISE_PROFILE_FS_HDR
+static uint8_t _calibration_noise_profile_fs_hdr[ ]
+ = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,49};
+
+// CALIBRATION_DEMOSAIC_FS_HDR
+static uint8_t _calibration_demosaic_fs_hdr[ ]
+ = {3,12,17,20,23,25,27,28,30,31,32,33,34,35,35,37,37,38,38,39,40,40,41,41,42,42,43,43,43,44,44,44,45,45,46,46,46,46,47,47,47,48,48,48,48,49,49,49,49,50,50,50,50,50,51,51,51,51,52,52,52,52,52,52,53,53,53,53,53,53,54,54,54,54,54,54,55,55,55,55,55,55,55,56,56,56,56,56,56,56,56,57,57,57,57,57,57,57,57,58,58,58,58,58,58,58,58,58,59,59,59,59,59,59,59,59,59,59,60,60,60,60,60,60,60,60,60,60};
+
+// CALIBRATION_GAMMA_FE_0_FS_HDR
+static uint16_t _calibration_gamma_fe_0_fs_hdr[ ]
+ = {0,32768,33825,34882,35939,36996,38053,39110,40167,41224,42281,43338,44395,45452,46509,47566,48623,49681,50738,51795,52852,53909,54966,56023,57080,58137,59194,60251,61308,62365,63422,64479,65535};
+
+// CALIBRATION_GAMMA_FE_1_FS_HDR
+static uint16_t _calibration_gamma_fe_1_fs_hdr[ ]
+ = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,151,310,477,656,848,1057,1287,1549,1860,2265,3243,4221,4626,4937,5199,5430,5638,5830,6009,6177,6335,6486,6631,6769,6902,7030,7155,7275,7392,7506,7616,7724,7830,7933,8034,8133,8229,8324,8418,8509,8599,8688,8775,8861,8945,9028,9110,9191,9271,9350,9428,9505,9580,9655,9730,9803,9875,9947,10018,10088,10158,10227,10295,10362,10429,10495,10561,10626,10690,10754,10818,10881,10943,11005,11066,11127,11187,11247,11307,11366,11425,11483,11541,11598,11655,11712,11768,11824,11879,11935,11989,12044,12098,12152,12205,12259,12312,12364,12416,12468,12520,14000,15299,16471,17548,18549,19489,20377,21221,22027,22800,23544,24262,24955,25628,26280,26915,27533,28136,28724,29299,29862,30413,30953,31483,32003,32514,33016,33510,33995,34474,34945,35409,35866,36318,36764,37203,37637,38065,38488,38906,39319,39728,40132,40531,40927,41318,41705,42089,42468,42844,43217,43586,43952,44314,44673,45030,45383,45733,46081,46425,46767,47106,47442,47776,48108,48436,48763,49088,49410,49730,50047,50363,50677,50988,51297,51605,51910,52214,52516,52816,53114,53410,53705,53997,54289,54578,54866,55152,55437,55720,56002,56282,56561,56838,57115,57389,57662,57934,58204,58473,58741,59007,59272,59536,59799,60060,60321,60580,60838,61094,61350,61605,61858,62110,62361,62612,62861,63109,63356,63602,63847,64091,64334,64576,64818,65058,65298,65535};
+
+// CALIBRATION_BLACK_LEVEL_R_FS_HDR
+static uint16_t _calibration_black_level_r_fs_hdr[ ][2] =  {
+  { 0, 202 },
+  { 16, 202 },
+  { 32, 211 },
+  { 48, 219 },
+  { 80, 249 },
+  { 144, 314 }
+
+};
+
+// CALIBRATION_BLACK_LEVEL_GR_FS_HDR
+static uint16_t _calibration_black_level_gr_fs_hdr[ ][2]
+ =  {
+  { 0, 202 },
+  { 16, 202 },
+  { 32, 211 },
+  { 48, 219 },
+  { 80, 249 },
+  { 144, 314 }
+};
+
+// CALIBRATION_BLACK_LEVEL_GB_FS_HDR
+static uint16_t _calibration_black_level_gb_fs_hdr[ ][2]
+ =  {
+  { 0, 202 },
+  { 16, 202 },
+  { 32, 211 },
+  { 48, 219 },
+  { 80, 249 },
+  { 144, 314 }
+};
+
+// CALIBRATION_BLACK_LEVEL_B_FS_HDR
+static uint16_t _calibration_black_level_b_fs_hdr[ ][2]
+ =  {
+  { 0, 202 },
+  { 16, 202 },
+  { 32, 211 },
+  { 48, 219 },
+  { 80, 249 },
+  { 144, 314 }
+};
+
+// CALIBRATION_GAMMA_LINEAR
+static uint16_t _calibration_gamma_linear[ ]
+ = {0,54,158,259,356,450,540,628,713,795,874,951,1026,1098,1168,1236,1303,1367,1429,1490,1549,1607,1663,1717,1770,1822,1873,1922,1970,2017,2060,2105,2148,2191,2233,2273,2313,2352,2390,2427,2463,2499,2534,2568,2601,2634,2666,2698,2729,2759,2788,2817,2846,2874,2901,2928,2955,2981,3006,3031,3056,3080,3104,3127,3150,3173,3195,3217,3238,3260,3280,3301,3321,3341,3360,3379,3398,3417,3435,3453,3471,3488,3506,3523,3539,3556,3572,3588,3604,3619,3635,3650,3665,3680,3694,3709,3723,3737,3750,3764,3777,3791,3804,3817,3829,3842,3854,3867,3879,3891,3903,3914,3926,3937,3948,3960,3971,3981,3992,4003,4013,4024,4034,4044,4054,4064,4074,4083,4095};
+
+/* liner bt 709 */
+/* = {0, 144, 289, 426, 541, 641, 730, 812, 887, 957, 1024, 1086, 1146, 1203, 1257, 1310, 1360, 1409, 1456, 1502, 1547, 1590, 1632, 1673, 1714, 1753, 1791, 1829, 1866, 1902, 1938, 1972, 2007, 2040, 2073, 2106, 2138, 2169, 2200, 2231, 2261, 2291, 2321, 2350, 2378, 2406, 2434, 2462, 2489, 2516, 2543, 2569, 2596, 2621, 2647, 2672, 2697, 2722, 2747, 2771, 2795, 2819, 2843, 2866, 2889, 2913, 2935, 2958, 2981, 3003, 3025, 3047, 3069, 3090, 3112, 3133, 3154, 3175, 3196, 3217, 3237, 3258, 3278, 3298, 3318, 3338, 3358, 3378, 3397, 3417, 3436, 3455, 3474, 3493, 3512, 3530, 3549, 3567, 3586, 3604, 3622, 3640, 3658, 3676, 3694, 3712, 3729, 3747, 3764, 3782, 3799, 3816, 3833, 3850, 3867, 3884, 3900, 3917, 3934, 3950, 3967, 3983, 3999, 4016, 4032, 4048, 4064, 4080, 4095}; */
+
+
+// CALIBRATION_GAMMA_FS_HDR
+static uint16_t _calibration_gamma_fs_hdr[ ]
+ = {0,1,2,5,7,12,17,23,30,38,47,57,70,86,102,121,140,160,180,203,223,243,263,286,311,338,364,392,420,449,478,509,540,573,606,640,675,710,746,784,822,861,901,942,982,1024,1067,1111,1155,1201,1247,1294,1342,1392,1442,1493,1544,1595,1647,1700,1753,1806,1859,1914,1970,2027,2083,2139,2193,2252,2304,2356,2405,2452,2498,2545,2592,2640,2688,2737,2787,2836,2875,2911,2946,2980,3014,3048,3080,3114,3146,3178,3210,3241,3272,3302,3332,3361,3390,3419,3447,3475,3502,3530,3557,3583,3609,3634,3660,3685,3710,3734,3758,3781,3804,3828,3850,3873,3895,3916,3937,3959,3979,3999,4020,4040,4060,4079,4095};
+
+// CALIBRATION_IRIDIX_RGB2REC709
+static uint16_t _calibration_iridix_rgb2rec709[ ]
+ = {0,2529,5697,8642,11411,13987,16420,18692,20853,22869,24790,26614,28326,29975,31527,32968,34376,35736,37016,38249,39417,40553,41626,42666,43674,44618,45546,46427,47291,48107,48907,49675,50412,51132,51820,52492,53148,53772,54380,54973,55549,56109,56637,57165,57677,58173,58653,59118,59582,60014,60446,60878,61278,61678,62078,62462,62830,63182,63551,63887,64223,64559,64879,65199,65535};
+
+// CALIBRATION_IRIDIX_REC709TORGB
+static uint16_t _calibration_iridix_rec709torgb[ ]
+ = {0,561,876,1196,1520,1858,2200,2549,2912,3281,3655,4041,4438,4847,5265,5692,6129,6583,7049,7527,8014,8518,9040,9574,10124,10687,11270,11878,12501,13137,13799,14484,15212,15950,16711,17491,18310,19152,20031,20941,21887,22876,23894,24958,26083,27237,28451,29723,31046,32440,33891,35411,37024,38729,40511,42381,44390,46495,48719,51127,53647,56325,59210,62314,65535};
+
+// CALIBRATION_IRIDIX_ASYMMETRY
+static uint16_t _calibration_iridix_asymmetry[ ]
+ = {0,9937,18288,23899,28319,31918,34922,37479,39689,41625,43341,44880,46274,47548,48725,49821,50852,51831,52768,53673,54555,55422,56279,57134,57992,58858,59738,60636,61555,62502,63477,64487,65535};
+
+// CALIBRATION_DEFECT_PIXELS
+static  uint32_t _calibration_defect_pixels[ ]
+ =  {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+  } ;
+// CALIBRATION_CT40POS
+static uint32_t _calibration_black_level_fs[ ]
+=  { 3856 } ;
+// calibration_awb_scene_presets in the following order AWB_DAY_LIGHT AWB_CLOUDY AWB_INCANDESCENT AWB_FLOURESCENT AWB_TWILIGHT AWB_SHADE AWB_WARM_FLOURESCENT
+ static const uint16_t _calibration_awb_scene_presets[ 7 ][ 2 ]
+= {
+  { 256, 257 },
+  { 293, 202 },
+  { 147, 461 },
+  { 210, 307 },
+  { 210, 307 },
+  { 313, 187 },
+  { 160, 376 },
+  } ;
+
+
+static LookupTable  calibration_awb_scene_presets =  { .ptr = _calibration_awb_scene_presets, .cols = 2, .rows = sizeof(_calibration_awb_scene_presets) / sizeof(_calibration_awb_scene_presets[ 0 ]), .width = sizeof(_calibration_awb_scene_presets[ 0 ][ 0 ] )  } ; 
+static LookupTable  calibration_black_level_fs =  { .ptr = _calibration_black_level_fs, .rows = 1, .cols = sizeof(_calibration_black_level_fs) / sizeof(_calibration_black_level_fs[ 0 ]), .width = sizeof(_calibration_black_level_fs[ 0 ] ) } ;
+static LookupTable  calibration_defect_pixels =  { .ptr = _calibration_defect_pixels, .rows = 1, .cols = sizeof(_calibration_defect_pixels) / sizeof(_calibration_defect_pixels[ 0 ]), .width = sizeof(_calibration_defect_pixels[ 0 ] ) } ;
+static LookupTable calibration_light_src = { .ptr = _calibration_light_src, .cols = 2, .rows = sizeof(_calibration_light_src) / sizeof(_calibration_light_src[0]), .width = sizeof(_calibration_light_src[0][0] ) };
+static LookupTable calibration_rg_pos = { .ptr = _calibration_rg_pos, .rows = 1, .cols = sizeof(_calibration_rg_pos) / sizeof(_calibration_rg_pos[0]), .width = sizeof(_calibration_rg_pos[0] ) };
+static LookupTable calibration_bg_pos = { .ptr = _calibration_bg_pos, .rows = 1, .cols = sizeof(_calibration_bg_pos) / sizeof(_calibration_bg_pos[0]), .width = sizeof(_calibration_bg_pos[0] ) };
+static LookupTable calibration_mesh_rgbg_weight = { .ptr = _calibration_mesh_rgbg_weight, .cols = 15, .rows = sizeof(_calibration_mesh_rgbg_weight) / sizeof(_calibration_mesh_rgbg_weight[0]), .width = sizeof(_calibration_mesh_rgbg_weight[0][0] ) };
+static LookupTable calibration_mesh_ls_weight = { .ptr = _calibration_mesh_ls_weight, .cols = 15, .rows = sizeof(_calibration_mesh_ls_weight) / sizeof(_calibration_mesh_ls_weight[0]), .width = sizeof(_calibration_mesh_ls_weight[0][0] ) };
+static LookupTable calibration_mesh_color_temperature = { .ptr = _calibration_mesh_color_temperature, .cols = 15, .rows = sizeof(_calibration_mesh_color_temperature) / sizeof(_calibration_mesh_color_temperature[0]), .width = sizeof(_calibration_mesh_color_temperature[0][0] ) };
+static LookupTable calibration_luxlow_lut_min = { .ptr = _calibration_luxlow_lut_min, .rows = 1, .cols = sizeof(_calibration_luxlow_lut_min) / sizeof(_calibration_luxlow_lut_min[0]), .width = sizeof(_calibration_luxlow_lut_min[0] ) };
+static LookupTable calibration_luxlow_lut_max = { .ptr = _calibration_luxlow_lut_max, .rows = 1, .cols = sizeof(_calibration_luxlow_lut_max) / sizeof(_calibration_luxlow_lut_max[0]), .width = sizeof(_calibration_luxlow_lut_max[0] ) };
+static LookupTable calibration_luxlow_lut_step = { .ptr = _calibration_luxlow_lut_step, .rows = 1, .cols = sizeof(_calibration_luxlow_lut_step) / sizeof(_calibration_luxlow_lut_step[0]), .width = sizeof(_calibration_luxlow_lut_step[0] ) };
+static LookupTable calibration_luxlow_lut = { .ptr = _calibration_luxlow_lut, .rows = 1, .cols = sizeof(_calibration_luxlow_lut) / sizeof(_calibration_luxlow_lut[0]), .width = sizeof(_calibration_luxlow_lut[0] ) };
+static LookupTable calibration_luxhigh_lut_min = { .ptr = _calibration_luxhigh_lut_min, .rows = 1, .cols = sizeof(_calibration_luxhigh_lut_min) / sizeof(_calibration_luxhigh_lut_min[0]), .width = sizeof(_calibration_luxhigh_lut_min[0] ) };
+static LookupTable calibration_luxhigh_lut_max = { .ptr = _calibration_luxhigh_lut_max, .rows = 1, .cols = sizeof(_calibration_luxhigh_lut_max) / sizeof(_calibration_luxhigh_lut_max[0]), .width = sizeof(_calibration_luxhigh_lut_max[0] ) };
+static LookupTable calibration_luxhigh_lut_step = { .ptr = _calibration_luxhigh_lut_step, .rows = 1, .cols = sizeof(_calibration_luxhigh_lut_step) / sizeof(_calibration_luxhigh_lut_step[0]), .width = sizeof(_calibration_luxhigh_lut_step[0] ) };
+static LookupTable calibration_luxhigh_lut = { .ptr = _calibration_luxhigh_lut, .rows = 1, .cols = sizeof(_calibration_luxhigh_lut) / sizeof(_calibration_luxhigh_lut[0]), .width = sizeof(_calibration_luxhigh_lut[0] ) };
+static LookupTable calibration_rglow_lut_min = { .ptr = _calibration_rglow_lut_min, .rows = 1, .cols = sizeof(_calibration_rglow_lut_min) / sizeof(_calibration_rglow_lut_min[0]), .width = sizeof(_calibration_rglow_lut_min[0] ) };
+static LookupTable calibration_rglow_lut_max = { .ptr = _calibration_rglow_lut_max, .rows = 1, .cols = sizeof(_calibration_rglow_lut_max) / sizeof(_calibration_rglow_lut_max[0]), .width = sizeof(_calibration_rglow_lut_max[0] ) };
+static LookupTable calibration_rglow_lut_step = { .ptr = _calibration_rglow_lut_step, .rows = 1, .cols = sizeof(_calibration_rglow_lut_step) / sizeof(_calibration_rglow_lut_step[0]), .width = sizeof(_calibration_rglow_lut_step[0] ) };
+static LookupTable calibration_rglow_lut = { .ptr = _calibration_rglow_lut, .rows = 1, .cols = sizeof(_calibration_rglow_lut) / sizeof(_calibration_rglow_lut[0]), .width = sizeof(_calibration_rglow_lut[0] ) };
+static LookupTable calibration_rghigh_lut_min = { .ptr = _calibration_rghigh_lut_min, .rows = 1, .cols = sizeof(_calibration_rghigh_lut_min) / sizeof(_calibration_rghigh_lut_min[0]), .width = sizeof(_calibration_rghigh_lut_min[0] ) };
+static LookupTable calibration_rghigh_lut_max = { .ptr = _calibration_rghigh_lut_max, .rows = 1, .cols = sizeof(_calibration_rghigh_lut_max) / sizeof(_calibration_rghigh_lut_max[0]), .width = sizeof(_calibration_rghigh_lut_max[0] ) };
+static LookupTable calibration_rghigh_lut_step = { .ptr = _calibration_rghigh_lut_step, .rows = 1, .cols = sizeof(_calibration_rghigh_lut_step) / sizeof(_calibration_rghigh_lut_step[0]), .width = sizeof(_calibration_rghigh_lut_step[0] ) };
+static LookupTable calibration_rghigh_lut = { .ptr = _calibration_rghigh_lut, .rows = 1, .cols = sizeof(_calibration_rghigh_lut) / sizeof(_calibration_rghigh_lut[0]), .width = sizeof(_calibration_rghigh_lut[0] ) };
+static LookupTable calibration_wb_strength = { .ptr = _calibration_wb_strength, .rows = 1, .cols = sizeof(_calibration_wb_strength) / sizeof(_calibration_wb_strength[0]), .width = sizeof(_calibration_wb_strength[0] ) };
+static LookupTable calibration_sky_lux_th = { .ptr = _calibration_sky_lux_th, .rows = 1, .cols = sizeof(_calibration_sky_lux_th) / sizeof(_calibration_sky_lux_th[0]), .width = sizeof(_calibration_sky_lux_th[0] ) };
+static LookupTable calibration_ct_rg_pos_calc = { .ptr = _calibration_ct_rg_pos_calc, .rows = 1, .cols = sizeof(_calibration_ct_rg_pos_calc) / sizeof(_calibration_ct_rg_pos_calc[0]), .width = sizeof(_calibration_ct_rg_pos_calc[0] ) };
+static LookupTable calibration_ct_bg_pos_calc = { .ptr = _calibration_ct_bg_pos_calc, .rows = 1, .cols = sizeof(_calibration_ct_bg_pos_calc) / sizeof(_calibration_ct_bg_pos_calc[0]), .width = sizeof(_calibration_ct_bg_pos_calc[0] ) };
+static LookupTable calibration_color_temp = { .ptr = _calibration_color_temp, .rows = 1, .cols = sizeof(_calibration_color_temp) / sizeof(_calibration_color_temp[0]), .width = sizeof(_calibration_color_temp[0] ) };
+static LookupTable calibration_ct65pos = { .ptr = _calibration_ct65pos, .rows = 1, .cols = sizeof(_calibration_ct65pos) / sizeof(_calibration_ct65pos[0]), .width = sizeof(_calibration_ct65pos[0] ) };
+static LookupTable calibration_ct40pos = { .ptr = _calibration_ct40pos, .rows = 1, .cols = sizeof(_calibration_ct40pos) / sizeof(_calibration_ct40pos[0]), .width = sizeof(_calibration_ct40pos[0] ) };
+static LookupTable calibration_ct30pos = { .ptr = _calibration_ct30pos, .rows = 1, .cols = sizeof(_calibration_ct30pos) / sizeof(_calibration_ct30pos[0]), .width = sizeof(_calibration_ct30pos[0] ) };
+static LookupTable calibration_evtolux_ev_lut_linear = { .ptr = _calibration_evtolux_ev_lut_linear, .rows = 1, .cols = sizeof(_calibration_evtolux_ev_lut_linear) / sizeof(_calibration_evtolux_ev_lut_linear[0]), .width = sizeof(_calibration_evtolux_ev_lut_linear[0] ) };
+static LookupTable calibration_evtolux_ev_lut_fs_hdr = { .ptr = _calibration_evtolux_ev_lut_fs_hdr, .rows = 1, .cols = sizeof(_calibration_evtolux_ev_lut_fs_hdr) / sizeof(_calibration_evtolux_ev_lut_fs_hdr[0]), .width = sizeof(_calibration_evtolux_ev_lut_fs_hdr[0] ) };
+static LookupTable calibration_evtolux_lux_lut = { .ptr = _calibration_evtolux_lux_lut, .rows = 1, .cols = sizeof(_calibration_evtolux_lux_lut) / sizeof(_calibration_evtolux_lux_lut[0]), .width = sizeof(_calibration_evtolux_lux_lut[0] ) };
+static LookupTable calibration_black_level_r_linear = { .ptr = _calibration_black_level_r_linear, .cols = 2, .rows = sizeof(_calibration_black_level_r_linear) / sizeof(_calibration_black_level_r_linear[0]), .width = sizeof(_calibration_black_level_r_linear[0][0] ) };
+static LookupTable calibration_black_level_gr_linear = { .ptr = _calibration_black_level_gr_linear, .cols = 2, .rows = sizeof(_calibration_black_level_gr_linear) / sizeof(_calibration_black_level_gr_linear[0]), .width = sizeof(_calibration_black_level_gr_linear[0][0] ) };
+static LookupTable calibration_black_level_gb_linear = { .ptr = _calibration_black_level_gb_linear, .cols = 2, .rows = sizeof(_calibration_black_level_gb_linear) / sizeof(_calibration_black_level_gb_linear[0]), .width = sizeof(_calibration_black_level_gb_linear[0][0] ) };
+static LookupTable calibration_black_level_b_linear = { .ptr = _calibration_black_level_b_linear, .cols = 2, .rows = sizeof(_calibration_black_level_b_linear) / sizeof(_calibration_black_level_b_linear[0]), .width = sizeof(_calibration_black_level_b_linear[0][0] ) };
+static LookupTable calibration_static_wb = { .ptr = _calibration_static_wb, .rows = 1, .cols = sizeof(_calibration_static_wb) / sizeof(_calibration_static_wb[0]), .width = sizeof(_calibration_static_wb[0] ) };
+static LookupTable calibration_auto_wb = { .ptr = _calibration_auto_wb, .rows = 1, .cols = sizeof(_calibration_auto_wb) / sizeof(_calibration_auto_wb[0]), .width = sizeof(_calibration_auto_wb[0] ) };
+static LookupTable calibration_skin_tone_ccm = { .ptr = _calibration_skin_tone_ccm, .rows = 1, .cols = sizeof(_calibration_skin_tone_ccm) / sizeof(_calibration_skin_tone_ccm[0]), .width = sizeof(_calibration_skin_tone_ccm[0] ) };
+static LookupTable calibration_mt_absolute_ls_a_ccm_linear = { .ptr = _calibration_mt_absolute_ls_a_ccm_linear, .rows = 1, .cols = sizeof(_calibration_mt_absolute_ls_a_ccm_linear) / sizeof(_calibration_mt_absolute_ls_a_ccm_linear[0]), .width = sizeof(_calibration_mt_absolute_ls_a_ccm_linear[0] ) };
+static LookupTable calibration_mt_absolute_ls_d40_ccm_linear = { .ptr = _calibration_mt_absolute_ls_d40_ccm_linear, .rows = 1, .cols = sizeof(_calibration_mt_absolute_ls_d40_ccm_linear) / sizeof(_calibration_mt_absolute_ls_d40_ccm_linear[0]), .width = sizeof(_calibration_mt_absolute_ls_d40_ccm_linear[0] ) };
+static LookupTable calibration_mt_absolute_ls_d50_ccm_linear = { .ptr = _calibration_mt_absolute_ls_d50_ccm_linear, .rows = 1, .cols = sizeof(_calibration_mt_absolute_ls_d50_ccm_linear) / sizeof(_calibration_mt_absolute_ls_d50_ccm_linear[0]), .width = sizeof(_calibration_mt_absolute_ls_d50_ccm_linear[0] ) };
+static LookupTable calibration_mt_absolute_ls_a_ccm_hdr = { .ptr = _calibration_mt_absolute_ls_a_ccm_hdr, .rows = 1, .cols = sizeof(_calibration_mt_absolute_ls_a_ccm_hdr) / sizeof(_calibration_mt_absolute_ls_a_ccm_hdr[0]), .width = sizeof(_calibration_mt_absolute_ls_a_ccm_hdr[0] ) };
+static LookupTable calibration_mt_absolute_ls_d40_ccm_hdr = { .ptr = _calibration_mt_absolute_ls_d40_ccm_hdr, .rows = 1, .cols = sizeof(_calibration_mt_absolute_ls_d40_ccm_hdr) / sizeof(_calibration_mt_absolute_ls_d40_ccm_hdr[0]), .width = sizeof(_calibration_mt_absolute_ls_d40_ccm_hdr[0] ) };
+static LookupTable calibration_mt_absolute_ls_d50_ccm_hdr = { .ptr = _calibration_mt_absolute_ls_d50_ccm_hdr, .rows = 1, .cols = sizeof(_calibration_mt_absolute_ls_d50_ccm_hdr) / sizeof(_calibration_mt_absolute_ls_d50_ccm_hdr[0]), .width = sizeof(_calibration_mt_absolute_ls_d50_ccm_hdr[0] ) };
+static LookupTable calibration_shading_ls_a_r = { .ptr = _calibration_shading_ls_a_r, .rows = 1, .cols = sizeof(_calibration_shading_ls_a_r) / sizeof(_calibration_shading_ls_a_r[0]), .width = sizeof(_calibration_shading_ls_a_r[0] ) };
+static LookupTable calibration_shading_ls_a_g = { .ptr = _calibration_shading_ls_a_g, .rows = 1, .cols = sizeof(_calibration_shading_ls_a_g) / sizeof(_calibration_shading_ls_a_g[0]), .width = sizeof(_calibration_shading_ls_a_g[0] ) };
+static LookupTable calibration_shading_ls_a_b = { .ptr = _calibration_shading_ls_a_b, .rows = 1, .cols = sizeof(_calibration_shading_ls_a_b) / sizeof(_calibration_shading_ls_a_b[0]), .width = sizeof(_calibration_shading_ls_a_b[0] ) };
+static LookupTable calibration_shading_ls_tl84_r = { .ptr = _calibration_shading_ls_tl84_r, .rows = 1, .cols = sizeof(_calibration_shading_ls_tl84_r) / sizeof(_calibration_shading_ls_tl84_r[0]), .width = sizeof(_calibration_shading_ls_tl84_r[0] ) };
+static LookupTable calibration_shading_ls_tl84_g = { .ptr = _calibration_shading_ls_tl84_g, .rows = 1, .cols = sizeof(_calibration_shading_ls_tl84_g) / sizeof(_calibration_shading_ls_tl84_g[0]), .width = sizeof(_calibration_shading_ls_tl84_g[0] ) };
+static LookupTable calibration_shading_ls_tl84_b = { .ptr = _calibration_shading_ls_tl84_b, .rows = 1, .cols = sizeof(_calibration_shading_ls_tl84_b) / sizeof(_calibration_shading_ls_tl84_b[0]), .width = sizeof(_calibration_shading_ls_tl84_b[0] ) };
+static LookupTable calibration_shading_ls_d65_r = { .ptr = _calibration_shading_ls_d65_r, .rows = 1, .cols = sizeof(_calibration_shading_ls_d65_r) / sizeof(_calibration_shading_ls_d65_r[0]), .width = sizeof(_calibration_shading_ls_d65_r[0] ) };
+static LookupTable calibration_shading_ls_d65_g = { .ptr = _calibration_shading_ls_d65_g, .rows = 1, .cols = sizeof(_calibration_shading_ls_d65_g) / sizeof(_calibration_shading_ls_d65_g[0]), .width = sizeof(_calibration_shading_ls_d65_g[0] ) };
+static LookupTable calibration_shading_ls_d65_b = { .ptr = _calibration_shading_ls_d65_b, .rows = 1, .cols = sizeof(_calibration_shading_ls_d65_b) / sizeof(_calibration_shading_ls_d65_b[0]), .width = sizeof(_calibration_shading_ls_d65_b[0] ) };
+static LookupTable calibration_shading_ls_a_r_wdr = { .ptr = _calibration_shading_ls_a_r_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_a_r_wdr) / sizeof(_calibration_shading_ls_a_r_wdr[0]), .width = sizeof(_calibration_shading_ls_a_r_wdr[0] ) };
+static LookupTable calibration_shading_ls_a_g_wdr = { .ptr = _calibration_shading_ls_a_g_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_a_g_wdr) / sizeof(_calibration_shading_ls_a_g_wdr[0]), .width = sizeof(_calibration_shading_ls_a_g_wdr[0] ) };
+static LookupTable calibration_shading_ls_a_b_wdr = { .ptr = _calibration_shading_ls_a_b_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_a_b_wdr) / sizeof(_calibration_shading_ls_a_b_wdr[0]), .width = sizeof(_calibration_shading_ls_a_b_wdr[0] ) };
+static LookupTable calibration_shading_ls_tl84_r_wdr = { .ptr = _calibration_shading_ls_tl84_r_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_tl84_r_wdr) / sizeof(_calibration_shading_ls_tl84_r_wdr[0]), .width = sizeof(_calibration_shading_ls_tl84_r_wdr[0] ) };
+static LookupTable calibration_shading_ls_tl84_g_wdr = { .ptr = _calibration_shading_ls_tl84_g_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_tl84_g_wdr) / sizeof(_calibration_shading_ls_tl84_g_wdr[0]), .width = sizeof(_calibration_shading_ls_tl84_g_wdr[0] ) };
+static LookupTable calibration_shading_ls_tl84_b_wdr = { .ptr = _calibration_shading_ls_tl84_b_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_tl84_b_wdr) / sizeof(_calibration_shading_ls_tl84_b_wdr[0]), .width = sizeof(_calibration_shading_ls_tl84_b_wdr[0] ) };
+static LookupTable calibration_shading_ls_d65_r_wdr = { .ptr = _calibration_shading_ls_d65_r_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_d65_r_wdr) / sizeof(_calibration_shading_ls_d65_r_wdr[0]), .width = sizeof(_calibration_shading_ls_d65_r_wdr[0] ) };
+static LookupTable calibration_shading_ls_d65_g_wdr = { .ptr = _calibration_shading_ls_d65_g_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_d65_g_wdr) / sizeof(_calibration_shading_ls_d65_g_wdr[0]), .width = sizeof(_calibration_shading_ls_d65_g_wdr[0] ) };
+static LookupTable calibration_shading_ls_d65_b_wdr = { .ptr = _calibration_shading_ls_d65_b_wdr, .rows = 1, .cols = sizeof(_calibration_shading_ls_d65_b_wdr) / sizeof(_calibration_shading_ls_d65_b_wdr[0]), .width = sizeof(_calibration_shading_ls_d65_b_wdr[0] ) };
+static LookupTable calibration_awb_warming_ls_a = { .ptr = _calibration_awb_warming_ls_a, .rows = 1, .cols = sizeof(_calibration_awb_warming_ls_a) / sizeof(_calibration_awb_warming_ls_a[0]), .width = sizeof(_calibration_awb_warming_ls_a[0] ) };
+static LookupTable calibration_awb_warming_ls_d40 = { .ptr = _calibration_awb_warming_ls_d40, .rows = 1, .cols = sizeof(_calibration_awb_warming_ls_d40) / sizeof(_calibration_awb_warming_ls_d40[0]), .width = sizeof(_calibration_awb_warming_ls_d40[0] ) };
+static LookupTable calibration_awb_warming_ls_d50 = { .ptr = _calibration_awb_warming_ls_d50, .rows = 1, .cols = sizeof(_calibration_awb_warming_ls_d50) / sizeof(_calibration_awb_warming_ls_d50[0]), .width = sizeof(_calibration_awb_warming_ls_d50[0] ) };
+static LookupTable calibration_noise_profile_linear = { .ptr = _calibration_noise_profile_linear, .rows = 1, .cols = sizeof(_calibration_noise_profile_linear) / sizeof(_calibration_noise_profile_linear[0]), .width = sizeof(_calibration_noise_profile_linear[0] ) };
+static LookupTable calibration_demosaic_linear = { .ptr = _calibration_demosaic_linear, .rows = 1, .cols = sizeof(_calibration_demosaic_linear) / sizeof(_calibration_demosaic_linear[0]), .width = sizeof(_calibration_demosaic_linear[0] ) };
+static LookupTable calibration_noise_profile_fs_hdr = { .ptr = _calibration_noise_profile_fs_hdr, .rows = 1, .cols = sizeof(_calibration_noise_profile_fs_hdr) / sizeof(_calibration_noise_profile_fs_hdr[0]), .width = sizeof(_calibration_noise_profile_fs_hdr[0] ) };
+static LookupTable calibration_demosaic_fs_hdr = { .ptr = _calibration_demosaic_fs_hdr, .rows = 1, .cols = sizeof(_calibration_demosaic_fs_hdr) / sizeof(_calibration_demosaic_fs_hdr[0]), .width = sizeof(_calibration_demosaic_fs_hdr[0] ) };
+static LookupTable calibration_gamma_fe_0_fs_hdr = { .ptr = _calibration_gamma_fe_0_fs_hdr, .rows = 1, .cols = sizeof(_calibration_gamma_fe_0_fs_hdr) / sizeof(_calibration_gamma_fe_0_fs_hdr[0]), .width = sizeof(_calibration_gamma_fe_0_fs_hdr[0] ) };
+static LookupTable calibration_gamma_fe_1_fs_hdr = { .ptr = _calibration_gamma_fe_1_fs_hdr, .rows = 1, .cols = sizeof(_calibration_gamma_fe_1_fs_hdr) / sizeof(_calibration_gamma_fe_1_fs_hdr[0]), .width = sizeof(_calibration_gamma_fe_1_fs_hdr[0] ) };
+static LookupTable calibration_black_level_r_fs_hdr = { .ptr = _calibration_black_level_r_fs_hdr, .cols = 2, .rows = sizeof(_calibration_black_level_r_fs_hdr) / sizeof(_calibration_black_level_r_fs_hdr[0]), .width = sizeof(_calibration_black_level_r_fs_hdr[0][0] ) };
+static LookupTable calibration_black_level_gr_fs_hdr = { .ptr = _calibration_black_level_gr_fs_hdr, .cols = 2, .rows = sizeof(_calibration_black_level_gr_fs_hdr) / sizeof(_calibration_black_level_gr_fs_hdr[0]), .width = sizeof(_calibration_black_level_gr_fs_hdr[0][0] ) };
+static LookupTable calibration_black_level_gb_fs_hdr = { .ptr = _calibration_black_level_gb_fs_hdr, .cols = 2, .rows = sizeof(_calibration_black_level_gb_fs_hdr) / sizeof(_calibration_black_level_gb_fs_hdr[0]), .width = sizeof(_calibration_black_level_gb_fs_hdr[0][0] ) };
+static LookupTable calibration_black_level_b_fs_hdr = { .ptr = _calibration_black_level_b_fs_hdr, .cols = 2, .rows = sizeof(_calibration_black_level_b_fs_hdr) / sizeof(_calibration_black_level_b_fs_hdr[0]), .width = sizeof(_calibration_black_level_b_fs_hdr[0][0] ) };
+static LookupTable calibration_gamma_linear = { .ptr = _calibration_gamma_linear, .rows = 1, .cols = sizeof(_calibration_gamma_linear) / sizeof(_calibration_gamma_linear[0]), .width = sizeof(_calibration_gamma_linear[0] ) };
+static LookupTable calibration_gamma_fs_hdr = { .ptr = _calibration_gamma_fs_hdr, .rows = 1, .cols = sizeof(_calibration_gamma_fs_hdr) / sizeof(_calibration_gamma_fs_hdr[0]), .width = sizeof(_calibration_gamma_fs_hdr[0] ) };
+static LookupTable calibration_iridix_rgb2rec709 = { .ptr = _calibration_iridix_rgb2rec709, .rows = 1, .cols = sizeof(_calibration_iridix_rgb2rec709) / sizeof(_calibration_iridix_rgb2rec709[0]), .width = sizeof(_calibration_iridix_rgb2rec709[0] ) };
+static LookupTable calibration_iridix_rec709torgb = { .ptr = _calibration_iridix_rec709torgb, .rows = 1, .cols = sizeof(_calibration_iridix_rec709torgb) / sizeof(_calibration_iridix_rec709torgb[0]), .width = sizeof(_calibration_iridix_rec709torgb[0] ) };
+static LookupTable calibration_iridix_asymmetry = { .ptr = _calibration_iridix_asymmetry, .rows = 1, .cols = sizeof(_calibration_iridix_asymmetry) / sizeof(_calibration_iridix_asymmetry[0]), .width = sizeof(_calibration_iridix_asymmetry[0] ) };
+
+uint32_t get_static_calibrations( ApicalCalibrations * c ) {
+    uint32_t result = 0;
+    if (c != 0) {
+	    c->calibrations[ _CALIBRATION_BLACK_LEVEL_FS ] = &calibration_black_level_fs ;
+       c->calibrations[ _CALIBRATION_DEFECT_PIXELS ] = &calibration_defect_pixels;
+        c->calibrations[_CALIBRATION_LIGHT_SRC] = &calibration_light_src;
+        c->calibrations[_CALIBRATION_RG_POS] = &calibration_rg_pos;
+        c->calibrations[_CALIBRATION_BG_POS] = &calibration_bg_pos;
+        c->calibrations[_CALIBRATION_MESH_RGBG_WEIGHT] = &calibration_mesh_rgbg_weight;
+        c->calibrations[_CALIBRATION_MESH_LS_WEIGHT] = &calibration_mesh_ls_weight;
+        c->calibrations[_CALIBRATION_MESH_COLOR_TEMPERATURE] = &calibration_mesh_color_temperature;
+        c->calibrations[_CALIBRATION_LUXLOW_LUT_MIN] = &calibration_luxlow_lut_min;
+        c->calibrations[_CALIBRATION_LUXLOW_LUT_MAX] = &calibration_luxlow_lut_max;
+        c->calibrations[_CALIBRATION_LUXLOW_LUT_STEP] = &calibration_luxlow_lut_step;
+        c->calibrations[_CALIBRATION_LUXLOW_LUT] = &calibration_luxlow_lut;
+        c->calibrations[_CALIBRATION_LUXHIGH_LUT_MIN] = &calibration_luxhigh_lut_min;
+        c->calibrations[_CALIBRATION_LUXHIGH_LUT_MAX] = &calibration_luxhigh_lut_max;
+        c->calibrations[_CALIBRATION_LUXHIGH_LUT_STEP] = &calibration_luxhigh_lut_step;
+        c->calibrations[_CALIBRATION_LUXHIGH_LUT] = &calibration_luxhigh_lut;
+        c->calibrations[_CALIBRATION_RGLOW_LUT_MIN] = &calibration_rglow_lut_min;
+        c->calibrations[_CALIBRATION_RGLOW_LUT_MAX] = &calibration_rglow_lut_max;
+        c->calibrations[_CALIBRATION_RGLOW_LUT_STEP] = &calibration_rglow_lut_step;
+        c->calibrations[_CALIBRATION_RGLOW_LUT] = &calibration_rglow_lut;
+        c->calibrations[_CALIBRATION_RGHIGH_LUT_MIN] = &calibration_rghigh_lut_min;
+        c->calibrations[_CALIBRATION_RGHIGH_LUT_MAX] = &calibration_rghigh_lut_max;
+        c->calibrations[_CALIBRATION_RGHIGH_LUT_STEP] = &calibration_rghigh_lut_step;
+        c->calibrations[_CALIBRATION_RGHIGH_LUT] = &calibration_rghigh_lut;
+        c->calibrations[_CALIBRATION_WB_STRENGTH] = &calibration_wb_strength;
+        c->calibrations[_CALIBRATION_SKY_LUX_TH] = &calibration_sky_lux_th;
+		c->calibrations[_CALIBRATION_AWB_SCENE_PRESETS] = &calibration_awb_scene_presets;
+        c->calibrations[_CALIBRATION_CT_RG_POS_CALC] = &calibration_ct_rg_pos_calc;
+        c->calibrations[_CALIBRATION_CT_BG_POS_CALC] = &calibration_ct_bg_pos_calc;
+        c->calibrations[_CALIBRATION_COLOR_TEMP] = &calibration_color_temp;
+        c->calibrations[_CALIBRATION_CT65POS] = &calibration_ct65pos;
+        c->calibrations[_CALIBRATION_CT40POS] = &calibration_ct40pos;
+        c->calibrations[_CALIBRATION_CT30POS] = &calibration_ct30pos;
+        c->calibrations[_CALIBRATION_EVTOLUX_EV_LUT_LINEAR] = &calibration_evtolux_ev_lut_linear;
+        c->calibrations[_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR] = &calibration_evtolux_ev_lut_fs_hdr;
+        c->calibrations[_CALIBRATION_EVTOLUX_LUX_LUT] = &calibration_evtolux_lux_lut;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_R_LINEAR] = &calibration_black_level_r_linear;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_GR_LINEAR] = &calibration_black_level_gr_linear;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_GB_LINEAR] = &calibration_black_level_gb_linear;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_B_LINEAR] = &calibration_black_level_b_linear;
+        c->calibrations[_CALIBRATION_STATIC_WB] = &calibration_static_wb;
+        c->calibrations[_CALIBRATION_AUTO_WB] = &calibration_auto_wb;
+        c->calibrations[_CALIBRATION_SKIN_TONE_CCM] = &calibration_skin_tone_ccm;
+        c->calibrations[_CALIBRATION_MT_ABSOLUTE_LS_A_CCM_LINEAR] = &calibration_mt_absolute_ls_a_ccm_linear;
+        c->calibrations[_CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_LINEAR] = &calibration_mt_absolute_ls_d40_ccm_linear;
+        c->calibrations[_CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_LINEAR] = &calibration_mt_absolute_ls_d50_ccm_linear;
+        c->calibrations[_CALIBRATION_MT_ABSOLUTE_LS_A_CCM_HDR] = &calibration_mt_absolute_ls_a_ccm_hdr;
+        c->calibrations[_CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_HDR] = &calibration_mt_absolute_ls_d40_ccm_hdr;
+        c->calibrations[_CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_HDR] = &calibration_mt_absolute_ls_d50_ccm_hdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_A_R_LINEAR] = &calibration_shading_ls_a_r;
+        c->calibrations[_CALIBRATION_SHADING_LS_A_G_LINEAR] = &calibration_shading_ls_a_g;
+        c->calibrations[_CALIBRATION_SHADING_LS_A_B_LINEAR] = &calibration_shading_ls_a_b;
+        c->calibrations[_CALIBRATION_SHADING_LS_TL84_R_LINEAR] = &calibration_shading_ls_tl84_r;
+        c->calibrations[_CALIBRATION_SHADING_LS_TL84_G_LINEAR] = &calibration_shading_ls_tl84_g;
+        c->calibrations[_CALIBRATION_SHADING_LS_TL84_B_LINEAR] = &calibration_shading_ls_tl84_b;
+        c->calibrations[_CALIBRATION_SHADING_LS_D65_R_LINEAR] = &calibration_shading_ls_d65_r;
+        c->calibrations[_CALIBRATION_SHADING_LS_D65_G_LINEAR] = &calibration_shading_ls_d65_g;
+        c->calibrations[_CALIBRATION_SHADING_LS_D65_B_LINEAR] = &calibration_shading_ls_d65_b;
+        c->calibrations[_CALIBRATION_SHADING_LS_A_R_WDR] = &calibration_shading_ls_a_r_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_A_G_WDR] = &calibration_shading_ls_a_g_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_A_B_WDR] = &calibration_shading_ls_a_b_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_TL84_R_WDR] = &calibration_shading_ls_tl84_r_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_TL84_G_WDR] = &calibration_shading_ls_tl84_g_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_TL84_B_WDR] = &calibration_shading_ls_tl84_b_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_D65_R_WDR] = &calibration_shading_ls_d65_r_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_D65_G_WDR] = &calibration_shading_ls_d65_g_wdr;
+        c->calibrations[_CALIBRATION_SHADING_LS_D65_B_WDR] = &calibration_shading_ls_d65_b_wdr;
+        c->calibrations[_CALIBRATION_AWB_WARMING_LS_A] = &calibration_awb_warming_ls_a;
+        c->calibrations[_CALIBRATION_AWB_WARMING_LS_D40] = &calibration_awb_warming_ls_d40;
+        c->calibrations[_CALIBRATION_AWB_WARMING_LS_D50] = &calibration_awb_warming_ls_d50;
+        c->calibrations[_CALIBRATION_NOISE_PROFILE_LINEAR] = &calibration_noise_profile_linear;
+        c->calibrations[_CALIBRATION_DEMOSAIC_LINEAR] = &calibration_demosaic_linear;
+        c->calibrations[_CALIBRATION_NOISE_PROFILE_FS_HDR] = &calibration_noise_profile_fs_hdr;
+        c->calibrations[_CALIBRATION_DEMOSAIC_FS_HDR] = &calibration_demosaic_fs_hdr;
+        c->calibrations[_CALIBRATION_GAMMA_FE_0_FS_HDR] = &calibration_gamma_fe_0_fs_hdr;
+        c->calibrations[_CALIBRATION_GAMMA_FE_1_FS_HDR] = &calibration_gamma_fe_1_fs_hdr;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_R_FS_HDR] = &calibration_black_level_r_fs_hdr;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_GR_FS_HDR] = &calibration_black_level_gr_fs_hdr;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_GB_FS_HDR] = &calibration_black_level_gb_fs_hdr;
+        c->calibrations[_CALIBRATION_BLACK_LEVEL_B_FS_HDR] = &calibration_black_level_b_fs_hdr;
+        c->calibrations[_CALIBRATION_GAMMA_LINEAR] = &calibration_gamma_linear;
+        c->calibrations[_CALIBRATION_GAMMA_FS_HDR] = &calibration_gamma_fs_hdr;
+        c->calibrations[_CALIBRATION_IRIDIX_RGB2REC709] = &calibration_iridix_rgb2rec709;
+        c->calibrations[_CALIBRATION_IRIDIX_REC709TORGB] = &calibration_iridix_rec709torgb;
+        c->calibrations[_CALIBRATION_IRIDIX_ASYMMETRY] = &calibration_iridix_asymmetry;
+    } else {
+        result = -1;
+    }
+    return result;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/calibration.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/calibration.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/calibration.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/calibration.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,18 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __CALIBRATION_H__
+#define __CALIBRATION_H__
+
+#define PACK_DATE(y, m, d) (((((y)-2000) << 9)+(((m) & 0xF) << 5)+((d) & 0x1F)) & 0xFFFF)
+
+#endif // __CALIBRATION_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/isp_config_seq.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/isp_config_seq.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/isp_config_seq.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/isp_config_seq.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,455 @@
+#if !defined(__ISP_SENSOR_H__)
+#define __ISP_SENSOR_H__
+
+/*-----------------------------------------------------------------------------
+     This confidential and proprietary software/information may be used only
+        as authorized by a licensing agreement from Apical Limited
+
+                   (C) COPYRIGHT 2011 - 2014 Apical Limited
+                          ALL RIGHTS RESERVED
+
+      The entire notice above must be reproduced on all authorized
+       copies and copies may only be made to the extent permitted
+             by a licensing agreement from Apical Limited.
+-----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+Generated by Sensor Sequence compiler - do not edit
+-----------------------------------------------------------------------------*/
+
+#define SENSOR_ISP_SEQUENCE_DEFAULT    \
+    "\x06\x00\x0e\x00\x16\x00\x01\x40\x00\x30\x00\x00\x90\x00\x01\x40" \
+    "\x00\x30\x00\x90\x90\x00\x01\x00\x08\x20\x00\x0d\x01\x00\x0c\x31" \
+    "\x00\x02\x00\xcf\x0f\x01\x04\x08\x20\x00\x40\x02\x00\x00\x04\x00" \
+    "\x33\x00\x00\x00\x00\x00\xff\x0f\xff\x0f\x01\x08\x08\x20\x00\x90" \
+    "\x01\xac\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x80\x20" \
+    "\x33\x00\x00\x00\x00\x00\x00\x03\x33\xc0\x01\x0c\x08\x20\x00\xc0" \
+    "\x01\x10\x00\x21\x00\x80\x07\x01\x58\x1d\x23\x00\x33\x33\x34\x34" \
+    "\x01\x14\x00\x21\x00\x38\x04\x30\x04\x00\x03\x01\x04\x0c\x23\x00" \
+    "\x80\x07\x38\x04\x01\x20\x08\x21\x00\x45\x77\x01\xb0\x1e\x33\x00" \
+    "\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x24\x08\x21\x00\xc1\x56\x01" \
+    "\x28\x00\x21\x00\x20\x00\x01\x5c\x1d\x23\x00\x34\x34\x34\x34\x01" \
+    "\x2c\x08\x21\x00\xfd\x15\x01\x30\x00\x30\x00\x02\x03\x01\x08\x0c" \
+    "\x23\x00\x00\x80\x78\x22\x01\x34\x20\x33\x00\x00\x00\x00\x00\xff" \
+    "\xff\x01\x80\x33\x04\x00\x00\x00\x00\xff\xff\x01\x80\x33\x08\x00" \
+    "\x00\x00\x00\xff\xff\x01\x80\x01\x40\x00\x33\x00\x92\x05\x00\x00" \
+    "\xff\xff\x7f\x7f\x01\x60\x05\x21\x00\x0a\x80\x01\x44\x00\x31\x00" \
+    "\x04\x00\x7f\x6e\x30\x04\x00\x07\x01\x0c\x0c\x23\x00\x00\x10\x73" \
+    "\x22\x01\x4c\x00\x30\x00\x00\x03\x01\x10\x0d\x23\x00\x00\x90\x7e" \
+    "\x30\x01\x50\x00\x30\x00\x00\x03\x01\xb8\x1e\x33\x00\x00\x00\x00" \
+    "\x00\x0f\x0f\x0f\x0f\x01\x54\x00\x30\x00\x00\x03\x01\xe0\x01\x31" \
+    "\x00\x00\x08\xff\x0f\x01\x58\x00\x30\x00\x00\x07\x01\x64\x05\x31" \
+    "\x00\x00\x00\xff\x07\x01\x88\x0c\x23\x00\x00\x00\x00\x00\x01\x5c" \
+    "\x08\x31\x00\xff\x00\xff\x0f\x23\x04\xf7\x58\x1e\x00\x01\x10\x0c" \
+    "\x23\x00\x00\xa0\xf1\x24\x01\x64\x20\x23\x00\x00\x00\x00\x00\x02" \
+    "\x14\x01\x02\x00\x23\x00\x00\x1e\x00\x00\x01\x68\x08\x30\x00\x00" \
+    "\x01\x01\xbc\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x6c" \
+    "\x20\x23\x00\x00\x00\x00\x00\x01\x70\x08\x21\x00\x0f\x0f\x01\x68" \
+    "\x1d\x23\x00\x35\x36\x36\x36\x02\x8c\x00\x04\x00\x23\x00\x00\x00" \
+    "\x00\x00\x01\x0c\x21\x23\x00\x00\x00\x00\x00\x01\x78\x00\x30\x00" \
+    "\x00\x03\x01\x14\x0c\x23\x00\x00\x00\x00\x20\x01\x7c\x00\x30\x00" \
+    "\x01\x01\x02\x04\x00\x04\x00\x23\x00\x98\x08\x65\x04\x01\x80\x08" \
+    "\x23\x00\xff\xff\x00\x00\x01\xc0\x1e\x33\x00\x00\x00\x00\x00\x0f" \
+    "\x0f\x0f\x0f\x01\x84\x20\x23\x00\x00\x00\x00\x00\x01\x84\x08\x23" \
+    "\x00\x48\x00\x00\x00\x23\x04\x57\x02\x9c\x0e\x01\x6c\x1d\x23\x00" \
+    "\x36\x36\x36\x36\x01\x8c\x08\x30\x00\x03\x0f\x21\x04\x0f\x0f\x01" \
+    "\x18\x0c\x23\x00\x00\x00\x00\x20\x01\x94\x08\x20\x00\xcc\x30\x04" \
+    "\x02\x07\x01\xc4\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01" \
+    "\x9c\x08\x21\x00\x9c\x0e\x01\xa0\x20\x33\x00\x00\x00\x00\x00\x00" \
+    "\x03\x33\xc0\x01\x70\x1d\x23\x00\x36\x36\x37\x37\x01\xa4\x20\x23" \
+    "\x00\x00\x00\x00\x00\x02\x10\x01\x04\x00\x23\x00\x68\x01\x08\x20" \
+    "\x01\xa8\x20\x23\x00\x00\x00\x00\x00\x01\x1c\x0c\x30\x00\x02\x0f" \
+    "\x01\xac\x20\x23\x00\x00\x00\x00\x00\x23\x04\x00\x00\x00\x00\x01" \
+    "\x64\x1e\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xc0\x08\x20" \
+    "\x00\x00\x01\x20\x0c\x23\x00\x00\x1e\x00\x00\x01\xc4\x08\x20\x00" \
+    "\x00\x01\x14\x0d\x23\x00\x00\x00\x00\x30\x01\xc8\x08\x23\x00\x00" \
+    "\xd2\x0f\x00\x01\xcc\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f" \
+    "\x01\xcc\x08\x23\x00\x00\x10\x05\x00\x31\x04\xff\x0f\xff\x0f\x01" \
+    "\x78\x1d\x23\x00\x37\x37\x37\x37\x01\x8c\x0c\x23\x00\x00\x00\x00" \
+    "\x00\x01\xd4\x08\x31\x00\x00\x00\xff\x0f\x31\x04\xff\x0f\xff\x0f" \
+    "\x01\x24\x0c\x33\x00\x00\x0a\x00\x00\x03\x3f\x07\x00\x01\xdc\x08" \
+    "\x31\x00\x00\x00\xff\x0f\x02\x18\x01\x04\x00\x21\x00\x00\xe0\x01" \
+    "\xe0\x20\x33\x00\x00\x00\x00\x00\x00\x03\x33\xc0\x01\xd0\x1e\x33" \
+    "\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\xe4\x20\x23\x00\x00\x00" \
+    "\x00\x00\x23\x04\x00\x00\x00\x00\x01\x7c\x1d\x23\x00\x38\x38\x38" \
+    "\x38\x02\x90\x00\x04\x00\x21\x00\xc0\x0c\x01\xec\x20\x23\x00\x00" \
+    "\x00\x00\x00\x23\x24\x00\x00\x00\x00\x23\x04\x00\x00\x00\x00\x01" \
+    "\x28\x08\x21\x00\x57\x06\x02\x08\x00\x04\x00\x23\x00\x80\x07\x38" \
+    "\x04\x01\x88\x20\x23\x00\x00\x00\x00\x00\x01\x00\x01\x33\x00\x0f" \
+    "\x00\x02\x00\x0f\xdf\x9f\x01\x01\x80\x1d\x23\x00\x06\x0c\x10\x12" \
+    "\x01\x04\x01\x33\x00\x00\x17\x09\x09\x03\x1f\x0f\x0f\x01\x00\x20" \
+    "\x21\x00\x08\x10\x01\x08\x01\x21\x00\x0f\x0f\x01\x2c\x0c\x23\x00" \
+    "\x00\x10\x5c\x2c\x01\x0c\x01\x21\x00\xac\x00\x21\x04\x80\x07\x21" \
+    "\x08\xac\x00\x21\x0c\x80\x07\x01\x84\x1d\x23\x00\x15\x17\x18\x19" \
+    "\x01\x1c\x01\x21\x00\x0f\x0f\x21\x04\x20\x00\x01\x30\x08\x21\x00" \
+    "\x0f\x0f\x01\x24\x01\x21\x00\x38\x04\x21\x04\x80\x07\x01\x68\x1e" \
+    "\x33\x00\x0f\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x2c\x01\x21\x00\x38" \
+    "\x04\x30\x04\x01\x87\x01\x88\x1d\x23\x00\x1b\x1c\x1d\x1e\x01\x34" \
+    "\x01\x30\x00\x01\x07\x01\x38\x09\x31\x00\xff\x03\xff\x0f\x01\x34" \
+    "\x0c\x33\x00\x00\x00\x00\x00\x0f\xff\xff\xff\x01\x3c\x09\x31\x00" \
+    "\xff\x03\xff\x0f\x01\x18\x0d\x23\x00\x00\x00\x00\x30\x01\x40\x01" \
+    "\x31\x00\x00\x00\xff\x0f\x01\xe0\x1e\x30\x00\x00\x0f\x01\x44\x01" \
+    "\x31\x00\x00\x00\xff\x0f\x31\x04\x00\x00\xff\x0f\x01\x8c\x1d\x23" \
+    "\x00\x1e\x20\x20\x21\x01\x90\x0c\x23\x00\x00\x00\x00\x00\x01\x4c" \
+    "\x01\x31\x00\x00\x00\xff\x0f\x01\x40\x1f\x33\x00\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x01\x50\x09\x30\x00\x04\x0f\x01\x38\x0c\x31\x00" \
+    "\x30\x01\xff\x03\x02\x40\x00\x04\x00\x23\x00\xb9\xe3\x08\x00\x01" \
+    "\x90\x1d\x23\x00\x22\x22\x23\x24\x02\x50\x00\x02\x00\x33\x00\x40" \
+    "\x00\x10\x00\xff\x1f\xff\x1f\x01\x3c\x0c\x23\x00\x00\x00\x00\x00" \
+    "\x02\x54\x00\x02\x00\x30\x00\x0c\x0c\x02\x0c\x00\x04\x00\x33\x00" \
+    "\x48\x00\x03\x00\xff\x0f\xff\x0f\x02\x70\x01\x02\x00\x33\x00\x00" \
+    "\x00\x00\x00\x1f\x00\x01\x00\x01\x8c\x20\x23\x00\x00\x00\x00\x00" \
+    "\x01\x48\x20\x23\x00\x00\x00\x00\x00\x01\x94\x0d\x23\x00\x00\x00" \
+    "\x00\x00\x01\x40\x08\x31\x00\xff\x03\xff\x03\x01\xc0\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x88\x01\x30\x00\x33\xfb\x01" \
+    "\x98\x0d\x23\x00\x00\x00\x00\x00\x01\x44\x08\x31\x00\x00\x00\xff" \
+    "\x03\x02\x04\x01\x04\x00\x30\x00\x00\x3f\x01\x9c\x0d\x30\x00\x00" \
+    "\x0f\x01\x48\x08\x31\x00\xff\x01\xff\x0f\x01\x1c\x0d\x30\x00\x02" \
+    "\x0f\x01\x4c\x20\x23\x00\x00\x00\x00\x00\x02\xc0\x00\x04\x00\x30" \
+    "\x00\x0f\x0f\x01\xc0\x01\x30\x00\x05\xcd\x01\xa0\x0d\x23\x00\x00" \
+    "\x10\x00\x00\x01\x94\x0c\x23\x00\x00\x00\x00\x00\x01\x48\x09\x31" \
+    "\x00\xff\x0f\xff\x0f\x01\xc4\x01\x20\x00\xc8\x01\x50\x1e\x33\x00" \
+    "\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xc8\x09\x21\x00\xff\xff\x01" \
+    "\x4c\x08\x31\x00\x40\x00\xff\x0f\x01\xcc\x01\x31\x00\xff\x0f\xff" \
+    "\x0f\x02\x20\x01\x02\x00\x23\x00\x00\x00\x00\x00\x01\xd0\x01\x31" \
+    "\x00\xaa\x00\xff\x0f\x01\xd4\x09\x21\x00\x00\x00\x01\xd8\x01\x31" \
+    "\x00\x1d\x01\xff\x0f\x01\xa4\x0d\x33\x00\x00\x00\x00\x00\x03\x3f" \
+    "\x07\x00\x01\xdc\x09\x21\x00\x00\x00\x21\x04\x4c\x19\x01\x50\x08" \
+    "\x31\x00\xff\x01\xff\x0f\x01\xe4\x09\x21\x00\x00\x00\x02\x10\x00" \
+    "\x02\x00\x21\x00\x80\x07\x01\xe8\x09\x31\x00\x01\x00\xff\x3f\x01" \
+    "\x90\x20\x23\x00\x00\x00\x00\x00\x01\xec\x09\x31\x00\x00\x01\xff" \
+    "\x3f\x31\x04\x01\x00\xff\x3f\x01\xa8\x0d\x23\x00\x00\x00\x00\x00" \
+    "\x01\xf4\x01\x20\x00\x30\x01\x08\x20\x31\x00\x20\x00\xff\x03\x01" \
+    "\xf8\x09\x31\x00\x00\x01\xff\x3f\x01\x54\x08\x31\x00\x40\x00\xff" \
+    "\x0f\x02\x4c\x00\x02\x00\x33\x00\x48\x00\x03\x00\xff\x1f\xff\x1f" \
+    "\x01\xfc\x09\x23\x00\x00\x00\x00\x00\x01\x00\x02\x30\x00\x04\x5f" \
+    "\x01\x00\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x33\x80\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x04\x02\x31\x00\x00\x00\xff\x0f" \
+    "\x31\x04\x00\x00\xff\x0f\x01\xac\x0d\x23\x00\x00\x00\x00\x00\x01" \
+    "\x0c\x02\x31\x00\x00\x00\xff\x0f\x01\x20\x09\x20\x00\x0c\x21\xf0" \
+    "\x80\x07\x01\x58\x08\x31\x00\x00\x01\xff\x0f\x01\x14\x0a\x21\x00" \
+    "\x38\x04\x23\x04\x00\x00\x00\x00\x01\x04\x1f\x33\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x01\x1c\x0a\x23\x00\x00\x00\x00\x00\x01\xb0" \
+    "\x0d\x23\x00\xde\x90\x00\x00\x01\x24\x0a\x23\x00\x00\x1e\x00\x00" \
+    "\x30\x04\x00\x01\x01\x20\x0d\x23\x00\x00\x1e\x00\x00\x01\x08\x1f" \
+    "\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x02\xf0\x01\x04\x00\x23" \
+    "\x00\x06\x00\x00\x00\x01\xb4\x0d\x33\x00\x00\x00\x00\x00\x0f\xff" \
+    "\xff\xff\x01\x98\x0c\x23\x00\x00\x00\x00\x00\x01\x40\x02\x33\x00" \
+    "\x43\xc0\x00\x00\xe3\xe0\x03\x00\x01\x60\x20\x33\x00\x00\x00\x00" \
+    "\x00\x00\x03\x33\xc0\x01\x44\x02\x31\x00\x00\x0f\xff\x0f\x02\x20" \
+    "\x01\x04\x00\x21\x00\x00\x60\x02\x24\x01\x02\x00\x23\x00\x00\x00" \
+    "\x00\x00\x01\x48\x02\x31\x00\x00\x0c\xff\x0f\x01\x0c\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x4c\x02\x31\x00\x00\x04\xff" \
+    "\x0f\x20\x04\x80\x01\xb8\x0d\x31\x00\x30\x01\xff\x03\x01\x54\x02" \
+    "\x21\x00\x40\x00\x21\x04\x00\x02\x01\x5c\x0a\x23\x00\x00\x90\x7e" \
+    "\x00\x02\x14\x00\x02\x00\x21\x00\x38\x04\x01\x60\x02\x31\x00\xf1" \
+    "\x00\xff\x0f\x01\x10\x0b\x23\x00\x00\x40\xe3\x09\x01\x64\x02\x31" \
+    "\x00\xf1\x00\xff\x0f\x21\x04\x10\x0f\x01\xbc\x0d\x23\x00\x00\x00" \
+    "\x00\x00\x01\x70\x02\x21\x00\xff\xff\x01\x68\x20\x23\x00\x00\x00" \
+    "\x00\x00\x01\x74\x02\x20\x00\x20\x20\x04\x04\x01\x14\x0b\x23\x00" \
+    "\x00\x20\xfd\x00\x01\x84\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x01\x7c\x02\x20\x00\x00\x02\x10\x00\x04\x00\x33\x00\x40\x00" \
+    "\x10\x00\xff\x0f\xff\x0f\x01\x80\x02\x31\x00\x5c\x07\xff\x0f\x01" \
+    "\xc0\x09\x30\x00\x00\x0f\x01\x84\x02\x21\x00\x00\x00\x01\x24\x09" \
+    "\x33\x00\x08\x00\x10\x00\xff\x00\xff\x00\x01\x88\x02\x21\x00\x00" \
+    "\x00\x02\x44\x00\x02\x00\x23\x00\x98\x08\x65\x04\x01\x8c\x02\x21" \
+    "\x00\x00\x01\x33\x04\x00\x00\x00\x00\xff\x00\xff\x00\x01\x18\x0b" \
+    "\x23\x00\x00\x20\xfd\x00\x01\x94\x02\x33\x00\x00\x00\x00\x00\xff" \
+    "\x00\xff\x00\x33\x04\x7e\x00\x00\x00\xff\x00\xff\x00\x01\xc4\x09" \
+    "\x20\x00\x00\x01\x9c\x02\x33\x00\x43\x00\x00\x00\xff\x00\xff\x00" \
+    "\x01\x70\x20\x23\x00\x00\x00\x00\x00\x01\xa4\x02\x20\x00\x04\x01" \
+    "\x24\x0d\x33\x00\x00\x0a\x01\x00\x03\x3f\x07\x00\x01\xa8\x02\x20" \
+    "\x00\x04\x01\x1c\x0b\x30\x00\x02\x0f\x01\xac\x02\x20\x00\xff\x20" \
+    "\x04\xb4\x01\xc8\x01\x21\x00\x00\x00\x01\x9c\x0c\x30\x00\x00\x0f" \
+    "\x01\xb4\x02\x20\x00\xff\x20\x04\xff\x02\x28\x01\x04\x00\x33\x00" \
+    "\x19\x00\x19\x03\xff\x00\xff\xff\x01\xc0\x02\x31\x00\x03\x00\xdb" \
+    "\x01\x01\x20\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xc4" \
+    "\x02\x20\x00\x46\x20\x04\x46\x01\xcc\x09\x21\x00\xff\xff\x01\xcc" \
+    "\x02\x30\x00\x01\x0f\x01\x20\x21\x33\x00\x00\x00\x00\x00\x00\x03" \
+    "\x33\xc0\x01\x24\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01" \
+    "\xe0\x02\x21\x00\xff\xff\x01\xd0\x09\x21\x00\xff\xff\x01\xe4\x02" \
+    "\x20\x00\x20\x20\x04\x04\x20\x08\x00\x01\x28\x1f\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\xd4\x01\x31\x00\xaa\x00\xff\x0f\x02" \
+    "\x14\x01\x04\x00\x23\x00\x5a\x00\x65\x04\x01\x00\x0b\x31\x00\x02" \
+    "\x00\xcf\x0f\x01\x80\x04\x21\x00\x95\x01\x01\x04\x0b\x23\x00\x80" \
+    "\x07\x38\x04\x23\x04\x00\x20\xe6\x07\x01\x4c\x1e\x33\x00\x00\x00" \
+    "\x00\x00\x0f\x0f\x0f\x0f\x01\x0c\x0b\x23\x00\x00\xb0\x64\x09\x01" \
+    "\x10\x03\x31\x00\xf1\x00\xff\x0f\x01\xd8\x09\x21\x00\x00\x00\x01" \
+    "\x14\x03\x31\x00\xf1\x00\xff\x0f\x31\x04\xf1\x00\xff\x0f\x01\x84" \
+    "\x04\x21\x00\x7c\x80\x01\x1c\x03\x31\x00\xf1\x00\xff\x0f\x02\xd0" \
+    "\x00\x04\x00\x33\x00\x00\x00\x00\x00\x13\x00\x13\x00\x01\x28\x0d" \
+    "\x23\x00\x00\xe0\x6d\x36\x01\x20\x0b\x23\x00\x00\x1e\x00\x00\x33" \
+    "\x04\x00\x12\x01\x00\x03\x3f\x07\x00\x23\x08\x00\x40\xcc\x11\x01" \
+    "\xdc\x01\x20\x00\x80\x01\xa0\x0c\x23\x00\x00\x10\x00\x00\x01\x2c" \
+    "\x0b\x23\x00\x00\x40\xcc\x11\x23\x04\x2d\x90\x2d\x90\x01\x88\x1c" \
+    "\x23\x00\x06\x0c\x10\x12\x01\x34\x0b\x33\x00\x00\x00\x00\x00\x0f" \
+    "\xff\xff\xff\x02\x2c\x01\x04\x00\x33\x00\x27\x00\xb4\x00\xff\x00" \
+    "\xff\xff\x01\x38\x0b\x31\x00\x30\x01\xff\x03\x23\x04\x00\x00\x00" \
+    "\x00\x01\x40\x03\x30\x00\x06\x07\x01\xe0\x1d\x23\x00\x35\x36\x36" \
+    "\x36\x01\x44\x03\x21\x00\xc0\x03\x01\x24\x21\x23\x00\x00\x00\x00" \
+    "\x00\x01\x48\x03\x21\x00\x1c\x02\x01\x8c\x04\x21\x00\x48\x80\x01" \
+    "\x4c\x03\x21\x00\xc0\x03\x21\x04\x1c\x02\x01\x38\x1f\x33\x00\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x54\x03\x21\x00\xc0\x03\x21\x04" \
+    "\x1c\x02\x01\xe4\x01\x31\x00\x00\x00\xff\x0f\x01\x5c\x03\x21\x00" \
+    "\xea\x06\x21\x04\xea\x06\x01\x90\x04\x21\x00\x8d\x01\x01\x64\x03" \
+    "\x21\x00\xea\x06\x01\xe8\x01\x20\x00\x00\x01\x94\x04\x21\x00\x4a" \
+    "\x80\x01\x80\x03\x33\x00\x05\x24\x1f\x1f\x1f\x3f\x3f\x3f\x01\x40" \
+    "\x0b\x23\x00\x11\x00\x00\x00\x01\x84\x03\x30\x00\x00\x01\x01\x88" \
+    "\x0b\x23\x00\x00\x00\x00\x00\x01\xec\x01\x31\x00\x00\x00\xff\x0f" \
+    "\x01\x8c\x0b\x23\x00\x00\x00\x00\x00\x01\x90\x03\x30\x00\x02\x03" \
+    "\x01\x98\x04\x21\x00\x1f\x00\x01\x94\x03\x33\x00\x02\x02\x02\x00" \
+    "\x07\x07\x07\x00\x33\x04\x00\x00\x00\x00\xff\xff\xff\x00\x01\x44" \
+    "\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x9c\x03\x21\x00" \
+    "\x00\x10\x01\xa0\x0b\x23\x00\x00\x10\x00\x00\x01\xf0\x01\x20\x00" \
+    "\x00\x01\xa4\x0c\x33\x00\x00\x00\x00\x00\x03\x3f\x07\x00\x01\xa4" \
+    "\x0b\x33\x00\x00\x00\x00\x00\x03\x3f\x07\x00\x23\x04\x00\x00\x00" \
+    "\x00\x01\x9c\x1c\x23\x00\x24\x25\x25\x26\x01\xac\x0b\x23\x00\x00" \
+    "\x00\x00\x00\x02\x30\x01\x04\x00\x33\x00\x04\x00\x44\x04\xff\x00" \
+    "\xff\xff\x01\xb0\x0b\x23\x00\x54\x90\x00\x00\x01\x48\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xb4\x0b\x33\x00\x00\x00\x00" \
+    "\x00\x0f\xff\xff\xff\x31\x04\x30\x01\xff\x03\x02\xf4\x01\x04\x00" \
+    "\x23\x00\x12\x00\x00\x00\x01\xbc\x0b\x23\x00\x00\x00\x00\x00\x01" \
+    "\x28\x21\x23\x00\x00\x00\x00\x00\x01\xc0\x03\x30\x00\x29\x69\x21" \
+    "\xe0\xab\x01\x20\x04\x46\x02\x20\x00\x02\x00\x30\x00\x01\x01\x01" \
+    "\xc8\x03\x33\x00\xf7\xc8\x14\x00\xff\xff\xff\x00\x01\x4c\x1f\x33" \
+    "\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xd0\x03\x31\x00\x00\x00" \
+    "\xff\x0f\x31\x04\xff\x0f\xff\x0f\x20\x08\x00\x30\xd4\x01\x01\x31" \
+    "\x0c\xfc\x00\xff\x0f\x02\x48\x00\x04\x00\x23\x00\xc9\x15\xbb\x31" \
+    "\x01\xe0\x03\x30\x00\x03\x03\x01\x50\x1f\x33\x00\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x33\x40\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x02\x20" \
+    "\x00\x04\x00\x31\x00\x03\x01\x07\xf3\x01\xc0\x0d\x23\x00\x00\x00" \
+    "\x00\x00\x01\xa8\x04\x21\x00\x00\x01\x01\x54\x1f\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\x00\x04\x20\x00\xbd\x01\x00\x0a\x33" \
+    "\x00\x05\x00\x02\x00\xcf\x00\x03\x03\x01\x04\x04\x20\x00\xbc\x20" \
+    "\x04\xbd\x01\xac\x1c\x23\x00\x2a\x2b\x2b\x2b\x01\x0c\x04\x20\x00" \
+    "\xa5\x01\x30\x0d\x23\x00\xb6\x90\xb7\x90\x01\x10\x04\x20\x00\x80" \
+    "\x01\x58\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x14\x04" \
+    "\x31\x00\x3c\x00\xff\x0f\x02\xc4\x00\x04\x00\x21\x00\xae\x4f\x01" \
+    "\x18\x04\x31\x00\x3a\x00\xff\x0f\x01\x04\x1e\x33\x00\x00\x00\x00" \
+    "\x00\x0f\x0f\x0f\x0f\x01\xa8\x0c\x23\x00\x00\x00\x00\x00\x01\x1c" \
+    "\x04\x31\x00\x3e\x00\xff\x0f\x31\x04\x40\x00\xff\x0f\x21\x94\x00" \
+    "\x01\x31\x08\x71\x01\xff\x0f\x02\x34\x01\x04\x00\x33\x00\x46\x00" \
+    "\x6e\x46\xff\x00\xff\xff\x01\x28\x04\x31\x00\x00\x08\xff\x0f\x01" \
+    "\x5c\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x2c\x04\x31" \
+    "\x00\x00\x08\xff\x0f\x31\x04\x00\x08\xff\x0f\x01\x08\x0a\x23\x00" \
+    "\x00\x00\x00\x00\x01\x34\x04\x31\x00\x00\x00\xff\x0f\x01\x2c\x21" \
+    "\x23\x00\x00\x00\x00\x00\x01\x38\x04\x31\x00\x00\x00\xff\x0f\x31" \
+    "\x7c\x00\x00\xff\x0f\x20\x04\x22\x20\x08\x18\x01\x60\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x44\x04\x31\x00\xa0\x00\xff" \
+    "\x0f\x20\x04\x00\x01\x0c\x0a\x23\x00\x20\x0c\x00\x00\x01\x4c\x04" \
+    "\x20\x00\x00\x02\x3c\x01\x04\x00\x20\x00\x00\x01\x50\x04\x31\x00" \
+    "\xb3\x01\xff\x0f\x31\x68\x00\x00\xff\x0f\x20\x04\xcf\x01\x50\x20" \
+    "\x23\x00\x00\x00\x00\x00\x01\x58\x04\x31\x00\x00\x00\xff\x0f\x01" \
+    "\x64\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x33\x30\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\x5c\x04\x20\x00\x82\x01\x54\x1e\x33" \
+    "\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x60\x04\x20\x00\x46\x01" \
+    "\x10\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x64\x04\x20" \
+    "\x00\x00\x01\xbc\x1c\x23\x00\x2f\x2f\x2f\x2f\x01\x6c\x04\x20\x00" \
+    "\x00\x01\x58\x1e\x33\x00\x0f\x0f\x00\x00\x0f\x0f\x0f\x0f\x01\x68" \
+    "\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x40\x1e\x33\x00" \
+    "\x00\x00\x0f\x0f\x0f\x0f\x0f\x0f\x01\x80\x1c\x23\x00\x00\x00\x00" \
+    "\x00\x01\xc0\x0c\x23\x00\x00\x00\x00\x00\x01\x84\x1c\x23\x00\x00" \
+    "\x00\x00\x00\x01\x40\x0d\x23\x00\x11\x00\x00\x00\x01\x34\x0d\x33" \
+    "\x00\x00\x00\x00\x00\x0f\xff\xff\xff\x01\x88\x04\x21\x00\x1d\x80" \
+    "\x01\x8c\x1c\x23\x00\x15\x17\x18\x19\x23\x04\x1b\x1c\x1d\x1e\x01" \
+    "\xac\x0c\x23\x00\x00\x00\x00\x00\x01\x94\x1c\x23\x00\x1e\x20\x20" \
+    "\x21\x01\x48\x1e\x33\x00\x0f\x0f\x0f\x00\x0f\x0f\x0f\x0f\x01\x98" \
+    "\x1c\x23\x00\x22\x22\x23\x24\x01\xc4\x20\x23\x00\x00\x00\x00\x00" \
+    "\x01\x9c\x04\x21\x00\xcf\x80\x02\x38\x01\x04\x00\x33\x00\x7a\x88" \
+    "\x32\x00\xff\xff\xff\x00\x01\xa0\x1c\x23\x00\x26\x26\x27\x27\x23" \
+    "\x04\x28\x28\x28\x29\x23\x08\x29\x29\x2a\x2a\x01\xac\x04\x21\x00" \
+    "\x00\x01\x01\x30\x21\x23\x00\x00\x00\x00\x00\x01\xb0\x1c\x23\x00" \
+    "\x2c\x2c\x2c\x2c\x01\xc8\x20\x23\x00\x00\x00\x00\x00\x01\xb4\x1c" \
+    "\x23\x00\x2d\x2d\x2d\x2d\x23\x04\x2e\x2e\x2e\x2e\x01\xbc\x04\x31" \
+    "\x00\x00\x00\xff\x0f\x01\xc0\x1c\x23\x00\x2f\x30\x30\x30\x01\x20" \
+    "\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\xc4\x1c\x23\x00" \
+    "\x30\x30\x30\x31\x01\x20\x20\x33\x00\x00\x00\x00\x00\xff\xff\x01" \
+    "\x80\x01\xc8\x1c\x23\x00\x31\x31\x31\x31\x01\xcc\x20\x23\x00\x00" \
+    "\x00\x00\x00\x01\xcc\x1c\x23\x00\x31\x32\x32\x32\x23\x04\x32\x32" \
+    "\x32\x33\x02\x40\x01\x04\x00\x20\x00\x80\x01\x98\x1f\x33\x00\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xd4\x1c\x23\x00\x33\x33\x33\x33" \
+    "\x02\x14\x00\x04\x00\x30\x00\x00\x0c\x01\xd8\x1c\x23\x00\x33\x33" \
+    "\x34\x34\x01\x24\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01" \
+    "\xdc\x1c\x23\x00\x34\x34\x34\x34\x01\x10\x1f\x33\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x01\xe0\x04\x30\x00\x07\x07\x01\xd0\x20\x23" \
+    "\x00\x00\x00\x00\x00\x01\xe4\x1c\x23\x00\x35\x35\x35\x35\x01\xe8" \
+    "\x04\x30\x00\x07\x07\x01\xec\x1c\x23\x00\x36\x36\x36\x36\x23\x04" \
+    "\x36\x36\x37\x37\x01\x28\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f" \
+    "\x0f\x01\xf4\x1c\x23\x00\x37\x37\x37\x37\x01\x00\x1e\x33\x00\x00" \
+    "\x00\x00\x00\x0f\x0f\x0f\x0f\x01\xf8\x1c\x23\x00\x37\x37\x37\x37" \
+    "\x02\xd4\x00\x04\x00\x30\x00\x01\x03\x01\xfc\x1c\x23\x00\x38\x38" \
+    "\x38\x38\x23\x04\x00\x00\x00\x00\x01\x80\x0b\x31\x00\x00\x00\xcf" \
+    "\x0f\x01\x04\x1d\x23\x00\x00\x00\x00\x00\x23\x04\x06\x0c\x10\x12" \
+    "\x01\x44\x20\x23\x00\x00\x00\x00\x00\x01\xb0\x0c\x23\x00\xab\x90" \
+    "\x00\x00\x01\x0c\x1d\x23\x00\x15\x17\x18\x19\x23\x04\x1b\x1c\x1d" \
+    "\x1e\x01\x40\x09\x31\x00\xff\x07\xff\x0f\x01\x14\x1d\x23\x00\x1e" \
+    "\x20\x20\x21\x01\x28\x0c\x23\x00\x00\x10\x5c\x2c\x01\x18\x1d\x23" \
+    "\x00\x22\x22\x23\x24\x01\x84\x0b\x23\x00\x80\x07\x38\x04\x01\x1c" \
+    "\x1d\x23\x00\x24\x25\x25\x26\x23\x04\x26\x26\x27\x27\x01\x24\x05" \
+    "\x20\x00\x08\x01\x28\x1d\x23\x00\x29\x29\x2a\x2a\x23\x04\x2a\x2b" \
+    "\x2b\x2b\x23\x08\x2c\x2c\x2c\x2c\x01\x88\x1f\x33\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x01\x34\x1d\x23\x00\x2d\x2d\x2d\x2d\x23\x04" \
+    "\x2e\x2e\x2e\x2e\x23\x08\x2f\x2f\x2f\x2f\x01\x24\x20\x33\x00\x00" \
+    "\x00\x00\x00\xff\xff\x01\x80\x01\x40\x1d\x23\x00\x2f\x30\x30\x30" \
+    "\x01\xe0\x1c\x23\x00\x34\x35\x35\x35\x23\x64\x30\x30\x30\x31\x23" \
+    "\x68\x31\x31\x31\x31\x01\x8c\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x33\x10\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x4c\x1d\x23" \
+    "\x00\x31\x32\x32\x32\x01\x50\x05\x21\x00\x57\x80\x21\x04\x70\x00" \
+    "\x21\x08\x70\x00\x01\xe4\x04\x30\x00\x07\x07\x21\x78\x66\x80\x01" \
+    "\x60\x1d\x23\x00\x34\x35\x35\x35\x01\x90\x0b\x23\x00\x00\x00\x00" \
+    "\x00\x01\x64\x1d\x23\x00\x35\x35\x35\x35\x01\x68\x05\x31\x00\x00" \
+    "\x02\xff\x07\x31\x04\x00\x02\xff\x07\x30\x08\x00\x0f\x01\xe8\x1c" \
+    "\x23\x00\x35\x36\x36\x36\x01\x80\x0d\x31\x00\x00\x00\xcf\x0f\x01" \
+    "\x74\x1d\x23\x00\x37\x37\x37\x37\x01\x40\x20\x33\x00\x00\x00\x00" \
+    "\x00\x00\x03\x33\xc0\x01\x78\x05\x31\x00\x00\x00\xff\x03\x01\x94" \
+    "\x0b\x23\x00\x00\x00\x00\x00\x01\x7c\x05\x31\x00\xff\x03\xff\x03" \
+    "\x31\x04\x00\x00\xff\x03\x01\x40\x0a\x33\x00\x05\x00\x02\x00\xcf" \
+    "\x00\x03\x03\x01\xb4\x0c\x33\x00\x00\x00\x00\x00\x0f\xff\xff\xff" \
+    "\x01\x84\x05\x31\x00\xff\x03\xff\x03\x31\x04\xff\x03\xff\x03\x31" \
+    "\x08\xff\x03\xff\x03\x31\x0c\xff\x03\xff\x03\x01\x98\x0b\x23\x00" \
+    "\x00\x00\x00\x00\x01\x94\x1d\x23\x00\x24\x25\x25\x26\x23\x04\x26" \
+    "\x26\x27\x27\x33\xb0\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x23\x08\x28" \
+    "\x28\x28\x29\x23\x0c\x29\x29\x2a\x2a\x23\x10\x2a\x2b\x2b\x2b\x02" \
+    "\x30\x00\x04\x00\x33\x00\xff\x0f\x00\x00\xff\x0f\xfb\x00\x01\xa8" \
+    "\x1d\x23\x00\x2c\x2c\x2c\x2c\x01\x9c\x0b\x30\x00\x00\x0f\x01\xac" \
+    "\x1d\x23\x00\x2d\x2d\x2d\x2d\x23\x04\x2e\x2e\x2e\x2e\x01\x48\x0a" \
+    "\x23\x00\x00\x00\x00\x00\x01\xb4\x1d\x23\x00\x2f\x2f\x2f\x2f\x01" \
+    "\x28\x20\x33\x00\x00\x00\x00\x00\xff\xff\x01\x80\x01\xb8\x1d\x23" \
+    "\x00\x2f\x30\x30\x30\x23\x04\x30\x30\x30\x31\x23\x08\x31\x31\x31" \
+    "\x31\x01\xa0\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xc4" \
+    "\x1d\x23\x00\x31\x32\x32\x32\x01\xc0\x20\x33\x00\x00\x00\x00\x00" \
+    "\x00\x03\x33\xc0\x01\xc8\x1d\x23\x00\x32\x32\x32\x33\x01\x4c\x0a" \
+    "\x23\x00\x20\x0c\x00\x00\x01\xcc\x1d\x23\x00\x33\x33\x33\x33\x23" \
+    "\x04\x33\x33\x34\x34\x23\x08\x34\x34\x34\x34\x23\x0c\x34\x35\x35" \
+    "\x35\x01\xa4\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xdc" \
+    "\x1d\x23\x00\x35\x35\x35\x35\x01\xe0\x05\x30\x00\x00\x17\x01\x50" \
+    "\x0a\x21\x00\x80\x07\x01\xe4\x1d\x23\x00\x36\x36\x36\x36\x33\x24" \
+    "\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x23\x04\x36\x36\x37\x37\x01\x84" \
+    "\x0d\x23\x00\x80\x07\x38\x04\x01\xec\x1d\x23\x00\x37\x37\x37\x37" \
+    "\x23\x04\x37\x37\x37\x37\x01\xa8\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x01\xf4\x1d\x23\x00\x38\x38\x38\x38\x23\x04\x38\x38" \
+    "\x38\x38\x01\x54\x0a\x21\x00\x38\x04\x01\xb8\x0c\x31\x00\x30\x01" \
+    "\xff\x03\x01\xfc\x1d\x23\x00\x38\x38\x38\x38\x02\x24\x01\x04\x00" \
+    "\x33\x00\x23\x00\x23\x04\xff\x00\xff\xff\x01\x00\x06\x30\x00\x00" \
+    "\x01\x01\x00\x05\x30\x00\x04\x0d\x01\x04\x06\x21\x00\x00\x00\x01" \
+    "\x30\x0c\x23\x00\x80\x90\x80\x90\x01\x08\x06\x21\x00\x00\x00\x01" \
+    "\xac\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x0c\x06\x21" \
+    "\x00\xff\xff\x02\x00\x01\x02\x00\x20\x00\x02\x01\x10\x06\x21\x00" \
+    "\xff\xff\x01\x58\x0a\x23\x00\x00\x90\x7e\x00\x01\x14\x1e\x33\x00" \
+    "\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x33\x04\x00\x00\x00\x00\x0f\x0f" \
+    "\x0f\x0f\x01\x04\x05\x20\x00\x14\x01\x1c\x1e\x33\x00\x00\x00\x00" \
+    "\x00\x0f\x0f\x0f\x0f\x02\x34\x00\x04\x00\x23\x00\xbb\x03\x00\x00" \
+    "\x01\x20\x06\x30\x00\x04\x0d\x01\xb0\x1f\x33\x00\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x01\x24\x06\x20\x00\x32\x21\x04\x60\x40\x01\x5c" \
+    "\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x2c\x1e\x33\x00" \
+    "\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x2c\x20\x33\x00\x00\x00\x00" \
+    "\x00\xff\xff\x01\x80\x01\x30\x1e\x33\x00\x00\x00\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x01\x08\x05\x21\x00\x60\x40\x01\x34\x1e\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x33\x04\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x33\x08\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x40\x06\x30\x00\x00" \
+    "\x0c\x01\x60\x1e\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x44" \
+    "\x06\x30\x00\x20\x38\x31\x04\x80\x07\xff\x0f\x01\x0c\x09\x21\x00" \
+    "\x10\x00\x01\x4c\x06\x31\x00\x38\x04\xff\x0f\x01\x00\x09\x21\x00" \
+    "\x80\x07\x02\x0c\x01\x04\x00\x23\x00\x89\x16\x00\x00\x01\x50\x06" \
+    "\x31\x00\x80\x07\xff\x07\x01\xb8\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x01\x54\x06\x31\x00\x38\x04\xff\x0f\x33\x04\x00\x00" \
+    "\x10\x00\xff\xff\xff\x00\x01\x64\x0a\x23\x00\x00\x1e\x00\x00\x01" \
+    "\x5c\x06\x30\x00\x00\x0f\x01\x0c\x1e\x33\x00\x00\x00\x00\x00\x0f" \
+    "\x0f\x0f\x0f\x01\x60\x06\x33\x00\x00\x00\x10\x00\xff\xff\xff\x00" \
+    "\x01\x10\x09\x21\x00\x10\x00\x01\x88\x0d\x23\x00\x00\x00\x00\x00" \
+    "\x01\x64\x06\x30\x00\x00\x0f\x30\x04\x00\x01\x01\xbc\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x6c\x1e\x33\x00\x00\x00\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x02\xc8\x00\x04\x00\x23\x00\xc9\xf8\xbb\x31" \
+    "\x01\x00\x0d\x31\x00\x02\x00\xcf\x0f\x01\x70\x1e\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\x68\x0a\x30\x00\x00\x01\x01\xbc\x0c" \
+    "\x23\x00\x00\x00\x00\x00\x01\x74\x1e\x33\x00\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x33\x04\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01\x14\x09" \
+    "\x31\x00\x20\x00\xff\x01\x01\x7c\x1e\x33\x00\x00\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x01\x80\x06\x21\x00\x2f\x00\x01\xc0\x0b\x23\x00\x00" \
+    "\x00\x00\x00\x01\x84\x06\x21\x00\x9d\x00\x02\x04\x01\x02\x00\x30" \
+    "\x00\x00\x01\x01\x88\x06\x21\x00\x10\x00\x21\x04\x1a\x80\x21\x08" \
+    "\x57\x80\x01\x18\x09\x31\x00\x20\x00\xff\x01\x01\x94\x06\x21\x00" \
+    "\x70\x00\x02\x38\x00\x04\x00\x23\x00\xc0\x01\x00\x80\x01\x98\x06" \
+    "\x21\x00\x70\x00\x01\xc4\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x01\x9c\x06\x21\x00\x66\x80\x21\x04\x0a\x80\x31\x08\x00\x00" \
+    "\xff\x07\x01\x30\x20\x33\x00\x00\x00\x00\x00\xff\xff\x01\x80\x01" \
+    "\xa8\x06\x31\x00\x00\x02\xff\x07\x01\x1c\x09\x20\x00\x0c\x01\xac" \
+    "\x06\x31\x00\x00\x02\xff\x07\x30\x04\x00\x0f\x01\xc8\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xb4\x1e\x33\x00\x00\x00\x00" \
+    "\x00\x0f\x0f\x0f\x0f\x33\x14\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01" \
+    "\xb8\x06\x31\x00\x00\x00\xff\x03\x31\x04\xff\x03\xff\x03\x31\x08" \
+    "\x00\x00\xff\x03\x01\x20\x05\x20\x00\x08\x01\xc4\x06\x31\x00\xff" \
+    "\x03\xff\x03\x01\x04\x09\x21\x00\x38\x04\x01\xc8\x06\x31\x00\xff" \
+    "\x03\xff\x03\x01\xcc\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x01\xcc\x06\x31\x00\xff\x03\xff\x03\x31\x04\xff\x03\xff\x03\x02" \
+    "\x40\x00\x02\x00\x33\x00\x00\x00\x00\x00\xff\x1f\xff\x1f\x01\xd4" \
+    "\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x33\x04\x00\x00\x00" \
+    "\x00\x0f\x0f\x0f\x0f\x01\x24\x1d\x23\x00\x28\x28\x28\x29\x01\x8c" \
+    "\x0d\x23\x00\x00\x00\x00\x00\x01\xdc\x1e\x33\x00\x00\x00\x00\x00" \
+    "\x0f\x0f\x0f\x0f\x01\xe0\x06\x30\x00\x00\x17\x01\xd0\x1f\x33\x00" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x04\x0d\x23\x00\x80\x07\x38" \
+    "\x04\x01\x28\x09\x33\x00\x20\x00\x40\x00\xff\x00\xff\x00\x02\x08" \
+    "\x01\x04\x00\x30\x00\x00\x01\x01\x00\x07\x30\x00\x00\x01\x01\x80" \
+    "\x1e\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x04\x07\x21\x00" \
+    "\x00\x00\x21\x04\x00\x00\x01\x2c\x0d\x23\x00\x00\x00\x6a\x36\x02" \
+    "\x80\x00\x04\x00\x23\x00\x00\x00\x00\x00\x01\x0c\x07\x21\x00\xff" \
+    "\xff\x01\x00\x21\x33\x00\x00\x00\x00\x00\x00\x03\x33\xc0\x02\x3c" \
+    "\x00\x04\x00\x33\x00\x18\x07\x22\x00\xff\x0f\xff\xff\x01\x10\x07" \
+    "\x21\x00\xff\xff\x01\x14\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x33\x04\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x84\x1e\x33\x00" \
+    "\x0f\x0f\x0f\x00\x0f\x0f\x0f\x0f\x33\x98\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x01\x20\x07\x30\x00\x04\x0d\x01\x30\x09\x33\x00\x01\x01" \
+    "\x02\x03\x0f\x0f\x0f\x0f\x01\x24\x07\x20\x00\x46\x21\x04\x60\x40" \
+    "\x02\x44\x01\x04\x00\x20\x00\x84\x01\x2c\x1f\x33\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x33\x04\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01" \
+    "\x88\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x33\xac\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\x4c\x09\x30\x00\x00\x07\x01\x34\x09" \
+    "\x30\x00\x04\x0f\x01\x3c\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x01\x08\x09\x31\x00\x04\x08\x1f\x1f\x01\x40\x07\x30\x00\x00" \
+    "\x0c\x01\xe0\x1f\x30\x00\x0f\x0f\x01\x44\x07\x30\x00\x20\x30\x02" \
+    "\x00\x01\x04\x00\x21\x00\x00\x00\x01\x48\x07\x31\x00\x20\x0a\xff" \
+    "\x0f\x01\x8c\x1e\x33\x00\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x4c" \
+    "\x07\x31\x00\x98\x07\xff\x0f\x31\x04\x80\x07\xff\x07\x01\x38\x0d" \
+    "\x31\x00\x30\x01\xff\x03\x23\x58\x00\x00\x00\x00\x01\x54\x07\x31" \
+    "\x00\x38\x04\xff\x0f\x33\x04\x99\x99\x15\x00\xff\xff\xff\x00\x30" \
+    "\x08\x02\x0f\x01\x08\x0d\x23\x00\x00\x70\xd7\x3d\x01\x60\x07\x33" \
+    "\x00\xcc\xcc\x1c\x00\xff\xff\xff\x00\x01\x90\x1e\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\x64\x07\x30\x00\x00\x0f\x30\x04\x00" \
+    "\x01\x01\x3c\x0d\x23\x00\x00\x00\x00\x00\x01\x80\x0c\x31\x00\x00" \
+    "\x00\xcf\x0f\x01\x44\x09\x31\x00\xff\x0b\xff\x0f\x01\x6c\x1f\x33" \
+    "\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x33\x04\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x33\x08\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x02\x0c\x01" \
+    "\x02\x00\x30\x00\x10\x11\x01\x78\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x01\x94\x1e\x33\x00\x0f\x0f\x00\x00\x0f\x0f\x0f\x0f" \
+    "\x33\xe8\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\x80\x07\x21\x00\x2f" \
+    "\x00\x01\x40\x05\x21\x00\x2f\x00\x02\x84\x00\x04\x00\x23\x00\x00" \
+    "\x00\x00\x00\x01\x84\x07\x21\x00\x9d\x00\x01\x04\x21\x23\x00\x00" \
+    "\x00\x00\x00\x01\x88\x07\x21\x00\x10\x00\x21\x04\x1a\x80\x21\x08" \
+    "\x57\x80\x01\x98\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f\x01" \
+    "\x94\x07\x21\x00\x70\x00\x21\x04\x70\x00\x01\x44\x05\x21\x00\x9d" \
+    "\x00\x01\x9c\x07\x21\x00\x66\x80\x21\x04\x0a\x80\x31\x08\x00\x00" \
+    "\xff\x07\x31\x0c\x00\x02\xff\x07\x01\x9c\x1e\x33\x00\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x01\xac\x07\x31\x00\x00\x02\xff\x07\x02\x1c" \
+    "\x01\x04\x00\x21\x00\x00\x00\x01\xb0\x07\x30\x00\x00\x0f\x01\x48" \
+    "\x05\x21\x00\x10\x00\x01\xb4\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x01\xb8\x07\x31\x00\x00\x00\xff\x03\x31\x04\xff\x03\xff" \
+    "\x03\x31\x08\x00\x00\xff\x03\x01\xa0\x1e\x33\x00\x0f\x0f\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x01\xc4\x07\x31\x00\xff\x03\xff\x03\x31\x04\xff" \
+    "\x03\xff\x03\x01\x4c\x05\x21\x00\x1a\x80\x01\xcc\x07\x31\x00\xff" \
+    "\x03\xff\x03\x31\x04\xff\x03\xff\x03\x01\xd4\x1f\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\x0c\x0d\x23\x00\x00\x00\x00\x30\x01" \
+    "\xd8\x1f\x33\x00\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x01\xa4\x1e\x33" \
+    "\x00\x0f\x00\x00\x00\x0f\x0f\x0f\x0f\x01\xdc\x1f\x33\x00\x0f\x0f" \
+    "\x0f\x0f\x0f\x0f\x0f\x0f\x01\xe0\x07\x30\x00\x00\x17\x01\x50\x1d" \
+    "\x23\x00\x32\x32\x32\x33\x01\x84\x0c\x23\x00\x80\x07\x38\x04\x01" \
+    "\x40\x0c\x23\x00\x11\x00\x00\x00\x02\x10\x01\x02\x00\x23\x00\x00" \
+    "\x40\xe3\x29\x01\xa8\x1e\x33\x00\x00\x00\x00\x00\x0f\x0f\x0f\x0f" \
+    "\x02\xcc\x00\x04\x00\x23\x00\x51\x05\x00\x00\x01\x54\x1d\x23\x00" \
+    "\x33\x33\x33\x33\x02\x88\x00\x04\x00\x23\x00\x00\x00\x00\x00\x01" \
+    "\x08\x21\x23\x00\x00\x00\x00\x00\x00"
+
+#define SENSOR_ISP_SEQUENCE_DEFAULT_FS_HDR    0
+#define SENSOR_ISP_SEQUENCE_DEFAULT_LINEAR    1
+#define SENSOR_ISP_SEQUENCE_DEFAULT_SETTINGS    2
+
+#endif /* __ISP_SENSOR_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/log.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/log.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/log.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/log.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,2 @@
+#include "log.h"
+const char * const log_level[LOG_MAX] = {"","EMERG","ALERT","CRIT","ERR","WARNING","NOTICE","INFO","DEBUG"};
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/log.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/log.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/log.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/log.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef LOG_H_INCLUDED
+#define LOG_H_INCLUDED
+
+#include <apical-isp/apical.h>
+
+enum {
+	LOG_NOTHING,
+	LOG_EMERG,
+	LOG_ALERT,
+	LOG_CRIT,
+	LOG_ERR,
+	LOG_WARNING,
+	LOG_NOTICE,
+	LOG_INFO,
+	LOG_DEBUG,
+	LOG_MAX
+};
+
+extern const char * const log_level[LOG_MAX];
+
+#define FILE (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
+
+int printk(const char *fmt,...);
+
+#define LOG(level,fmt,...) if((level)<=FW_LOG_LEVEL) printk("%s: %s(%d) %s: " fmt "\n",FILE,__func__,__LINE__,log_level[level],##__VA_ARGS__)
+
+#endif // LOG_H_INCLUDED
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/Makefile kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/Makefile
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/Makefile	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,7 @@
+# Makefile for APICAL ISP video driver
+
+
+obj-y += tx-isp-core-tuning.o tx-isp-core.o apical_dynamic_calibrations.o apical_static_calibrations.o \
+	system_isp_io.o log.o system_io.o apical_calibrations.o apical_calibrations_init.o tx-isp-load-parameters.o \
+	apical_custom_initialization.o ApicalDefault.o \
+	system_i2c.o system_spi.o system_timer.o system_uart.o system_semaphore.o sensor_drv.o system_chardev.o
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/sensor_drv.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/sensor_drv.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/sensor_drv.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/sensor_drv.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,343 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+/*-----------------------------------------------------------------------------
+  Generated by CSRCGEN compiler - do not edit
+  -----------------------------------------------------------------------------*/
+
+#include "sensor_drv.h"
+#include <apical-isp/apical_types.h>
+#include "spi_defs.h"
+#include <apical-isp/apical_configuration.h>
+#include <apical-isp/apical_calibrations.h>
+#include "apical_modulation.h"
+#include <apical-isp/system_isp_io.h>
+#include "sensor_init.h"
+#include <apical-isp/apical_math.h>
+
+EXPORT_SYMBOL(log2_fixed_to_fixed);
+EXPORT_SYMBOL(math_exp2);
+//-------------------------------------------------------------------------------------
+
+static struct tx_isp_core_device *ispcore = NULL;
+
+//--------------------RESET------------------------------------------------------------
+static void sensor_hw_reset_enable(void)
+{
+	//	printk("^^^ %s ^^^\n",__func__);
+	//	system_reset_sensor(0);
+}
+static void sensor_hw_reset_disable(void)
+{
+	//	printk("^^^ %s ^^^\n",__func__);
+	//	system_reset_sensor(3);
+}
+//static uint32_t x;
+//-------------------------------------------------------------------------------------
+static int32_t sensor_alloc_analog_gain(int32_t gain, sensor_context_t *p_ctx)
+{
+	unsigned int again = 0;
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+
+	gain = attr->sensor_ctrl.alloc_again(gain, LOG2_GAIN_SHIFT, &again);
+	p_ctx->again = again;
+	/* printk("result gain is 0x%x\n",again); */
+	return gain;
+}
+
+static int32_t sensor_alloc_digital_gain(int32_t gain, sensor_context_t *p_ctx)
+{
+	unsigned int dgain = 0;
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+
+	gain = attr->sensor_ctrl.alloc_dgain(gain, LOG2_GAIN_SHIFT, &dgain);
+	p_ctx->dgain = dgain;
+	/* printk("result gain is 0x%x\n",p_ctx->dgain); */
+	return gain;
+}
+
+static void sensor_alloc_integration_time(uint16_t *int_time, sensor_context_t *p_ctx)
+{
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	//	printk("^^^ %s ^^^\n",__func__);
+	if(*int_time < attr->min_integration_time_native)
+		*int_time = attr->min_integration_time_native;
+	if(*int_time > attr->max_integration_time_native - 1)
+		*int_time = attr->max_integration_time_native - 1;
+}
+
+static void sensor_set_integration_time(apical_sbus_ptr_t p_sbus, uint16_t int_time, sensor_param_t* param)
+{
+#if 0
+	int32_t expo;
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+
+	expo = int_time;
+	/* printk("expo is 0x%x,int_time is 0x%x\n",expo,int_time); */
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_INT_TIME;
+	ioctl.value = expo;
+
+	if(ioctl.value != attr->integration_time){
+		/* printk("111interation time is 0x%x\n",ioctl.value); */
+		attr->integration_time = expo;
+		arg.value = (int)&ioctl;
+		sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+	}
+#else
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	if(int_time != attr->integration_time){
+		attr->integration_time = int_time;
+		ispcore->i2c_msgs[TX_ISP_I2C_SET_INTEGRATION].flag = 1;
+		ispcore->i2c_msgs[TX_ISP_I2C_SET_INTEGRATION].value = int_time;
+	}
+#endif
+}
+
+static void sensor_set_analog_gain(apical_sbus_ptr_t p_sbus,uint32_t again_reg_val, sensor_context_t *p_ctx)
+{
+#if 0
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_AGAIN;
+	ioctl.value = again_reg_val;
+
+	if(ioctl.value != attr->again){
+		attr->again = again_reg_val;
+		/* printk("set again is 0x%x\n",again_reg_val); */
+		arg.value = (int)&ioctl;
+		sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+	}
+#else
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	if(again_reg_val != attr->again){
+		attr->again = again_reg_val;
+		ispcore->i2c_msgs[TX_ISP_I2C_SET_AGAIN].flag = 1;
+		ispcore->i2c_msgs[TX_ISP_I2C_SET_AGAIN].value = again_reg_val;
+	}
+#endif
+}
+
+static void sensor_set_digital_gain(apical_sbus_ptr_t p_sbus, uint32_t dgain_reg_val, sensor_context_t *p_ctx)
+{
+#if 0
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_DGAIN;
+	ioctl.value = dgain_reg_val;
+
+	arg.value = (int)&ioctl;
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+#else
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	if(dgain_reg_val != attr->dgain){
+		attr->dgain = dgain_reg_val;
+		ispcore->i2c_msgs[TX_ISP_I2C_SET_DGAIN].flag = 1;
+		ispcore->i2c_msgs[TX_ISP_I2C_SET_DGAIN].value = dgain_reg_val;
+	}
+#endif
+}
+
+static uint16_t sensor_get_normal_fps(sensor_param_t* param)
+{
+	unsigned int fps = ispcore->vin.fps;
+	return (((fps >> 16) / (fps & 0xffff)) << 8) + ((((fps >> 16) % (fps & 0xffff)) << 8) / (fps & 0xffff));
+}
+
+static uint16_t sensor_read_black_pedestal(apical_sbus_ptr_t p_sbus,int i,uint32_t gain)
+{
+	unsigned int black = 0;
+#if USE_BLACK_CALIBRATION
+	switch(i)
+	{
+		case 0: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_R_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_R_LINEAR));
+		case 1: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_GR_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_GR_LINEAR));
+		case 2: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_GB_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_GB_LINEAR));
+		case 3: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_B_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_B_LINEAR));
+	}
+#else
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_BLACK_LEVEL;
+	ioctl.value = i;
+
+	arg.value = (int)&ioctl;
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+	if(arg.ret)
+		printk("## ERROR: %s[%d] ##\n", __func__,__LINE__);
+#endif
+	return black;
+}
+
+static void sensor_set_mode(apical_sbus_ptr_t p_sbus, uint8_t mode, sensor_param_t* param)
+{
+	unsigned char tx_mode = TX_ISP_SENSOR_PREVIEW_RES_MAX_FPS;
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	struct v4l2_mbus_framefmt *mbus = &(ispcore->vin.mbus);
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	if(mode == SENSOR_SEQUENCE_PREVIEW_RES_MAX_FPS){
+		tx_mode = TX_ISP_SENSOR_PREVIEW_RES_MAX_FPS;
+	}else if(mode == SENSOR_SEQUENCE_FULL_RES_MAX_FPS){
+		tx_mode = TX_ISP_SENSOR_FULL_RES_MAX_FPS;
+	}else{
+		printk("^^^ %s mode(%d) is invalid! ^^^\n",__func__, mode);
+		return;
+	}
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_RESIZE;
+	ioctl.value = tx_mode;
+
+	arg.value = (int)&ioctl;
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+
+	param->active.width = mbus->width;
+	param->active.height = mbus->height;
+	param->total.width = attr->total_width;
+	param->total.height = attr->total_height;
+	param->integration_time_min = attr->min_integration_time;
+	param->integration_time_max = attr->max_integration_time;
+	param->integration_time_long_max = attr->max_integration_time;
+	param->integration_time_limit = attr->integration_time_limit;
+	param->mode = mode;
+}
+
+static void sensor_start_changes(apical_sbus_ptr_t p_sbus, sensor_context_t *p_ctx)
+{
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SUBDEV_PREPARE_CHANGE;
+	return;
+	arg.value = (int)&ioctl;
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+	//	printk("^^^ %s ^^^\n",__func__);
+	// Does not support this function!
+}
+
+static void sensor_end_changes(apical_sbus_ptr_t p_sbus, sensor_context_t *p_ctx)
+{
+	struct v4l2_subdev *sd = &ispcore->sd;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SUBDEV_FINISH_CHANGE;
+	return;
+	arg.value = (int)&ioctl;
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+	//	printk("^^^ %s ^^^\n",__func__);
+	// Does not support this function!
+}
+
+static uint16_t sensor_get_id(apical_sbus_ptr_t p_sbus)
+{
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+	return attr->chip_id;
+}
+
+static void sensor_set_wdr_mode(apical_sbus_ptr_t p_sbus, uint8_t mode, sensor_param_t* param)
+{
+	//	printk("^^^ %s ^^^\n",__func__);
+	// This sensor does not support native WDR
+}
+
+static uint8_t sensor_fps_control(apical_sbus_ptr_t p_sbus, uint8_t fps, sensor_param_t* param)
+{
+	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
+
+	param->total.width = attr->total_width;
+	param->total.height = attr->total_height;
+	param->integration_time_min = attr->min_integration_time;
+	param->integration_time_max = attr->max_integration_time;
+	param->integration_time_long_max = attr->max_integration_time;
+	param->integration_time_limit = attr->integration_time_limit;
+	return ispcore->vin.fps >> 16;
+}
+
+static void sensor_disable_isp(apical_sbus_ptr_t p_sbus)
+{
+}
+static uint32_t sensor_get_lines_per_second(apical_sbus_ptr_t p_sbus,sensor_param_t* param)
+{
+	uint32_t lines_per_second=0;
+	return lines_per_second;
+}
+
+static inline unsigned int fixed16_add_fixed16(unsigned int f1, unsigned int f2)
+{
+	unsigned int i = ((f1 >> TX_ISP_GAIN_FIXED_POINT) + (f2 >> TX_ISP_GAIN_FIXED_POINT)) << TX_ISP_GAIN_FIXED_POINT;
+	unsigned int p = (f1 & ((1 << TX_ISP_GAIN_FIXED_POINT) - 1)) + (f2 & ((1 << TX_ISP_GAIN_FIXED_POINT) - 1));
+	return i + p;
+}
+//--------------------Initialization------------------------------------------------------------
+void sensor_init(sensor_control_t *ctrl)
+{
+	struct tx_isp_video_in *vin = &ispcore->vin;
+	struct tx_isp_sensor_attribute *attr = vin->attr;
+	if(attr->cbus_type == TX_SENSOR_CONTROL_INTERFACE_I2C){
+		ctrl->sbus.mask = attr->cbus_mask;
+		ctrl->sbus.device = attr->cbus_device;
+		apical_sbus_i2c_init(&ctrl->sbus);
+	}else if(attr->cbus_type == TX_SENSOR_CONTROL_INTERFACE_SPI){
+		ctrl->sbus.mask = attr->cbus_mask;
+		ctrl->sbus.control = attr->cbus_device;
+		apical_sbus_spi_init(&ctrl->sbus);
+	}else
+		return;
+
+	ctrl->param.again_log2_max = attr->max_again;
+	ctrl->param.dgain_log2_max= attr->max_dgain;
+	ctrl->param.integration_time_apply_delay = attr->integration_time_apply_delay;
+	ctrl->param.analog_gain_apply_delay = attr->again_apply_delay;
+	ctrl->param.digital_gain_apply_delay = attr->dgain_apply_delay;
+	ctrl->hw_reset_disable = sensor_hw_reset_disable;
+	ctrl->hw_reset_enable = sensor_hw_reset_enable;
+	ctrl->alloc_analog_gain = sensor_alloc_analog_gain;
+	ctrl->alloc_digital_gain = sensor_alloc_digital_gain;
+	ctrl->alloc_integration_time = sensor_alloc_integration_time;
+	ctrl->set_integration_time = sensor_set_integration_time;
+	ctrl->start_changes = sensor_start_changes;
+	ctrl->end_changes = sensor_end_changes;
+	ctrl->set_analog_gain = sensor_set_analog_gain;
+	ctrl->set_digital_gain = sensor_set_digital_gain;
+	ctrl->get_normal_fps = sensor_get_normal_fps;
+	ctrl->read_black_pedestal = sensor_read_black_pedestal;
+	ctrl->set_mode = sensor_set_mode;
+	ctrl->set_wdr_mode = sensor_set_wdr_mode;
+	ctrl->fps_control = sensor_fps_control;
+	ctrl->get_id = sensor_get_id;
+	ctrl->disable_isp=sensor_disable_isp;
+	ctrl->get_lines_per_second=sensor_get_lines_per_second;
+}
+//********************CONSTANT SECTION END*********************************************
+int apical_sensor_early_init(struct tx_isp_core_device *core)
+{
+	if(!core)
+		return -ISP_ERROR;
+	if(!ispcore)
+		ispcore = core;
+	return ISP_SUCCESS;
+}
+//*************************************************************************************
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/sensor_drv.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/sensor_drv.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/sensor_drv.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/sensor_drv.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,114 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __SENSOR_DRV_H__
+#define __SENSOR_DRV_H__
+
+#include <apical-isp/apical_types.h>
+#include <apical-isp/apical_firmware_config.h>
+#include <apical-isp/apical_sensor_config.h>
+#include <apical-isp/apical_interface_config.h>
+#include "apical_sbus.h"
+#include "apical_sbus_i2c.h"
+#include "apical_sbus_spi.h"
+#include "tx-isp-core.h"
+
+typedef struct _sensor_context_t
+{
+	uint16_t again;
+	uint16_t dgain;
+	uint8_t n_context;
+	uint8_t wdr_mode;
+	uint16_t again_x2;
+	uint16_t dgain_coarse;
+	uint16_t dgain_fine;
+	uint8_t column_buffer_gain_index;
+} sensor_context_t;
+
+typedef struct _image_resolution_t
+{
+	uint16_t width;
+	uint16_t height;
+} image_resolution_t;
+
+typedef struct _sensor_param_t
+{
+	uint8_t mode;
+	image_resolution_t total;
+	image_resolution_t active;
+	sensor_context_t sensor_ctx;
+	int32_t again_log2_max;
+	int32_t dgain_log2_max;
+	uint32_t integration_time_min;
+	uint32_t integration_time_max;
+	uint32_t integration_time_long_max;
+	uint32_t integration_time_limit;
+	uint16_t day_light_integration_time_max;
+	uint8_t integration_time_apply_delay;
+	uint8_t analog_gain_apply_delay;
+	uint8_t digital_gain_apply_delay;
+	int32_t xoffset;
+	int32_t yoffset;
+	int32_t anti_flicker_pos;
+	uint32_t lines_per_second;
+} sensor_param_t;
+typedef struct _sensor_control_t
+{
+	apical_sbus_t sbus;
+	sensor_param_t param;
+	void (*hw_reset_disable)(void);
+	void (*hw_reset_enable)(void);
+	int32_t (*alloc_analog_gain)(int32_t gain, sensor_context_t *p_ctx);
+	int32_t (*alloc_digital_gain)(int32_t gain, sensor_context_t *p_ctx);
+
+	void (*alloc_integration_time)(uint16_t *int_time
+#if SENSOR_EXP_NUMBER >= 3
+			,uint16_t* int_time_M
+#endif
+#if SENSOR_EXP_NUMBER >= 2
+			,uint16_t* int_time_L
+#endif
+			,sensor_context_t *p_ctx);
+
+	void (*set_integration_time)(apical_sbus_ptr_t, uint16_t int_time
+#if SENSOR_EXP_NUMBER >= 3
+			,uint16_t int_time_M
+#endif
+#if SENSOR_EXP_NUMBER >= 2
+			,uint16_t int_time_L
+#endif
+			,sensor_param_t *param);
+
+	void (*start_changes)(apical_sbus_ptr_t, sensor_context_t *p_ctx);
+	void (*end_changes)(apical_sbus_ptr_t, sensor_context_t *p_ctx);
+	void (*set_analog_gain)(apical_sbus_ptr_t, uint32_t again_reg_val, sensor_context_t *p_ctx);
+	void (*set_digital_gain)(apical_sbus_ptr_t, uint32_t dgain_reg_val, sensor_context_t *p_ctx);
+#if SENSOR_CROP_OFFSET
+	uint32_t (*set_xoffset)(apical_sbus_ptr_t, uint32_t xoffset, sensor_context_t *p_ctx);
+	uint32_t (*set_yoffset)(apical_sbus_ptr_t, uint32_t yoffset, sensor_context_t *p_ctx);
+#endif
+	uint16_t (*get_normal_fps)(sensor_param_t *param);
+	uint16_t (*read_black_pedestal)(apical_sbus_ptr_t, int i, uint32_t gain);
+	void (*set_mode)(apical_sbus_ptr_t, uint8_t mode, sensor_param_t *param);
+	void (*set_wdr_mode)(apical_sbus_ptr_t, uint8_t wdr, sensor_param_t *param);
+	uint8_t (*fps_control)(apical_sbus_ptr_t, uint8_t fps, sensor_param_t *param);
+	uint16_t (*get_id)(apical_sbus_ptr_t);
+	void (*disable_isp)(apical_sbus_ptr_t);
+	uint32_t (*get_lines_per_second)(apical_sbus_ptr_t, sensor_param_t *param);
+} sensor_control_t;
+
+typedef sensor_control_t *sensor_control_ptr_t;
+
+void sensor_init(sensor_control_ptr_t);
+int apical_sensor_early_init(struct tx_isp_core_device *core);
+
+#endif /* __SENSOR_DRV_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/sensor_init.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/sensor_init.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/sensor_init.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/sensor_init.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,33 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __SENSOR_INIT_H__
+#define __SENSOR_INIT_H__
+
+#include "apical_sbus.h"
+#include <apical-isp/apical_configuration.h>
+
+#if SENSOR_BINARY_SEQUENCE == 1
+#define sensor_load_sequence sensor_load_binary_sequence
+#else
+#define sensor_load_sequence sensor_load_array_sequence
+#endif
+
+typedef struct sensor_reg_t {
+	uint16_t address ;
+	uint16_t value ;
+} sensor_reg_t ;
+
+void sensor_load_binary_sequence(apical_sbus_ptr_t p_sbus, const char *sequence, int group);
+void sensor_load_array_sequence(apical_sbus_ptr_t p_sbus, const sensor_reg_t **sequence, int group);
+
+#endif /* __SENSOR_INIT_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/spi_defs.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/spi_defs.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/spi_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/spi_defs.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,31 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __SPI_DEFS_H__
+#define __SPI_DEFS_H__
+
+
+#define AUTO_SS_MSK 0x2000
+
+#define IE_MSK 0x1000
+
+#define LSB_MSK 0x0800
+
+#define TX_NEG_MSK 0x0400
+
+#define RX_NEG_MSK 0x0200
+
+#define GO_BUSY_MSK 0x0100
+
+#define CHAR_LEN_MSK 0x007F
+
+#endif /* __SPI_DEFS_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_chardev.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_chardev.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_chardev.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_chardev.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,210 @@
+/*-----------------------------------------------------------------------------
+	 This confidential and proprietary software/information may be used only
+		as authorized by a licensing agreement from Apical Limited
+
+				   (C) COPYRIGHT 2011 - 2015 Apical Limited
+						  ALL RIGHTS RESERVED
+
+	  The entire notice above must be reproduced on all authorized
+	   copies and copies may only be made to the extent permitted
+			 by a licensing agreement from Apical Limited.
+-----------------------------------------------------------------------------*/
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/kfifo.h>
+#include "system_chardev.h"
+#include "log.h"
+
+#define SYSTEM_CHARDEV_FIFO_SIZE 4096
+#define SYSTEM_CHARDEV_NAME "isp"
+
+/* fifo from user to fw */
+static DECLARE_KFIFO(isp_kfifo_in, char, SYSTEM_CHARDEV_FIFO_SIZE);
+
+/* fifo from fw to user */
+static DECLARE_KFIFO(isp_kfifo_out, char, SYSTEM_CHARDEV_FIFO_SIZE);
+
+/* sync between fw and user */
+static DEFINE_MUTEX(isp_lock);
+
+struct isp_client_state {
+	int id;
+	int opened;
+};
+
+#define ISP_CLIENT_INITIAL_STATE {0, 0}
+
+/* the actual state of the character device, updated immediately*/
+static struct isp_client_state isp_client_state_kernel = ISP_CLIENT_INITIAL_STATE;
+
+/* last accessed state of the character device, updated only on fw call */
+static struct isp_client_state isp_client_state_fw = ISP_CLIENT_INITIAL_STATE;
+
+/* only one client available at a time */
+static int isp_client_state_open(struct isp_client_state *state)
+{
+	if (state->opened)
+		return -EBUSY;
+
+	state->id = state->id + 1;
+	state->opened = 1;
+
+	return 0;
+}
+
+static void isp_client_state_release(struct isp_client_state *state)
+{
+	state->opened = 0;
+}
+
+static int isp_client_state_equal(struct isp_client_state *left, struct isp_client_state *right)
+{
+	return (left->id == right->id && left->opened == right->opened);
+}
+
+static void isp_client_state_assign(struct isp_client_state *left, struct isp_client_state *right)
+{
+	left->id = right->id;
+	left->opened = right->opened;
+}
+
+static int isp_fops_open(struct inode *inode, struct file *f)
+{
+	int rc;
+
+	rc = mutex_lock_interruptible(&isp_lock);
+	if (rc)
+		goto lock_failure;
+
+	rc = isp_client_state_open(&isp_client_state_kernel);
+	if (rc)
+		goto open_failure;
+
+	kfifo_reset(&isp_kfifo_in);
+	kfifo_reset(&isp_kfifo_out);
+
+open_failure:
+	mutex_unlock(&isp_lock);
+
+lock_failure:
+	return rc;
+}
+
+static int isp_fops_release(struct inode *inode, struct file *f)
+{
+	int rc;
+
+	rc = mutex_lock_interruptible(&isp_lock);
+	if (rc)
+		return rc;
+
+	isp_client_state_release(&isp_client_state_kernel);
+
+	mutex_unlock(&isp_lock);
+
+	return 0;
+}
+
+static ssize_t isp_fops_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+{
+	int rc;
+	unsigned int copied;
+
+	if (mutex_lock_interruptible(&isp_lock))
+		return -ERESTARTSYS;
+
+	rc = kfifo_from_user(&isp_kfifo_in, buf, count, &copied);
+
+	mutex_unlock(&isp_lock);
+
+	return rc ? rc : copied;
+}
+
+static ssize_t isp_fops_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+{
+	int rc;
+	unsigned int copied;
+
+	if (mutex_lock_interruptible(&isp_lock))
+		return -ERESTARTSYS;
+
+	rc = kfifo_to_user(&isp_kfifo_out, buf, count, &copied);
+
+	mutex_unlock(&isp_lock);
+
+	return rc ? rc : copied;
+}
+
+static struct file_operations isp_fops = {
+	.owner = THIS_MODULE,
+	.open = isp_fops_open,
+	.release = isp_fops_release,
+	.read = isp_fops_read,
+	.write = isp_fops_write,
+	.llseek = noop_llseek
+};
+
+
+static struct miscdevice isp_miscdevice = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = SYSTEM_CHARDEV_NAME,
+	.fops = &isp_fops
+};
+
+int system_chardev_init(void)
+{
+	int rc;
+
+	INIT_KFIFO(isp_kfifo_in);
+	INIT_KFIFO(isp_kfifo_out);
+
+	rc = misc_register(&isp_miscdevice);
+	if (rc)
+		return -1;
+
+	return 0;
+}
+
+int system_chardev_read(char *data, int size)
+{
+	int rc;
+
+	mutex_lock(&isp_lock);
+
+	if (!isp_client_state_equal(&isp_client_state_fw, &isp_client_state_kernel)) {
+		isp_client_state_assign(&isp_client_state_fw, &isp_client_state_kernel);
+		rc = -1;
+		goto done;
+	}
+
+	rc = kfifo_out(&isp_kfifo_in, data, size);
+
+done:
+	mutex_unlock(&isp_lock);
+	return rc;
+}
+
+int system_chardev_write(const char *data, int size)
+{
+	int rc;
+
+	mutex_lock(&isp_lock);
+
+	if (!isp_client_state_equal(&isp_client_state_fw, &isp_client_state_kernel)) {
+		isp_client_state_assign(&isp_client_state_fw, &isp_client_state_kernel);
+		rc = -1;
+		goto done;
+	}
+
+	rc = kfifo_in(&isp_kfifo_out, data, size);
+
+done:
+	mutex_unlock(&isp_lock);
+	return rc;
+}
+
+int system_chardev_destroy(void)
+{
+	int rc = misc_deregister(&isp_miscdevice);
+	return rc;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_chardev.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_chardev.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_chardev.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_chardev.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,21 @@
+/*-----------------------------------------------------------------------------
+	 This confidential and proprietary software/information may be used only
+		as authorized by a licensing agreement from Apical Limited
+
+				   (C) COPYRIGHT 2011 - 2015 Apical Limited
+						  ALL RIGHTS RESERVED
+
+	  The entire notice above must be reproduced on all authorized
+	   copies and copies may only be made to the extent permitted
+			 by a licensing agreement from Apical Limited.
+-----------------------------------------------------------------------------*/
+
+#ifndef SYSTEM_CHARDEV_H
+#define SYSTEM_CHARDEV_H
+
+int system_chardev_init(void);
+int system_chardev_read(char *data, int size);
+int system_chardev_write(const char *data, int size);
+int system_chardev_destroy(void);
+
+#endif /* SYSTEM_CHARDEV_H */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_i2c.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_i2c.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_i2c.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,24 @@
+#include <asm/io.h>
+#include "system_i2c.h"
+
+void I2C_init(void)
+{
+	printk("^^^ %s ^^^\n",__func__);
+}
+
+void I2C_close(void)
+{
+	printk("^^^ %s ^^^\n",__func__);
+}
+
+uint8_t I2C_write(uint8_t address, uint8_t* data, uint32_t size)
+{
+	printk("%s: {add = 0x%02x, *data = 0x%02x} size = %d\n",__func__, address, *data, size);
+	return 0;
+}
+
+uint8_t I2C_read(uint8_t address, uint8_t* data, uint32_t size)
+{
+	printk("%s: {add = 0x%02x, data = %p} size = %d\n",__func__, address, data, size);
+	return 0;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_i2c.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_i2c.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_i2c.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,15 @@
+#ifndef __SYSTEM_I2C_H__
+#define __SYSTEM_I2C_H__
+
+#include <apical-isp/apical_types.h>
+
+void I2C_init(void);
+void I2C_close(void);
+uint8_t I2C_write(uint8_t address, uint8_t* data, uint32_t size);
+uint8_t I2C_read(uint8_t address, uint8_t* data, uint32_t size);
+
+#define I2C_OK 			0
+#define I2C_NOACK 		1
+#define I2C_NOCONNECT 	2
+
+#endif /* __SYSTEM_I2C_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_io.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_io.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_io.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_io.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,45 @@
+#include <asm/io.h>
+#include <apical-isp/system_io.h>
+#include "tx-isp-core.h"
+#include <apical-isp/apical_ext_config.h>
+
+uint8_t apical_ext_sytem_mem[APICAL_EXT_SYSTEM_ADDR_MAX-APICAL_EXT_SYSTEM_ADDR_MIN+1];
+static void __iomem *apical_io_base;
+
+void system_isp_set_base_address(void *address)
+{
+	apical_io_base = address;
+}
+
+uint32_t system_isp_read_32(uint32_t addr)
+{
+	return tx_isp_readl(apical_io_base, addr);
+}
+
+uint16_t system_isp_read_16(uint32_t addr)
+{
+	return tx_isp_readw(apical_io_base, addr);
+}
+
+uint8_t  system_isp_read_8(uint32_t addr)
+{
+	return tx_isp_readb(apical_io_base, addr);
+}
+
+void system_isp_write_32(uint32_t addr, uint32_t data)
+{
+	/* if(addr >= 0x540 && addr <= 0x590 && addr != 0x570) */
+	/* 	return; */
+	tx_isp_writel(apical_io_base, addr, data);
+}
+
+void system_isp_write_16(uint32_t addr, uint16_t data)
+{
+	tx_isp_writew(apical_io_base, addr, data);
+}
+
+void system_isp_write_8( uint32_t addr, uint8_t  data)
+{
+	tx_isp_writeb(apical_io_base, addr, data);
+}
+
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_isp_io.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_isp_io.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_isp_io.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_isp_io.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,8 @@
+#include <tx-isp-common.h>
+#include <apical-isp/apical_types.h>
+
+void system_reset_sensor(uint32_t mask)
+{
+	printk("^^^ %s  ^^^\n",__func__);
+	dump_stack();
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_semaphore.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_semaphore.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_semaphore.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_semaphore.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,26 @@
+#include "system_semaphore.h"
+#include "linux/semaphore.h"
+#include "linux/slab.h"
+
+void init_semaphore(sem_t *sem)
+{
+	sem->psem = kmalloc(sizeof(struct semaphore), GFP_KERNEL | __GFP_NOFAIL);
+	sema_init(sem->psem, 1);
+}
+
+void raise_semaphore(sem_t *sem)
+{
+	up(sem->psem);
+}
+
+void wait_semaphore(sem_t *sem, uint32_t timeout_ms)
+{
+	uint32_t ignore_ret;
+	ignore_ret = down_timeout(sem->psem, msecs_to_jiffies(timeout_ms));
+}
+
+void destroy_semaphore(sem_t *sem)
+{
+	kfree(sem->psem);
+	sem->psem = NULL;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_semaphore.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_semaphore.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_semaphore.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_semaphore.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef __SEMAPHORE_H_INCLUDED
+#define __SEMAPHORE_H_INCLUDED
+//-----------------------------------------------------------------------------
+#include <apical-isp/apical_types.h>
+
+struct semaphore;
+
+typedef struct _sem_t {
+	struct semaphore *psem;
+} sem_t;
+
+//-----------------------------------------------------------------------------
+void init_semaphore(sem_t *sem);
+void raise_semaphore(sem_t *sem);
+void wait_semaphore(sem_t *sem, uint32_t timeout_ms);
+void destroy_semaphore(sem_t *sem);
+//-----------------------------------------------------------------------------
+#endif //__SEMAPHORE_H_INCLUDED
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_spi.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_spi.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_spi.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_spi.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,27 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "system_spi.h"
+
+uint32_t spi_rw32(uint32_t sel_mask,uint32_t control,uint32_t data,uint8_t data_size)
+{
+	return 0;
+}
+
+uint32_t spi_rw48(uint32_t sel_mask, uint32_t control, uint32_t addr,uint8_t addr_size, uint32_t data,uint8_t data_size)
+{
+	return 0;
+}
+
+void spi_init_access(void)
+{
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_spi.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_spi.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_spi.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,10 @@
+#if !defined(__SYSTEM_SPI_H__)
+#define __SYSTEM_SPI_H__
+
+#include <apical-isp/apical_types.h>
+
+uint32_t spi_rw32(uint32_t sel_mask, uint32_t control, uint32_t data,uint8_t data_size);
+uint32_t spi_rw48(uint32_t sel_mask, uint32_t control, uint32_t addr,uint8_t addr_size, uint32_t data,uint8_t data_size);
+void spi_init_access(void);
+
+#endif /* __SYSTEM_SPI_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_timer.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_timer.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_timer.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_timer.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,38 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/time.h>
+#include <apical-isp/apical_types.h>
+
+//================================================================================
+// timer functions (for FPS calculation)
+#if 1
+uint32_t system_timer_timestamp(void)
+{
+	unsigned long long time = sched_clock();
+	//	unsigned int ret = 0;
+	do_div(time, 1000);
+	return (uint32_t)time;
+}
+uint32_t system_timer_frequency(void)
+{
+	return 1000000;
+}
+#else
+uint32_t system_timer_timestamp(void)
+{
+	struct timeval tv;
+	unsigned long time = 0;
+	do_gettimeofday(&tv);
+	time = tv.tv_sec * 1000000 + tv.tv_usec;
+	return time;
+}
+uint32_t system_timer_frequency(void)
+{
+	return 1000000;
+}
+#endif
+void system_timer_init(void)
+{
+}
+//================================================================================
+
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_timer.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_timer.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_timer.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_timer.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,10 @@
+#if !defined(__SYSTEM_TIMER_H__)
+#define __SYSTEM_TIMER_H__
+
+#include "apical_types.h"
+
+uint32_t system_timer_timestamp(void);
+void system_timer_init(void);
+uint32_t system_timer_frequency(void);
+
+#endif /* __SYSTEM_TIMER_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_uart.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_uart.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_uart.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,20 @@
+#include "system_uart.h"
+//#include <fcntl.h>
+
+int system_uart_open(void)
+{
+	//return open("",O_RDWR|O_NONBLOCK);
+	return -1;
+}
+
+int system_uart_write(int fd, uint8_t* p, int len)
+{
+	//return write(fd, p, len);
+	return 0;
+}
+
+int system_uart_read(int fd, uint8_t* p, int len)
+{
+	//return read(fd, p, len);
+	return 0;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_uart.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_uart.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/system_uart.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/system_uart.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef __SYSTEM_UART_H__
+#define __SYSTEM_UART_H__
+
+#include <apical-isp/apical.h>
+
+int system_uart_open(void);
+int system_uart_write(int fd, uint8_t* p, int len);
+int system_uart_read(int fd, uint8_t* p, int len);
+
+#endif
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,2802 @@
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <media/v4l2-common.h>
+#include <linux/v4l2-mediabus.h>
+#include <asm/mipsregs.h>
+#include <linux/mm.h>
+#include <linux/clk.h>
+
+#include "tx-isp-core.h"
+#include "../tx-isp-video-in.h"
+
+#include <apical-isp/apical_math.h>
+#include "system_i2c.h"
+#include <apical-isp/apical_isp_io.h>
+#include <apical-isp/system_io.h>
+#include <apical-isp/apical_configuration.h>
+#include <apical-isp/system_interrupts.h>
+#include <apical-isp/apical_isp_config.h>
+#include "system_semaphore.h"
+#include "apical_command_api.h"
+#include <apical-isp/apical_isp_core_nomem_settings.h>
+#include "apical_scaler_lut.h"
+#include "sensor_drv.h"
+#include <apical-isp/apical_firmware_config.h>
+#include "tx-isp-core-tuning.h"
+
+#if ISP_HAS_CONNECTION_DEBUG
+#include "apical_cmd_interface.h"
+#endif
+
+system_tab stab ;
+#define SOFT_VERSION "H201712121018"
+#define FIRMWARE_VERSION "H01-380"
+
+#if defined(CONFIG_SOC_T10)
+static int isp_clk = ISP_CLK_960P_MODE;
+#elif defined(CONFIG_SOC_T20)
+static int isp_clk = ISP_CLK_1080P_MODE;
+#elif defined(CONFIG_SOC_T30)
+static int isp_clk = ISP_CLK_1080P_MODE;
+#endif
+module_param(isp_clk, int, S_IRUGO);
+MODULE_PARM_DESC(isp_clk, "isp core clock");
+
+/*
+   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+   manager the buffer of frame channels
+   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+ */
+static inline void init_buffer_fifo(struct list_head *fifo)
+{
+	INIT_LIST_HEAD(fifo);
+}
+
+static struct frame_channel_buffer *pop_buffer_fifo(struct list_head *fifo)
+{
+	struct frame_channel_buffer *buf;
+	if(!list_empty(fifo)){
+		buf = list_first_entry(fifo, struct frame_channel_buffer, entry);
+		//		printk("^-^ %s %d %p %p^-^\n",__func__,__LINE__, fifo, buf);
+		list_del(&(buf->entry));
+	}else
+		buf = NULL;
+
+	return buf;
+}
+
+static void inline push_buffer_fifo(struct list_head *fifo, struct frame_channel_buffer *buf)
+{
+	//	printk("^@^ %s %d %p %p^-^\n",__func__,__LINE__, fifo, buf);
+	list_add_tail(&(buf->entry), fifo);
+}
+
+static void inline cleanup_buffer_fifo(struct list_head *fifo)
+{
+	struct frame_channel_buffer *buf;
+	while(!list_empty(fifo)){
+		buf = list_first_entry(fifo, struct frame_channel_buffer, entry);
+		list_del(&(buf->entry));
+	}
+}
+
+/*
+   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+   interrupt handler
+   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+ */
+static system_interrupt_handler_t isr_func[APICAL_IRQ_COUNT] = {NULL};
+static void* isr_param[APICAL_IRQ_COUNT] = {NULL};
+//static int interrupt_line[APICAL_IRQ_COUNT] = {0};
+static struct v4l2_subdev *use_to_intc_sd = NULL;
+
+static void inline isp_set_interrupt_ops(struct v4l2_subdev *sd)
+{
+	use_to_intc_sd = sd;
+}
+static inline unsigned short isp_intc_state(void)
+{
+	return apical_isp_interrupts_interrupt_status_read();
+}
+
+void system_program_interrupt_event(uint8_t event, uint8_t id)
+{
+	switch(event)
+	{
+		case 0: apical_isp_interrupts_interrupt0_source_write(id); break;
+		case 1: apical_isp_interrupts_interrupt1_source_write(id); break;
+		case 2: apical_isp_interrupts_interrupt2_source_write(id); break;
+		case 3: apical_isp_interrupts_interrupt3_source_write(id); break;
+		case 4: apical_isp_interrupts_interrupt4_source_write(id); break;
+		case 5: apical_isp_interrupts_interrupt5_source_write(id); break;
+		case 6: apical_isp_interrupts_interrupt6_source_write(id); break;
+		case 7: apical_isp_interrupts_interrupt7_source_write(id); break;
+		case 8: apical_isp_interrupts_interrupt8_source_write(id); break;
+		case 9: apical_isp_interrupts_interrupt9_source_write(id); break;
+		case 10: apical_isp_interrupts_interrupt10_source_write(id); break;
+		case 11: apical_isp_interrupts_interrupt11_source_write(id); break;
+		case 12: apical_isp_interrupts_interrupt12_source_write(id); break;
+		case 13: apical_isp_interrupts_interrupt13_source_write(id); break;
+		case 14: apical_isp_interrupts_interrupt14_source_write(id); break;
+		case 15: apical_isp_interrupts_interrupt15_source_write(id); break;
+	}
+}
+static inline void isp_clear_irq_source(void)
+{
+	int event = 0;
+	for(event = 0; event < APICAL_IRQ_COUNT; event++){
+		system_program_interrupt_event(event, 0);
+	}
+}
+
+void system_set_interrupt_handler(uint8_t source,
+		system_interrupt_handler_t handler, void* param)
+{
+	isr_func[source] = handler;
+	isr_param[source] = param;
+}
+void system_init_interrupt(void)
+{
+	int i;
+	for (i = 0; i < APICAL_IRQ_COUNT; i++)
+	{
+		isr_func[i] = NULL;
+		isr_param[i] = NULL;
+	}
+
+	isp_clear_irq_source();
+}
+
+void system_hw_interrupts_enable(void)
+{
+	struct tx_isp_notify_argument arg;
+	arg.value = TX_ISP_TOP_IRQ_ISP;
+	use_to_intc_sd->v4l2_dev->notify(use_to_intc_sd, TX_ISP_NOTIFY_ENABLE_IRQ, &arg);
+}
+
+void system_hw_interrupts_disable(void)
+{
+	struct tx_isp_notify_argument arg;
+	arg.value = TX_ISP_TOP_IRQ_ISP;
+	use_to_intc_sd->v4l2_dev->notify(use_to_intc_sd, TX_ISP_NOTIFY_DISABLE_IRQ, &arg);
+}
+
+/*
+   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+   v4l2_subdev_ops will be defined as follows
+   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
+ */
+static int isp_set_buffer_lineoffset_vflip_disable(struct tx_isp_frame_channel *chan)
+{
+	frame_chan_vdev_t *video = &chan->video;
+	struct v4l2_format *output = &(video->attr.output);
+	unsigned int regw = 0xb00;
+
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			APICAL_WRITE_32(regw + 0xa0 + 0x100 * (video->index), video->attr.lineoffset);//lineoffset
+			//	printk("(offset = 0x%08x)\n",offset);
+		default:
+			APICAL_WRITE_32(regw + 0x20 + 0x100 * (video->index), video->attr.lineoffset);//lineoffset
+			break;
+	}
+	return 0;
+}
+static int isp_set_buffer_lineoffset_vflip_enable(struct tx_isp_frame_channel *chan)
+{
+	frame_chan_vdev_t *video = &chan->video;
+	struct v4l2_format *output = &(video->attr.output);
+	unsigned int regw = 0xb00;
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			/* UV */
+			APICAL_WRITE_32(regw + 0xa0 + 0x100 * (video->index), -video->attr.lineoffset);//lineoffset
+			/* Y */
+			APICAL_WRITE_32(regw + 0x20 + 0x100 * (video->index), -video->attr.lineoffset);//lineoffset
+			break;
+		default:
+			APICAL_WRITE_32(regw + 0x20 + 0x100 * (video->index), -video->attr.lineoffset);//lineoffset
+			break;
+	}
+	return 0;
+}
+
+static int isp_set_buffer_address_vflip_disable(struct tx_isp_frame_channel *chan, struct frame_channel_buffer *buf, unsigned char bank_id)
+{
+	frame_chan_vdev_t *video = &chan->video;
+	struct v4l2_format *output = &(video->attr.output);
+	unsigned int regw = 0xb00;
+	unsigned int offset;
+
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			offset = output->fmt.pix.width * ((output->fmt.pix.height + 0xf) & ~0xf);
+			APICAL_WRITE_32((regw + 0x88 + 0x100 * (video->index) + 0x04 * bank_id), buf->addr + offset);
+			//	printk("(offset = 0x%08x)\n",offset);
+		default:
+			APICAL_WRITE_32((regw + 0x08 + 0x100 * (video->index) + 0x04 * bank_id), buf->addr);
+			break;
+	}
+	return 0;
+}
+static int isp_set_buffer_address_vflip_enable(struct tx_isp_frame_channel *chan, struct frame_channel_buffer *buf, unsigned char bank_id)
+{
+	frame_chan_vdev_t *video = &chan->video;
+	struct v4l2_format *output = &(video->attr.output);
+	unsigned int regw = 0xb00;
+	unsigned int offset;
+	unsigned int offset_uv;
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			/* UV */
+			offset = output->fmt.pix.width * output->fmt.pix.height;
+			offset_uv = (output->fmt.pix.height & 0xf) ? output->fmt.pix.width * (0x10 - (output->fmt.pix.height & 0xf)) :0; /* align at 16 lines */
+			APICAL_WRITE_32((regw + 0x88 + 0x100 * (video->index) + 0x04 * bank_id),
+											buf->addr + output->fmt.pix.sizeimage + offset_uv - video->attr.lineoffset);
+			/* Y */
+			APICAL_WRITE_32((regw + 0x08 + 0x100 * (video->index) + 0x04 * bank_id), buf->addr + offset - video->attr.lineoffset);
+			break;
+		default:
+			APICAL_WRITE_32((regw + 0x08 + 0x100 * (video->index) + 0x04 * bank_id), buf->addr + output->fmt.pix.sizeimage - video->attr.lineoffset);
+			break;
+	}
+	return 0;
+}
+
+static int isp_enable_dma_transfer(struct tx_isp_frame_channel *chan, int onoff)
+{
+	frame_chan_vdev_t *video = &chan->video;
+	struct v4l2_format *output = &(video->attr.output);
+	unsigned int regw = 0xb00;
+	//	unsigned int primary;
+	//	printk("^~^ %s[%d] index = %d onoff = %d ^~^\n",__func__, __LINE__, video->index, onoff);
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			if(onoff)
+				APICAL_WRITE_32(regw + 0xa4 + 0x100*(video->index), 0x02);// axi_port_enable set 1, frame_write_cancel set 0.
+			else
+				APICAL_WRITE_32(regw + 0xa4 + 0x100*(video->index), 0x03);// axi_port_enable set 1, frame_write_cancel set 0.
+
+		default:
+			if(onoff)
+				APICAL_WRITE_32(regw + 0x24 + 0x100*(video->index), 0x02);// axi_port_enable set 1, frame_write_cancel set 0.
+			else
+				APICAL_WRITE_32(regw + 0x24 + 0x100*(video->index), 0x03);// axi_port_enable set 1, frame_write_cancel set 0.
+			//	printk("[%s]dma enable(0x%08x is wrote 0x%08x)\n",onoff ? "on":"off",regw + 0x100*(video->index), primary);
+			break;
+	}
+	return 0;
+}
+
+static int isp_configure_base_addr(struct tx_isp_core_device *core)
+{
+	struct tx_isp_frame_channel *chan;
+	struct frame_channel_buffer *buf;
+	unsigned int hw_dma = 0;
+	unsigned char current_bank = 0;
+	unsigned char bank_id = 0;
+	unsigned char i = 0;
+	int index = 0;
+	for(index = 0; index < ISP_MAX_OUTPUT_VIDEOS; index++){
+		chan = &(core->chans[index]);
+		if(chan->state == TX_ISP_STATE_RUN){
+			hw_dma = APICAL_READ_32(0xb24 + 0x100*index);
+			current_bank = (hw_dma >> 8) & 0x7;
+			/* The begin pointer is next bank. */
+			for(i = 0, bank_id = current_bank; i < chan->usingbanks; i++, bank_id++){
+				bank_id = bank_id % chan->usingbanks;
+				if(chan->bank_flag[bank_id] == 0){
+					buf = pop_buffer_fifo(&chan->fifo);
+					if(buf != NULL){
+						if(core->vflip_state){
+							isp_set_buffer_address_vflip_enable(chan, buf, bank_id);
+						}else{
+							isp_set_buffer_address_vflip_disable(chan, buf, bank_id);
+						}
+						chan->vflip_flag[bank_id] = core->vflip_state;
+						chan->bank_flag[bank_id] = 1;
+						chan->banks_addr[bank_id] = buf->addr;
+					}else
+						break;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+static inline int isp_enable_channel(struct tx_isp_frame_channel *chan)
+{
+	unsigned int hw_dma = 0;
+	/*unsigned char current_bank = 0;*/
+	unsigned char next_bank = 0;
+	hw_dma = APICAL_READ_32(0xb24 + 0x100 * (chan->video.index));
+	next_bank = (((hw_dma >> 8) & 0x7) + 1) % chan->usingbanks;
+	/*current_bank = (hw_dma >> 8) & 0x7;*/
+	if(chan->bank_flag[next_bank] ^ chan->dma_state){
+		chan->dma_state = chan->bank_flag[next_bank];
+		isp_enable_dma_transfer(chan, chan->dma_state);
+	}
+	return 0;
+}
+
+static int isp_modify_dma_direction(struct tx_isp_frame_channel *chan)
+{
+	unsigned int hw_dma = 0;
+	unsigned char next_bank = 0;
+	if(chan->state == TX_ISP_STATE_RUN){
+		hw_dma = APICAL_READ_32(0xb24 + 0x100 * (chan->video.index));
+		next_bank = (((hw_dma >> 8) & 0x7) + 1) % chan->usingbanks;
+		if(chan->vflip_flag[next_bank] ^ chan->vflip_state){
+			chan->vflip_state = chan->vflip_flag[next_bank];
+			if(chan->vflip_state){
+				isp_set_buffer_lineoffset_vflip_enable(chan);
+			}else{
+				isp_set_buffer_lineoffset_vflip_disable(chan);
+			}
+		}
+	}
+	return 0;
+}
+
+static inline void cleanup_chan_banks(struct tx_isp_frame_channel *chan)
+{
+	int bank_id = 0;
+	while(bank_id < chan->usingbanks){
+		if(chan->bank_flag[bank_id]){
+			chan->video.interrupt_service_routine(&chan->video, chan->banks_addr[bank_id], NULL);
+			chan->bank_flag[bank_id] = 0;
+		}
+		bank_id++;
+	}
+}
+
+#define ISP_CHAN_DMA_STAT (1<<16)
+#define ISP_CHAN_DMA_ACTIVE (1<<16)
+static inline void isp_core_update_addr(struct tx_isp_frame_channel *chan)
+{
+	frame_chan_vdev_t *video = &chan->video;
+	struct v4l2_format *output = &(video->attr.output);
+	unsigned int y_hw_dma = 0;
+	unsigned int uv_hw_dma = 0;
+	unsigned char current_bank = 0;
+	unsigned char uv_bank = 0;
+	unsigned char last_bank = 0;
+	unsigned char next_bank = 0;
+	unsigned char bank_id = 0;
+	unsigned int current_active = 0;
+	unsigned int value = 0;
+	unsigned int isnv = 0;
+
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			uv_hw_dma = APICAL_READ_32(0xba4 + 0x100 * video->index);
+			current_active |= uv_hw_dma;
+			isnv = 1;
+		default:
+			y_hw_dma = APICAL_READ_32(0xb24 + 0x100 * video->index);
+			current_active |= y_hw_dma;
+			break;
+	}
+
+	current_bank = (y_hw_dma >> 8) & 0x7;
+	uv_bank = (uv_hw_dma >> 8) & 0x7;
+
+	if(isnv && (uv_bank != current_bank)){
+		/*printk("##### y_bank = %d, nv_bank = %d\n",current_bank,uv_bank);*/
+		value = (0x1<<3) | (chan->usingbanks - 1);
+		switch(output->fmt.pix.pixelformat){
+			case V4L2_PIX_FMT_NV12:
+			case V4L2_PIX_FMT_NV21:
+				APICAL_WRITE_32(0xb9c + 0x100*(video->index), value);
+			default:
+				APICAL_WRITE_32(0xb1c + 0x100*(video->index), value);
+				break;
+		}
+		chan->reset_dma_flag = 1;
+		return;
+	}
+	if(chan->reset_dma_flag){
+		/*printk("##### y_bank = %d, nv_bank = %d\n",current_bank,uv_bank);*/
+		value = (0x0<<3) | (chan->usingbanks - 1);
+		switch(output->fmt.pix.pixelformat){
+			case V4L2_PIX_FMT_NV12:
+			case V4L2_PIX_FMT_NV21:
+				APICAL_WRITE_32(0xb9c + 0x100*(video->index), value);
+			default:
+				APICAL_WRITE_32(0xb1c + 0x100*(video->index), value);
+				break;
+		}
+		chan->reset_dma_flag = 0;
+	}
+
+	if((current_active & ISP_CHAN_DMA_STAT) == ISP_CHAN_DMA_ACTIVE){
+		last_bank = (y_hw_dma >> 11) & 0x7;
+		bank_id = last_bank;
+	}else{
+		bank_id = current_bank;
+	}
+	if(chan->bank_flag[bank_id]){
+		chan->video.interrupt_service_routine(&chan->video, chan->banks_addr[bank_id], NULL);
+		chan->bank_flag[bank_id] = 0;
+	}
+
+	next_bank = (current_bank + 1) % chan->usingbanks;
+	if(chan->bank_flag[next_bank] != 1){
+		isp_enable_channel(chan);
+	}
+	return;
+}
+
+extern int apical_isp_day_or_night_s_ctrl_internal(struct tx_isp_core_device *core);
+
+extern void isp_frame_done_wakeup(void);
+
+static int isp_core_interrupt_service_routine(struct v4l2_subdev *sd, u32 status, bool *handled)
+{
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(sd);
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct tx_isp_frame_channel *chan;
+	unsigned short isp_irq_status = 0;
+	unsigned char color = apical_isp_top_rggb_start_read();
+	unsigned int i = 0;
+	int ret = IRQ_HANDLED;
+	if((isp_irq_status = isp_intc_state()) != 0)
+	{
+		apical_isp_interrupts_interrupt_clear_write(0);
+		apical_isp_interrupts_interrupt_clear_write(isp_irq_status);
+		/* printk("0xb00 = 0x%0x state = 0x%x\n", APICAL_READ_32(0xb00), isp_irq_status); */
+		for(i = 0; i < APICAL_IRQ_COUNT; i++){
+			if(isp_irq_status & (1 << i)){
+				switch(i){
+					case APICAL_IRQ_FRAME_START:
+						if(isr_func[i])
+							isr_func[i](isr_param[i]);
+						/*printk("^~^ frame start ^~^\n");*/
+						isp_configure_base_addr(core);
+						core->frame_state = 1;
+						ret = IRQ_WAKE_THREAD;
+						break;
+					case APICAL_IRQ_FRAME_WRITER_FR:
+						if(isr_func[i])
+							isr_func[APICAL_IRQ_FRAME_WRITER_FR](isr_param[APICAL_IRQ_FRAME_WRITER_FR]);
+						chan = &core->chans[ISP_FR_VIDEO_CHANNEL];
+						isp_core_update_addr(chan);
+						isp_modify_dma_direction(chan);
+						break;
+					case APICAL_IRQ_FRAME_WRITER_DS:
+						if(isr_func[i])
+							isr_func[APICAL_IRQ_FRAME_WRITER_DS](isr_param[APICAL_IRQ_FRAME_WRITER_DS]);
+						chan = &core->chans[ISP_DS1_VIDEO_CHANNEL];
+						isp_core_update_addr(chan);
+						isp_modify_dma_direction(chan);
+						break;
+					case APICAL_IRQ_FRAME_WRITER_DS2:
+						if(isr_func[i])
+							isr_func[i](isr_param[i]);
+						#if TX_ISP_EXIST_DS2_CHANNEL
+						chan = &core->chans[ISP_DS2_VIDEO_CHANNEL];
+						isp_core_update_addr(chan);
+						isp_modify_dma_direction(chan);
+						#endif
+						break;
+					case APICAL_IRQ_FRAME_END:
+						if(core->hflip_state == apical_isp_top_bypass_mirror_read())						{
+							if(core->hflip_state){
+								color ^= 1;
+							}else{
+								if(contrl->pattern != color){
+									color ^= 1;
+								}
+							}
+							//	printk("$$$$ %s %d pattern = %d color = %d $$$$$\n", __func__,__LINE__,contrl->pattern,color);
+							apical_isp_top_rggb_start_write(color);
+							apical_isp_top_bypass_mirror_write(core->hflip_state ?0:1);
+						}
+						/* APICAL_WRITE_32(0x18,2);  */
+						chan = &core->chans[ISP_FR_VIDEO_CHANNEL];
+						core->frame_state = 0;
+						isp_configure_base_addr(core);
+						isp_modify_dma_direction(chan);
+						if(chan->dma_state != 1){
+							isp_enable_channel(chan);
+						}
+
+						isp_frame_done_wakeup();
+
+						if (1 == core->isp_daynight_switch) {
+							int ret = 0;
+							ret = apical_isp_day_or_night_s_ctrl_internal(core);
+							if (ret)
+								printk("%s[%d] apical_isp_day_or_night_s_ctrl_internal failed!\n", __func__, __LINE__);
+							core->isp_daynight_switch = 0;
+						}
+					case APICAL_IRQ_AE_STATS:
+					case APICAL_IRQ_AWB_STATS:
+					case APICAL_IRQ_AF_STATS:
+					case APICAL_IRQ_FPGA_FRAME_START:
+					case APICAL_IRQ_FPGA_FRAME_END:
+					case APICAL_IRQ_FPGA_WDR_BUF:
+						if(isr_func[i])
+							isr_func[i](isr_param[i]);
+						break;
+					case APICAL_IRQ_DS1_OUTPUT_END:
+						chan = &core->chans[ISP_DS1_VIDEO_CHANNEL];
+						isp_modify_dma_direction(chan);
+						if(chan->dma_state != 1){
+							isp_enable_channel(chan);
+						}
+						break;
+					#if TX_ISP_EXIST_DS2_CHANNEL
+					case APICAL_IRQ_DS2_OUTPUT_END:
+						chan = &core->chans[ISP_DS2_VIDEO_CHANNEL];
+						isp_modify_dma_direction(chan);
+						if(chan->dma_state != 1){
+							isp_enable_channel(chan);
+						}
+						break;
+					#endif
+					default:
+						break;
+				}
+			}
+		}
+		/*printk("^~^ intc end ^~^\n");*/
+	}
+	return ret;
+}
+
+irqreturn_t isp_irq_thread_handle(int this_irq, void *dev)
+{
+	tx_isp_device_t *ispdev = (tx_isp_device_t *)dev;
+	struct tx_isp_media_pipeline *p = &ispdev->pipeline;
+	struct tx_isp_core_device *core = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	int i = 0;
+
+	sd = p->subdevs[TX_ISP_CORE_GRP_IDX];
+	core = v4l2_get_subdevdata(sd);
+	if(core){
+		ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+		for(i = 0; i < TX_ISP_I2C_SET_BUTTON; i++){
+			if(core->i2c_msgs[i].flag == 0)
+				continue;
+			core->i2c_msgs[i].flag = 0;
+			switch(i){
+				case TX_ISP_I2C_SET_AGAIN:
+					ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_AGAIN;
+					break;
+				case TX_ISP_I2C_SET_DGAIN:
+					ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_DGAIN;
+					break;
+				case TX_ISP_I2C_SET_INTEGRATION:
+					ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_INT_TIME;
+					break;
+				default:
+					break;
+			}
+			ioctl.value = core->i2c_msgs[i].value;
+			arg.value = (int)&ioctl;
+			tx_isp_sd_notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/*
+ * the ops of isp's clks
+ */
+//#ifdef CONFIG_PRODUCT_FPGA
+#if 0
+static int isp_core_init_clk(struct tx_isp_core_device *core)
+{
+	*(volatile unsigned int*)(0xb0000080) = 0x20000007;
+	while(*(volatile unsigned int*)(0xb0000080) & (1 << 28));
+	return 0;
+}
+static long isp_core_set_clk(struct tx_isp_core_device *core, int state)
+{
+	*(volatile unsigned int*)(0xb0000020) &= ~(1 << 23);
+	return 0;
+}
+static int isp_core_release_clk(struct tx_isp_core_device *core)
+{
+	return 0;
+}
+#else
+static int isp_core_init_clk(struct tx_isp_core_device *core)
+{
+	struct clk **clks = NULL;
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	struct tx_isp_subdev_platform_data *pdata = core->pdata;
+	struct tx_isp_subdev_clk_info *info = pdata->clks;
+	unsigned int num = pdata->clk_num;
+	int ret = 0;
+	int i;
+
+	core->clk_num = pdata->clk_num;
+	if(!core->clk_num){
+		core->clks = NULL;
+		return ISP_SUCCESS;
+	}
+
+	clks = (struct clk **)kzalloc(sizeof(clks) * num, GFP_KERNEL);
+	if(!clks){
+		v4l2_err(v4l2_dev, "%s[%d] Failed to allocate core's clks\n",__func__,__LINE__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	for (i = 0; i < num; i++) {
+		clks[i] = clk_get(core->dev, info[i].name);
+		if (IS_ERR(clks[i])) {
+			v4l2_err(v4l2_dev, "Failed to get %s clock %ld\n", info[i].name, PTR_ERR(clks[i]));
+			ret = PTR_ERR(clks[i]);
+			goto failed_to_get_clk;
+		}
+		if(info[i].rate != DUMMY_CLOCK_RATE) {
+			ret = clk_set_rate(clks[i], isp_clk);
+			if(ret){
+				v4l2_err(v4l2_dev, "Failed to set %s clock rate(%ld)\n", info[i].name, info[i].rate);
+				goto failed_to_get_clk;
+			}
+		}
+	}
+	core->clks = clks;
+	return ISP_SUCCESS;
+failed_to_get_clk:
+	while(--i >= 0){
+		clk_put(clks[i]);
+	}
+	kfree(clks);
+exit:
+	return ret;
+}
+
+static int isp_core_release_clk(struct tx_isp_core_device *core)
+{
+	struct clk **clks = core->clks;
+	int i = 0;
+
+	if(clks == NULL)
+		return 0;
+	for (i = 0; i < core->clk_num; i++)
+		clk_put(clks[i]);
+
+	kfree(clks);
+	return 0;
+}
+
+
+static long isp_core_set_clk(struct tx_isp_core_device *core, int state)
+{
+	struct clk **clks = core->clks;
+	int i;
+
+	if(state){
+		for(i = 0; i < core->clk_num; i++)
+			clk_enable(clks[i]);
+	}else{
+		for(i = core->clk_num - 1; i >=0; i--)
+			clk_disable(clks[i]);
+	}
+	return ISP_SUCCESS;
+}
+#endif
+static int isp_fw_process(void *data)
+{
+	while(!kthread_should_stop()){
+		apical_process();
+#if ISP_HAS_CONNECTION_DEBUG && ISP_HAS_API
+		apical_cmd_process();
+#endif //ISP_HAS_API
+#if ISP_HAS_STREAM_CONNECTION
+		apical_connection_process();
+#endif
+	}
+#if ISP_HAS_STREAM_CONNECTION
+	apical_connection_destroy();
+#endif
+	return 0;
+}
+
+static int isp_core_ops_init(struct v4l2_subdev *sd, u32 on)
+{
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(sd);
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	int ret = ISP_SUCCESS;
+
+	if(on){
+		if(atomic_read(&core->state) == TX_ISP_STATE_STOP){
+			core->param = load_tx_isp_parameters(core->vin.attr);
+			apical_init();
+#if ISP_HAS_STREAM_CONNECTION
+			apical_connection_init();
+#endif
+			system_program_interrupt_event(APICAL_IRQ_DS1_OUTPUT_END, 50);
+#if TX_ISP_EXIST_DS2_CHANNEL
+			system_program_interrupt_event(APICAL_IRQ_DS2_OUTPUT_END, 53);
+#endif
+			core->process_thread = kthread_run(isp_fw_process, NULL, "apical_isp_fw_process");
+			if(IS_ERR_OR_NULL(core->process_thread)){
+				v4l2_err(v4l2_dev, "%s[%d] kthread_run was failed!\n",__func__,__LINE__);
+				ret = -ISP_ERROR;
+				goto exit;
+			}
+			atomic_set(&core->state, TX_ISP_STATE_START);
+		}
+	}else{
+		if(atomic_read(&core->state) == TX_ISP_STATE_RUN){
+			v4l2_err(v4l2_dev, "%s[%d] Cann't deinit the device, please streamoff it firstly!\n",__func__,__LINE__);
+			ret = -ISP_ERROR;
+			goto exit;
+		}
+		if(atomic_read(&core->state) == TX_ISP_STATE_START){
+			ret = kthread_stop(core->process_thread);
+			isp_clear_irq_source();
+			atomic_set(&core->state, TX_ISP_STATE_STOP);
+			/*printk("^^^^ %s[%d] ^^^^\n",__func__,__LINE__);*/
+		}
+	}
+exit:
+	return ret;
+}
+
+static int isp_core_ops_reset(struct v4l2_subdev *sd, u32 enable)
+{
+	return ISP_SUCCESS;
+}
+
+static int isp_core_ops_s_power(struct v4l2_subdev *sd, int on)
+{
+	return ISP_SUCCESS;
+}
+
+static void isp_core_config_top_ctl_register(unsigned int name, unsigned int value)
+{
+	apical_isp_top_ctl_t top;
+	top.reg.low = APICAL_READ_32(0x40);
+	top.reg.high = APICAL_READ_32(0x44);
+
+	switch(name){
+		case TEST_GEN_BIT:
+			top.bits.test_gen = value;
+			break;
+		case MIRROR_BIT:
+			top.bits.mirror = value;
+			break;
+		case SENSOR_OFFSET_BIT:
+			top.bits.sensor_offset = value;
+			break;
+		case DIG_GAIN_BIT:
+			top.bits.dig_gain = value;
+			break;
+		case GAMMA_FE_BIT:
+			top.bits.gamma_fe = value;
+			break;
+		case RAW_FRONT_BIT:
+			top.bits.raw_front = value;
+			break;
+		case DEFECT_PIXEL_BIT:
+			top.bits.defect_pixel = value;
+			break;
+		case FRAME_STITCH_BIT:
+			top.bits.frame_stitch = value;
+			break;
+		case GAMMA_FE_POS_BIT:
+			top.bits.gamma_fe_pos = value;
+			break;
+		case SINTER_BIT:
+			top.bits.sinter = value;
+			break;
+		case TEMPER_BIT:
+			top.bits.temper = value;
+			break;
+		case ORDER_BIT:
+			top.bits.order = value;
+			break;
+		case WB_BIT:
+			top.bits.wb = value;
+			break;
+		case RADIAL_BIT:
+			top.bits.radial = value;
+			break;
+		case MESH_BIT:
+			top.bits.mesh = value;
+			break;
+		case IRIDIX_BIT:
+			top.bits.iridix = value;
+			break;
+		case DEMOSAIC_BIT:
+			top.bits.demosaic = value;
+			break;
+		case MATRIX_BIT:
+			top.bits.matrix = value;
+			break;
+		case FR_CROP_BIT:
+			top.bits.fr_crop = value;
+			break;
+		case FR_GAMMA_BIT:
+			top.bits.fr_gamma = value;
+			break;
+		case FR_SHARPEN_BIT:
+			top.bits.fr_sharpen = value;
+			break;
+		case FR_LOGO_BIT:
+			top.bits.fr_logo = value;
+			break;
+		case FR_CSC_BIT:
+			top.bits.fr_csc = value;
+			break;
+		case DS1_CROP_BIT:
+			top.bits.ds1_crop = value;
+			break;
+		case DS1_SCALER_BIT:
+			top.bits.ds1_scaler = value;
+			break;
+		case DS1_GAMMA_BIT:
+			top.bits.ds1_gamma = value;
+			break;
+		case DS1_SHARPEN_BIT:
+			top.bits.ds1_sharpen = value;
+			break;
+		case DS1_LOGO_BIT:
+			top.bits.ds1_logo = value;
+			break;
+		case DS1_CSC_BIT:
+			top.bits.ds1_csc = value;
+			break;
+		case DS1_DMA_BIT:
+			top.bits.ds1_dma = value;
+			break;
+		case DS2_SCALER_SOURCE_BIT:
+			top.bits.ds2_scaler_source = value;
+			break;
+		case DS2_CROP_BIT:
+			top.bits.ds2_crop = value;
+			break;
+		case DS2_SCALER_BIT:
+			top.bits.ds2_scaler = value;
+			break;
+		case DS2_GAMMA_BIT:
+			top.bits.ds2_gamma = value;
+			break;
+		case DS2_SHARPEN_BIT:
+			top.bits.ds2_sharpen = value;
+			break;
+		case DS2_LOGO_BIT:
+			top.bits.ds2_logo = value;
+			break;
+		case DS2_CSC_BIT:
+			top.bits.ds2_csc = value;
+			break;
+		case RAW_BYPASS_BIT:
+			top.bits.raw_bypass = value;
+			break;
+		case DEBUG_BIT:
+			top.bits.debug = value;
+			break;
+		case PROC_BYPASS_MODE_BIT:
+			top.bits.proc_bypass_mode = value;
+			break;
+		default:
+			break;
+	}
+
+	APICAL_WRITE_32(0x40, top.reg.low);
+	APICAL_WRITE_32(0x44, top.reg.high);
+}
+
+static int isp_core_config_dma_channel_write(struct tx_isp_core_device *core,
+		frame_chan_vdev_t *vdev)
+{
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &(attr->output);
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	struct frame_channel_format *cfmt = (struct frame_channel_format *)(output->fmt.pix.priv);
+	unsigned int base = 0x00b00 + 0x100 * vdev->index; // the base of address of dma channel write
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int ret = ISP_SUCCESS;
+	unsigned int csc = 0xf;
+
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			/* dma channel uv write */
+			APICAL_WRITE_32(base + 0x80, cfmt->priv);
+			APICAL_WRITE_32(base + 0x84, output->fmt.pix.height << 16 | output->fmt.pix.width);
+			APICAL_WRITE_32(base + 0xa0, vdev->attr.lineoffset);//lineoffset
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		case V4L2_PIX_FMT_YUV444:
+			switch(vdev->index){
+				case ISP_FR_VIDEO_CHANNEL:
+					if(mbus->code == V4L2_MBUS_FMT_YUYV8_1X16)
+						csc = 0x08;
+					else
+						csc = 0x0f;
+
+					isp_core_config_top_ctl_register(FR_CSC_BIT,
+							ISP_MODULE_BYPASS_DISABLE);
+					break;
+				case ISP_DS1_VIDEO_CHANNEL:
+					if(mbus->code == V4L2_MBUS_FMT_YUYV8_1X16)
+						csc = 0x08;
+					else
+						csc = 0x0f;
+					isp_core_config_top_ctl_register(DS1_CSC_BIT,
+							ISP_MODULE_BYPASS_DISABLE);
+					break;
+				#if TX_ISP_EXIST_DS2_CHANNEL
+				case ISP_DS2_VIDEO_CHANNEL:
+					if(mbus->code == V4L2_MBUS_FMT_YUYV8_1X16)
+						csc = 0x08;
+					else
+						csc = 0x0f;
+					isp_core_config_top_ctl_register(DS2_CSC_BIT,
+							ISP_MODULE_BYPASS_DISABLE);
+					break;
+				#endif
+				default:
+					break;
+			}
+			if(contrl->fmt_end == APICAL_ISP_INPUT_RAW_FMT_INDEX_END){
+				isp_core_config_top_ctl_register(DEMOSAIC_BIT, ISP_MODULE_BYPASS_DISABLE);
+			}
+			APICAL_WRITE_32(base, cfmt->priv & 0x0f);
+			APICAL_WRITE_32(base + 0x04, output->fmt.pix.height << 16 | output->fmt.pix.width);
+			APICAL_WRITE_32(base + 0x20, vdev->attr.lineoffset);//lineoffset
+			break;
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_BGR24:
+		case V4L2_PIX_FMT_BGR32:
+		case V4L2_PIX_FMT_RGB310:
+			switch(vdev->index){
+				case ISP_FR_VIDEO_CHANNEL:
+					isp_core_config_top_ctl_register(FR_CSC_BIT,
+							ISP_MODULE_BYPASS_ENABLE);
+					break;
+				case ISP_DS1_VIDEO_CHANNEL:
+					isp_core_config_top_ctl_register(DS1_CSC_BIT,
+							ISP_MODULE_BYPASS_ENABLE);
+					break;
+				#if TX_ISP_EXIST_DS2_CHANNEL
+				case ISP_DS2_VIDEO_CHANNEL:
+					isp_core_config_top_ctl_register(DS2_CSC_BIT,
+							ISP_MODULE_BYPASS_ENABLE);
+					break;
+				#endif
+				default:
+					break;
+			}
+			if(contrl->fmt_end == APICAL_ISP_INPUT_RAW_FMT_INDEX_END){
+				isp_core_config_top_ctl_register(DEMOSAIC_BIT, ISP_MODULE_BYPASS_DISABLE);
+			}
+		case V4L2_PIX_FMT_SBGGR12:
+		case V4L2_PIX_FMT_SGBRG12:
+		case V4L2_PIX_FMT_SGRBG12:
+		case V4L2_PIX_FMT_SRGGB12:
+			APICAL_WRITE_32(base, cfmt->priv & 0x0f);
+			APICAL_WRITE_32(base + 0x04, output->fmt.pix.height << 16 | output->fmt.pix.width);
+			APICAL_WRITE_32(base + 0x20, vdev->attr.lineoffset);//lineoffset
+			break;
+		default:
+			break;
+	}
+
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = -1;
+	api.value = -1;
+	switch(vdev->index){
+		case ISP_FR_VIDEO_CHANNEL:
+			api.id = FR_OUTPUT_MODE_ID;
+			break;
+		case ISP_DS1_VIDEO_CHANNEL:
+			api.id = DS1_OUTPUT_MODE_ID;
+			break;
+#if TX_ISP_EXIST_DS2_CHANNEL
+		case ISP_DS2_VIDEO_CHANNEL:
+			api.id = DS2_OUTPUT_MODE_ID;
+			break;
+#endif
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			api.value = YUV420;
+			break;
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+			api.value = YUV422;
+			break;
+		case V4L2_PIX_FMT_YUV444:
+			api.value = YUV444;
+			break;
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_BGR24:
+		case V4L2_PIX_FMT_BGR32:
+		case V4L2_PIX_FMT_RGB310:
+			api.value = RGB;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	if(api.value != -1 && api.id != -1){
+		status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	}
+
+	switch(vdev->index){
+	case ISP_FR_VIDEO_CHANNEL:
+		APICAL_WRITE_32(0x570, csc);
+		break;
+	case ISP_DS1_VIDEO_CHANNEL:
+		APICAL_WRITE_32(0x6b0, csc);
+		break;
+#if TX_ISP_EXIST_DS2_CHANNEL
+	case ISP_DS2_VIDEO_CHANNEL:
+		APICAL_WRITE_32(0x7b0, csc);
+		break;
+#endif
+	default:
+		break;
+	}
+
+	return ISP_SUCCESS;
+}
+
+static struct frame_channel_format isp_output_fmt[APICAL_ISP_FMT_MAX_INDEX] = {
+	{
+		.name     = "YUV 4:2:0 semi planar, Y/CbCr",
+		.fourcc   = V4L2_PIX_FMT_NV12,
+		.depth    = 12,
+		.priv     = DMA_FORMAT_NV12_UV,
+	},
+	{
+		.name     = "YUV 4:2:0 semi planar, Y/CrCb",
+		.fourcc   = V4L2_PIX_FMT_NV21,
+		.depth    = 12,
+		.priv     = DMA_FORMAT_NV12_VU,
+	},
+	{
+		.name     = "YUV 4:2:2 packed, YCbYCr",
+		.fourcc   = V4L2_PIX_FMT_YUYV,
+		.depth    = 16,
+		.priv     = DMA_FORMAT_YUY2,
+	},
+	{
+		.name     = "YUV 4:2:2 packed, CbYCrY",
+		.fourcc   = V4L2_PIX_FMT_UYVY,
+		.depth    = 16,
+		.priv	  = DMA_FORMAT_UYVY,
+	},
+	{
+		.name     = "YUV 4:4:4 packed, YCbCr",
+		.fourcc   = V4L2_PIX_FMT_YUV444,
+		.depth    = 32,
+		.priv     = DMA_FORMAT_AYUV,
+	},
+	{
+		.name     = "RGB565, RGB-5-6-5",
+		.fourcc   = V4L2_PIX_FMT_RGB565,
+		.depth    = 16,
+		.priv     = DMA_FORMAT_RGB565,
+	},
+	{
+		.name     = "BGR24, RGB-8-8-8-3",
+		.fourcc   = V4L2_PIX_FMT_BGR24,
+		.depth    = 24,
+		.priv     = DMA_FORMAT_RGB24,
+	},
+	{
+		.name     = "BGR32, RGB-8-8-8-4",
+		.fourcc   = V4L2_PIX_FMT_BGR32,
+		.depth    = 32,
+		.priv     = DMA_FORMAT_RGB32,
+	},
+	{
+		.name     = "RGB101010, RGB-10-10-10",
+		.fourcc   = V4L2_PIX_FMT_RGB310,
+		.depth    = 32,
+		.priv     = DMA_FORMAT_A2R10G10B10,
+	},
+	/* the last member will be determined when isp input confirm.*/
+	{
+		.name     = "undetermine",
+		.fourcc   = 0,
+		.depth    = 0,
+		.priv     = 0,
+	},
+};
+
+static int isp_core_frame_channel_enum_fmt (struct tx_isp_core_device *core, int value)
+{
+	struct apical_isp_contrl *contrl = &core->contrl;
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct v4l2_fmtdesc *f = vdev->fmtdesc;
+	struct frame_channel_format *cfmt;
+	int index = 0;
+	//	printk("contrl->fmt_start + f->index============%d\n",contrl->fmt_start + f->index);
+
+	if(core->bypass == TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE){
+		index = contrl->fmt_end;
+	}else{
+		index = contrl->fmt_start;
+	}
+
+	if(index + f->index <= contrl->fmt_end){
+		cfmt = &(isp_output_fmt[index + f->index]);
+	}else{
+		return -ISP_ERROR;
+	}
+	strlcpy(f->description, cfmt->name, sizeof(f->description));
+	f->pixelformat = cfmt->fourcc;
+	return ISP_SUCCESS;
+}
+
+static int isp_core_frame_channel_try_fmt (struct tx_isp_core_device *core, int value)
+{
+	struct apical_isp_contrl *contrl = &core->contrl;
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct v4l2_format *f = vdev->fmt;
+	struct frame_channel_format *cfmt;
+	int i = 0;
+	if(core->bypass == TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE){
+		i = contrl->fmt_end;
+	}else{
+		i = contrl->fmt_start;
+	}
+	//	printk("^^^^ %s[%d] i = %d^^^^\n",__func__,__LINE__,i);
+	for(; i <= contrl->fmt_end; i++){
+		cfmt = &(isp_output_fmt[i]);
+		//	printk("^^^^ %s[%d] i = %d  0x%08x^^^^\n",__func__,__LINE__,i,
+		//		f->fmt.pix.pixelformat);//, cfmt->fourcc);
+		//	printk("^^^^ %s[%d] i = %d  0x%08x^^^^\n",__func__,__LINE__,i,
+		//		cfmt->fourcc);
+		if(f->fmt.pix.pixelformat == cfmt->fourcc){
+			break;
+		}
+	}
+	//	printk("^^^^ %s[%d] i = %d^^^^\n",__func__,__LINE__,i);
+	if(i > contrl->fmt_end){
+		printk("%s[%d], don't support the format(0x%08x)\n",
+				__func__, __LINE__, f->fmt.pix.pixelformat);
+		return -ISP_ERROR;
+	}
+	return ISP_SUCCESS;
+}
+
+static int isp_core_frame_channel_set_fmt(struct tx_isp_core_device *core, int value)
+{
+	struct apical_isp_contrl *contrl = &core->contrl;
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &(attr->output);
+	struct v4l2_format *f = vdev->fmt;
+	struct frame_channel_format *cfmt = NULL;
+	int i = 0;
+
+	if(f->fmt.pix.width != output->fmt.pix.width ||
+			f->fmt.pix.height != output->fmt.pix.height){
+		printk("%s[%d] f->width = %d f->height = %d, output->width=%d, output->height=%d\n",
+				__func__, __LINE__,
+				f->fmt.pix.width, f->fmt.pix.height,
+				output->fmt.pix.width, output->fmt.pix.height);
+		return -EINVAL;
+	}
+
+	if(output->fmt.pix.width > attr->max_width ||
+			output->fmt.pix.height > attr->max_height){
+		printk("%s[%d] attr->max_width = %d attr->max_height = %d, output->width=%d, output->height=%d\n",
+				__func__, __LINE__,
+				attr->max_width, attr->max_height,
+				output->fmt.pix.width, output->fmt.pix.height);
+		return -EINVAL;
+	}
+
+	for(i = contrl->fmt_start; i <= contrl->fmt_end; i++){
+		cfmt = &(isp_output_fmt[i]);
+		if(f->fmt.pix.pixelformat == cfmt->fourcc)
+			break;
+	}
+
+	if (i > contrl->fmt_end) {
+		printk("%s[%d] unfound the pixelformat = %d\n", __func__, __LINE__, f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	f->fmt.pix.bytesperline = f->fmt.pix.width * cfmt->depth / 8;
+	f->fmt.pix.sizeimage = f->fmt.pix.bytesperline * f->fmt.pix.height;
+	output->fmt.pix.pixelformat = f->fmt.pix.pixelformat;
+	output->fmt.pix.bytesperline = f->fmt.pix.bytesperline;
+	output->fmt.pix.sizeimage = f->fmt.pix.sizeimage;
+	vdev->attr.lineoffset = output->fmt.pix.width * (cfmt->depth / 8);
+	output->fmt.pix.priv = (unsigned int)cfmt;
+//	printk("~~~~~ %s[%d] width = %d, height = %d bytesperline = %d sizeimage = %d ~~~~~\n",__func__,__LINE__,
+//			output->fmt.pix.width, output->fmt.pix.height, output->fmt.pix.bytesperline, output->fmt.pix.sizeimage);
+	return isp_core_config_dma_channel_write(core, vdev);
+}
+
+static int isp_core_frame_channel_crop_capture(struct tx_isp_core_device *core, int value)
+{
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	int width, height;
+	int ret = ISP_SUCCESS;
+
+	if(core->bypass == TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE ||
+			mbus->code == V4L2_MBUS_FMT_YUYV8_1X16){
+		width = height = 0;
+		ret = -EPERM;
+	}else{
+		width = contrl->inwidth;
+		height = contrl->inheight;
+	}
+	attr->bounds.top = 0;
+	attr->bounds.left = 0;
+	attr->bounds.width = width;
+	attr->bounds.height = height;
+
+	return ret;
+}
+
+static int isp_core_frame_channel_set_crop(struct tx_isp_core_device *core, int value)
+{
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	apical_api_control_t api;
+	unsigned int chan;
+	unsigned char status = 0;
+	int ret = ISP_SUCCESS;
+
+	if(core->bypass == TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE ){
+		ret = -EPERM;
+	}
+	switch(vdev->index){
+		case ISP_FR_VIDEO_CHANNEL:
+			apical_isp_top_bypass_fr_crop_write(attr->crop_enable?0:1);
+			chan = CROP_FR;
+			break;
+		case ISP_DS1_VIDEO_CHANNEL:
+			apical_isp_top_bypass_ds1_crop_write(attr->crop_enable?0:1);
+			chan = CROP_DS;
+			break;
+#if TX_ISP_EXIST_DS2_CHANNEL
+		case ISP_DS2_VIDEO_CHANNEL:
+			apical_isp_top_bypass_ds2_crop_write(attr->crop_enable?0:1);
+			chan = CROP_DS2;
+			break;
+#endif
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	if(ret < 0)
+		return ret;
+	api.type = TIMAGE;
+	api.dir = COMMAND_SET;
+	if(attr->crop_enable){
+	api.value = (chan << 16) + attr->crop.width;
+	api.id = IMAGE_RESIZE_WIDTH_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+
+	api.value = (chan << 16) + attr->crop.height;
+	api.id = IMAGE_RESIZE_HEIGHT_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+
+	api.value = (chan << 16) + attr->crop.left;
+	api.id = IMAGE_CROP_XOFFSET_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+
+	api.value = (chan << 16) + attr->crop.top;
+	api.id = IMAGE_CROP_YOFFSET_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+
+	api.value = (chan << 16) + ENABLE;
+	api.id = IMAGE_RESIZE_ENABLE_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+
+	attr->output.fmt.pix.width = attr->crop.width;
+	attr->output.fmt.pix.height = attr->crop.height;
+	}else{
+	api.value = (chan << 16) + DISABLE;
+	api.id = IMAGE_RESIZE_ENABLE_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	}
+	return ret;
+}
+
+static int isp_core_frame_channel_scaler_capture(struct tx_isp_core_device *core, int value)
+{
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	int inwidth, inheight;
+	int ret = ISP_SUCCESS;
+
+	if(core->bypass == TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE ||
+			vdev->index == ISP_FR_VIDEO_CHANNEL ||
+			mbus->code == V4L2_MBUS_FMT_YUYV8_1X16){
+		inwidth = inheight = 0;
+		attr->scalercap.min_width = 0;
+		attr->scalercap.min_height = 0;
+//		printk("&&&&&&&&&&&&&&&&&&&& %s[%d] chan%d bypass = 0x%08x &&&&&&&&&&&&&&&&&&&&&&&\n",
+//				__func__, __LINE__, vdev->index, vdev->bypass);
+		ret = -EPERM;
+	}else{
+		inwidth = attr->output.fmt.pix.width;
+		inheight = attr->output.fmt.pix.height;
+		attr->scalercap.min_width = attr->min_width;
+		attr->scalercap.min_height = attr->min_height;
+	}
+	attr->scalercap.max_width = inwidth > attr->max_width
+		? attr->max_width : inwidth;
+	attr->scalercap.max_height = inheight > attr->max_height
+		? attr->max_height : inheight;
+	printk("&&& chan%d  scaler.max_width = %d max_height = %d  min_width = %d min_height = %d &&&\n",
+			vdev->index, attr->scalercap.max_width, attr->scalercap.max_height,
+			attr->scalercap.min_width, attr->scalercap.min_height);
+	return ret;
+}
+
+static int isp_core_frame_channel_set_scaler(struct tx_isp_core_device *core, int value)
+{
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	apical_api_control_t api;
+	unsigned int chan;
+	unsigned char status = 0;
+	int ret = ISP_SUCCESS;
+
+	if(core->bypass == TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE){
+		ret = -EPERM;
+	}
+
+	switch(vdev->index){
+	case ISP_DS1_VIDEO_CHANNEL:
+		apical_isp_top_bypass_ds1_scaler_write(attr->scaler_enable?0:1);
+		apical_isp_ds1_scaler_imgrst_write(1);
+		chan = SCALER;
+		break;
+#if TX_ISP_EXIST_DS2_CHANNEL
+	case ISP_DS2_VIDEO_CHANNEL:
+		apical_isp_top_bypass_ds2_scaler_write(attr->scaler_enable?0:1);
+		apical_isp_ds2_scaler_imgrst_write(1);
+		chan = SCALER2;
+		break;
+#endif
+	case ISP_FR_VIDEO_CHANNEL:
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	if(ret < 0)
+		return ret;
+	api.type = TIMAGE;
+	api.dir = COMMAND_SET;
+	if(attr->scaler_enable){
+		api.value = (chan << 16) + DISABLE;
+		api.id = IMAGE_RESIZE_ENABLE_ID;
+		status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+
+		api.value = (chan << 16) + attr->scaler.out_width;
+		api.id = IMAGE_RESIZE_WIDTH_ID;
+		status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+		//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+
+		api.value = (chan << 16) + attr->scaler.out_height;
+		api.id = IMAGE_RESIZE_HEIGHT_ID;
+		status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+		//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);
+		switch(vdev->index){
+		case ISP_DS1_VIDEO_CHANNEL:
+			apical_isp_ds1_scaler_imgrst_write(0);
+			break;
+#if TX_ISP_EXIST_DS2_CHANNEL
+		case ISP_DS2_VIDEO_CHANNEL:
+			apical_isp_ds2_scaler_imgrst_write(0);
+			break;
+#endif
+		case ISP_FR_VIDEO_CHANNEL:
+		default:
+			ret = -EINVAL;
+			break;
+		}
+
+		api.value = (chan << 16) + ENABLE;
+		api.id = IMAGE_RESIZE_ENABLE_ID;
+		status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+		//	printk("[%d]apical command: status = %d, ret = 0x%08x\n",__LINE__, status, ret);	return ret;
+
+		attr->output.fmt.pix.width = attr->scaler.out_width;
+		attr->output.fmt.pix.height = attr->scaler.out_height;
+	}else{
+		api.value = (chan << 16) + DISABLE;
+		api.id = IMAGE_RESIZE_ENABLE_ID;
+		status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+	}
+
+	return ret;
+}
+
+static int isp_core_frame_channel_streamon(struct tx_isp_core_device *core, int value)
+{
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct tx_isp_frame_channel *chan = &(core->chans[vdev->index]);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &(attr->output);
+	unsigned int base = 0x00b00 + 0x100 * vdev->index; // the base of address of dma channel write
+	unsigned int primary;
+	unsigned long flags;
+
+	memset(chan->bank_flag, 0 ,sizeof(chan->bank_flag));
+	memset(chan->vflip_flag, 0 ,sizeof(chan->vflip_flag));
+	memset(chan->banks_addr, 0 ,sizeof(chan->banks_addr));
+	chan->end = 0;
+	chan->start = 0;
+	chan->dma_state = 0;
+	chan->vflip_state = 0xff;
+	chan->state = TX_ISP_STATE_STOP;
+
+	chan->usingbanks = vdev->reqbufs > ISP_DMA_WRITE_MAXBASE_NUM ? ISP_DMA_WRITE_MAXBASE_NUM : vdev->reqbufs;
+
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			/* dma channel uv write */
+			//			APICAL_WRITE_32(base + 0xa4, 0x03);// axi_port_enable set 1, frame_write_cancel set 1.
+			primary = APICAL_READ_32(base + 0x80);
+			primary |= (1 << 9);
+			APICAL_WRITE_32(base + 0x80, primary);
+			APICAL_WRITE_32(base + 0x9c, chan->usingbanks > 0 ? chan->usingbanks -1 : 0);//MAX BANK
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		case V4L2_PIX_FMT_YUV444:
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_BGR24:
+		case V4L2_PIX_FMT_BGR32:
+		case V4L2_PIX_FMT_RGB310:
+		case V4L2_PIX_FMT_SBGGR12:
+		case V4L2_PIX_FMT_SGBRG12:
+		case V4L2_PIX_FMT_SGRBG12:
+		case V4L2_PIX_FMT_SRGGB12:
+			/* dma channel y write */
+			//			APICAL_WRITE_32(base + 0x24, 0x03);// axi_port_enable set 1, frame_write_cancel set 1.
+			primary = APICAL_READ_32(base);
+			primary |= (1 << 9);
+			APICAL_WRITE_32(base, primary);
+			APICAL_WRITE_32(base + 0x1c, chan->usingbanks > 0 ? chan->usingbanks -1 : 0);//MAX BANK
+			break;
+		default:
+			break;
+	}
+	/* streamon */
+	spin_lock_irqsave(&chan->slock, flags);
+	chan->state = TX_ISP_STATE_RUN;
+	spin_unlock_irqrestore(&chan->slock, flags);
+	apical_isp_input_port_field_mode_write(0); // Temporary measures
+	mutex_lock(&core->mlock);
+	atomic_add(TX_ISP_STATE_RUN, &core->chan_state);
+	mutex_unlock(&core->mlock);
+
+#if 0
+	printk("0x%08x = 0x%08x\n",0x40, APICAL_READ_32(0x40));
+	printk("0x%08x = 0x%08x\n",0x44, APICAL_READ_32(0x44));
+	printk("0x%08x = 0x%08x\n", base + 0x00, APICAL_READ_32(base + 0x00));
+	printk("0x%08x = 0x%08x\n", base + 0x04, APICAL_READ_32(base + 0x04));
+	printk("0x%08x = 0x%08x\n", base + 0x1c, APICAL_READ_32(base + 0x1c));
+	printk("0x%08x = 0x%08x\n", base + 0x20, APICAL_READ_32(base + 0x20));
+	printk("0x%08x = 0x%08x\n", base + 0x80 + 0x00, APICAL_READ_32(base + 0x80 + 0x00));
+	printk("0x%08x = 0x%08x\n", base + 0x80 + 0x04, APICAL_READ_32(base + 0x80 + 0x04));
+	printk("0x%08x = 0x%08x\n", base + 0x80 + 0x1c, APICAL_READ_32(base + 0x80 + 0x1c));
+	printk("0x%08x = 0x%08x\n", base + 0x80 + 0x20, APICAL_READ_32(base + 0x80 + 0x20));
+	{
+		unsigned int reg;
+		for(reg = 0x80; reg < 0xa4; reg = reg + 4)
+			printk("0x%08x = 0x%08x\n", reg, APICAL_READ_32(reg));
+		for(reg = 0x640; reg < 0x66c; reg = reg + 4)
+			printk("0x%08x = 0x%08x\n", reg, APICAL_READ_32(reg));
+	}
+#endif
+	return ISP_SUCCESS;
+}
+
+static int isp_core_frame_channel_streamoff(struct tx_isp_core_device *core, int value)
+{
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)value;
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct frame_channel_format *cfmt;
+	struct tx_isp_frame_channel *chan = &(core->chans[vdev->index]);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &(attr->output);
+	unsigned int base = 0x00b00 + 0x100 * vdev->index; // the base of address of dma channel write
+	unsigned int primary;
+	unsigned long flags;
+	int ret = ISP_SUCCESS;
+
+	spin_lock_irqsave(&chan->slock, flags);
+	if(chan->state == TX_ISP_STATE_STOP){
+		spin_unlock_irqrestore(&chan->slock, flags);
+		return ISP_SUCCESS;
+	}
+	spin_unlock_irqrestore(&chan->slock, flags);
+
+	switch(output->fmt.pix.pixelformat){
+		case V4L2_PIX_FMT_NV12:
+		case V4L2_PIX_FMT_NV21:
+			/* dma channel uv write */
+			while(APICAL_READ_32(base + 0xa4) & (1<<16));
+			primary = APICAL_READ_32(base + 0x80);
+			primary &= ~(1 << 9);
+			APICAL_WRITE_32(base + 0x80, primary);
+			APICAL_WRITE_32(base + 0x9c, 0x08);// axi_port_enable set 0, frame_write_cancel set 1.
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		case V4L2_PIX_FMT_YUV444:
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_BGR24:
+		case V4L2_PIX_FMT_BGR32:
+		case V4L2_PIX_FMT_RGB310:
+			/* dma channel y write */
+			while(APICAL_READ_32(base + 0x24) & (1<<16));
+			primary = APICAL_READ_32(base);
+			primary &= ~(1 << 9);
+			APICAL_WRITE_32(base, primary);
+			APICAL_WRITE_32(base + 0x1c, 0x08);// axi_port_enable set 0, frame_write_cancel set 1.
+			break;
+		default:
+			break;
+	}
+
+	/* streamoff */
+	spin_lock_irqsave(&chan->slock, flags);
+	chan->state = TX_ISP_STATE_STOP;
+	cleanup_buffer_fifo(&chan->fifo);
+	cleanup_chan_banks(chan);
+	spin_unlock_irqrestore(&chan->slock, flags);
+
+	atomic_sub(TX_ISP_STATE_RUN, &core->chan_state);
+
+	/* reset output parameters */
+	cfmt = &(isp_output_fmt[contrl->fmt_end]);
+	output->fmt.pix.width = contrl->inwidth;
+	output->fmt.pix.height = contrl->inheight;
+	output->fmt.pix.pixelformat = cfmt->fourcc;
+	output->fmt.pix.bytesperline = output->fmt.pix.width * cfmt->depth / 8;
+	output->fmt.pix.sizeimage = output->fmt.pix.bytesperline * output->fmt.pix.height;
+
+	return ret;
+}
+
+static int isp_core_frame_channel_queue_buffer(struct tx_isp_core_device *core, int value)
+{
+	struct frame_channel_video_buffer *vbuf = (struct frame_channel_video_buffer *)value;
+	frame_chan_vdev_t *vdev = (frame_chan_vdev_t *)vbuf->buf.priv;
+	struct tx_isp_frame_channel *chan = &(core->chans[vdev->index]);
+	unsigned long flags;
+	spin_lock_irqsave(&chan->slock, flags);
+	push_buffer_fifo(&chan->fifo, &vbuf->buf);
+	spin_unlock_irqrestore(&chan->slock, flags);
+	return ISP_SUCCESS;
+}
+static long isp_core_ops_private_ioctl(struct tx_isp_core_device *core, struct isp_private_ioctl *ctl)
+{
+	long ret = ISP_SUCCESS;
+	switch(ctl->cmd){
+		case TX_ISP_PRIVATE_IOCTL_MODULE_CLK:
+			ret = isp_core_set_clk(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SUBDEV_PREPARE_CHANGE:
+			if(atomic_read(&core->chan_state) > TX_ISP_STATE_START)
+				ret = -ISP_ERROR;
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SUBDEV_FINISH_CHANGE:
+			if(atomic_read(&core->chan_state) > TX_ISP_STATE_START)
+				ret = -ISP_ERROR;
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SYNC_VIDEO_IN:
+			if(ctl->value){
+				memcpy(&core->vin, (void *)(ctl->value), sizeof(struct tx_isp_video_in));
+				stab.global_max_integration_time = core->vin.attr->max_integration_time;
+			}else
+				memset(&core->vin, 0, sizeof(struct tx_isp_video_in));
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_ENUM_FMT:
+			ret = isp_core_frame_channel_enum_fmt(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_TRY_FMT:
+			ret = isp_core_frame_channel_try_fmt(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_FMT:
+			ret = isp_core_frame_channel_set_fmt(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_CROP_CAP:
+			ret = isp_core_frame_channel_crop_capture(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_CROP:
+			ret = isp_core_frame_channel_set_crop(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SCALER_CAP:
+			ret = isp_core_frame_channel_scaler_capture(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_SCALER:
+			ret = isp_core_frame_channel_set_scaler(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_STREAM_ON:
+			ret = isp_core_frame_channel_streamon(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_STREAM_OFF:
+			ret = isp_core_frame_channel_streamoff(core, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_QUEUE_BUFFER:
+			ret = isp_core_frame_channel_queue_buffer(core, ctl->value);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+
+static long isp_core_ops_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(sd);
+	long ret = ISP_SUCCESS;
+
+	switch(cmd){
+		case VIDIOC_ISP_PRIVATE_IOCTL:
+			ret = isp_core_ops_private_ioctl(core, arg);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+static const struct v4l2_subdev_core_ops isp_core_subdev_core_ops ={
+	.init = isp_core_ops_init,
+	.reset = isp_core_ops_reset,
+	.s_power = isp_core_ops_s_power,
+	.g_ctrl = isp_core_ops_g_ctrl,
+	.s_ctrl = isp_core_ops_s_ctrl,
+	.ioctl = isp_core_ops_ioctl,
+	.interrupt_service_routine = isp_core_interrupt_service_routine,
+};
+
+static void isp_core_config_frame_channel_attr(struct tx_isp_core_device *core)
+{
+	//	struct v4l2_subdev *sd = &core->sd;
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct tx_isp_frame_channel *chan = core->chans;
+	struct frame_channel_attribute *attr;
+	struct frame_channel_format *cfmt;
+	int index = 0;
+
+	cfmt = &(isp_output_fmt[contrl->fmt_end]);
+	for(index = 0; index < ISP_MAX_OUTPUT_VIDEOS; index++){
+		attr = &(chan[index].video.attr);
+		attr->output.fmt.pix.width = contrl->inwidth;
+		attr->output.fmt.pix.height = contrl->inheight;
+		attr->output.fmt.pix.pixelformat = cfmt->fourcc;
+		attr->output.fmt.pix.bytesperline = attr->output.fmt.pix.width * cfmt->depth / 8;
+		attr->output.fmt.pix.sizeimage = attr->output.fmt.pix.bytesperline * attr->output.fmt.pix.height;
+		//	printk("## %s[%d] width = %d height = %d pixformat = 0x%08x ##\n",
+		//		__func__,__LINE__,contrl->inwidth,contrl->inheight,cfmt->fourcc);
+	}
+}
+
+
+static int isp_config_input_port(struct tx_isp_core_device *core)
+{
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	struct apical_isp_contrl *contrl = &core->contrl;
+	unsigned char color = APICAL_ISP_TOP_RGGB_START_DEFAULT;
+	int ret = ISP_SUCCESS;
+	int index;
+
+	if(mbus->width > TX_ISP_INPUT_PORT_MAX_WIDTH || mbus->height > TX_ISP_INPUT_PORT_MAX_HEIGHT){
+		printk("Sensor outputs bigger resolution than that ISP device can't deal with!\n");
+		return -1;
+	}
+	switch(mbus->code){
+		case V4L2_MBUS_FMT_SBGGR8_1X8:
+		case V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8:
+		case V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE:
+		case V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE:
+		case V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE:
+		case V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE:
+		case V4L2_MBUS_FMT_SBGGR10_1X10:
+		case V4L2_MBUS_FMT_SBGGR12_1X12:
+			color = APICAL_ISP_TOP_RGGB_START_B_GB_GR_R;
+			memcpy(isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].name, "Bayer formats (sBGGR)", 32);
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].fourcc = V4L2_PIX_FMT_SBGGR12;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].depth = 16;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].priv = DMA_FORMAT_RAW16;
+			contrl->fmt_start = APICAL_ISP_INPUT_RAW_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_RAW_FMT_INDEX_END;
+			break;
+		case V4L2_MBUS_FMT_SGBRG8_1X8:
+		case V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8:
+		case V4L2_MBUS_FMT_SGBRG10_1X10:
+		case V4L2_MBUS_FMT_SGBRG12_1X12:
+			color = APICAL_ISP_TOP_RGGB_START_GB_B_R_GR;
+			memcpy(isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].name, "Bayer formats (sGBRG)", 32);
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].fourcc = V4L2_PIX_FMT_SGBRG12;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].depth = 16;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].priv = DMA_FORMAT_RAW16;
+			contrl->fmt_start = APICAL_ISP_INPUT_RAW_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_RAW_FMT_INDEX_END;
+			break;
+		case V4L2_MBUS_FMT_SGRBG8_1X8:
+		case V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:
+		case V4L2_MBUS_FMT_SGRBG10_1X10:
+		case V4L2_MBUS_FMT_SGRBG12_1X12:
+			color = APICAL_ISP_TOP_RGGB_START_GR_R_B_GB;
+			memcpy(isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].name, "Bayer formats (sGRBG)", 32);
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].fourcc = V4L2_PIX_FMT_SGRBG12;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].depth = 16;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].priv = DMA_FORMAT_RAW16;
+			contrl->fmt_start = APICAL_ISP_INPUT_RAW_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_RAW_FMT_INDEX_END;
+			break;
+		case V4L2_MBUS_FMT_SRGGB8_1X8:
+		case V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8:
+		case V4L2_MBUS_FMT_SRGGB10_1X10:
+		case V4L2_MBUS_FMT_SRGGB12_1X12:
+			color = APICAL_ISP_TOP_RGGB_START_R_GR_GB_B;
+			memcpy(isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].name, "Bayer formats (sRGGB)", 32);
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].fourcc = V4L2_PIX_FMT_SRGGB12;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].depth = 16;
+			isp_output_fmt[APICAL_ISP_RAW_FMT_INDEX].priv = DMA_FORMAT_RAW16;
+			contrl->fmt_start = APICAL_ISP_INPUT_RAW_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_RAW_FMT_INDEX_END;
+			break;
+		case V4L2_MBUS_FMT_RGB565_2X8_LE:
+			contrl->fmt_start = APICAL_ISP_INPUT_RGB565_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_RGB565_FMT_INDEX_END;
+			apical_isp_top_isp_raw_bypass_write(1);
+			break;
+		case V4L2_MBUS_FMT_RGB888_3X8_LE:
+			contrl->fmt_start = APICAL_ISP_INPUT_RGB888_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_RGB888_FMT_INDEX_END;
+			apical_isp_top_isp_raw_bypass_write(1);
+			break;
+		case V4L2_MBUS_FMT_YUYV8_1X16:
+			contrl->fmt_start = APICAL_ISP_INPUT_YUV_FMT_INDEX_START;
+			contrl->fmt_end = APICAL_ISP_INPUT_YUV_FMT_INDEX_END;
+			apical_isp_top_isp_processing_bypass_mode_write(3);
+			apical_isp_top_isp_raw_bypass_write(1);
+			break;
+		default:
+			contrl->fmt_start = contrl->fmt_end = APICAL_ISP_INPUT_RAW_FMT_INDEX_END;
+			v4l2_err(v4l2_dev, "%s[%d] the format(0x%08x) of input couldn't be handled!\n",
+					__func__,__LINE__, mbus->code);
+			ret = -ISP_ERROR;
+			break;
+	}
+	if(ret == ISP_SUCCESS){
+		contrl->inwidth = mbus->width;
+		contrl->inheight = mbus->height;
+		contrl->pattern = color;
+		apical_isp_top_active_width_write(contrl->inwidth);
+		apical_isp_top_active_height_write(contrl->inheight);
+		apical_isp_top_rggb_start_write(color); //Starting color of the rggb pattern
+		isp_core_config_frame_channel_attr(core);
+		/* downscaler paramerters */
+		for(index = 0; index < (sizeof(apical_downscaler_lut) / sizeof(apical_downscaler_lut[0])); index++)
+			APICAL_WRITE_32(apical_downscaler_lut[index].reg, apical_downscaler_lut[index].value);
+
+	}
+	return ret;
+}
+
+static int inline isp_core_video_streamon(struct tx_isp_core_device *core)
+{
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	apical_api_control_t api;
+	struct tx_isp_notify_argument arg;
+	unsigned int status, reason;
+	int ret = ISP_SUCCESS;
+
+	api.type = TSYSTEM;
+	api.id = ISP_SYSTEM_STATE;
+	api.dir = COMMAND_SET;
+	api.value = PAUSE;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret);
+
+	/* 2-->module config updates during local vertical blanking */
+	apical_isp_top_config_buffer_mode_write(2);
+	/* set input port mode, mode1 */
+	APICAL_WRITE_32(0x100, 0x00100001);
+
+	/* enable default isp modules and disable bypass isp process */
+	core->top.reg.low = APICAL_READ_32(0x40);
+	core->top.reg.high = APICAL_READ_32(0x44);
+	core->bypass = TX_ISP_FRAME_CHANNEL_BYPASS_ISP_DISABLE;
+
+	/* config isp input port */
+	isp_config_input_port(core);
+
+	/*
+	 * clear interrupts state of isp-core.
+	 * Interrupt event clear register writing 0-1 transition will clear the corresponding status bits.
+	 */
+	apical_isp_interrupts_interrupt_clear_write(0);
+	apical_isp_interrupts_interrupt_clear_write(0xffff);
+	/* unmask isp's top interrupts */
+	arg.value = TX_ISP_TOP_IRQ_ISP;
+	//	v4l2_dev->notify(&core->sd, TX_ISP_NOTIFY_UNMASK_IRQ, &arg);
+	//	v4l2_dev->notify(&core->sd, TX_ISP_NOTIFY_ENABLE_IRQ, &arg);
+	//	v4l2_dev->notify(&core->sd, TX_ISP_NOTIFY_DISABLE_IRQ, &arg);
+#if 1
+	api.type = TSYSTEM;
+	api.id = ISP_SYSTEM_STATE;
+	api.dir = COMMAND_SET;
+	api.value = RUN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if(status == ISP_SUCCESS){
+		atomic_set(&core->state, TX_ISP_STATE_RUN);
+	}else{
+		v4l2_err(v4l2_dev, "%s[%d] state = %d, reason = %d!\n",
+				__func__,__LINE__, status, ret);
+		ret = -ISP_ERROR;
+	}
+#endif
+	return ret;
+}
+
+
+static int isp_core_video_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(sd);
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	apical_api_control_t api;
+	unsigned int status = ISP_SUCCESS, reason;
+	struct tx_isp_frame_channel *chans;
+	frame_chan_vdev_t *video;
+	int ret = ISP_SUCCESS;
+	int index = 0;
+	if(atomic_read(&core->state) == TX_ISP_STATE_STOP){
+		v4l2_err(v4l2_dev, "%s[%d] the device hasn't been inited!\n",__func__,__LINE__);
+		return -ISP_ERROR;
+	}
+	/*printk("~~~~~~ %s[%d] enable = %d ~~~~~~\n",__func__, __LINE__, enable);*/
+	core->frame_state = 0;
+	core->vflip_state = 0;
+	core->hflip_state = 0;
+	if(enable){
+		/* streamon */
+		if(atomic_read(&core->state) == TX_ISP_STATE_START){
+			ret = isp_core_video_streamon(core);
+		}
+	}else{
+		/* streamoff */
+		if(atomic_read(&core->state) == TX_ISP_STATE_RUN){
+			if(atomic_read(&core->chan_state) >= TX_ISP_STATE_RUN){
+				/* At least one channel is in streamon state. */
+				/* Firstly we must be streamoff them */
+				chans = core->chans;
+				for(index = 0; index < ISP_MAX_OUTPUT_VIDEOS; index++){
+					if(chans[index].state == TX_ISP_STATE_RUN){
+						video = &(chans[index].video);
+						isp_core_frame_channel_streamoff(core, (int)video);
+					}
+				}
+			}
+			if(atomic_read(&core->chan_state) < TX_ISP_STATE_RUN){
+				/* all frame channels are streamoff state. */
+				api.type = TSYSTEM;
+				api.id = ISP_SYSTEM_STATE;
+				api.dir = COMMAND_SET;
+				api.value = PAUSE;
+				status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+				if(status == ISP_SUCCESS){
+					atomic_set(&core->state, TX_ISP_STATE_START);
+				}else{
+					v4l2_err(v4l2_dev, "%s[%d] status = %d, reason = %d!\n",
+							__func__,__LINE__, status, ret);
+					ret = -ISP_ERROR;
+				}
+			}else{
+				/* At least one channel is in streamon state. */
+				v4l2_err(v4l2_dev, "%s[%d] status = %d, reason = %d!\n",
+						__func__,__LINE__, status, ret);
+				ret = -ISP_ERROR;
+			}
+		}
+	}
+	return ret;
+}
+
+static const struct v4l2_subdev_video_ops isp_core_subdev_video_ops = {
+	.s_stream = isp_core_video_s_stream,
+};
+
+static const struct v4l2_subdev_ops isp_core_ops ={
+	.core = &isp_core_subdev_core_ops,
+	.video = &isp_core_subdev_video_ops,
+};
+
+/*
+ * ----------------- init device ------------------------
+ */
+
+static int isp_core_frame_channel_init(struct tx_isp_core_device *core)
+{
+	struct v4l2_subdev *sd = &core->sd;
+	struct v4l2_device *v4l2_dev = sd->v4l2_dev;
+	struct tx_isp_frame_channel *chans;
+	struct frame_channel_attribute *attr;
+	frame_chan_vdev_t *video;
+	int ret = ISP_SUCCESS;
+
+	chans = (struct tx_isp_frame_channel *)kzalloc(sizeof(*chans) * ISP_MAX_OUTPUT_VIDEOS, GFP_KERNEL);
+	if(!chans){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor device\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+#if TX_ISP_EXIST_FR_CHANNEL
+	/* init FR channel */
+	video = &(chans[ISP_FR_VIDEO_CHANNEL].video);
+	video->parent = sd;
+	video->vbm = core->vbm;
+	video->index = ISP_FR_VIDEO_CHANNEL;
+	ret = tx_isp_frame_channel_device_register(video);
+	if(ret){
+		v4l2_err(v4l2_dev, "Failed to register fr channel device\n");
+		goto err_fr_channel;
+	}
+	attr = &(video->attr);
+	attr->max_width = TX_ISP_FR_CAHNNEL_MAX_WIDTH;
+	attr->max_height = TX_ISP_FR_CAHNNEL_MAX_HEIGHT;
+	attr->min_width = 128;
+	attr->min_height = 128;
+	attr->step_width = 8;
+	attr->step_height = 8;
+	init_buffer_fifo(&(chans[ISP_FR_VIDEO_CHANNEL].fifo));
+	spin_lock_init(&(chans[ISP_FR_VIDEO_CHANNEL].slock));
+#endif
+	/* init DS1 channel */
+	video = &(chans[ISP_DS1_VIDEO_CHANNEL].video);
+	video->parent = sd;
+	video->vbm = core->vbm;
+	video->index = ISP_DS1_VIDEO_CHANNEL;
+	ret = tx_isp_frame_channel_device_register(video);
+	if(ret){
+		v4l2_err(v4l2_dev, "Failed to register ds1 channel device\n");
+		goto err_ds1_channel;
+	}
+	attr = &(video->attr);
+	attr->max_width = TX_ISP_DS1_CAHNNEL_MAX_WIDTH;
+	attr->max_height = TX_ISP_DS1_CAHNNEL_MAX_HEIGHT;
+	attr->min_width = 128;
+	attr->min_height = 128;
+	attr->step_width = 8;
+	attr->step_height = 8;
+	init_buffer_fifo(&(chans[ISP_DS1_VIDEO_CHANNEL].fifo));
+	spin_lock_init(&(chans[ISP_DS1_VIDEO_CHANNEL].slock));
+
+#if TX_ISP_EXIST_DS2_CHANNEL
+	/* init DS2 channel */
+	video = &(chans[ISP_DS2_VIDEO_CHANNEL].video);
+	video->parent = sd;
+	video->vbm = core->vbm;
+	video->index = ISP_DS2_VIDEO_CHANNEL;
+	ret = tx_isp_frame_channel_device_register(video);
+	if(ret){
+		v4l2_err(v4l2_dev, "Failed to register ds2 channel device\n");
+		goto err_ds2_channel;
+	}
+	attr = &(video->attr);
+	attr->max_width = TX_ISP_DS2_CAHNNEL_MAX_WIDTH;
+	attr->max_height = TX_ISP_DS2_CAHNNEL_MAX_HEIGHT;
+	attr->min_width = 128;
+	attr->min_height = 128;
+	attr->step_width = 8;
+	attr->step_height = 8;
+	init_buffer_fifo(&(chans[ISP_DS2_VIDEO_CHANNEL].fifo));
+	spin_lock_init(&(chans[ISP_DS2_VIDEO_CHANNEL].slock));
+#endif
+	atomic_set(&core->chan_state, TX_ISP_STATE_START);
+	core->chans = chans;
+	return ISP_SUCCESS;
+
+#if TX_ISP_EXIST_DS2_CHANNEL
+err_ds2_channel:
+	video = &(chans[ISP_DS1_VIDEO_CHANNEL].video);
+	tx_isp_frame_channel_device_unregister(video);
+#endif
+err_ds1_channel:
+	video = &(chans[ISP_FR_VIDEO_CHANNEL].video);
+	tx_isp_frame_channel_device_unregister(video);
+#if TX_ISP_EXIST_FR_CHANNEL
+err_fr_channel:
+#endif
+exit:
+	kfree(chans);
+	return ret;
+}
+
+static int isp_core_frame_channel_deinit(struct tx_isp_core_device *core)
+{
+	struct tx_isp_frame_channel *chans = core->chans;
+	frame_chan_vdev_t *video;
+
+#if TX_ISP_EXIST_FR_CHANNEL
+	video = &(chans[ISP_FR_VIDEO_CHANNEL].video);
+	tx_isp_frame_channel_device_unregister(video);
+#endif
+	video = &(chans[ISP_DS1_VIDEO_CHANNEL].video);
+	tx_isp_frame_channel_device_unregister(video);
+#if TX_ISP_EXIST_DS2_CHANNEL
+	video = &(chans[ISP_DS2_VIDEO_CHANNEL].video);
+	tx_isp_frame_channel_device_unregister(video);
+#endif
+
+	kfree(chans);
+	atomic_set(&core->chan_state, TX_ISP_STATE_STOP);
+	return ISP_SUCCESS;
+}
+
+/* debug system node */
+static int isp_info_show(struct seq_file *m, void *v)
+{
+	int len=0;
+	struct tx_isp_core_device *core = m->private;
+	struct tx_isp_video_in *vin = &core->vin;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	struct apical_isp_contrl *contrl = &core->contrl;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	char *colorspace = NULL;
+	char *ae_strategy = NULL;
+	unsigned int flicker = 0;
+	unsigned int temperature = 0;
+	unsigned int sensor_again = 0;
+	unsigned int max_sensor_again = 0;
+	unsigned int sensor_dgain = 0;
+	unsigned int max_sensor_dgain = 0;
+	unsigned int isp_dgain = 0;
+	unsigned int max_isp_dgain = 0;
+	unsigned int gain_log2_id = 0;
+	unsigned int total_gain = 0;
+	unsigned int exposure_log2_id = 0;
+	unsigned int saturation_target = 0;
+	unsigned int saturation = 0;
+	unsigned int contrast = 0;
+	unsigned int sharpness = 0;
+	unsigned int brightness = 0;
+	int ret = 0;
+	uint8_t evtolux = 0;
+
+
+	len += seq_printf(m ,"****************** ISP INFO **********************\n");
+	if(atomic_read(&core->state) < TX_ISP_STATE_RUN){
+		len += seq_printf(m ,"sensor doesn't work, please enable sensor\n");
+		return len;
+	}
+	switch(contrl->pattern){
+		case APICAL_ISP_TOP_RGGB_START_R_GR_GB_B:
+			colorspace = "RGGB";
+			break;
+		case APICAL_ISP_TOP_RGGB_START_GR_R_B_GB:
+			colorspace = "GRBG";
+			break;
+		case APICAL_ISP_TOP_RGGB_START_GB_B_R_GR:
+			colorspace = "GBRB";
+			break;
+		case APICAL_ISP_TOP_RGGB_START_B_GB_GR_R:
+			colorspace = "BGGR";
+			break;
+		default:
+			colorspace = "The format of isp input is RGB or YUV422";
+			break;
+	}
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+	api.id = ANTIFLICKER_MODE_ID;
+	api.value = 0;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	flicker = reason;
+
+	api.id = AWB_TEMPERATURE_ID;
+	api.value = 0;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	temperature = reason * 100;
+
+	api.id = AE_SPLIT_PRESET_ID;
+	api.value = 0;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	switch(reason){
+	case AE_SPLIT_BALANCED:
+		ae_strategy = "AE_SPLIT_BALANCED";
+		break;
+	case AE_SPLIT_INTEGRATION_PRIORITY:
+		ae_strategy = "AE_SPLIT_INTEGRATION_PRIORITY";
+		break;
+	default:
+		ae_strategy = "AE_STRATEGY_BUTT";
+		break;
+	}
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_GET;
+	api.value = 0;
+	api.id = SYSTEM_SENSOR_ANALOG_GAIN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	sensor_again = reason;
+
+	api.id = SYSTEM_MAX_SENSOR_ANALOG_GAIN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	max_sensor_again = reason;
+
+	api.id = SYSTEM_SENSOR_DIGITAL_GAIN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	sensor_dgain = reason;
+
+	api.id = SYSTEM_MAX_SENSOR_DIGITAL_GAIN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	max_sensor_dgain = reason;
+
+	api.id = SYSTEM_ISP_DIGITAL_GAIN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	isp_dgain = reason;
+
+	api.id = SYSTEM_MAX_ISP_DIGITAL_GAIN;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	max_isp_dgain = reason;
+
+	api.id = SYSTEM_SATURATION_TARGET;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	saturation_target = reason;
+
+	api.type = CALIBRATION;
+	api.id = GAIN_LOG2_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	gain_log2_id = reason;
+
+	api.id = EXPOSURE_LOG2_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	exposure_log2_id = reason;
+
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_GET;
+	api.id = SHARPENING_STRENGTH_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	sharpness = reason;
+
+	api.id = BRIGHTNESS_STRENGTH_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	brightness = reason;
+
+	api.id = SATURATION_STRENGTH_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	saturation = reason;
+
+	api.id = CONTRAST_STRENGTH_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	contrast = reason;
+
+	apical_api_calibration(CALIBRATION_EVTOLUX_PROBABILITY_ENABLE,COMMAND_GET,(void *) (&evtolux), 1, &ret);
+	total_gain =  stab.global_sensor_analog_gain  + stab.global_sensor_digital_gain + stab.global_isp_digital_gain;
+	total_gain = math_exp2(total_gain, 5, 8);
+
+	len += seq_printf(m ,"Software Version : %s\n", SOFT_VERSION);
+	len += seq_printf(m ,"Firmware Version : %s\n", FIRMWARE_VERSION);
+	len += seq_printf(m ,"SENSOR NAME : %s\n", vin->attr->name);
+	len += seq_printf(m ,"SENSOR OUTPUT WIDTH : %d\n", mbus->width);
+	len += seq_printf(m ,"SENSOR OUTPUT HEIGHT : %d\n", mbus->height);
+	len += seq_printf(m ,"SENSOR OUTPUT RAW PATTERN : %s\n", colorspace);
+	len += seq_printf(m ,"SENSOR Integration Time : %d lines\n", stab.global_integration_time);
+	len += seq_printf(m ,"ISP Top Value : 0x%x\n", APICAL_READ_32(0x40));
+	len += seq_printf(m ,"ISP Runing Mode : %s\n", ((apical_isp_ds1_cs_conv_clip_min_uv_read() == 512) ? "Night" : "Day"));
+	len += seq_printf(m ,"ISP OUTPUT FPS : %d / %d\n", vin->fps >> 16, vin->fps & 0xffff);
+	len += seq_printf(m ,"SENSOR analog gain : %d\n", sensor_again);
+	len += seq_printf(m ,"MAX SENSOR analog gain : %d\n", max_sensor_again);
+	len += seq_printf(m ,"SENSOR digital gain : %d\n", sensor_dgain);
+	len += seq_printf(m ,"MAX SENSOR digital gain : %d\n", max_sensor_dgain);
+	len += seq_printf(m ,"ISP digital gain : %d\n", isp_dgain);
+	len += seq_printf(m ,"MAX ISP digital gain : %d\n", max_isp_dgain);
+	len += seq_printf(m ,"ISP gain log2 id : %d\n", gain_log2_id);
+	len += seq_printf(m ,"ISP total gain : %d\n", total_gain);
+	len += seq_printf(m ,"ISP exposure log2 id: %d\n", exposure_log2_id);
+	len += seq_printf(m ,"ISP AE strategy: %s\n", ae_strategy);
+	len += seq_printf(m ,"ISP Antiflicker : %d[0 means disable]\n", flicker);
+	len += seq_printf(m ,"Evtolux Probability Enable  : %d\n", evtolux);
+	len += seq_printf(m ,"ISP WB Gain00 : %d\n", apical_isp_white_balance_gain_00_read());
+	len += seq_printf(m ,"ISP WB Gain01 : %d\n", apical_isp_white_balance_gain_01_read());
+	len += seq_printf(m ,"ISP WB Gain10 : %d\n", apical_isp_white_balance_gain_10_read());
+	len += seq_printf(m ,"ISP WB Gain11 : %d\n", apical_isp_white_balance_gain_11_read());
+	len += seq_printf(m ,"ISP WB rg : %d\n", apical_isp_metering_awb_rg_read());
+	len += seq_printf(m ,"ISP WB bg : %d\n", apical_isp_metering_awb_bg_read());
+	len += seq_printf(m ,"ISP WB Temperature : %d\n", temperature);
+	len += seq_printf(m ,"ISP Black level 00 : %d\n", apical_isp_offset_black_00_read());
+	len += seq_printf(m ,"ISP Black level 01 : %d\n", apical_isp_offset_black_01_read());
+	len += seq_printf(m ,"ISP Black level 10 : %d\n", apical_isp_offset_black_10_read());
+	len += seq_printf(m ,"ISP Black level 11 : %d\n", apical_isp_offset_black_11_read());
+	len += seq_printf(m ,"ISP LSC mesh module : %s\n", apical_isp_mesh_shading_enable_read()?"enable":"disable");
+	len += seq_printf(m ,"ISP LSC mesh blend mode : %d\n", apical_isp_mesh_shading_mesh_alpha_mode_read());
+	len += seq_printf(m ,"ISP LSC mesh R table : %d\n", apical_isp_mesh_shading_mesh_alpha_bank_r_read());
+	len += seq_printf(m ,"ISP LSC mesh G table : %d\n", apical_isp_mesh_shading_mesh_alpha_bank_g_read());
+	len += seq_printf(m ,"ISP LSC mesh B table : %d\n", apical_isp_mesh_shading_mesh_alpha_bank_b_read());
+	len += seq_printf(m ,"ISP LSC mesh R blend : %d\n", apical_isp_mesh_shading_mesh_alpha_r_read());
+	len += seq_printf(m ,"ISP LSC mesh G blend : %d\n", apical_isp_mesh_shading_mesh_alpha_g_read());
+	len += seq_printf(m ,"ISP LSC mesh B blend : %d\n", apical_isp_mesh_shading_mesh_alpha_b_read());
+	len += seq_printf(m ,"ISP LSC mesh shading strength : %d\n", APICAL_READ_32(0x39c));
+	len += seq_printf(m ,"ISP Sinter thresh1h : %d\n", apical_isp_sinter_thresh_1h_read());
+	len += seq_printf(m ,"ISP Sinter thresh4h : %d\n", apical_isp_sinter_thresh_4h_read());
+	len += seq_printf(m ,"ISP Sinter thresh1v : %d\n", apical_isp_sinter_thresh_1v_read());
+	len += seq_printf(m ,"ISP Sinter thresh4v : %d\n", apical_isp_sinter_thresh_4v_read());
+	len += seq_printf(m ,"ISP Sinter thresh short : %d\n", apical_isp_sinter_thresh_short_read());
+	len += seq_printf(m ,"ISP Sinter thresh long : %d\n", apical_isp_sinter_thresh_long_read());
+	len += seq_printf(m ,"ISP Sinter strength1 : %d\n", apical_isp_sinter_strength_1_read());
+	len += seq_printf(m ,"ISP Sinter strength4 : %d\n", apical_isp_sinter_strength_4_read());
+	len += seq_printf(m ,"ISP Temper thresh module :%s\n", apical_isp_temper_enable_read()?"enable":"disable");
+	len += seq_printf(m ,"ISP Temper thresh short : %d\n", apical_isp_temper_thresh_short_read());
+	len += seq_printf(m ,"ISP Temper thresh long : %d\n", apical_isp_temper_thresh_long_read());
+	len += seq_printf(m ,"ISP Iridix strength : %d\n", apical_isp_iridix_strength_read());
+	len += seq_printf(m ,"ISP Defect pixel threshold : %d\n", apical_isp_raw_frontend_dp_threshold_read());
+	len += seq_printf(m ,"ISP Defect pixel slope : %d\n", apical_isp_raw_frontend_dp_slope_read());
+	len += seq_printf(m ,"ISP sharpening directional : %d\n", apical_isp_demosaic_sharp_alt_d_read());
+	len += seq_printf(m ,"ISP sharpening undirectional : %d\n", apical_isp_demosaic_sharp_alt_ud_read());
+	len += seq_printf(m ,"ISP FR sharpen strength : %d\n", apical_isp_fr_sharpen_strength_read());
+	len += seq_printf(m ,"ISP DS1 sharpen strength : %d\n", apical_isp_ds1_sharpen_strength_read());
+#if TX_ISP_EXIST_DS2_CHANNEL
+	len += seq_printf(m ,"ISP DS2 sharpen strength : %d\n", apical_isp_ds2_sharpen_strength_read());
+#endif
+	len += seq_printf(m ,"ISP CCM R_R : %d\n", apical_isp_matrix_rgb_coefft_r_r_read());
+	len += seq_printf(m ,"ISP CCM R_G : %d\n", apical_isp_matrix_rgb_coefft_r_g_read());
+	len += seq_printf(m ,"ISP CCM R_B : %d\n", apical_isp_matrix_rgb_coefft_r_b_read());
+	len += seq_printf(m ,"ISP CCM G_R : %d\n", apical_isp_matrix_rgb_coefft_g_r_read());
+	len += seq_printf(m ,"ISP CCM G_B : %d\n", apical_isp_matrix_rgb_coefft_g_b_read());
+	len += seq_printf(m ,"ISP CCM G_G : %d\n", apical_isp_matrix_rgb_coefft_g_g_read());
+	len += seq_printf(m ,"ISP CCM B_R : %d\n", apical_isp_matrix_rgb_coefft_b_r_read());
+	len += seq_printf(m ,"ISP CCM B_G : %d\n", apical_isp_matrix_rgb_coefft_b_g_read());
+	len += seq_printf(m ,"ISP CCM B_B : %d\n", apical_isp_matrix_rgb_coefft_b_b_read());
+	len += seq_printf(m ,"Saturation Target : %d\n", saturation_target);
+	len += seq_printf(m ,"Saturation : %d\n", saturation);
+	len += seq_printf(m ,"Sharpness : %d\n", sharpness);
+	len += seq_printf(m ,"Contrast : %d\n", contrast);
+	len += seq_printf(m ,"Brightness : %d\n", brightness);
+
+	return len;
+}
+
+static int dump_isp_info_open(struct inode *inode, struct file *file)
+{
+	return single_open_size(file, isp_info_show, PDE_DATA(inode),8192);
+}
+
+static const struct file_operations isp_info_proc_fops ={
+	.read = seq_read,
+	.open = dump_isp_info_open,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+/* gamma info */
+static int isp_gamma_show(struct seq_file *m, void *v)
+{
+	int len = 0;
+	int i = 0;
+	int ret = 0;
+	uint16_t gamma[129] = {0};
+
+	struct tx_isp_core_device *core = m->private;
+
+	if(atomic_read(&core->state) < TX_ISP_STATE_RUN){
+		len += seq_printf(m ,"sensor doesn't work, please enable sensor\n");
+		return len;
+	}
+
+	apical_api_calibration(CALIBRATION_GAMMA_LINEAR, COMMAND_GET, gamma, 1*129*2, &ret);
+	printk("ret = %d\n", ret);
+	for (i = 0; i < 129; i++) {
+		len += seq_printf(m ," %d", gamma[i]);
+	}
+	len += seq_printf(m ,"\n");
+#if 0
+	for (i = 0; i < 129; i++) {
+		len += seq_printf(m ," %d", APICAL_READ_32(0x10400+4*i));
+	}
+	len += seq_printf(m ,"\n");
+#endif
+	return len;
+}
+
+static int dump_isp_gamma_open(struct inode *inode, struct file *file)
+{
+	return single_open_size(file, isp_gamma_show, PDE_DATA(inode),8192);
+}
+
+static ssize_t isp_gamma_put(struct file *file, const char __user *buffer, size_t count, loff_t *f_pos)
+{
+	int i = 0;
+	int ret = 0;
+	uint16_t gamma[129] = {0};
+	char *ps;
+	char *pe;
+	char *bufe;
+
+	char *buf = kzalloc((count+1), GFP_KERNEL);
+	if(!buf)
+		return -ENOMEM;
+	if(copy_from_user(buf, buffer, count))
+	{
+		kfree(buf);
+		return EFAULT;
+	}
+	printk("%s\n", buf);
+
+	ps = buf;
+	pe = buf;
+	bufe = buf + count;
+	for (i = 0; i < (129+1); i++) {
+		while((*ps)<'0'||(*ps)>'9')	{
+			ps++;
+			if ((uint32_t)ps >= (uint32_t)bufe) {
+				if (129 != i) {
+					goto err_gamma_parse;
+				} else {
+					goto end_gamma_parse;
+				}
+
+			}
+		}
+		if (i >= 129) {
+			goto err_gamma_parse;
+		}
+		gamma[i] = simple_strtoull(ps, &pe, 0);
+		ps = pe;
+	}
+
+end_gamma_parse:
+	apical_api_calibration(CALIBRATION_GAMMA_LINEAR, COMMAND_SET, gamma, 1*129*2, &ret);
+#if 0
+	for (i = 0; i < 129; i++) {
+		APICAL_WRITE_32(0x10400+4*i, gamma[i]);
+	}
+#endif
+	printk("isp gamma set ok\n");
+	kfree(buf);
+	return count;
+
+err_gamma_parse:
+	printk("err_gamma_parse\n");
+	kfree(buf);
+	return count;
+}
+
+static const struct file_operations isp_gamma_proc_fops ={
+	.read = seq_read,
+	.open = dump_isp_gamma_open,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = isp_gamma_put,
+};
+
+
+/* hilight func info */
+static int isp_de_hilight_show(struct seq_file *m, void *v)
+{
+	int len = 0;
+	struct tx_isp_core_device *core = m->private;
+	struct v4l2_control ctrl;
+
+	if(atomic_read(&core->state) < TX_ISP_STATE_RUN){
+		len += seq_printf(m ,"sensor doesn't work, please enable sensor\n");
+		return len;
+	}
+
+	ctrl.id = IMAGE_TUNING_CID_HILIGHT_DEPRESS_STRENGTH;
+	ctrl.value = 0;
+	v4l2_subdev_call(&core->sd, core, g_ctrl, &ctrl);
+	len += seq_printf(m ,"de_hilight_strength:%d\n", ctrl.value);
+
+	len += seq_printf(m ,"hist0:%d\n", apical_isp_metering_hist_0_read());
+	len += seq_printf(m ,"hist1:%d\n", apical_isp_metering_hist_1_read());
+	len += seq_printf(m ,"hist3:%d\n", apical_isp_metering_hist_3_read());
+	len += seq_printf(m ,"hist4:%d\n", apical_isp_metering_hist_4_read());
+
+	return len;
+}
+static ssize_t isp_de_hilight_strength_set(struct file *file, const char __user *buffer, size_t count, loff_t *f_pos)
+{
+	unsigned v = 0;
+	struct seq_file *m = file->private_data;
+	struct tx_isp_core_device *core = m->private;
+	struct v4l2_control ctrl;
+
+	char *buf = kzalloc((count+1), GFP_KERNEL);
+	if(!buf)
+		return -ENOMEM;
+	if(copy_from_user(buf, buffer, count))
+	{
+		kfree(buf);
+		return EFAULT;
+	}
+	v = simple_strtoull(buf, NULL, 0);
+	ctrl.id = IMAGE_TUNING_CID_HILIGHT_DEPRESS_STRENGTH;
+	ctrl.value = v;
+	v4l2_subdev_call(&core->sd, core, s_ctrl, &ctrl);
+	kfree(buf);
+	return count;
+}
+static int dump_isp_de_hilight_open(struct inode *inode, struct file *file)
+{
+	return single_open_size(file, isp_de_hilight_show, PDE_DATA(inode),8192);
+}
+static const struct file_operations isp_de_hilight_fops ={
+	.read = seq_read,
+	.open = dump_isp_de_hilight_open,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = isp_de_hilight_strength_set,
+};
+
+
+
+/* cmd */
+#define ISP_CMD_BUF_SIZE 100
+static uint8_t isp_cmd_buf[100];
+static int isp_cmd_show(struct seq_file *m, void *v)
+{
+	int len = 0;
+	struct tx_isp_core_device *core = m->private;
+	if(atomic_read(&core->state) < TX_ISP_STATE_RUN){
+		len += seq_printf(m ,"sensor doesn't work, please enable sensor\n");
+		return len;
+	}
+
+	len += seq_printf(m ,"%s\n", isp_cmd_buf);
+	return len;
+}
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+int isp_sen_reg_read(struct tx_isp_core_device *core, uint32_t reg, uint32_t *val)
+{
+	int ret = 0;
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	struct v4l2_subdev *sd;
+	struct list_head *pos;
+	int find = 0;
+	struct tx_isp_video_in_device *vi = 0;
+	struct tx_isp_sensor *active;
+	struct v4l2_dbg_register dbg_reg;
+
+	if(atomic_read(&core->state) < TX_ISP_STATE_RUN){
+		ret = -1;
+		goto err_isp_state;
+	}
+
+	list_for_each(pos, &v4l2_dev->subdevs) {
+		sd = list_entry(pos, struct v4l2_subdev, list);
+		if (!strcmp(sd->name, "tx-isp-video-in")) {
+			find = 1;
+			break;
+		}
+	}
+	if (1 != find) {
+		ret = -1;
+		goto err_find_video_in;
+	}
+	vi = sd_to_tx_video_in_device(sd);
+	active = vi->active;
+	if (NULL == active) {
+		ret = -1;
+		goto err_active_sensor;
+	}
+	memset(&dbg_reg, 0, sizeof(dbg_reg));
+	dbg_reg.match.type = V4L2_CHIP_MATCH_SUBDEV;
+	dbg_reg.reg = reg;
+	v4l2_subdev_call(&active->sd, core, g_register, &dbg_reg);
+	*val = dbg_reg.val;
+
+	return ret;
+err_active_sensor:
+err_find_video_in:
+err_isp_state:
+
+	printk("##### err %s,%d\n", __func__, __LINE__);
+	*val = 0;
+	return ret;
+}
+static int isp_sen_reg_write(struct tx_isp_core_device *core, uint32_t reg, uint32_t val)
+{
+	int ret = 0;
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	struct v4l2_subdev *sd;
+	struct list_head *pos;
+	int find = 0;
+	struct tx_isp_video_in_device *vi = 0;
+	struct tx_isp_sensor *active;
+	struct v4l2_dbg_register dbg_reg;
+
+	if(atomic_read(&core->state) < TX_ISP_STATE_RUN){
+		ret = -1;
+		goto err_isp_state;
+	}
+
+	list_for_each(pos, &v4l2_dev->subdevs) {
+		sd = list_entry(pos, struct v4l2_subdev, list);
+		if (!strcmp(sd->name, "tx-isp-video-in")) {
+			find = 1;
+			break;
+		}
+	}
+	if (1 != find) {
+		ret = -1;
+		goto err_find_video_in;
+	}
+	vi = sd_to_tx_video_in_device(sd);
+	active = vi->active;
+	if (NULL == active) {
+		ret = -1;
+		goto err_active_sensor;
+	}
+	memset(&dbg_reg, 0, sizeof(dbg_reg));
+	dbg_reg.match.type = V4L2_CHIP_MATCH_SUBDEV;
+	dbg_reg.reg = reg;
+	dbg_reg.val = val;
+	ret = v4l2_subdev_call(&active->sd, core, s_register, &dbg_reg);
+	return ret;
+err_active_sensor:
+err_find_video_in:
+err_isp_state:
+
+	printk("##### err %s,%d\n", __func__, __LINE__);
+	return ret;
+}
+#endif
+static ssize_t isp_cmd_set(struct file *file, const char __user *buffer, size_t count, loff_t *f_pos)
+{
+	int ret = 0;
+	struct seq_file *m = file->private_data;
+	struct tx_isp_core_device *core = m->private;
+
+	char *buf = kzalloc((count+1), GFP_KERNEL);
+	if(!buf)
+		return -ENOMEM;
+	if(copy_from_user(buf, buffer, count))
+	{
+		kfree(buf);
+		return EFAULT;
+	}
+	//printk("##### %s\n", buf);
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	if (!strncmp(buf, "r sen_reg", sizeof("r sen_reg")-1)) {
+		unsigned reg = 0;
+		unsigned val = 0;
+		reg = simple_strtoull(buf+sizeof("r sen_reg"), NULL, 0);
+		ret = isp_sen_reg_read(core, reg, &val);
+		if (ret)
+			printk("##### err %s.%d\n", __func__, __LINE__);
+		printk("isp: sensor reg read 0x%x(0x%x)\n", reg, val);
+		sprintf(isp_cmd_buf, "0x%x\n", val);
+	} else if (!strncmp(buf, "w sen_reg", sizeof("w sen_reg")-1)) {
+		unsigned reg = 0;
+		unsigned val = 0;
+		char *p = 0;
+		reg = simple_strtoull(buf+sizeof("w sen_reg"), &p, 0);
+		val = simple_strtoull(p+1, NULL, 0);
+		printk("isp: sensor reg write 0x%x(0x%x)\n", reg, val);
+		ret = isp_sen_reg_write(core, reg, val);
+		if (!ret)
+			sprintf(isp_cmd_buf, "%s\n", "ok");
+		else
+			sprintf(isp_cmd_buf, "%s\n", "nok");
+#else
+		if (0) {
+			;
+#endif
+		} else {
+			sprintf(isp_cmd_buf, "null");
+		}
+		kfree(buf);
+		return count;
+}
+static int isp_cmd_open(struct inode *inode, struct file *file)
+{
+	return single_open_size(file, isp_cmd_show, PDE_DATA(inode),8192);
+}
+static const struct file_operations isp_cmd_fops ={
+	.read = seq_read,
+	.open = isp_cmd_open,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.write = isp_cmd_set,
+};
+
+
+static const struct media_entity_operations core_media_ops = {
+	.link_setup = NULL,
+};
+
+int register_tx_isp_core_device(struct platform_device *pdev, struct v4l2_device *v4l2_dev)
+{
+	struct tx_isp_subdev_platform_data *pdata = pdev->dev.platform_data;
+	struct tx_isp_core_device *core_dev = NULL;
+	struct resource *res = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct media_pad *pads = NULL;
+	struct media_entity *me = NULL;
+	struct proc_dir_entry *proc;
+	int ret;
+
+	if(!pdata){
+		v4l2_err(v4l2_dev, "The platform_data of csi is NULL!\n");
+		ret = -ISP_ERROR;
+		goto exit;
+	};
+	core_dev = (struct tx_isp_core_device *)kzalloc(sizeof(*core_dev), GFP_KERNEL);
+	if(!core_dev){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor device\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	res = request_mem_region(res->start,
+			res->end - res->start + 1, dev_name(&pdev->dev));
+	if (!res) {
+		v4l2_err(v4l2_dev, "Not enough memory for resources\n");
+		ret = -EBUSY;
+		goto mem_region_failed;
+	}
+	core_dev->base = ioremap(res->start, res->end - res->start + 1);
+	if (!core_dev->base) {
+		v4l2_err(v4l2_dev, "Unable to ioremap registers!\n");
+		ret = -ENXIO;
+		goto ioremap_failed;
+	}
+	core_dev->res = res;
+	spin_lock_init(&core_dev->slock);
+	mutex_init(&core_dev->mlock);
+	core_dev->refcnt = 0;
+	core_dev->pdata = pdata;
+	core_dev->dev = &pdev->dev;
+	sd = &core_dev->sd;
+	pads = core_dev->pads;
+	me = &sd->entity;
+
+	/*printk("&&&&&&&&&&& %s:slock = %p, mlock = %p &&&&&&&&&&\n",__func__,*/
+			/*&core_dev->slock, &core_dev->mlock);*/
+	v4l2_subdev_init(sd, &isp_core_ops);
+	strlcpy(sd->name, "tx-isp-core-subdev", sizeof(sd->name));
+
+	sd->grp_id = pdata->grp_id ;	/* group ID for isp subdevs */
+	v4l2_set_subdevdata(sd, core_dev);
+
+	pads[TX_ISP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	pads[TX_ISP_PAD_LINK].flags = MEDIA_PAD_FL_SINK;
+
+	me->ops = &core_media_ops;
+	//	me->parent = v4l2_dev->mdev;
+	ret = media_entity_init(me, TX_ISP_PADS_NUM, pads, 0);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to init media entity!\n");
+		ret = -ISP_ERROR;
+		goto entity_init_failed;
+	}
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to register csi-subdev!\n");
+		ret = -ISP_ERROR;
+		goto register_failed;
+	}
+
+	ret = isp_core_init_clk(core_dev);
+	if(ret < 0){
+		v4l2_err(v4l2_dev, "Failed to init isp's clks!\n");
+		ret = -ISP_ERROR;
+		goto failed_to_init_clk;
+	}
+
+	/* the frame buffer manager */
+	core_dev->vbm = frame_buffer_manager_create(core_dev->dev);
+	if(!core_dev->vbm){
+		v4l2_err(v4l2_dev, "Failed to create the manager of frame buffer!\n");
+		ret = -ISP_ERROR;
+		goto failed_to_frame_buffer;
+	}
+
+	/* the video node of image tuning is registered */
+	core_dev->tun = tx_isp_image_tuning_device_register(sd);
+	if(core_dev->tun == NULL){
+		v4l2_err(v4l2_dev, "Failed to init image tuning node!\n");
+		ret = -ISP_ERROR;
+		goto failed_to_image_tuning;
+	}
+
+	/* init isp's dma channel */
+	ret = isp_core_frame_channel_init(core_dev);
+	if(ret){
+		v4l2_err(v4l2_dev, "Failed to init frame channels!\n");
+		ret = -ISP_ERROR;
+		goto failed_to_frame_channel;
+	}
+
+	/* init v4l2_priority */
+	v4l2_prio_init(&core_dev->prio);
+
+	atomic_set(&core_dev->state, TX_ISP_STATE_STOP);
+	platform_set_drvdata(pdev, core_dev);
+
+	/* apical init */
+	system_isp_set_base_address(core_dev->base);
+	apical_sensor_early_init(core_dev);
+	isp_set_interrupt_ops(sd);
+
+	/* creat the node of printing isp info */
+	proc = jz_proc_mkdir("isp");
+	if (!proc) {
+		v4l2_err(v4l2_dev, "create dev_attr_isp_info failed!\n");
+		printk("################## %s %d ############################\n",__func__,__LINE__);
+	}
+	proc_create_data("isp_info", S_IRUGO, proc, &isp_info_proc_fops, (void *)core_dev);
+	proc_create_data("isp_gamma", S_IRUGO, proc, &isp_gamma_proc_fops, (void *)core_dev);
+	proc_create_data("isp_de_hilight", S_IRUGO, proc, &isp_de_hilight_fops, (void *)core_dev);
+
+	proc_create_data("cmd", S_IRUGO, proc, &isp_cmd_fops, (void *)core_dev);
+
+	core_dev->proc = proc;
+	return ISP_SUCCESS;
+failed_to_frame_channel:
+	tx_isp_image_tuning_device_release(core_dev->tun);
+failed_to_image_tuning:
+	frame_buffer_manager_cleanup(core_dev->vbm);
+failed_to_frame_buffer:
+	isp_core_release_clk(core_dev);
+failed_to_init_clk:
+	v4l2_device_unregister_subdev(sd);
+register_failed:
+	media_entity_cleanup(me);
+entity_init_failed:
+	iounmap(core_dev->base);
+ioremap_failed:
+	release_mem_region(res->start, res->end - res->start + 1);
+mem_region_failed:
+	kfree(core_dev);
+exit:
+	return ret;
+}
+
+void release_tx_isp_core_device(struct v4l2_subdev *sd)
+{
+	struct tx_isp_core_device *core = v4l2_get_subdevdata(sd);
+
+	tx_isp_image_tuning_device_release(core->tun);
+	isp_core_frame_channel_deinit(core);
+	frame_buffer_manager_cleanup(core->vbm);
+	free_tx_isp_priv_param_manage();
+
+	isp_core_release_clk(core);
+	v4l2_device_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+
+	iounmap(core->base);
+	release_mem_region(core->res->start,core->res->end - core->res->start + 1);
+	if (core->proc)
+		proc_remove(core->proc);
+	kfree(core);
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,151 @@
+#ifndef __TX_ISP_CORE_H__
+#define __TX_ISP_CORE_H__
+
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <jz_proc.h>
+
+#include <apical-isp/apical.h>
+#include <tx-isp-common.h>
+#include "../tx-isp-frame-channel.h"
+#include "../tx-isp-interrupt.h"
+#include "../tx-isp-videobuf.h"
+#include "tx-isp-load-parameters.h"
+
+
+/* apical ISP channel define */
+enum isp_video_channel_define{
+	ISP_FR_VIDEO_CHANNEL,
+	ISP_DS1_VIDEO_CHANNEL,
+#if TX_ISP_EXIST_DS2_CHANNEL
+	ISP_DS2_VIDEO_CHANNEL,
+#endif
+	ISP_MAX_OUTPUT_VIDEOS,
+};
+
+struct isp_reg_t {
+	unsigned int reg;
+	unsigned int value;
+};
+#define ISP_DMA_WRITE_MAXBASE_NUM 5
+#define ISP_DMA_WRITE_BANK_FLAG_UNCONFIG 0
+#define ISP_DMA_WRITE_BANK_FLAG_CONFIG 1
+enum apical_isp_format_check_index {
+	APICAL_ISP_INPUT_RAW_FMT_INDEX_START = 0,
+	APICAL_ISP_INPUT_RGB888_FMT_INDEX_START = 0,
+	APICAL_ISP_INPUT_YUV_FMT_INDEX_START = 0,
+	APICAL_ISP_NV12_FMT_INDEX = 0,
+	APICAL_ISP_NV21_FMT_INDEX,
+	APICAL_ISP_YUYV_FMT_INDEX,
+	APICAL_ISP_UYVY_FMT_INDEX,
+	APICAL_ISP_INPUT_YUV_FMT_INDEX_END = APICAL_ISP_UYVY_FMT_INDEX,
+	APICAL_ISP_YUV444_FMT_INDEX,
+	APICAL_ISP_INPUT_RGB565_FMT_INDEX_START = APICAL_ISP_YUV444_FMT_INDEX,
+	APICAL_ISP_RGB565_FMT_INDEX,
+	APICAL_ISP_INPUT_RGB565_FMT_INDEX_END = APICAL_ISP_RGB565_FMT_INDEX,
+	APICAL_ISP_RGB24_FMT_INDEX,
+	APICAL_ISP_RGB888_FMT_INDEX,
+	APICAL_ISP_INPUT_RGB888_FMT_INDEX_END = APICAL_ISP_RGB888_FMT_INDEX,
+	APICAL_ISP_RGB310_FMT_INDEX,
+	APICAL_ISP_RAW_FMT_INDEX,
+	APICAL_ISP_INPUT_RAW_FMT_INDEX_END = APICAL_ISP_RAW_FMT_INDEX,
+	APICAL_ISP_FMT_MAX_INDEX,
+};
+
+struct tx_isp_frame_channel {
+	frame_chan_vdev_t video;
+	struct list_head fifo;
+	unsigned char bank_flag[ISP_DMA_WRITE_MAXBASE_NUM];
+	unsigned char vflip_flag[ISP_DMA_WRITE_MAXBASE_NUM];
+	unsigned int banks_addr[ISP_DMA_WRITE_MAXBASE_NUM];
+	unsigned char start;
+	unsigned char end;
+	unsigned char dma_state;
+	unsigned char reset_dma_flag;
+	unsigned char vflip_state;
+	unsigned char state;
+	unsigned char usingbanks;
+	spinlock_t slock;
+};
+
+#define APICAL_ISP_TOP_CONTROL_LOW_REG_DEFAULT (0x3f7fffff)
+//#define APICAL_ISP_TOP_CONTROL_LOW_REG_DEFAULT (0x33658593)
+//#define APICAL_ISP_TOP_CONTROL_LOW_REG_TEST (0x3f7ffffe)
+#define APICAL_ISP_TOP_CONTROL_HIGH_REG_DEFAULT (0x00000c7e)
+
+struct apical_isp_contrl {
+	unsigned int infmt;
+	unsigned short inwidth;
+	unsigned short inheight;
+	unsigned int pattern;
+	enum apical_isp_format_check_index fmt_start;
+	enum apical_isp_format_check_index fmt_end;
+};
+
+struct tx_isp_dma_conf {
+	void *vaddr;
+	dma_addr_t paddr;
+	unsigned long size;
+};
+
+enum tx_isp_i2c_index {
+	TX_ISP_I2C_SET_AGAIN,
+	TX_ISP_I2C_SET_DGAIN,
+	TX_ISP_I2C_SET_INTEGRATION,
+	TX_ISP_I2C_SET_BUTTON,
+};
+
+struct tx_isp_i2c_msg {
+	unsigned int flag;
+	unsigned int value;
+};
+
+struct tx_isp_core_device {
+	/* the common parameters */
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pads[TX_ISP_PADS_NUM];
+	struct resource *res;
+	void __iomem *base;
+	struct clk **clks;
+	unsigned int clk_num;
+	spinlock_t slock;
+	atomic_t state;
+	unsigned int refcnt;
+	const unsigned int revision;
+	struct tx_isp_video_in vin;
+	struct v4l2_prio_state prio;
+	void * pdata;
+
+	/* the special parameters of a instance */
+	apical_isp_top_ctl_t top;
+	struct apical_isp_contrl contrl;
+
+	struct video_device *tun;
+	struct mutex mlock;
+
+	struct tx_isp_frame_channel *chans;
+	atomic_t chan_state;
+	int bypass;
+	void *vbm;
+
+	/* frame state */
+	volatile unsigned int frame_state; // 0 : idle, 1 : processing
+	unsigned int vflip_state; //0:disable, 1: enable
+	unsigned int hflip_state; //0:disable, 1: enable
+	unsigned int isp_daynight_switch;
+	/* i2c sync messages */
+	struct tx_isp_i2c_msg i2c_msgs[TX_ISP_I2C_SET_BUTTON];
+	/* the private parameters */
+	struct task_struct *process_thread;
+	TXispPrivParamManage *param;
+	/* the node of printing isp info */
+	struct proc_dir_entry *proc;
+};
+
+#define sd_to_tx_isp_core_device(x) (container_of((x), struct tx_isp_core_device, sd))
+int register_tx_isp_core_device(struct platform_device *pdev, struct v4l2_device *v4l2_dev);
+void release_tx_isp_core_device(struct v4l2_subdev *sd);
+#endif /* __TX_ISP_CORE_H__  */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,4570 @@
+#include <linux/videodev2.h>
+#include <linux/delay.h>
+#include "apical_command_api.h"
+#include <apical-isp/apical_isp_config.h>
+#include <apical-isp/apical_math.h>
+#include <apical-isp/apical_metering_mem_config.h>
+#include <apical-isp/apical_isp_core_nomem_settings.h>
+#include <apical-isp/apical_histogram_mem_config.h>
+#include "tx-isp-core-tuning.h"
+#include "../tx-isp-debug.h"
+
+/** the kernel command line whether the mem of WDR and Temper exist. **/
+extern unsigned long ispmem_base;
+extern unsigned long ispmem_size;
+extern system_tab stab ;
+
+static inline int wb_value_v4l2_to_apical(int val)
+{
+	int ret = 0;
+	switch(val){
+		case V4L2_WHITE_BALANCE_MANUAL:
+			ret = AWB_MANUAL;
+			break;
+		case V4L2_WHITE_BALANCE_AUTO:
+			ret = AWB_AUTO;
+			break;
+		case V4L2_WHITE_BALANCE_INCANDESCENT:
+			ret = AWB_INCANDESCENT;
+			break;
+		case V4L2_WHITE_BALANCE_FLUORESCENT:
+			ret = AWB_FLOURESCENT;
+			break;
+		case V4L2_WHITE_BALANCE_FLUORESCENT_H:
+			ret = AWB_WARM_FLOURESCENT;
+			break;
+		case V4L2_WHITE_BALANCE_HORIZON:
+			ret = AWB_TWILIGHT;
+			break;
+		case V4L2_WHITE_BALANCE_DAYLIGHT:
+			ret = AWB_DAY_LIGHT;
+			break;
+		case V4L2_WHITE_BALANCE_CLOUDY:
+			ret = AWB_CLOUDY;
+			break;
+		case V4L2_WHITE_BALANCE_SHADE:
+			ret = AWB_SHADE;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+#if 0
+static int apical_isp_wb_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *wb_mode = tuning->ctrls.wb_mode;
+	apical_api_control_t api;
+	struct isp_core_awb_attr *attr = &tuning->ctrls.awb_attr;
+	struct isp_core_mwb_attr *mattr = &tuning->ctrls.mwb_attr;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	switch(control->id){
+		case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+			api.id = AWB_MODE_ID;
+			api.value = wb_value_v4l2_to_apical(wb_mode->val);
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			break;
+		case IMAGE_TUNING_CID_AWB_ATTR:
+			copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+			/* sets the lowest color temperature that the AWB algorithm can select */
+			api.id = AWB_RANGE_LOW_ID;
+			api.value = attr->low_color_temp / 100;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			/* sets the highest color temperature that the AWB algorithm can select */
+			api.id = AWB_RANGE_HIGH_ID;
+			api.value = attr->high_color_temp / 100;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			/*
+			* select which zones are used to gather AWB statistics.
+			* the region of interest is defined as rectangle with top-left coordinates(startx, starty)
+			* and bottom-right coordinates(endx, endy).
+			*/
+			api.id = AWB_ROI_ID;
+			api.value = attr->zone_sel.val;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+#if 0
+			/* config the weight of every zone  */
+			for(i = 0; i < WEIGHT_ZONE_NUM; i++)
+#endif
+			break;
+		case IMAGE_TUNING_CID_MWB_ATTR:
+			copy_from_user(mattr, (const void __user *)control->value, sizeof(*mattr));
+			if(wb_mode->cur.val == V4L2_WHITE_BALANCE_MANUAL){
+				api.id = AWB_RGAIN_ID;
+				api.value = mattr->red_gain;
+				status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+				api.id = AWB_BGAIN_ID;
+				api.value = mattr->blue_gain;
+				status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+#endif
+static inline int ae_value_v4l2_to_apical(int val)
+{
+	int ret = 0;
+	switch(val){
+		case V4L2_EXPOSURE_AUTO:
+			ret = AE_AUTO;
+			break;
+		case V4L2_EXPOSURE_MANUAL:
+			ret = AE_FULL_MANUAL;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+#if 0
+static int apical_isp_ae_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *exp_mode = tuning->ctrls.exp_mode;
+	struct v4l2_ctrl *ctrl = NULL;
+	apical_api_control_t api;
+	struct isp_core_ae_attr *attr = &tuning->ctrls.ae_attr;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+
+	switch(control->id){
+		case V4L2_CID_EXPOSURE_AUTO:
+			if(exp_mode->is_new){
+				api.id = AE_MODE_ID;
+				api.value = ae_value_v4l2_to_apical(exp_mode->val);
+				status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			}
+
+			/* set absolut exposure */
+			ctrl = tuning->ctrls.manual_exp;
+			if(ctrl->is_new && exp_mode->cur.val == V4L2_EXPOSURE_MANUAL){
+					api.id = AE_EXPOSURE_ID;
+					api.value = ctrl->val;
+					status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			}
+			/* set exposure gain */
+			ctrl = tuning->ctrls.exp_gain;
+			if(ctrl->is_new){
+				api.id = AE_GAIN_ID;
+				api.value = ctrl->val;
+				status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			}
+			/* set exposure compensation */
+			ctrl = tuning->ctrls.exp_compensation;
+			if(ctrl->is_new){
+				api.id = AE_COMPENSATION_ID;
+				api.value = ctrl->val;
+				status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			}
+			break;
+		case IMAGE_TUNING_CID_AE_ATTR:
+			copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+			api.id = AE_ROI_ID;
+			api.value = attr->zone_sel.val;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+#if 0
+			/* config the weight of every zone  */
+			for(i = 0; i < WEIGHT_ZONE_NUM; i++)
+#endif
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return 0;
+}
+#endif
+static int apical_isp_ae_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	apical_api_control_t api;
+	struct isp_core_ae_attr *attr = &tuning->ctrls.ae_attr;
+	unsigned char status = 0;
+	int reason = 0;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+
+	/* get exposure gain */
+	api.id = AE_GAIN_ID;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	attr->gain = api.value;
+	/* get exposure compensation */
+	api.id = AE_COMPENSATION_ID;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	attr->comp = api.value;
+	/* get exposure ROI */
+	api.id = AE_ROI_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	attr->zone_sel.val = api.value;
+	copy_to_user((void __user *)control->value, (const void *)attr, sizeof(*attr));
+#if 0
+	/* config the weight of every zone  */
+	for(i = 0; i < WEIGHT_ZONE_NUM; i++)
+#endif
+	return 0;
+}
+
+/* the format of return value is 8.8 */
+static inline int apical_isp_g_totalgain(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+//	struct video_device *video = core->tun;
+//	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	/* input format 27.5, output format 24.8 */
+	unsigned int total_gain;
+	total_gain =  stab.global_sensor_analog_gain  + stab.global_sensor_digital_gain + stab.global_isp_digital_gain;
+
+	total_gain = math_exp2(total_gain, 5, 8);
+
+	copy_to_user((void __user *)control->value, (const void *)&total_gain, sizeof(unsigned int));
+	return ISP_SUCCESS;
+}
+static inline int af_value_v4l2_to_apical(int val)
+{
+	return val + AF_AUTO_SINGLE;
+}
+#if 0
+static int apical_isp_af_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *af_mode = tuning->ctrls.af_mode;
+	apical_api_control_t api;
+	struct isp_core_af_attr *attr = &tuning->ctrls.af_attr;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	switch(control->id){
+		case IMAGE_TUNING_CID_CUSTOM_AF_MODE:
+			api.id = AF_MODE_ID;
+			api.value = af_value_v4l2_to_apical(af_mode->val);
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			break;
+		case IMAGE_TUNING_CID_AF_ATTR:
+			copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+			api.id = AF_RANGE_LOW_ID;
+			api.value = attr->af_low_range;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+			api.id = AF_RANGE_HIGH_ID;
+			api.value = attr->af_high_range;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+			api.id = AF_ROI_ID;
+			api.value = attr->zone_sel.val;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			apical_isp_metering_af_threshold_write_write(attr->af_threshold);
+			apical_isp_metering_af_threshold_alt_write_write(attr->af_threshold_alt);
+			apical_isp_metering_af_np_offset_write(attr->af_np_offset);
+			apical_isp_metering_af_intensity_norm_mode_write(attr->af_intensity_mode);
+			apical_isp_metering_af_metrics_shift_write(attr->af_metrics_shift);
+			break;
+		default:
+			ret = -EPERM;
+			break;
+	}
+	return ret;
+}
+#endif
+
+static inline int apical_isp_3alock_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *aefwb = tuning->ctrls.aefwb_lock;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = AE_FREEZE_ID;
+	if(aefwb->val & V4L2_LOCK_EXPOSURE)
+		api.value = FREEZE;
+	else
+		api.value = UNFREEZE;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+	api.id = AWB_FREEZE_ID;
+	if(aefwb->val & V4L2_LOCK_WHITE_BALANCE)
+		api.value = FREEZE;
+	else
+		api.value = UNFREEZE;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+	return ret;
+}
+
+static inline int apical_isp_vflip_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	int ret = ISP_SUCCESS;
+#if 1
+	core->vflip_state = tuning->ctrls.vflip->val;
+#else
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	api.type = TIMAGE;
+	api.dir = COMMAND_SET;
+	api.id = ORIENTATION_VFLIP_ID;
+	api.value = tuning->ctrls.vflip->val ? ENABLE : DISABLE;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+#endif
+	return ret;
+}
+
+static inline int apical_isp_hflip_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+//	struct apical_isp_contrl *contrl = &core->contrl;
+	int ret = ISP_SUCCESS;
+	core->hflip_state = tuning->ctrls.hflip->val;
+#if 0
+	unsigned char color = apical_isp_top_rggb_start_read();
+	if(tuning->ctrls.hflip->val){
+		color ^= 1;
+	}else{
+		if(contrl->pattern != color){
+			color ^= 1;
+		}
+	}
+//	printk("$$$$ %s %d pattern = %d color = %d $$$$$\n", __func__,__LINE__,contrl->pattern,color);
+	apical_isp_top_rggb_start_write(color);
+	apical_isp_top_bypass_mirror_write(tuning->ctrls.hflip->val ?0:1);
+#endif
+	return ret;
+}
+
+static int apical_isp_sinter_dns_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *sinter = tuning->ctrls.sinter;
+
+	/* enable the module mean that disable bypass function */
+	apical_isp_top_bypass_sinter_write(sinter->val?0:1);
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_sinter_dns_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_sinter_attr *attr = &(tuning->ctrls.sinter_attr);
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	copy_from_user(attr, (const void __user*)control->value, sizeof(*attr));
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = SINTER_MODE_ID;
+	api.value = attr->type == ISPCORE_MODULE_AUTO ? AUTO : MANUAL;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+	if(attr->type == ISPCORE_MODULE_MANUAL){
+		api.id = SINTER_STRENGTH_ID;
+		api.value = attr->manual_strength;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	}
+	if(status != ISP_SUCCESS)
+		ret = -ISP_ERROR;
+	return ret;
+}
+#if 0
+static int apical_isp_temper_dns_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct v4l2_ctrl *temper = tuning->ctrls.temper;
+
+	if(tuning->temper_paddr == 0){
+		return -EPERM;
+	}
+	printk("###### %s %d #######\n",__func__,__LINE__);
+//	while(core->frame_state)
+//		mdelay(1);
+	printk("###### %s %d #######\n",__func__,__LINE__);
+	if(temper->val == ISPCORE_MODULE_ENABLE){
+		apical_isp_temper_frame_buffer_active_width_write(contrl->inwidth);
+		apical_isp_temper_frame_buffer_active_height_write(contrl->inheight);
+		apical_isp_temper_frame_buffer_line_offset_write(contrl->inwidth * 4);
+		apical_isp_temper_frame_buffer_bank0_base_write(tuning->temper_paddr);
+		apical_isp_temper_frame_buffer_bank1_base_write(tuning->temper_paddr);
+	//	apical_isp_temper_frame_buffer_bank1_base_write(tuning->temper_paddr + (tuning->temper_buffer_size >> 1));
+		apical_isp_temper_frame_buffer_frame_write_cancel_write(0);
+		apical_isp_temper_frame_buffer_frame_read_cancel_write(0);
+		apical_isp_temper_frame_buffer_frame_write_on_write(1);
+		apical_isp_temper_frame_buffer_frame_read_on_write(1);
+	}else{
+		apical_isp_temper_frame_buffer_frame_write_cancel_write(1);
+		apical_isp_temper_frame_buffer_frame_read_cancel_write(1);
+		apical_isp_temper_frame_buffer_frame_write_on_write(0);
+		apical_isp_temper_frame_buffer_frame_read_on_write(0);
+	}
+	/* enable the module mean that disable bypass function */
+	apical_isp_temper_frame_buffer_axi_port_enable_write(temper->val);
+	apical_isp_top_bypass_temper_write(temper->val?0:1);
+	apical_isp_temper_enable_write(temper->val);
+//	printk("##[%s %d] width = %d height = %d \n", __func__, __LINE__,APICAL_READ_32(0xa10),APICAL_READ_32(0xa14));
+//	printk("##[%s %d] bank0 = 0x%08x bank1 = 0x%08x \n", __func__, __LINE__,APICAL_READ_32(0xa18),APICAL_READ_32(0xa1c));
+//	printk("##[%s %d] axi port = 0x%08x temper enable = 0x%08x \n", __func__, __LINE__,APICAL_READ_32(0xa28),APICAL_READ_32(0x2c0));
+//	printk("##[%s %d] 0xa00 = 0x%08x 0xa24 = 0x%08x \n", __func__, __LINE__,APICAL_READ_32(0xa00),APICAL_READ_32(0xa24));
+
+	return ISP_SUCCESS;
+}
+#else
+static int apical_isp_temper_dns_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct v4l2_ctrl *temper = tuning->ctrls.temper;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_SET;
+	api.id = SYSTEM_MANUAL_TEMPER;
+	switch(temper->val){
+		case ISPCORE_TEMPER_MODE_DISABLE:
+			api.value = OFF;
+			break;
+		case ISPCORE_TEMPER_MODE_AUTO:
+		case ISPCORE_TEMPER_MODE_MANUAL:
+			if(tuning->temper_paddr == 0){
+				return -EPERM;
+			}
+			apical_isp_temper_temper2_mode_write(1);
+			apical_isp_temper_frame_buffer_active_width_write(contrl->inwidth);
+			apical_isp_temper_frame_buffer_active_height_write(contrl->inheight);
+			apical_isp_temper_frame_buffer_line_offset_write(contrl->inwidth * 4);
+			api.value = temper->val == ISPCORE_TEMPER_MODE_AUTO ? 0 : 1;
+			break;
+		default:
+			ret = -ISP_ERROR;
+			break;
+	}
+	if(ret != ISP_SUCCESS)
+		return ret;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if(status != ISP_SUCCESS){
+		printk("##[%s %d] failed to temper set command(status = %d)\n", __func__, __LINE__,status);
+		ret = -ISP_ERROR;
+	}
+	/* enable the module mean that disable bypass function */
+	apical_isp_temper_frame_buffer_axi_port_enable_write(temper->val?1:0);
+	apical_isp_top_bypass_temper_write(temper->val?0:1);
+	apical_isp_temper_enable_write(temper->val?1:0);
+//	printk("##[%s %d] width = %d height = %d \n", __func__, __LINE__,APICAL_READ_32(0xa10),APICAL_READ_32(0xa14));
+//	printk("##[%s %d] bank0 = 0x%08x bank1 = 0x%08x \n", __func__, __LINE__,APICAL_READ_32(0xa18),APICAL_READ_32(0xa1c));
+//	printk("##[%s %d] axi port = 0x%08x temper enable = 0x%08x \n", __func__, __LINE__,APICAL_READ_32(0xa28),APICAL_READ_32(0x2c0));
+//	printk("##[%s %d] 0xa00 = 0x%08x 0xa24 = 0x%08x \n", __func__, __LINE__,APICAL_READ_32(0xa00),APICAL_READ_32(0xa24));
+
+	return ISP_SUCCESS;
+}
+#endif
+
+static int apical_isp_temper_dns_s_strength(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_temper_attr *attr = &(tuning->ctrls.temper_attr);
+	struct v4l2_ctrl *temper = tuning->ctrls.temper;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	attr->manual_strength = control->value;
+	if(temper->val == ISPCORE_TEMPER_MODE_MANUAL){
+		api.type = TSYSTEM;
+		api.dir = COMMAND_SET;
+		api.id = SYSTEM_TEMPER_THRESHOLD_TARGET;
+		api.value = attr->manual_strength;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	}
+	if(status != ISP_SUCCESS)
+		ret = -ISP_ERROR;
+	return ret;
+}
+
+static int apical_isp_temper_dns_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_temper_attr *attr = &(tuning->ctrls.temper_attr);
+	struct v4l2_ctrl *temper = tuning->ctrls.temper;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	copy_from_user(attr, (const void __user*)control->value, sizeof(*attr));
+	if(temper->val == ISPCORE_TEMPER_MODE_MANUAL){
+		api.type = TALGORITHMS;
+		api.dir = COMMAND_SET;
+		api.id = TEMPER_STRENGTH_ID;
+		api.value = attr->manual_strength;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	}
+	if(status != ISP_SUCCESS)
+		ret = -ISP_ERROR;
+	return ret;
+}
+
+static int apical_isp_temper_dns_g_strength(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int apical_isp_temper_dns_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_temper_attr *attr = &(tuning->ctrls.temper_attr);
+	struct v4l2_ctrl *temper = tuning->ctrls.temper;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	if(temper->val == ISPCORE_TEMPER_MODE_MANUAL){
+		api.type = TALGORITHMS;
+		api.dir = COMMAND_GET;
+		api.id = TEMPER_STRENGTH_ID;
+		api.value = -1;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if(status != ISP_SUCCESS){
+			printk("##[%s %d] failed to temper set command(status = %d)\n", __func__, __LINE__,status);
+			ret = -ISP_ERROR;
+		}else{
+			attr->manual_strength = api.value;
+			copy_to_user((void __user*)control->value, (const void *)attr, sizeof(*attr));
+		}
+	}
+	return ret;
+}
+
+/* Iridix modules */
+static inline int rawdrc_value_v4l2_to_apical(int val)
+{
+	int ret = 0;
+	switch(val){
+		case 0:
+			ret = MANUAL;
+			break;
+		case 1:
+			ret = UNLIMIT;
+			break;
+		case 2:
+			ret = HIGH;
+			break;
+		case 3:
+			ret = MEDIUM;
+			break;
+		case 4:
+			ret = LOW;
+			break;
+		case 5:
+			ret = OFF;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+
+static int apical_isp_drc_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *drc = tuning->ctrls.raw_drc;
+	struct isp_core_drc_attr *attr = &tuning->ctrls.drc_attr;
+	ISP_CORE_MODE_DN_E dn = tuning->ctrls.daynight;
+	LookupTable** table = NULL;
+	TXispPrivParamManage *param = core->param;
+	apical_api_control_t api;
+	unsigned char status = ISP_SUCCESS;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	if(drc->is_new){
+/*
+		api.type = TALGORITHMS;
+		api.dir = COMMAND_SET;
+		api.id = IRIDIX_MODE_ID;
+		api.value = rawdrc_value_v4l2_to_apical(drc->val);
+	//	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+*/
+		stab.global_manual_iridix = drc->val == ISPMODULE_DRC_MANUAL ? 1 : 0;
+
+		if(param == NULL)
+			goto set_drc_val;
+
+		if(dn == ISP_CORE_RUNING_MODE_DAY_MODE)
+			table = param->isp_param[TX_ISP_PRIV_PARAM_DAY_MODE].calibrations;
+		else
+			table = param->isp_param[TX_ISP_PRIV_PARAM_NIGHT_MODE].calibrations;
+		if(drc->val == ISPMODULE_DRC_MANUAL){
+			stab.global_minimum_iridix_strength = 0;
+			stab.global_maximum_iridix_strength = 255;
+		}else{
+			api.type = TIMAGE;
+			api.dir = COMMAND_GET;
+			api.id = WDR_MODE_ID;
+			api.value = -1;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			if(status != ISP_SUCCESS) {
+				ISP_PRINT(ISP_WARNING_LEVEL,"Get WDR mode failure!reture value is %d,reason is %d\n",status,reason);
+			}
+
+			if (reason == IMAGE_WDR_MODE_LINEAR) {
+				stab.global_maximum_iridix_strength = *(uint8_t *)(table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR]->ptr);
+			} else if (reason == IMAGE_WDR_MODE_FS_HDR) {
+				stab.global_maximum_iridix_strength = *(uint8_t *)(table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR]->ptr);
+			} else {
+				printk("No this mode! Iridix set failure!\n");
+			}
+			stab.global_minimum_iridix_strength = *(uint8_t *)(table[_CALIBRATION_IRIDIX_MIN_MAX_STR]->ptr);
+		}
+set_drc_val:
+		apical_isp_top_bypass_iridix_write((drc->val == 5)?1:0);
+		attr->mode = drc->val;
+	}
+	return ret;
+}
+
+static inline int apical_isp_drc_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_drc_attr *attr = &tuning->ctrls.drc_attr;
+	apical_api_control_t api;
+	unsigned char status = ISP_SUCCESS;
+	int reason = 0;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = IRIDIX_STRENGTH_ID;
+	api.value = attr->strength;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+#if 0
+	apical_isp_iridix_strength_write(attr->strength);
+	apical_isp_iridix_slope_max_write(attr->slope_max);
+	apical_isp_iridix_slope_min_write(attr->slope_min);
+	apical_isp_iridix_black_level_write(attr->black_level);
+	apical_isp_iridix_white_level_write(attr->white_level);
+#endif
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_drc_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_drc_attr *attr = &tuning->ctrls.drc_attr;
+
+	attr->strength = apical_isp_iridix_strength_read();
+	attr->slope_max = apical_isp_iridix_slope_max_read();
+	attr->slope_min = apical_isp_iridix_slope_min_read();
+	attr->black_level = apical_isp_iridix_black_level_read();
+	attr->white_level = apical_isp_iridix_white_level_read();
+	copy_to_user((void __user*)control->value, (const void *)attr, sizeof(*attr));
+
+	return 0;
+}
+
+/* WDR module */
+static int apical_isp_wdr_lut_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+//	struct video_device *video = core->tun;
+//	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+//	struct v4l2_ctrl *ctrl = tuning->ctrls.wdr_lut;
+
+	/* enable the module mean that disable bypass function */
+//	apical_isp_top_bypass_gamma_fe_write(sinter->val?0:1);
+//	APICAL_WRITE_32(0x188, );
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_noise_profile_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_noise_profile_attr *attr = &tuning->ctrls.np_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	return ISP_SUCCESS;
+}
+static inline int apical_isp_wdr_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct apical_isp_contrl *contrl = &core->contrl;
+	struct v4l2_ctrl *wdr = tuning->ctrls.wdr;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	if(tuning->wdr_paddr == 0){
+		return -EPERM;
+	}
+
+	api.type = TIMAGE;
+	api.dir = COMMAND_SET;
+	api.id = WDR_MODE_ID;
+	if(wdr->val == ISPCORE_MODULE_DISABLE){
+//		APICAL_WRITE_32(0x240, 0x000300b1); //disable frame buffers
+//		APICAL_WRITE_32(0x188, 0x0);
+		api.value = IMAGE_WDR_MODE_LINEAR;
+	}else{
+//		apical_isp_frame_stitch_frame_buffer_active_width_write(contrl->inwidth);
+//		apical_isp_frame_stitch_frame_buffer_active_height_write(contrl->inheight);
+		apical_isp_frame_stitch_frame_buffer_line_offset_write(contrl->inwidth * 4);
+//		APICAL_WRITE_32(0x240, 0x00030041); //enable frame buffers
+//		APICAL_WRITE_32(0x188, 0x3);
+		api.value = IMAGE_WDR_MODE_FS_HDR;
+	}
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	/* enable the moudle [WDR companded frontend lookup table] */
+	apical_isp_top_bypass_gamma_fe_write(wdr->val?0:1);
+	/* enable the module mean that disable bypass function */
+	apical_isp_frame_stitch_frame_buffer_axi_port_enable_write(wdr->val?1:0);
+	apical_isp_top_bypass_frame_stitch_write(wdr->val?0:1);
+	/** if enable isp wdr, set 1; if enable sensor wdr, set 0 **/
+	apical_isp_top_gamma_fe_position_write(wdr->val?1:0);
+	apical_isp_input_port_field_mode_write(wdr->val?1:0);
+	if(status != ISP_SUCCESS)
+		ret = -ISP_ERROR;
+	return ret;
+}
+
+static inline int apical_isp_wdr_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_wdr_attr *attr = &tuning->ctrls.wdr_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	apical_isp_frame_stitch_short_thresh_write(attr->short_thresh);
+	apical_isp_frame_stitch_long_thresh_write(attr->long_thresh);
+	apical_isp_frame_stitch_exposure_ratio_write(attr->exp_ratio);
+	apical_isp_frame_stitch_stitch_correct_write(attr->stitch_correct);
+	apical_isp_frame_stitch_stitch_error_thresh_write(attr->stitch_err_thresh);
+	apical_isp_frame_stitch_stitch_error_limit_write(attr->stitch_err_limit);
+	apical_isp_frame_stitch_black_level_long_write(attr->black_level_long);
+	apical_isp_frame_stitch_black_level_short_write(attr->black_level_short);
+	apical_isp_frame_stitch_black_level_out_write(attr->black_level_out);
+	return ISP_SUCCESS;
+}
+
+
+static int apical_isp_bypass_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *isp_process = tuning->ctrls.isp_process;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+
+	if(isp_process->val == ISPCORE_MODULE_ENABLE){
+		switch(mbus->code){
+		case V4L2_MBUS_FMT_RGB565_2X8_LE:
+		case V4L2_MBUS_FMT_RGB888_3X8_LE:
+			apical_isp_top_isp_processing_bypass_mode_write(0);
+			apical_isp_top_isp_raw_bypass_write(1);
+			break;
+		case V4L2_MBUS_FMT_YUYV8_1X16:
+			apical_isp_top_isp_processing_bypass_mode_write(3);
+			apical_isp_top_isp_raw_bypass_write(1);
+			break;
+		default:
+			apical_isp_top_isp_processing_bypass_mode_write(0);
+			apical_isp_top_isp_raw_bypass_write(0);
+			break;
+		}
+		apical_isp_top_ds1_dma_source_write(0);
+		core->bypass = TX_ISP_FRAME_CHANNEL_BYPASS_ISP_DISABLE;
+	}else{
+		apical_isp_top_isp_processing_bypass_mode_write(2);
+		apical_isp_top_isp_raw_bypass_write(1);
+		apical_isp_top_ds1_dma_source_write(1);
+		core->bypass = TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE;
+	}
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_freeze_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *freeze_fw = tuning->ctrls.freeze_fw;
+
+	apical_ext_system_freeze_firmware_write(freeze_fw->val);
+
+	return ISP_SUCCESS;
+}
+
+
+static inline int apical_isp_test_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *test = tuning->ctrls.test_pattern;
+	int ret = ISP_SUCCESS;
+#if 0
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	api.type = TSYSTEM;
+	api.dir = COMMAND_SET;
+	if(test->val == 0){
+		api.id = TEST_PATTERN_ENABLE_ID;
+		api.value = OFF;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		return ret;
+	}
+	api.id = TEST_PATTERN_MODE_ID;
+	api.value = test->val - 1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+	api.id = TEST_PATTERN_ENABLE_ID;
+	api.value = ON;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+#else
+	if(test->val == 0){
+		apical_isp_top_bypass_video_test_gen_write(1);
+		apical_isp_video_test_gen_test_pattern_off_on_write(0);
+		return ret;
+	}
+	apical_isp_video_test_gen_pattern_type_write(test->val-1);
+	apical_isp_video_test_gen_test_pattern_off_on_write(1);
+	apical_isp_top_bypass_video_test_gen_write(0);
+#endif
+	return ret;
+}
+
+static int apical_isp_blacklevel_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *bl = tuning->ctrls.black_level;
+
+	apical_isp_top_bypass_sensor_offset_write(bl->val?0:1);
+	return ISP_SUCCESS;
+}
+
+/* mve */
+static inline int apical_isp_dis_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = DIS_MODE_ID;
+	api.value = tuning->ctrls.dis->val;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int flicker_value_v4l2_to_apical(int val)
+{
+	int ret = 0;
+	switch(val){
+	case V4L2_CID_POWER_LINE_FREQUENCY_DISABLED:
+		ret = 0;
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY_50HZ:
+		ret = 50;
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY_60HZ:
+		ret = 60;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static inline int apical_isp_flicker_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = ANTIFLICKER_MODE_ID;
+	api.value = flicker_value_v4l2_to_apical(tuning->ctrls.flicker->val);
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	stab.global_antiflicker_enable = api.value ?1 :0;
+	return ret;
+}
+
+/* lens shading module */
+static int apical_isp_lens_shad_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *shad = tuning->ctrls.lens_shad;
+
+	apical_isp_mesh_shading_enable_write(shad->val);
+	apical_isp_top_bypass_mesh_shading_write(shad->val?0:1);
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_lens_shad_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_shading_attr *attr = &tuning->ctrls.shad_attr;
+	int i, base;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	apical_isp_mesh_shading_mesh_alpha_mode_write(attr->mesh_mode);
+	apical_isp_mesh_shading_mesh_scale_write(attr->mesh_scale);
+	apical_isp_mesh_shading_mesh_page_r_write(attr->r_page);
+	apical_isp_mesh_shading_mesh_page_g_write(attr->g_page);
+	apical_isp_mesh_shading_mesh_page_b_write(attr->b_page);
+	apical_isp_mesh_shading_mesh_alpha_bank_r_write(attr->mesh_alpha_bank_r);
+	apical_isp_mesh_shading_mesh_alpha_bank_g_write(attr->mesh_alpha_bank_g);
+	apical_isp_mesh_shading_mesh_alpha_bank_b_write(attr->mesh_alpha_bank_b);
+	apical_isp_mesh_shading_mesh_alpha_r_write(attr->mesh_alpha_r);
+	apical_isp_mesh_shading_mesh_alpha_g_write(attr->mesh_alpha_g);
+	apical_isp_mesh_shading_mesh_alpha_b_write(attr->mesh_alpha_b);
+//	apical_isp_mesh_shading_mesh_strength_write(attr->mesh_strength);
+	if(attr->update_page){
+		base = 0x4000;
+		for(i = 0; i < 1024; i++){
+			APICAL_WRITE_32(base, attr->page0.regs[i]);
+			base += 4;
+		}
+		for(i = 0; i < 1024; i++){
+			APICAL_WRITE_32(base, attr->page1.regs[i]);
+			base += 4;
+		}
+		for(i = 0; i < 1024; i++){
+			APICAL_WRITE_32(base, attr->page2.regs[i]);
+			base += 4;
+		}
+		apical_isp_mesh_shading_mesh_reload_write(1);
+	}
+
+	return ISP_SUCCESS;
+}
+
+/* Raw Frontend */
+static inline int apical_isp_ge_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_green_eq_attr *attr = &tuning->ctrls.ge_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	if(attr->mode){
+		apical_isp_raw_frontend_ge_strength_write(attr->strength);
+		apical_isp_raw_frontend_ge_threshold_write(attr->threshold);
+		apical_isp_raw_frontend_ge_slope_write(attr->slope);
+		apical_isp_raw_frontend_ge_sens_write(attr->sensitivity);
+	}
+	apical_isp_raw_frontend_ge_enable_write(attr->mode);
+	return ISP_SUCCESS;
+}
+
+
+static int apical_isp_dynamic_dp_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *ddp = tuning->ctrls.dynamic_dp;
+	struct v4l2_ctrl *ge = tuning->ctrls.green_eq;
+	unsigned char bypass_module = ddp->val | ge->val;
+
+	if(ddp->is_new){
+		apical_isp_raw_frontend_dp_enable_write(ddp->val);
+	}
+
+	if(ge->is_new){
+		apical_isp_raw_frontend_ge_enable_write(ge->val);
+	}
+
+	apical_isp_top_bypass_raw_frontend_write(bypass_module?0:1);
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_dynamic_dp_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_dynamic_defect_pixel_attr *attr = &tuning->ctrls.ddp_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	if(attr->mode){
+		apical_isp_raw_frontend_dark_disable_write(attr->dark_pixels);
+		apical_isp_raw_frontend_bright_disable_write(attr->bright_pixels);
+		apical_isp_raw_frontend_dp_threshold_write(attr->d_threshold);
+		apical_isp_raw_frontend_dp_slope_write(attr->d_slope);
+		apical_isp_raw_frontend_hpdev_threshold_write(attr->hpdev_thresh);
+		apical_isp_raw_frontend_line_thresh_write(attr->line_thresh);
+		apical_isp_raw_frontend_hp_blend_write(attr->hp_blend);
+	}
+	apical_isp_raw_frontend_dp_enable_write(attr->mode);
+
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_static_dp_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *sdp = tuning->ctrls.static_dp;
+
+	apical_isp_top_bypass_defect_pixel_write(sdp->val?0:1);
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_static_dp_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_static_defect_pixel_attr *attr = &tuning->ctrls.sdp_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+
+	return ISP_SUCCESS;
+}
+
+static int apical_isp_antifog_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *fog = tuning->ctrls.fog;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.value = ANTIFOG_STRONG;
+	if(fog->val){
+		/* set present mode */
+		api.id = ANTIFOG_PRESET_ID;
+		switch(fog->val){
+			case 3:
+				api.value = ANTIFOG_WEAK;
+				break;
+			case 2:
+				api.value = ANTIFOG_MEDIUM;
+				break;
+			case 1:
+				api.value = ANTIFOG_STRONG;
+				break;
+			default:
+				break;
+		}
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		/* enable anti fog modules */
+		api.id = ANTIFOG_MODE_ID;
+		api.value = ANTIFOG_ENABLE;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	}else{
+		/* disable anti fog modules */
+		api.id = ANTIFOG_MODE_ID;
+		api.value = ANTIFOG_DISABLE;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	}
+
+	return ret;
+}
+
+
+static inline int scene_value_v4l2_to_apical(int val)
+{
+	int ret = 0;
+	switch(val){
+		case V4L2_SCENE_MODE_NONE:
+			ret = AUTO;
+			break;
+		case V4L2_SCENE_MODE_BEACH_SNOW:
+			ret = BEACH_SNOW;
+			break;
+		case V4L2_SCENE_MODE_CANDLE_LIGHT:
+			ret = CANDLE;
+			break;
+		case V4L2_SCENE_MODE_DAWN_DUSK:
+			ret = DAWN;
+			break;
+		case V4L2_SCENE_MODE_FIREWORKS:
+			ret = FIREWORKS;
+			break;
+		case V4L2_SCENE_MODE_LANDSCAPE:
+			ret = LANDSCAPE;
+			break;
+		case V4L2_SCENE_MODE_NIGHT:
+			ret = NIGHT;
+			break;
+		case V4L2_SCENE_MODE_PARTY_INDOOR:
+			ret = INDOOR;
+			break;
+		case V4L2_SCENE_MODE_PORTRAIT:
+			ret = PORTRAIT;
+			break;
+		case V4L2_SCENE_MODE_SPORTS:
+			ret = MOTION;
+			break;
+		case V4L2_SCENE_MODE_SUNSET:
+			ret = SUNSET;
+			break;
+		case V4L2_SCENE_MODE_TEXT:
+			ret = TEXT;
+			break;
+		case V4L2_SCENE_MODE_TEXT + 1:
+			ret = NIGHT_PORTRAIT;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+
+static inline int apical_isp_scene_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	return ISP_SUCCESS;
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = SCENE_MODE_ID;
+	api.value = scene_value_v4l2_to_apical(tuning->ctrls.scene->val);
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int colorfx_value_v4l2_to_apical(int val)
+{
+	int ret = 0;
+	switch(val){
+		case V4L2_COLORFX_NONE:
+			ret = NORMAL;
+			break;
+		case V4L2_COLORFX_BW:
+			ret = BLACK_AND_WHITE;
+			break;
+		case V4L2_COLORFX_SEPIA:
+			ret = SEPIA;
+			break;
+		case V4L2_COLORFX_NEGATIVE:
+			ret = NEGATIVE;
+			break;
+		case V4L2_COLORFX_VIVID:
+			ret = VIVID;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+	return ret;
+}
+
+static inline int apical_isp_colorfx_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = COLOR_MODE_ID;
+	api.value = colorfx_value_v4l2_to_apical(tuning->ctrls.colorfx->val);
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int apical_isp_day_or_night_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	unsigned int  dn= ctrls->daynight;
+	copy_to_user((void __user *)control->value, (const void *)&dn, sizeof(unsigned int));
+
+	return ISP_SUCCESS;
+}
+
+
+int apical_isp_day_or_night_s_ctrl_internal(struct tx_isp_core_device *core)
+{
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	int ret = ISP_SUCCESS;
+	LookupTable** table = NULL;
+	TXispPrivCustomerParamer *customer = NULL;
+	unsigned int tmp_top = 0;
+	apical_api_control_t api;
+	unsigned int reason = 0;
+	unsigned int status = 0;
+
+	ISP_CORE_MODE_DN_E dn = ctrls->daynight;
+	if(!param){
+		v4l2_err(tuning->video->v4l2_dev,"Can't get the parameters of isp tuning!\n");
+		return -ISP_ERROR;
+	}
+	{
+		tmp_top = APICAL_READ_32(0x40);
+		if(dn == ISP_CORE_RUNING_MODE_DAY_MODE){
+#if TX_ISP_EXIST_FR_CHANNEL
+			apical_isp_fr_cs_conv_clip_min_uv_write(0);
+			apical_isp_fr_cs_conv_clip_max_uv_write(1023);
+#endif
+			apical_isp_ds1_cs_conv_clip_min_uv_write(0);
+			apical_isp_ds1_cs_conv_clip_max_uv_write(1023);
+#if TX_ISP_EXIST_DS2_CHANNEL
+			apical_isp_ds2_cs_conv_clip_min_uv_write(0);
+			apical_isp_ds2_cs_conv_clip_max_uv_write(1023);
+#endif
+			table = param->isp_param[TX_ISP_PRIV_PARAM_DAY_MODE].calibrations;
+			customer = &param->customer[TX_ISP_PRIV_PARAM_DAY_MODE];
+			/* tmp_top |= param->customer[TX_ISP_PRIV_PARAM_NIGHT_MODE].top; */
+		}else{
+#if TX_ISP_EXIST_FR_CHANNEL
+			apical_isp_fr_cs_conv_clip_min_uv_write(512);
+			apical_isp_fr_cs_conv_clip_max_uv_write(512);
+#endif
+			apical_isp_ds1_cs_conv_clip_min_uv_write(512);
+			apical_isp_ds1_cs_conv_clip_max_uv_write(512);
+#if TX_ISP_EXIST_DS2_CHANNEL
+			apical_isp_ds2_cs_conv_clip_min_uv_write(512);
+			apical_isp_ds2_cs_conv_clip_max_uv_write(512);
+#endif
+			table = param->isp_param[TX_ISP_PRIV_PARAM_NIGHT_MODE].calibrations;
+			customer = &param->customer[TX_ISP_PRIV_PARAM_NIGHT_MODE];
+			/* tmp_top |= param->customer[TX_ISP_PRIV_PARAM_DAY_MODE].top; */
+		}
+		if(table && customer){
+			tmp_top = (tmp_top | 0x0c02da6c) & (~(customer->top));
+			if(TX_ISP_EXIST_FR_CHANNEL == 0)
+				tmp_top |= 0x00fc0000;
+			/* dynamic calibration */
+			apical_api_calibration(CALIBRATION_NP_LUT_MEAN,COMMAND_SET, table[_CALIBRATION_NP_LUT_MEAN]->ptr,
+					       table[_CALIBRATION_NP_LUT_MEAN]->rows * table[_CALIBRATION_NP_LUT_MEAN]->cols
+					       * table[_CALIBRATION_NP_LUT_MEAN]->width, &ret);
+			apical_api_calibration(CALIBRATION_EVTOLUX_PROBABILITY_ENABLE,COMMAND_SET, table[ _CALIBRATION_EVTOLUX_PROBABILITY_ENABLE]->ptr,
+					       table[ _CALIBRATION_EVTOLUX_PROBABILITY_ENABLE]->rows * table[ _CALIBRATION_EVTOLUX_PROBABILITY_ENABLE]->cols
+					       * table[_CALIBRATION_EVTOLUX_PROBABILITY_ENABLE]->width, &ret);
+			apical_api_calibration(CALIBRATION_AE_EXPOSURE_AVG_COEF,COMMAND_SET, table[ _CALIBRATION_AE_EXPOSURE_AVG_COEF]->ptr,
+					       table[ _CALIBRATION_AE_EXPOSURE_AVG_COEF]->rows * table[ _CALIBRATION_AE_EXPOSURE_AVG_COEF]->cols
+					       * table[ _CALIBRATION_AE_EXPOSURE_AVG_COEF]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_AVG_COEF,COMMAND_SET, table[_CALIBRATION_IRIDIX_AVG_COEF]->ptr,
+					       table[_CALIBRATION_IRIDIX_AVG_COEF]->rows * table[_CALIBRATION_IRIDIX_AVG_COEF]->cols
+					       * table[_CALIBRATION_IRIDIX_AVG_COEF]->width, &ret);
+			apical_api_calibration(CALIBRATION_AF_MIN_TABLE,COMMAND_SET, table[_CALIBRATION_AF_MIN_TABLE]->ptr,
+					       table[_CALIBRATION_AF_MIN_TABLE]->rows * table[_CALIBRATION_AF_MIN_TABLE]->cols
+					       * table[_CALIBRATION_AF_MIN_TABLE]->width, &ret);
+			apical_api_calibration(CALIBRATION_AF_MAX_TABLE,COMMAND_SET, table[_CALIBRATION_AF_MAX_TABLE]->ptr,
+					       table[_CALIBRATION_AF_MAX_TABLE]->rows * table[_CALIBRATION_AF_MAX_TABLE]->cols
+					       * table[_CALIBRATION_AF_MAX_TABLE]->width, &ret);
+			apical_api_calibration(CALIBRATION_AF_WINDOW_RESIZE_TABLE,COMMAND_SET, table[_CALIBRATION_AF_WINDOW_RESIZE_TABLE]->ptr,
+					       table[_CALIBRATION_AF_WINDOW_RESIZE_TABLE]->rows * table[_CALIBRATION_AF_WINDOW_RESIZE_TABLE]->cols
+					       * table[_CALIBRATION_AF_WINDOW_RESIZE_TABLE]->width, &ret);
+			apical_api_calibration(CALIBRATION_EXP_RATIO_TABLE,COMMAND_SET, table[_CALIBRATION_EXP_RATIO_TABLE]->ptr,
+					       table[_CALIBRATION_EXP_RATIO_TABLE]->rows * table[_CALIBRATION_EXP_RATIO_TABLE]->cols
+					       * table[_CALIBRATION_EXP_RATIO_TABLE]->width, &ret);
+			apical_api_calibration(CALIBRATION_CCM_ONE_GAIN_THRESHOLD,COMMAND_SET, table[_CALIBRATION_CCM_ONE_GAIN_THRESHOLD]->ptr,
+					       table[_CALIBRATION_CCM_ONE_GAIN_THRESHOLD]->rows * table[_CALIBRATION_CCM_ONE_GAIN_THRESHOLD]->cols
+					       * table[_CALIBRATION_CCM_ONE_GAIN_THRESHOLD]->width, &ret);
+			apical_api_calibration(CALIBRATION_FLASH_RG,COMMAND_SET, table[_CALIBRATION_FLASH_RG]->ptr,
+					       table[_CALIBRATION_FLASH_RG]->rows * table[_CALIBRATION_FLASH_RG]->cols
+					       * table[_CALIBRATION_FLASH_RG]->width, &ret);
+			apical_api_calibration(CALIBRATION_FLASH_BG,COMMAND_SET, table[_CALIBRATION_FLASH_BG]->ptr,
+					       table[_CALIBRATION_FLASH_BG]->rows * table[_CALIBRATION_FLASH_BG]->cols
+					       * table[_CALIBRATION_FLASH_BG]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR,COMMAND_SET, table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR]->ptr,
+					       table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR]->rows * table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR]->cols
+					       * table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR,COMMAND_SET, table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR]->ptr,
+					       table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR]->rows * table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR]->cols
+					       * table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_BLACK_PRC,COMMAND_SET, table[_CALIBRATION_IRIDIX_BLACK_PRC]->ptr,
+					       table[_CALIBRATION_IRIDIX_BLACK_PRC]->rows * table[_CALIBRATION_IRIDIX_BLACK_PRC]->cols
+					       * table[_CALIBRATION_IRIDIX_BLACK_PRC]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_GAIN_MAX,COMMAND_SET, table[_CALIBRATION_IRIDIX_GAIN_MAX]->ptr,
+					       table[_CALIBRATION_IRIDIX_GAIN_MAX]->rows * table[_CALIBRATION_IRIDIX_GAIN_MAX]->cols
+					       * table[_CALIBRATION_IRIDIX_GAIN_MAX]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_MIN_MAX_STR,COMMAND_SET, table[_CALIBRATION_IRIDIX_MIN_MAX_STR]->ptr,
+					       table[_CALIBRATION_IRIDIX_MIN_MAX_STR]->rows * table[_CALIBRATION_IRIDIX_MIN_MAX_STR]->cols
+					       * table[_CALIBRATION_IRIDIX_MIN_MAX_STR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_EV_LIM_FULL_STR,COMMAND_SET, table[_CALIBRATION_IRIDIX_EV_LIM_FULL_STR]->ptr,
+					       table[_CALIBRATION_IRIDIX_EV_LIM_FULL_STR]->rows * table[_CALIBRATION_IRIDIX_EV_LIM_FULL_STR]->cols
+					       * table[_CALIBRATION_IRIDIX_EV_LIM_FULL_STR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR,COMMAND_SET, table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR]->ptr,
+					       table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR]->rows * table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR]->cols
+					       * table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR,COMMAND_SET, table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR]->ptr,
+					       table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR]->rows * table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR]->cols
+					       * table[_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_AE_CORRECTION_LINEAR,COMMAND_SET, table[_CALIBRATION_AE_CORRECTION_LINEAR]->ptr,
+					       table[_CALIBRATION_AE_CORRECTION_LINEAR]->rows * table[_CALIBRATION_AE_CORRECTION_LINEAR]->cols
+					       * table[_CALIBRATION_AE_CORRECTION_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_AE_CORRECTION_FS_HDR,COMMAND_SET, table[_CALIBRATION_AE_CORRECTION_FS_HDR]->ptr,
+					       table[_CALIBRATION_AE_CORRECTION_FS_HDR]->rows * table[_CALIBRATION_AE_CORRECTION_FS_HDR]->cols
+					       * table[_CALIBRATION_AE_CORRECTION_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_AE_EXPOSURE_CORRECTION,COMMAND_SET, table[_CALIBRATION_AE_EXPOSURE_CORRECTION]->ptr,
+					       table[_CALIBRATION_AE_EXPOSURE_CORRECTION]->rows * table[_CALIBRATION_AE_EXPOSURE_CORRECTION]->cols
+					       * table[_CALIBRATION_AE_EXPOSURE_CORRECTION]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_STRENGTH_LINEAR,COMMAND_SET, table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->ptr,
+					       table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->rows * table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->cols
+					       * table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->width, &ret);
+
+			apical_api_calibration(CALIBRATION_SINTER_STRENGTH_FS_HDR,COMMAND_SET, table[_CALIBRATION_SINTER_STRENGTH_FS_HDR]->ptr,
+					       table[_CALIBRATION_SINTER_STRENGTH_FS_HDR]->rows * table[_CALIBRATION_SINTER_STRENGTH_FS_HDR]->cols
+					       * table[_CALIBRATION_SINTER_STRENGTH_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_STRENGTH1_LINEAR,COMMAND_SET, table[_CALIBRATION_SINTER_STRENGTH1_LINEAR]->ptr,
+					       table[_CALIBRATION_SINTER_STRENGTH1_LINEAR]->rows * table[_CALIBRATION_SINTER_STRENGTH1_LINEAR]->cols
+					       * table[_CALIBRATION_SINTER_STRENGTH1_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_STRENGTH1_FS_HDR,COMMAND_SET, table[_CALIBRATION_SINTER_STRENGTH1_FS_HDR]->ptr,
+					       table[_CALIBRATION_SINTER_STRENGTH1_FS_HDR]->rows * table[_CALIBRATION_SINTER_STRENGTH1_FS_HDR]->cols
+					       * table[_CALIBRATION_SINTER_STRENGTH1_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_THRESH1_LINEAR,COMMAND_SET, table[_CALIBRATION_SINTER_THRESH1_LINEAR]->ptr,
+					       table[_CALIBRATION_SINTER_THRESH1_LINEAR]->rows * table[_CALIBRATION_SINTER_THRESH1_LINEAR]->cols
+					       * table[_CALIBRATION_SINTER_THRESH1_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_THRESH1_FS_HDR,COMMAND_SET, table[ _CALIBRATION_SINTER_THRESH1_FS_HDR]->ptr,
+					       table[ _CALIBRATION_SINTER_THRESH1_FS_HDR]->rows * table[ _CALIBRATION_SINTER_THRESH1_FS_HDR]->cols
+					       * table[ _CALIBRATION_SINTER_THRESH1_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_THRESH4_LINEAR,COMMAND_SET, table[ _CALIBRATION_SINTER_THRESH4_LINEAR]->ptr,
+					       table[ _CALIBRATION_SINTER_THRESH4_LINEAR]->rows * table[ _CALIBRATION_SINTER_THRESH4_LINEAR]->cols
+					       * table[ _CALIBRATION_SINTER_THRESH4_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SINTER_THRESH4_FS_HDR,COMMAND_SET, table[ _CALIBRATION_SINTER_THRESH4_FS_HDR]->ptr,
+					       table[_CALIBRATION_SINTER_THRESH4_FS_HDR]->rows * table[ _CALIBRATION_SINTER_THRESH4_FS_HDR]->cols
+					       * table[_CALIBRATION_SINTER_THRESH4_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHARP_ALT_D_LINEAR,COMMAND_SET, table[ _CALIBRATION_SHARP_ALT_D_LINEAR]->ptr,
+					       table[_CALIBRATION_SHARP_ALT_D_LINEAR]->rows * table[_CALIBRATION_SHARP_ALT_D_LINEAR]->cols
+					       * table[_CALIBRATION_SHARP_ALT_D_LINEAR]->width, &ret);
+
+			apical_api_calibration(CALIBRATION_SHARP_ALT_D_FS_HDR,COMMAND_SET, table[_CALIBRATION_SHARP_ALT_D_FS_HDR]->ptr,
+					       table[_CALIBRATION_SHARP_ALT_D_FS_HDR]->rows * table[_CALIBRATION_SHARP_ALT_D_FS_HDR]->cols
+					       * table[_CALIBRATION_SHARP_ALT_D_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHARP_ALT_UD_LINEAR,COMMAND_SET, table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->ptr,
+					       table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->rows * table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->cols
+					       * table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->width, &ret);
+
+			apical_api_calibration(CALIBRATION_SHARP_ALT_UD_FS_HDR,COMMAND_SET, table[ _CALIBRATION_SHARP_ALT_UD_FS_HDR]->ptr,
+					       table[_CALIBRATION_SHARP_ALT_UD_FS_HDR]->rows * table[_CALIBRATION_SHARP_ALT_UD_FS_HDR]->cols
+					       * table[_CALIBRATION_SHARP_ALT_UD_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHARPEN_FR_LINEAR,COMMAND_SET, table[ _CALIBRATION_SHARPEN_FR_LINEAR]->ptr,
+					       table[_CALIBRATION_SHARPEN_FR_LINEAR]->rows * table[_CALIBRATION_SHARPEN_FR_LINEAR]->cols
+					       * table[_CALIBRATION_SHARPEN_FR_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHARPEN_FR_WDR,COMMAND_SET, table[_CALIBRATION_SHARPEN_FR_WDR]->ptr,
+					       table[ _CALIBRATION_SHARPEN_FR_WDR]->rows * table[ _CALIBRATION_SHARPEN_FR_WDR]->cols
+					       * table[ _CALIBRATION_SHARPEN_FR_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHARPEN_DS1_LINEAR,COMMAND_SET, table[_CALIBRATION_SHARPEN_DS1_LINEAR]->ptr,
+					       table[_CALIBRATION_SHARPEN_DS1_LINEAR]->rows * table[_CALIBRATION_SHARPEN_DS1_LINEAR]->cols
+					       * table[_CALIBRATION_SHARPEN_DS1_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHARPEN_DS1_WDR,COMMAND_SET, table[_CALIBRATION_SHARPEN_DS1_WDR]->ptr,
+					       table[_CALIBRATION_SHARPEN_DS1_WDR]->rows * table[_CALIBRATION_SHARPEN_DS1_WDR]->cols
+					       * table[_CALIBRATION_SHARPEN_DS1_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR,COMMAND_SET, table[_CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR]->ptr,
+					       table[_CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR]->rows * table[_CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR]->cols
+					       * table[_CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR,COMMAND_SET, table[_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR]->ptr,
+					       table[_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR]->rows * table[_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR]->cols
+					       * table[_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_MESH_SHADING_STRENGTH,COMMAND_SET, table[_CALIBRATION_MESH_SHADING_STRENGTH]->ptr,
+					       table[_CALIBRATION_MESH_SHADING_STRENGTH]->rows * table[_CALIBRATION_MESH_SHADING_STRENGTH]->cols
+					       * table[_CALIBRATION_MESH_SHADING_STRENGTH]->width, &ret);
+			apical_api_calibration(CALIBRATION_SATURATION_STRENGTH_LINEAR,COMMAND_SET, table[_CALIBRATION_SATURATION_STRENGTH_LINEAR]->ptr,
+					       table[_CALIBRATION_SATURATION_STRENGTH_LINEAR]->rows * table[_CALIBRATION_SATURATION_STRENGTH_LINEAR]->cols
+					       * table[_CALIBRATION_SATURATION_STRENGTH_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_TEMPER_STRENGTH,COMMAND_SET, table[_CALIBRATION_TEMPER_STRENGTH]->ptr,
+					       table[_CALIBRATION_TEMPER_STRENGTH]->rows * table[_CALIBRATION_TEMPER_STRENGTH]->cols
+					       * table[_CALIBRATION_TEMPER_STRENGTH]->width, &ret);
+
+			apical_api_calibration(CALIBRATION_STITCHING_ERROR_THRESH,COMMAND_SET, table[_CALIBRATION_STITCHING_ERROR_THRESH]->ptr,
+					       table[_CALIBRATION_STITCHING_ERROR_THRESH]->rows * table[_CALIBRATION_STITCHING_ERROR_THRESH]->cols
+					       * table[_CALIBRATION_STITCHING_ERROR_THRESH]->width, &ret);
+			apical_api_calibration(CALIBRATION_DP_SLOPE_LINEAR,COMMAND_SET, table[_CALIBRATION_DP_SLOPE_LINEAR]->ptr,
+					       table[_CALIBRATION_DP_SLOPE_LINEAR]->rows * table[_CALIBRATION_DP_SLOPE_LINEAR]->cols
+					       * table[_CALIBRATION_DP_SLOPE_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DP_SLOPE_FS_HDR,COMMAND_SET, table[_CALIBRATION_DP_SLOPE_FS_HDR]->ptr,
+					       table[_CALIBRATION_DP_SLOPE_FS_HDR]->rows * table[_CALIBRATION_DP_SLOPE_FS_HDR]->cols
+					       * table[_CALIBRATION_DP_SLOPE_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DP_THRESHOLD_LINEAR,COMMAND_SET, table[_CALIBRATION_DP_THRESHOLD_LINEAR]->ptr,
+					       table[_CALIBRATION_DP_THRESHOLD_LINEAR]->rows * table[_CALIBRATION_DP_THRESHOLD_LINEAR]->cols
+					       * table[_CALIBRATION_DP_THRESHOLD_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DP_THRESHOLD_FS_HDR,COMMAND_SET, table[_CALIBRATION_DP_THRESHOLD_FS_HDR]->ptr,
+					       table[_CALIBRATION_DP_THRESHOLD_FS_HDR]->rows * table[_CALIBRATION_DP_THRESHOLD_FS_HDR]->cols
+					       * table[_CALIBRATION_DP_THRESHOLD_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_AE_BALANCED_LINEAR,COMMAND_SET, table[_CALIBRATION_AE_BALANCED_LINEAR]->ptr,
+					       table[_CALIBRATION_AE_BALANCED_LINEAR]->rows * table[_CALIBRATION_AE_BALANCED_LINEAR]->cols
+					       * table[_CALIBRATION_AE_BALANCED_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_AE_BALANCED_WDR,COMMAND_SET, table[_CALIBRATION_AE_BALANCED_WDR]->ptr,
+					       table[_CALIBRATION_AE_BALANCED_WDR]->rows * table[_CALIBRATION_AE_BALANCED_WDR]->cols
+					       * table[_CALIBRATION_AE_BALANCED_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_STRENGTH_TABLE,COMMAND_SET, table[_CALIBRATION_IRIDIX_STRENGTH_TABLE]->ptr,
+					       table[_CALIBRATION_IRIDIX_STRENGTH_TABLE]->rows * table[_CALIBRATION_IRIDIX_STRENGTH_TABLE]->cols
+					       * table[_CALIBRATION_IRIDIX_STRENGTH_TABLE]->width, &ret);
+
+			apical_api_calibration(CALIBRATION_RGB2YUV_CONVERSION,COMMAND_SET, table[_CALIBRATION_RGB2YUV_CONVERSION]->ptr,
+					       table[_CALIBRATION_RGB2YUV_CONVERSION]->rows * table[_CALIBRATION_RGB2YUV_CONVERSION]->cols
+					       * table[_CALIBRATION_RGB2YUV_CONVERSION]->width, &ret);
+
+			/* static parameter */
+			apical_api_calibration(CALIBRATION_EVTOLUX_EV_LUT_LINEAR, COMMAND_SET, table[_CALIBRATION_EVTOLUX_EV_LUT_LINEAR]->ptr,
+					       table[_CALIBRATION_EVTOLUX_EV_LUT_LINEAR]->rows * table[_CALIBRATION_EVTOLUX_EV_LUT_LINEAR]->cols
+					       * table[_CALIBRATION_EVTOLUX_EV_LUT_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_EVTOLUX_EV_LUT_FS_HDR, COMMAND_SET, table[_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR]->ptr,
+					       table[_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR]->rows * table[_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR]->cols
+					       * table[_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_EVTOLUX_LUX_LUT, COMMAND_SET, table[_CALIBRATION_EVTOLUX_LUX_LUT]->ptr,
+					       table[_CALIBRATION_EVTOLUX_LUX_LUT]->rows * table[_CALIBRATION_EVTOLUX_LUX_LUT]->cols
+					       * table[_CALIBRATION_EVTOLUX_LUX_LUT]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_A_R_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_A_R_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_A_R_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_A_R_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_A_R_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_A_G_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_A_G_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_A_G_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_A_G_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_A_G_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_A_B_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_A_B_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_A_B_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_A_B_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_A_B_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_TL84_R_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_TL84_R_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_TL84_R_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_TL84_R_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_TL84_R_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_TL84_G_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_TL84_G_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_TL84_G_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_TL84_G_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_TL84_G_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_TL84_B_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_TL84_B_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_TL84_B_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_TL84_B_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_TL84_B_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_D65_R_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_D65_R_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_D65_R_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_D65_R_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_D65_R_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_D65_G_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_D65_G_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_D65_G_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_D65_G_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_D65_G_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_D65_B_LINEAR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_D65_B_LINEAR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_D65_B_LINEAR]->rows * table[_CALIBRATION_SHADING_LS_D65_B_LINEAR]->cols
+					       * table[_CALIBRATION_SHADING_LS_D65_B_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_A_R_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_A_R_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_A_R_WDR]->rows * table[_CALIBRATION_SHADING_LS_A_R_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_A_R_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_A_G_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_A_G_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_A_G_WDR]->rows * table[_CALIBRATION_SHADING_LS_A_G_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_A_G_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_A_B_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_A_B_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_A_B_WDR]->rows * table[_CALIBRATION_SHADING_LS_A_B_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_A_B_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_TL84_R_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_TL84_R_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_TL84_R_WDR]->rows * table[_CALIBRATION_SHADING_LS_TL84_R_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_TL84_R_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_TL84_G_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_TL84_G_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_TL84_G_WDR]->rows * table[_CALIBRATION_SHADING_LS_TL84_G_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_TL84_G_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_TL84_B_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_TL84_B_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_TL84_B_WDR]->rows * table[_CALIBRATION_SHADING_LS_TL84_B_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_TL84_B_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_D65_R_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_D65_R_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_D65_R_WDR]->rows * table[_CALIBRATION_SHADING_LS_D65_R_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_D65_R_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_D65_G_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_D65_G_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_D65_G_WDR]->rows * table[_CALIBRATION_SHADING_LS_D65_G_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_D65_G_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_SHADING_LS_D65_B_WDR, COMMAND_SET, table[_CALIBRATION_SHADING_LS_D65_B_WDR]->ptr,
+					       table[_CALIBRATION_SHADING_LS_D65_B_WDR]->rows * table[_CALIBRATION_SHADING_LS_D65_B_WDR]->cols
+					       * table[_CALIBRATION_SHADING_LS_D65_B_WDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_NOISE_PROFILE_LINEAR, COMMAND_SET, table[_CALIBRATION_NOISE_PROFILE_LINEAR]->ptr,
+					       table[_CALIBRATION_NOISE_PROFILE_LINEAR]->rows * table[_CALIBRATION_NOISE_PROFILE_LINEAR]->cols
+					       * table[_CALIBRATION_NOISE_PROFILE_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DEMOSAIC_LINEAR, COMMAND_SET, table[_CALIBRATION_DEMOSAIC_LINEAR]->ptr,
+					       table[_CALIBRATION_DEMOSAIC_LINEAR]->rows * table[_CALIBRATION_DEMOSAIC_LINEAR]->cols
+					       * table[_CALIBRATION_DEMOSAIC_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_NOISE_PROFILE_FS_HDR, COMMAND_SET, table[_CALIBRATION_NOISE_PROFILE_FS_HDR]->ptr,
+					       table[_CALIBRATION_NOISE_PROFILE_FS_HDR]->rows * table[_CALIBRATION_NOISE_PROFILE_FS_HDR]->cols
+					       * table[_CALIBRATION_NOISE_PROFILE_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_DEMOSAIC_FS_HDR, COMMAND_SET, table[_CALIBRATION_DEMOSAIC_FS_HDR]->ptr,
+					       table[_CALIBRATION_DEMOSAIC_FS_HDR]->rows * table[_CALIBRATION_DEMOSAIC_FS_HDR]->cols
+					       * table[_CALIBRATION_DEMOSAIC_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_GAMMA_FE_0_FS_HDR, COMMAND_SET, table[_CALIBRATION_GAMMA_FE_0_FS_HDR]->ptr,
+					       table[_CALIBRATION_GAMMA_FE_0_FS_HDR]->rows * table[_CALIBRATION_GAMMA_FE_0_FS_HDR]->cols
+					       * table[_CALIBRATION_GAMMA_FE_0_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_GAMMA_FE_1_FS_HDR, COMMAND_SET, table[_CALIBRATION_GAMMA_FE_1_FS_HDR]->ptr,
+					       table[_CALIBRATION_GAMMA_FE_1_FS_HDR]->rows * table[_CALIBRATION_GAMMA_FE_1_FS_HDR]->cols
+					       * table[_CALIBRATION_GAMMA_FE_1_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_R_LINEAR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_R_LINEAR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_R_LINEAR]->rows * table[_CALIBRATION_BLACK_LEVEL_R_LINEAR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_R_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_GR_LINEAR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_GR_LINEAR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_GR_LINEAR]->rows * table[_CALIBRATION_BLACK_LEVEL_GR_LINEAR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_GR_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_GB_LINEAR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_GB_LINEAR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_GB_LINEAR]->rows * table[_CALIBRATION_BLACK_LEVEL_GB_LINEAR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_GB_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_B_LINEAR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_B_LINEAR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_B_LINEAR]->rows * table[_CALIBRATION_BLACK_LEVEL_B_LINEAR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_B_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_R_FS_HDR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_R_FS_HDR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_R_FS_HDR]->rows * table[_CALIBRATION_BLACK_LEVEL_R_FS_HDR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_R_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_GR_FS_HDR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_GR_FS_HDR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_GR_FS_HDR]->rows * table[_CALIBRATION_BLACK_LEVEL_GR_FS_HDR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_GR_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_GB_FS_HDR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_GB_FS_HDR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_GB_FS_HDR]->rows * table[_CALIBRATION_BLACK_LEVEL_GB_FS_HDR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_GB_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_BLACK_LEVEL_B_FS_HDR, COMMAND_SET, table[_CALIBRATION_BLACK_LEVEL_B_FS_HDR]->ptr,
+					       table[_CALIBRATION_BLACK_LEVEL_B_FS_HDR]->rows * table[_CALIBRATION_BLACK_LEVEL_B_FS_HDR]->cols
+					       * table[_CALIBRATION_BLACK_LEVEL_B_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_GAMMA_LINEAR, COMMAND_SET, table[_CALIBRATION_GAMMA_LINEAR]->ptr,
+					       table[_CALIBRATION_GAMMA_LINEAR]->rows * table[_CALIBRATION_GAMMA_LINEAR]->cols
+					       * table[_CALIBRATION_GAMMA_LINEAR]->width, &ret);
+			apical_api_calibration(CALIBRATION_GAMMA_FS_HDR, COMMAND_SET, table[_CALIBRATION_GAMMA_FS_HDR]->ptr,
+					       table[_CALIBRATION_GAMMA_FS_HDR]->rows * table[_CALIBRATION_GAMMA_FS_HDR]->cols
+					       * table[_CALIBRATION_GAMMA_FS_HDR]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_RGB2REC709, COMMAND_SET, table[_CALIBRATION_IRIDIX_RGB2REC709]->ptr,
+					       table[_CALIBRATION_IRIDIX_RGB2REC709]->rows * table[_CALIBRATION_IRIDIX_RGB2REC709]->cols
+					       * table[_CALIBRATION_IRIDIX_RGB2REC709]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_REC709TORGB, COMMAND_SET, table[_CALIBRATION_IRIDIX_REC709TORGB]->ptr,
+					       table[_CALIBRATION_IRIDIX_REC709TORGB]->rows * table[_CALIBRATION_IRIDIX_REC709TORGB]->cols
+					       * table[_CALIBRATION_IRIDIX_REC709TORGB]->width, &ret);
+			apical_api_calibration(CALIBRATION_IRIDIX_ASYMMETRY, COMMAND_SET, table[_CALIBRATION_IRIDIX_ASYMMETRY]->ptr,
+					       table[_CALIBRATION_IRIDIX_ASYMMETRY]->rows * table[_CALIBRATION_IRIDIX_ASYMMETRY]->cols
+					       * table[_CALIBRATION_IRIDIX_ASYMMETRY]->width, &ret);
+			apical_api_calibration(CALIBRATION_DEFECT_PIXELS, COMMAND_SET, table[_CALIBRATION_DEFECT_PIXELS]->ptr,
+					       table[_CALIBRATION_DEFECT_PIXELS]->rows * table[_CALIBRATION_DEFECT_PIXELS]->cols
+					       * table[_CALIBRATION_DEFECT_PIXELS]->width, &ret);
+
+			/* green equalization */
+			apical_isp_raw_frontend_ge_strength_write(customer->ge_strength);
+			apical_isp_raw_frontend_ge_threshold_write(customer->ge_threshold);
+			apical_isp_raw_frontend_ge_slope_write(customer->ge_slope);
+			apical_isp_raw_frontend_ge_sens_write(customer->ge_sensitivity);
+
+			/* dpc configuration	 */
+			apical_isp_raw_frontend_dp_enable_write(customer->dp_module);
+			apical_isp_raw_frontend_hpdev_threshold_write(customer->hpdev_threshold);
+			apical_isp_raw_frontend_line_thresh_write(customer->line_threshold);
+			apical_isp_raw_frontend_hp_blend_write(customer->hp_blend);
+
+			apical_isp_demosaic_vh_slope_write(customer->dmsc_vh_slope);
+			apical_isp_demosaic_aa_slope_write(customer->dmsc_aa_slope);
+			apical_isp_demosaic_va_slope_write(customer->dmsc_va_slope);
+			apical_isp_demosaic_uu_slope_write(customer->dmsc_uu_slope);
+			apical_isp_demosaic_sat_slope_write(customer->dmsc_sat_slope);
+			apical_isp_demosaic_vh_thresh_write(customer->dmsc_vh_threshold);
+			apical_isp_demosaic_aa_thresh_write(customer->dmsc_aa_threshold);
+			apical_isp_demosaic_va_thresh_write(customer->dmsc_va_threshold);
+			apical_isp_demosaic_uu_thresh_write(customer->dmsc_uu_threshold);
+			apical_isp_demosaic_sat_thresh_write(customer->dmsc_sat_threshold);
+			apical_isp_demosaic_vh_offset_write(customer->dmsc_vh_offset);
+			apical_isp_demosaic_aa_offset_write(customer->dmsc_aa_offset);
+			apical_isp_demosaic_va_offset_write(customer->dmsc_va_offset);
+			apical_isp_demosaic_uu_offset_write(customer->dmsc_uu_offset);
+			apical_isp_demosaic_sat_offset_write(customer->dmsc_sat_offset);
+			apical_isp_demosaic_lum_thresh_write(customer->dmsc_luminance_thresh);
+			apical_isp_demosaic_np_offset_write(customer->dmsc_np_offset);
+			apical_isp_demosaic_dmsc_config_write(customer->dmsc_config);
+			apical_isp_demosaic_ac_thresh_write(customer->dmsc_ac_threshold);
+			apical_isp_demosaic_ac_slope_write(customer->dmsc_ac_slope);
+			apical_isp_demosaic_ac_offset_write(customer->dmsc_ac_offset);
+			apical_isp_demosaic_fc_slope_write(customer->dmsc_fc_slope);
+			apical_isp_demosaic_fc_alias_slope_write(customer->dmsc_fc_alias_slope);
+			apical_isp_demosaic_fc_alias_thresh_write(customer->dmsc_fc_alias_thresh);
+			apical_isp_demosaic_np_off_write(customer->dmsc_np_off);
+			apical_isp_demosaic_np_off_reflect_write(customer->dmsc_np_reflect);
+
+			apical_isp_temper_recursion_limit_write(customer->temper_recursion_limit);
+			apical_isp_frame_stitch_short_thresh_write(customer->wdr_short_thresh);
+			apical_isp_frame_stitch_long_thresh_write(customer->wdr_long_thresh);
+			apical_isp_frame_stitch_exposure_ratio_write(customer->wdr_expo_ratio_thresh);
+			apical_isp_frame_stitch_stitch_correct_write(customer->wdr_stitch_correct);
+			apical_isp_frame_stitch_stitch_error_thresh_write(customer->wdr_stitch_error_thresh);
+			apical_isp_frame_stitch_stitch_error_limit_write(customer->wdr_stitch_error_limit);
+			apical_isp_frame_stitch_black_level_out_write(customer->wdr_stitch_bl_long);
+			apical_isp_frame_stitch_black_level_short_write(customer->wdr_stitch_bl_short);
+			apical_isp_frame_stitch_black_level_long_write(customer->wdr_stitch_bl_output);
+
+			/* Max ISP Digital Gain */
+			api.type = TSYSTEM;
+			api.dir = COMMAND_SET;
+			api.value = customer->max_isp_dgain;
+			api.id = SYSTEM_MAX_ISP_DIGITAL_GAIN;
+
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			if(status != ISP_SUCCESS) {
+				ISP_PRINT(ISP_WARNING_LEVEL,"Custom set max isp digital gain failure!reture value is %d,reason is %d\n",status,reason);
+			}
+
+			/* Max Sensor Analog Gain */
+			api.type = TSYSTEM;
+			api.dir = COMMAND_SET;
+			api.value = customer->max_sensor_again;
+			api.id = SYSTEM_MAX_SENSOR_ANALOG_GAIN;
+
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			if(status != ISP_SUCCESS) {
+				ISP_PRINT(ISP_WARNING_LEVEL,"Custom set max isp digital gain failure!reture value is %d,reason is %d\n",status,reason);
+			}
+
+			/* modify the node */
+			api.type = TIMAGE;
+			api.dir = COMMAND_GET;
+			api.id = WDR_MODE_ID;
+			api.value = -1;
+			status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+			if(status != ISP_SUCCESS) {
+				ISP_PRINT(ISP_WARNING_LEVEL,"Get WDR mode failure!reture value is %d,reason is %d\n",status,reason);
+			}
+
+			if (reason == IMAGE_WDR_MODE_LINEAR) {
+				stab.global_minimum_sinter_strength = *((uint16_t *)(table[ _CALIBRATION_SINTER_STRENGTH_LINEAR]->ptr) + 1);
+				stab.global_maximum_sinter_strength = *((uint16_t *)(table[ _CALIBRATION_SINTER_STRENGTH_LINEAR]->ptr) + table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->rows * table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->cols -1 );
+
+				stab.global_maximum_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_D_LINEAR]->ptr) + 1);
+				stab.global_minimum_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_D_LINEAR]->ptr) + table[_CALIBRATION_SHARP_ALT_D_LINEAR]->rows * table[_CALIBRATION_SHARP_ALT_D_LINEAR]->cols -1 );
+
+				stab.global_maximum_un_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_UD_LINEAR]->ptr) + 1);
+				stab.global_minimum_un_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_UD_LINEAR]->ptr) + table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->rows * table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->cols -1 );
+
+				stab.global_maximum_iridix_strength = *(uint8_t *)(table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR]->ptr);
+			} else if (reason == IMAGE_WDR_MODE_FS_HDR) {
+				stab.global_minimum_sinter_strength = *((uint16_t *)(table[ _CALIBRATION_SINTER_STRENGTH_FS_HDR]->ptr) + 1);
+				stab.global_maximum_sinter_strength = *((uint16_t *)(table[ _CALIBRATION_SINTER_STRENGTH_FS_HDR]->ptr) + table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->rows * table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->cols -1 );
+
+				stab.global_maximum_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_D_FS_HDR]->ptr) + 1);
+				stab.global_minimum_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_D_FS_HDR]->ptr) + table[_CALIBRATION_SHARP_ALT_D_LINEAR]->rows * table[_CALIBRATION_SHARP_ALT_D_LINEAR]->cols -1 );
+
+				stab.global_maximum_un_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_UD_FS_HDR]->ptr) + 1);
+				stab.global_minimum_un_directional_sharpening = *((uint16_t *)(table[ _CALIBRATION_SHARP_ALT_UD_FS_HDR]->ptr) + table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->rows * table[_CALIBRATION_SHARP_ALT_UD_LINEAR]->cols -1 );
+
+				stab.global_maximum_iridix_strength = *(uint8_t *)(table[_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR]->ptr);
+			}
+			stab.global_minimum_temper_strength = *((uint16_t *)(table[ _CALIBRATION_TEMPER_STRENGTH]->ptr) + 1);
+			stab.global_maximum_temper_strength = *((uint16_t *)(table[ _CALIBRATION_TEMPER_STRENGTH]->ptr) + table[_CALIBRATION_TEMPER_STRENGTH]->rows * table[_CALIBRATION_TEMPER_STRENGTH]->cols -1 );
+			stab.global_minimum_iridix_strength = *(uint8_t *)(table[_CALIBRATION_IRIDIX_MIN_MAX_STR]->ptr);
+
+			APICAL_WRITE_32(0x40, tmp_top);
+			/* if it is T20,the FR is corresponding to DS2 in bin file. */
+			if (customer->top & (1 << 19)){
+#if TX_ISP_EXIST_FR_CHANNEL
+				apical_isp_top_bypass_fr_gamma_rgb_write(0);
+				apical_isp_fr_gamma_rgb_enable_write(1);
+#endif
+#if TX_ISP_EXIST_DS2_CHANNEL
+				apical_isp_top_bypass_ds2_gamma_rgb_write(0);
+				apical_isp_ds2_gamma_rgb_enable_write(1);
+#endif
+			} else {
+#if TX_ISP_EXIST_FR_CHANNEL
+				apical_isp_top_bypass_fr_gamma_rgb_write(1);
+				apical_isp_fr_gamma_rgb_enable_write(0);
+#endif
+#if TX_ISP_EXIST_DS2_CHANNEL
+				apical_isp_top_bypass_ds2_gamma_rgb_write(1);
+				apical_isp_ds2_gamma_rgb_enable_write(0);
+#endif
+			}
+
+			if ((customer->top) & (1 << 20)){
+#if TX_ISP_EXIST_FR_CHANNEL
+				apical_isp_top_bypass_fr_sharpen_write(0);
+				apical_isp_fr_sharpen_enable_write(1);
+#endif
+#if TX_ISP_EXIST_DS2_CHANNEL
+				apical_isp_top_bypass_ds2_sharpen_write(0);
+				apical_isp_ds2_sharpen_enable_write(1);
+#endif
+			} else {
+#if TX_ISP_EXIST_FR_CHANNEL
+				apical_isp_fr_sharpen_enable_write(1);
+				apical_isp_top_bypass_fr_sharpen_write(0);
+#endif
+#ifdef TX_ISP_EXIST_DS2_CHANNEL
+				apical_isp_top_bypass_ds2_sharpen_write(1);
+				apical_isp_ds2_sharpen_enable_write(0);
+#endif
+			}
+			if ((customer->top) & (1 << 27))
+				apical_isp_ds1_sharpen_enable_write(1);
+			else
+				apical_isp_ds1_sharpen_enable_write(0);
+		}
+		ctrls->daynight = dn;
+	}
+	return ret;
+}
+
+
+static inline int apical_isp_day_or_night_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	int ret = ISP_SUCCESS;
+
+	ISP_CORE_MODE_DN_E dn;
+	copy_from_user(&dn, (const void __user *)control->value, sizeof(ISP_CORE_MODE_DN_E));
+	if(!param){
+		v4l2_err(tuning->video->v4l2_dev,"Can't get the parameters of isp tuning!\n");
+		return -ISP_ERROR;
+	}
+	if(dn != ctrls->daynight){
+		ctrls->daynight = dn;
+		core->isp_daynight_switch = 1;
+	}
+	return ret;
+}
+
+static inline int apical_isp_hvflip_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	uint32_t value = control->value;
+	core->vflip_state = value&0xffff;
+	//msleep(20);
+	core->hflip_state = (value>>16)&0xffff;
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_hvflip_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	uint32_t value = 0;
+	value = (core->hflip_state)<<16|core->vflip_state;
+	control->value = value;
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_ae_strategy_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	apical_api_control_t api;
+	unsigned int reason = 0;
+	unsigned int status = 0;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+	api.id = AE_SPLIT_PRESET_ID;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+	switch(reason){
+	case AE_SPLIT_BALANCED:
+		control->value = IMPISP_AE_STRATEGY_SPLIT_BALANCED;
+		break;
+	case AE_SPLIT_INTEGRATION_PRIORITY:
+		control->value = IMPISP_AE_STRATEGY_SPLIT_INTEGRATION_PRIORITY;
+		break;
+	default:
+		control->value = IMPISP_AE_STRATEGY_BUTT;
+		break;
+	}
+	if(status != ISP_SUCCESS) {
+		ISP_PRINT(ISP_WARNING_LEVEL,"Custom Get AE strategy failure!reture value is %d,reason is %d\n", status, reason);
+	}
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_ae_strategy_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	apical_api_control_t api;
+	unsigned int reason = 0;
+	unsigned int status = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.id = AE_SPLIT_PRESET_ID;
+	api.dir = COMMAND_SET;
+	api.value = control->value ? AE_SPLIT_INTEGRATION_PRIORITY : AE_SPLIT_BALANCED;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+
+	if(status != ISP_SUCCESS) {
+		ISP_PRINT(ISP_WARNING_LEVEL,"Custom Set AE strategy failure!reture value is %d,reason is %d\n",status, reason);
+	}
+	return ret;
+}
+
+static inline int apical_isp_awb_cwf_g_shift(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	LookupTable** table = NULL;
+	ISP_CORE_MODE_DN_E dn;
+	uint16_t rgain = 0;
+	uint16_t bgain = 0;
+
+	dn = ctrls->daynight;
+	if(param){
+		table = param->isp_param[dn].calibrations;
+
+		rgain = *(uint16_t *)(table[_CALIBRATION_LIGHT_SRC]->ptr);
+		bgain = *((uint16_t *)(table[_CALIBRATION_LIGHT_SRC]->ptr) + 1);
+		control->value = (rgain << 16) + bgain;
+	}
+	return 0;
+}
+
+static inline int apical_isp_awb_cwf_s_shift(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	LookupTable** table = NULL;
+	ISP_CORE_MODE_DN_E dn;
+	int ret = ISP_SUCCESS;
+
+	dn = ctrls->daynight;
+	if(param){
+		table = param->isp_param[dn].calibrations;
+
+		*(uint16_t *)(table[_CALIBRATION_LIGHT_SRC]->ptr) = control->value >> 16;
+		*((uint16_t *)(table[_CALIBRATION_LIGHT_SRC]->ptr) + 1) = control->value & 0xffff;
+		apical_api_calibration(CALIBRATION_LIGHT_SRC,COMMAND_SET, table[_CALIBRATION_LIGHT_SRC]->ptr,
+				table[_CALIBRATION_LIGHT_SRC]->rows * table[_CALIBRATION_LIGHT_SRC]->cols
+				* table[_CALIBRATION_LIGHT_SRC]->width, &ret);
+	}
+	return ret;
+}
+
+static inline int apical_isp_sat_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	TXispPrivParamManage *param = core->param;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	unsigned int value = 128;
+	unsigned int mid_node = 128;
+	int ret = ISP_SUCCESS;
+
+	if(mbus->code == V4L2_MBUS_FMT_YUYV8_1X16){
+		return ret;
+	}
+	/* the original value */
+	value = tuning->ctrls.saturation->val & 0xff;
+	if(param == NULL)
+		goto set_saturation_val;
+
+	if(tuning->ctrls.daynight == ISP_CORE_RUNING_MODE_DAY_MODE){
+			mid_node = param->customer[TX_ISP_PRIV_PARAM_DAY_MODE].saturation;
+	}else{
+			mid_node = param->customer[TX_ISP_PRIV_PARAM_NIGHT_MODE].saturation;
+	}
+
+	/* the amended value */
+	value = value < 128 ? (value * mid_node / 128) : (mid_node + (0xff - mid_node) * (value - 128) / 128);
+
+set_saturation_val:
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = SATURATION_STRENGTH_ID;
+	api.value = value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int apical_isp_bright_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	TXispPrivParamManage *param = core->param;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	unsigned int value = 128;
+	unsigned int mid_node = 128;
+	int ret = ISP_SUCCESS;
+
+	if(mbus->code == V4L2_MBUS_FMT_YUYV8_1X16){
+		return ret;
+	}
+	/* the original value */
+	value = tuning->ctrls.brightness->val & 0xff;
+
+	if(param == NULL)
+		goto set_bright_val;
+
+	if(tuning->ctrls.daynight == ISP_CORE_RUNING_MODE_DAY_MODE){
+			mid_node = param->customer[TX_ISP_PRIV_PARAM_DAY_MODE].brightness;
+	}else{
+			mid_node = param->customer[TX_ISP_PRIV_PARAM_NIGHT_MODE].brightness;
+	}
+
+	/* the amended value */
+	value = value < 128 ? (value * mid_node / 128) : (mid_node + (0xff - mid_node) * (value - 128) / 128);
+
+set_bright_val:
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = BRIGHTNESS_STRENGTH_ID;
+	api.value = value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int apical_isp_contrast_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	TXispPrivParamManage *param = core->param;
+	struct v4l2_mbus_framefmt *mbus = &core->vin.mbus;
+	unsigned char (*curves)[2] = NULL;
+	unsigned int value = 128;
+	int x1, x2;
+	unsigned int y1,y2,v1,v2;
+	unsigned int total_gain;
+	apical_api_control_t api;
+	int i = 0;
+	unsigned char status = 0;
+	int reason = 0;
+	int ret = ISP_SUCCESS;
+
+	if(mbus->code == V4L2_MBUS_FMT_YUYV8_1X16){
+		return ret;
+	}
+
+	value = tuning->ctrls.contrast->val & 0xff;
+
+	if(param == NULL)
+		goto set_contrast_val;
+	/* total_gain format 27.5; for example, the value is 170, is '101.01010'b, is 2^5 + (10 / 32), is 32.2125x */
+	total_gain =  stab.global_sensor_analog_gain  + stab.global_sensor_digital_gain + stab.global_isp_digital_gain;
+
+	total_gain = math_exp2(total_gain,5,5);
+
+	if(tuning->ctrls.daynight == ISP_CORE_RUNING_MODE_DAY_MODE){
+			curves = param->customer[TX_ISP_PRIV_PARAM_DAY_MODE].contrast;
+	}else{
+			curves = param->customer[TX_ISP_PRIV_PARAM_NIGHT_MODE].contrast;
+	}
+
+	/* When curve[0][0] == 0xff, the curves is invalid. */
+	if(curves[0][0] != 0xff){
+		for(i = 0; i < CONTRAST_CURVES_MAXNUM; i++){
+			if((curves[i][0] == 0xff) || ((curves[i][0] << 5) >= total_gain))
+				break;
+		}
+		if(curves[i][0] == 0xff){
+			x1 = i - 1;
+			x2 = i - 1;
+		}else{
+			x2 = i;
+			x1 = x2 - 1 < 0 ? 0 : x2 - 1;
+		}
+
+		if(x1 == x2){
+			y1 = curves[x1][1];
+			value = value < 128 ? (value * y1 / 128) : (y1 + (0xff - y1) * (value - 128) / 128);
+		}else{
+			y1 = curves[x1][1];
+			y2 = curves[x2][1];
+			v1 = value < 128 ? (value * y1 / 128) : (y1 + (0xff - y1) * (value - 128) / 128);
+			v2 = value < 128 ? (value * y2 / 128) : (y2 + (0xff - y2) * (value - 128) / 128);
+
+			x1 = curves[x1][0];
+			x2 = curves[x2][0];
+			x1 = x1 << 5;
+			x2 = x2 << 5;
+
+			value = ((total_gain - x1) * v2 + (x2 - total_gain) * v1) / (x2 - x1);
+		}
+	}
+set_contrast_val:
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = CONTRAST_STRENGTH_ID;
+	api.value = value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int apical_isp_resolution_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+//	struct video_device *video = core->tun;
+//	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+//	struct v4l2_ctrl *res = tuning->ctrls.resolution;
+//	apical_api_control_t api;
+//	unsigned char status = 0;
+	int ret = ISP_SUCCESS;
+	return ret;
+}
+
+static inline int apical_isp_fps_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_private_ioctl ioctl;
+	struct tx_isp_notify_argument arg;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	unsigned int fps = 0;
+	copy_from_user(&fps, (const void __user *)control->value, sizeof(unsigned int));
+	if(fps != core->vin.fps){
+		ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+		ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_FPS;
+		ioctl.value = fps;
+
+		arg.value = (int)&ioctl;
+		tx_isp_sd_notify(tuning->parent, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
+		api.type = TIMAGE;
+		api.dir = COMMAND_SET;
+		api.id = SENSOR_FPS_MODE_ID;
+		api.value = FPS25;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	}
+	return 0;
+}
+
+static inline int apical_isp_fps_g_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+//	struct video_device *video = core->tun;
+//	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	unsigned int fps = core->vin.fps;
+	copy_to_user((void __user *)control->value, (const void *)&fps, sizeof(unsigned int));
+
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_fc_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_false_color_attr *attr = &tuning->ctrls.fc_attr;
+
+	return ISP_SUCCESS;
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	apical_isp_demosaic_fc_slope_write(attr->strength);
+	apical_isp_demosaic_fc_alias_slope_write(attr->alias_strength);
+	apical_isp_demosaic_fc_alias_thresh_write(attr->alias_thresh);
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_sharp_s_control(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	TXispPrivParamManage *param = core->param;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+	unsigned int value = 128;
+	unsigned int mid_node = 128;
+	int ret = ISP_SUCCESS;
+
+	/* the original value */
+	value = tuning->ctrls.sharpness->val & 0xff;
+
+	if(param == NULL)
+		goto set_sharpness_val;
+
+	if(tuning->ctrls.daynight == ISP_CORE_RUNING_MODE_DAY_MODE){
+			mid_node = param->customer[TX_ISP_PRIV_PARAM_DAY_MODE].sharpness;
+	}else{
+			mid_node = param->customer[TX_ISP_PRIV_PARAM_NIGHT_MODE].sharpness;
+	}
+
+	/* the amended value */
+	value = value < 128 ? (value * mid_node / 128) : (mid_node + (0xff - mid_node) * (value - 128) / 128);
+
+set_sharpness_val:
+	api.type = TSCENE_MODES;
+	api.dir = COMMAND_SET;
+	api.id = SHARPENING_STRENGTH_ID;
+	api.value = value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	return ret;
+}
+
+static inline int apical_isp_sharp_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_sharpness_attr *attr = &tuning->ctrls.sharp_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+#if 1
+	apical_isp_fr_sharpen_strength_write(attr->target_sharp);
+	apical_isp_ds1_sharpen_strength_write(attr->target_sharp);
+	apical_isp_ds2_sharpen_strength_write(attr->target_sharp);
+#else
+	apical_isp_demosaic_sharp_alt_d_write(attr->demo_strength_d);
+	apical_isp_demosaic_sharp_alt_ud_write(attr->demo_strength_ud);
+	apical_isp_demosaic_lum_thresh_write(attr->demo_threshold);
+	apical_isp_fr_sharpen_enable_write(attr->fr_enable);
+	apical_isp_ds1_sharpen_enable_write(attr->ds1_enable);
+	apical_isp_ds2_sharpen_enable_write(attr->ds2_enable);
+	if(attr->fr_enable){
+		apical_isp_fr_sharpen_strength_write(attr->fr_strength);
+	}
+	if(attr->ds1_enable){
+		apical_isp_ds1_sharpen_strength_write(attr->ds1_strength);
+	}
+	if(attr->ds2_enable){
+		apical_isp_ds2_sharpen_strength_write(attr->ds2_strength);
+	}
+#endif
+	return ISP_SUCCESS;
+}
+
+static inline int apical_isp_demosaic_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct isp_core_demosaic_attr *attr = &tuning->ctrls.demo_attr;
+
+	copy_from_user(attr, (const void __user *)control->value, sizeof(*attr));
+	apical_isp_demosaic_vh_slope_write(attr->vh_slope);
+	apical_isp_demosaic_aa_slope_write(attr->aa_slope);
+	apical_isp_demosaic_va_slope_write(attr->va_slope);
+	apical_isp_demosaic_uu_slope_write(attr->uu_slope);
+	apical_isp_demosaic_sat_slope_write(attr->sat_slope);
+	apical_isp_demosaic_vh_thresh_write(attr->vh_thresh);
+	apical_isp_demosaic_aa_thresh_write(attr->aa_thresh);
+	apical_isp_demosaic_va_thresh_write(attr->va_thresh);
+	apical_isp_demosaic_uu_thresh_write(attr->uu_thresh);
+	apical_isp_demosaic_sat_thresh_write(attr->sat_thresh);
+	apical_isp_demosaic_vh_offset_write(attr->vh_offset);
+	apical_isp_demosaic_aa_offset_write(attr->aa_offset);
+	apical_isp_demosaic_va_offset_write(attr->va_offset);
+	apical_isp_demosaic_uu_offset_write(attr->uu_offset);
+	apical_isp_demosaic_sat_offset_write(attr->sat_offset);
+	apical_isp_demosaic_dmsc_config_write(attr->dmsc_config);
+
+	return ISP_SUCCESS;
+}
+
+static inline int af_status_apical_to_v4l2(unsigned int val)
+{
+	int ret = ISP_SUCCESS;
+	switch(val){
+		case AF_NOT_FOCUSED:
+			ret = V4L2_AUTO_FOCUS_STATUS_IDLE;
+			break;
+		case AF_SUCCESS:
+		case AF_LOCKED:
+			ret = V4L2_AUTO_FOCUS_STATUS_REACHED;
+			break;
+		case AF_FAIL:
+			ret = V4L2_AUTO_FOCUS_STATUS_FAILED;
+			break;
+		case AF_RUNNING:
+			ret = V4L2_AUTO_FOCUS_STATUS_BUSY;
+			break;
+		default:
+			ret = -ISP_ERROR;
+			break;
+	}
+	return ret;
+}
+static inline int apical_isp_af_g_status(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct v4l2_ctrl *af_status = tuning->ctrls.af_status;
+	apical_api_control_t api;
+	unsigned char status = 0;
+	unsigned int ret_value = 0;
+	int ret = ISP_SUCCESS;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+	api.id = AF_STATUS_ID;
+	api.value = 0;
+	status = apical_command(api.type, api.id, api.value, api.dir, &ret_value);
+	af_status->val = af_status_apical_to_v4l2(ret_value);
+	return ret;
+}
+
+static int apical_isp_gamma_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	int ret = ISP_SUCCESS;
+	struct isp_core_gamma_attr attr;
+	int i = 0;
+
+	for (i = 0; i < 129; i++) {
+		attr.gamma[i] = APICAL_READ_32(0x10400+4*i);
+	}
+	copy_to_user((void __user*)control->value, (const void *)&attr, sizeof(attr));
+	return ret;
+}
+
+static int apical_isp_stab_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_stab_attr stab_attr;
+	memset(&stab_attr, 0, sizeof(stab_attr));
+	memcpy(&stab_attr.stab, &stab, sizeof(stab));
+	copy_to_user((void __user*)control->value, &stab_attr, sizeof(stab_attr));
+	return 0;
+}
+
+#define SYSTEM_TAB_ITEM(x) if (stab_attr.stab_ctrl.ctrl_##x) stab.x = stab_attr.stab.x
+static int apical_isp_stab_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_stab_attr stab_attr;
+	copy_from_user(&stab_attr, (const void __user*)control->value, sizeof(stab_attr));
+	SYSTEM_TAB_ITEM(global_freeze_firmware);
+	SYSTEM_TAB_ITEM(global_manual_exposure);
+	SYSTEM_TAB_ITEM(global_manual_exposure_ratio);
+	SYSTEM_TAB_ITEM(global_manual_integration_time);
+	SYSTEM_TAB_ITEM(global_manual_sensor_analog_gain);
+	SYSTEM_TAB_ITEM(global_manual_sensor_digital_gain);
+	SYSTEM_TAB_ITEM(global_manual_isp_digital_gain);
+	SYSTEM_TAB_ITEM(global_manual_directional_sharpening);
+	SYSTEM_TAB_ITEM(global_manual_un_directional_sharpening);
+	SYSTEM_TAB_ITEM(global_manual_iridix);
+	SYSTEM_TAB_ITEM(global_manual_sinter);
+	SYSTEM_TAB_ITEM(global_manual_temper);
+	SYSTEM_TAB_ITEM(global_manual_awb);
+	SYSTEM_TAB_ITEM(global_antiflicker_enable);
+	SYSTEM_TAB_ITEM(global_slow_frame_rate_enable);
+	SYSTEM_TAB_ITEM(global_manual_saturation);
+	SYSTEM_TAB_ITEM(global_manual_exposure_time);
+	SYSTEM_TAB_ITEM(global_exposure_dark_target);
+	SYSTEM_TAB_ITEM(global_exposure_bright_target);
+	SYSTEM_TAB_ITEM(global_exposure_ratio);
+	SYSTEM_TAB_ITEM(global_max_exposure_ratio);
+	SYSTEM_TAB_ITEM(global_integration_time);
+	SYSTEM_TAB_ITEM(global_max_integration_time);
+	SYSTEM_TAB_ITEM(global_sensor_analog_gain);
+	SYSTEM_TAB_ITEM(global_max_sensor_analog_gain);
+	SYSTEM_TAB_ITEM(global_sensor_digital_gain);
+	SYSTEM_TAB_ITEM(global_max_sensor_digital_gain);
+	SYSTEM_TAB_ITEM(global_isp_digital_gain);
+	SYSTEM_TAB_ITEM(global_max_isp_digital_gain);
+	SYSTEM_TAB_ITEM(global_directional_sharpening_target);
+	SYSTEM_TAB_ITEM(global_maximum_directional_sharpening);
+	SYSTEM_TAB_ITEM(global_minimum_directional_sharpening);
+	SYSTEM_TAB_ITEM(global_un_directional_sharpening_target);
+	SYSTEM_TAB_ITEM(global_maximum_un_directional_sharpening);
+	SYSTEM_TAB_ITEM(global_minimum_un_directional_sharpening);
+	SYSTEM_TAB_ITEM(global_iridix_strength_target);
+	SYSTEM_TAB_ITEM(global_maximum_iridix_strength);
+	SYSTEM_TAB_ITEM(global_minimum_iridix_strength);
+	SYSTEM_TAB_ITEM(global_sinter_threshold_target);
+	SYSTEM_TAB_ITEM(global_maximum_sinter_strength);
+	SYSTEM_TAB_ITEM(global_minimum_sinter_strength);
+	SYSTEM_TAB_ITEM(global_temper_threshold_target);
+	SYSTEM_TAB_ITEM(global_maximum_temper_strength);
+	SYSTEM_TAB_ITEM(global_minimum_temper_strength);
+	SYSTEM_TAB_ITEM(global_awb_red_gain);
+	SYSTEM_TAB_ITEM(global_awb_blue_gain);
+	SYSTEM_TAB_ITEM(global_saturation_target);
+	SYSTEM_TAB_ITEM(global_anti_flicker_frequency);
+	SYSTEM_TAB_ITEM(global_ae_compensation);
+	SYSTEM_TAB_ITEM(global_calibrate_bad_pixels);
+	SYSTEM_TAB_ITEM(global_dis_x);
+	SYSTEM_TAB_ITEM(global_dis_y);
+	return 0;
+}
+
+static int apical_isp_gamma_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	int ret = ISP_SUCCESS;
+	struct isp_core_gamma_attr attr;
+
+	if (0 == control->value) {
+		apical_api_calibration(CALIBRATION_GAMMA_LINEAR, COMMAND_GET, attr.gamma, sizeof(attr.gamma), &ret);
+		if (ret != ISP_SUCCESS)
+			goto err_get_def_gamma;
+	} else {
+		copy_from_user(&attr, (const void __user*)control->value, sizeof(attr));
+	}
+	apical_api_calibration(CALIBRATION_GAMMA_LINEAR, COMMAND_SET, attr.gamma, sizeof(attr.gamma), &ret);
+		if (ret != ISP_SUCCESS)
+			goto err_set_def_gamma;
+	return ret;
+
+err_set_def_gamma:
+err_get_def_gamma:
+	return ret;
+}
+
+static int apical_isp_ae_weight_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_weight_attr attr;
+	unsigned int row,col;
+
+	copy_from_user(&attr, (const void __user*)control->value, sizeof(attr));
+
+	for (row = 0; row < 15; row++){
+		for (col = 0; col < 15; col++){
+			apical_isp_zones_aexp_weight_write(row, col, (attr.weight[row][col]));
+		}
+	}
+
+	return 0;
+}
+
+static int apical_isp_ae_weight_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_weight_attr attr;
+	unsigned int row,col;
+
+	for (row = 0; row < 15; row++){
+		for (col = 0; col < 15; col++){
+			attr.weight[row][col] = apical_isp_zones_aexp_weight_read(row,col);
+		}
+	}
+
+	copy_to_user((void __user*)control->value, &attr, sizeof(attr));
+
+	return 0;
+}
+
+static int apical_isp_ae_hist_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_ae_sta_info info;
+
+	info.ae_histhresh[0] = apical_isp_metering_hist_thresh_0_1_read();
+	info.ae_histhresh[1] = apical_isp_metering_hist_thresh_1_2_read();
+	info.ae_histhresh[2] = apical_isp_metering_hist_thresh_3_4_read();
+	info.ae_histhresh[3] = apical_isp_metering_hist_thresh_4_5_read();
+
+	info.ae_hist[0] = apical_isp_metering_hist_0_read();
+	info.ae_hist[1] = apical_isp_metering_hist_1_read();
+	info.ae_hist[3] = apical_isp_metering_hist_3_read();
+	info.ae_hist[4] = apical_isp_metering_hist_4_read();
+	info.ae_hist[2] = 0xffff - info.ae_hist[0] - info.ae_hist[1] - info.ae_hist[3] - info.ae_hist[4];
+
+	info.ae_stat_nodeh = apical_isp_metering_aexp_nodes_used_horiz_read();
+	info.ae_stat_nodev = apical_isp_metering_aexp_nodes_used_vert_read();
+
+	copy_to_user((void __user*)control->value, &info, sizeof(info));
+	return 0;
+}
+
+static int apical_isp_ae_hist_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_ae_sta_info info;
+
+	copy_from_user(&info, (const void __user*)control->value, sizeof(info));
+
+	apical_isp_metering_hist_thresh_0_1_write(info.ae_histhresh[0]);
+	apical_isp_metering_hist_thresh_1_2_write(info.ae_histhresh[1]);
+	apical_isp_metering_hist_thresh_3_4_write(info.ae_histhresh[2]);
+	apical_isp_metering_hist_thresh_4_5_write(info.ae_histhresh[3]);
+
+	apical_isp_metering_aexp_nodes_used_horiz_write(info.ae_stat_nodeh);
+	apical_isp_metering_aexp_nodes_used_vert_write(info.ae_stat_nodev);
+
+	return 0;
+}
+
+static int apical_isp_ae_zone_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_ae_zone ae_zone;
+	int i = 0;
+	unsigned int ae_meter;
+	unsigned int exp;
+	unsigned int val;
+
+	for (i = 0; i < ZONE_H_NUM * ZONE_V_NUM; i++){
+			ae_meter = apical_histogram_mem_array_data_read(i);
+			exp = (ae_meter >> 12) & 0xf;
+			val = ae_meter & 0xfff;
+			if(exp){
+				val = (val | 0x1000) << (exp - 1);
+			}
+			ae_zone.ae_sta_zone[i] = (unsigned short)val;
+	}
+
+	copy_to_user((void __user*)control->value, &ae_zone, sizeof(ae_zone));
+
+	return 0;
+
+}
+
+static int apical_isp_af_zone_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_ae_zone ae_zone;
+	int i = 0;
+	unsigned int ae_meter;
+	unsigned int exp;
+	unsigned int val;
+
+	for (i = 0; i < ZONE_H_NUM * ZONE_V_NUM; i++){
+		ae_meter = apical_histogram_mem_array_data_read(i);
+		exp = (ae_meter >> 12) & 0xf;
+		val = ae_meter & 0xfff;
+		if(exp){
+			val = (val | 0x1000) << (exp - 1);
+		}
+		ae_zone.ae_sta_zone[i] = (unsigned short)val;
+	}
+
+	copy_to_user((void __user*)control->value, &ae_zone, sizeof(ae_zone));
+
+	return 0;
+}
+
+static int apical_isp_awb_hist_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_awb_sta_info info;
+
+	info.awb_stat.r_gain = apical_isp_metering_awb_rg_read();
+	info.awb_stat.b_gain = apical_isp_metering_awb_bg_read();
+	info.awb_stat.awb_sum = apical_isp_metering_awb_sum_read();
+
+	info.awb_stats_mode = apical_isp_metering_awb_stats_mode_read()?ISPCORE_AWB_STATS_CURRENT_MODE:ISPCORE_AWB_STATS_LEGACY_MODE;
+	info.awb_whitelevel = apical_isp_metering_white_level_awb_read();
+	info.awb_blacklevel = apical_isp_metering_black_level_awb_read();
+	info.cr_ref_max = apical_isp_metering_cr_ref_max_awb_read();
+	info.cr_ref_min = apical_isp_metering_cr_ref_min_awb_read();
+	info.cb_ref_max = apical_isp_metering_cb_ref_max_awb_read();
+	info.cb_ref_min = apical_isp_metering_cb_ref_min_awb_read();
+	info.awb_stat_nodeh = apical_isp_metering_awb_nodes_used_horiz_read();
+	info.awb_stat_nodev = apical_isp_metering_awb_nodes_used_vert_read();
+	/* info.cr_ref_high = apical_isp_metering_cr_ref_high_awb_read(); */
+	/* info.cr_ref_low = apical_isp_metering_cr_ref_low_awb_read(); */
+	/* info.cb_ref_high = apical_isp_metering_cb_ref_high_awb_read(); */
+	/* info.cb_ref_low = apical_isp_metering_cb_ref_low_awb_read(); */
+
+	copy_to_user((void __user*)control->value, &info, sizeof(info));
+
+	return 0;
+}
+
+static int apical_isp_awb_zone_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	int i = 0;
+	int j = 0;
+	unsigned int awb_meter;
+	struct isp_wb_zone *wb_zone = kmalloc(sizeof(*wb_zone),GFP_KERNEL);
+	if(!wb_zone)
+		return -1;
+	memset(wb_zone, 0, sizeof(*wb_zone));
+	for (i = 0; i < ZONE_H_NUM; i++){
+		for (j = 0; j < ZONE_V_NUM; j++){
+			awb_meter = apical_metering_mem_array_data_read((ISP_METERING_OFFSET_AWB >> 2) + (i * ZONE_V_NUM + j) * 2);
+			wb_zone->awb_sta_zone[i][j].red_green = awb_meter & 0xfff;
+			wb_zone->awb_sta_zone[i][j].blue_green = awb_meter >> 16 & 0xfff;
+			awb_meter = apical_metering_mem_array_data_read((ISP_METERING_OFFSET_AWB >> 2) + ((i * ZONE_V_NUM + j) * 2 + 1));
+			wb_zone->awb_sta_zone[i][j].sum = awb_meter;
+		}
+
+	}
+	copy_to_user((void __user*)control->value, wb_zone, sizeof(*wb_zone));
+	kfree(wb_zone);
+
+	return 0;
+}
+
+static int apical_isp_awb_hist_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_awb_sta_info info;
+	copy_from_user(&info, (const void __user*)control->value, sizeof(info));
+
+	apical_isp_metering_awb_stats_mode_write(info.awb_stats_mode?1:0);
+	apical_isp_metering_white_level_awb_write(info.awb_whitelevel);
+	apical_isp_metering_black_level_awb_write(info.awb_blacklevel);
+	apical_isp_metering_cr_ref_max_awb_write(info.cr_ref_max);
+	apical_isp_metering_cr_ref_min_awb_write(info.cr_ref_min);
+	apical_isp_metering_cb_ref_max_awb_write(info.cb_ref_max);
+	apical_isp_metering_cb_ref_min_awb_write(info.cb_ref_min);
+	apical_isp_metering_awb_nodes_used_horiz_write(info.awb_stat_nodeh);
+	apical_isp_metering_awb_nodes_used_vert_write(info.awb_stat_nodev);
+	/* apical_isp_metering_cr_ref_high_awb_write(info.cr_ref_high); */
+	/* apical_isp_metering_cr_ref_low_awb_write(info.cr_ref_low); */
+	/* apical_isp_metering_cb_ref_high_awb_write(info.cb_ref_high); */
+	/* apical_isp_metering_cb_ref_low_awb_write(info.cb_ref_low); */
+
+	return 0;
+}
+
+static int apical_isp_af_hist_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_af_sta_info info;
+
+	info.af_stat.af_metrics = apical_isp_metering_af_metrics_read();
+	info.af_stat.af_metrics_alt = apical_isp_metering_af_metrics_alt_read();
+	info.af_stat.af_thresh_read = apical_isp_metering_af_threshold_read_read();
+	info.af_stat.af_intensity_read = apical_isp_metering_af_intensity_read_read();
+	info.af_stat.af_intensity_zone = apical_isp_metering_af_intensity_zone_read_read();
+	info.af_stat.af_total_pixels = apical_isp_metering_total_pixels_read();
+	info.af_stat.af_counted_pixels = apical_isp_metering_counted_pixels_read();
+
+	info.af_metrics_shift = apical_isp_metering_af_metrics_shift_read();
+	info.af_thresh = apical_isp_metering_af_threshold_write_read();
+	info.af_thresh_alt = apical_isp_metering_af_threshold_alt_write_read();
+	info.af_stat_nodeh = apical_isp_metering_af_nodes_used_horiz_read();
+	info.af_stat_nodev = apical_isp_metering_af_nodes_used_vert_read();
+	info.af_np_offset = apical_isp_metering_af_np_offset_read();
+	info.af_intensity_mode = apical_isp_metering_af_intensity_norm_mode_read();
+	info.af_skipx = apical_isp_metering_skip_x_read();
+	info.af_offsetx = apical_isp_metering_offset_x_read();
+	info.af_skipy = apical_isp_metering_skip_y_read();
+	info.af_offsety = apical_isp_metering_offset_y_read();
+	info.af_scale_top = apical_isp_metering_scale_top_read();
+	info.af_scale_bottom = apical_isp_metering_scale_bottom_read();
+
+	copy_to_user((void __user*)control->value, &info, sizeof(info));
+
+	return 0;
+}
+
+static int apical_isp_af_hist_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_af_sta_info info;
+	copy_from_user(&info, (const void __user*)control->value, sizeof(info));
+
+	 apical_isp_metering_af_metrics_shift_write(info.af_metrics_shift);
+	 apical_isp_metering_af_threshold_write_write(info.af_thresh);
+	 apical_isp_metering_af_threshold_alt_write_write(info.af_thresh_alt);
+	 apical_isp_metering_af_nodes_used_horiz_write(info.af_stat_nodeh);
+	 apical_isp_metering_af_nodes_used_vert_write(info.af_stat_nodev);
+	 apical_isp_metering_af_np_offset_write(info.af_np_offset);
+	 apical_isp_metering_af_intensity_norm_mode_write(info.af_intensity_mode);
+	 apical_isp_metering_skip_x_write(info.af_skipx);
+	 apical_isp_metering_offset_x_write(info.af_offsetx);
+	 apical_isp_metering_skip_y_write(info.af_skipy);
+	 apical_isp_metering_offset_y_write(info.af_offsety);
+	 apical_isp_metering_scale_top_write(info.af_scale_top);
+	 apical_isp_metering_scale_bottom_write(info.af_scale_bottom);
+
+	return 0;
+}
+
+static int apical_isp_awb_weight_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_weight_attr attr;
+	unsigned int row,col;
+
+	copy_from_user(&attr, (const void __user*)control->value, sizeof(attr));
+
+	for (row = 0; row < 15; row++){
+		for (col = 0; col < 15; col++){
+			apical_isp_zones_awb_weight_write(row, col, (attr.weight[row][col]));
+		}
+	}
+
+	return 0;
+}
+
+static int apical_isp_awb_weight_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_weight_attr attr;
+	unsigned int row,col;
+
+	for (row = 0; row < 15; row++){
+		for (col = 0; col < 15; col++){
+			attr.weight[row][col] = apical_isp_zones_awb_weight_read(row,col);
+		}
+	}
+
+	copy_to_user((void __user*)control->value, &attr, sizeof(attr));
+
+	return 0;
+}
+
+static int apical_isp_ae_comp_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int reason = 0;
+
+	apical_api_control_t api;
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+
+	api.id = AE_COMPENSATION_ID;
+	api.value = control->value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int apical_isp_ae_comp_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int reason = 0;
+	apical_api_control_t api;
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+
+	api.id = AE_COMPENSATION_ID;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		return -1;
+	}
+	control->value = reason;
+
+	return 0;
+}
+
+static int apical_isp_expr_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct tx_isp_sensor_attribute *attr = core->vin.attr;
+	union isp_core_expr_attr expr_attr;
+	apical_api_control_t api;
+	int mode = 0;
+	unsigned int integration_time = 0;
+
+	unsigned char status = 0;
+	int reason = 0;
+
+	copy_from_user(&expr_attr, (const void __user*)control->value, sizeof(expr_attr));
+
+	if (expr_attr.s_attr.mode == ISP_CORE_EXPR_MODE_AUTO) {
+		mode = 0;
+	} else {
+		mode = 1;
+	}
+
+	if ((expr_attr.s_attr.unit == ISP_CORE_EXPR_UNIT_US)&&(1 == mode)) {
+		if (attr->one_line_expr_in_us != 0)
+			integration_time = expr_attr.s_attr.time/attr->one_line_expr_in_us;
+		else {
+			printk("err: %s,%d one_line_expr_in_us = %d \n", __func__, __LINE__, attr->one_line_expr_in_us);
+			goto err_one_line_expr_in_us;
+		}
+	}
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_SET;
+	api.id = SYSTEM_MANUAL_INTEGRATION_TIME;
+	api.value = mode;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_set_expr_mode;
+	}
+
+	if (mode) {
+		api.type = TSYSTEM;
+		api.dir = COMMAND_SET;
+		api.id = SYSTEM_INTEGRATION_TIME;
+		api.value = integration_time;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if (status != ISP_SUCCESS) {
+			printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+			goto err_set_integration_time;
+		}
+	}
+	return 0;
+
+err_set_integration_time:
+err_set_expr_mode:
+err_one_line_expr_in_us:
+	return -1;
+}
+
+static int apical_isp_expr_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct tx_isp_sensor_attribute *attr = core->vin.attr;
+	union isp_core_expr_attr expr_attr;
+	apical_api_control_t api;
+	int mode = 0;
+	unsigned int integration_time = 0;
+
+	unsigned char status = 0;
+	int reason = 0;
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_GET;
+	api.id = SYSTEM_MANUAL_INTEGRATION_TIME;
+	api.value = mode;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_expr_mode;
+	}
+	mode = reason;
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_GET;
+	api.id = SYSTEM_INTEGRATION_TIME;
+	api.value = integration_time;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_integration_time;
+	}
+	integration_time = reason;
+
+	expr_attr.g_attr.mode = (0 == mode)?ISP_CORE_EXPR_MODE_AUTO:ISP_CORE_EXPR_MODE_MANUAL;
+	expr_attr.g_attr.integration_time = integration_time;
+	expr_attr.g_attr.integration_time_min = attr->min_integration_time;
+	expr_attr.g_attr.integration_time_max = attr->max_integration_time;
+	expr_attr.g_attr.one_line_expr_in_us = attr->one_line_expr_in_us;
+
+	copy_to_user((void __user*)control->value, &expr_attr, sizeof(expr_attr));
+
+	return 0;
+
+err_get_integration_time:
+err_get_expr_mode:
+	return 0;
+}
+
+static int apical_isp_ae_g_roi(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+	api.id = AE_ROI_ID;
+	api.value = 0;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	control->value = reason;
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		return -1;
+	}
+	return 0;
+}
+
+static int apical_isp_ae_s_roi(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	apical_api_control_t api;
+	unsigned char status = 0;
+	int reason = 0;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = AE_ROI_ID;
+	api.value = control->value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		return -1;
+	}
+	return 0;
+}
+
+static int isp_wb_mode_to_apical(enum isp_core_wb_mode mode)
+{
+	int apical_mode = -1;
+	switch(mode) {
+	case ISP_CORE_WB_MODE_AUTO:
+		apical_mode = AWB_AUTO;
+		break;
+	case ISP_CORE_WB_MODE_MANUAL:
+		apical_mode = AWB_MANUAL;
+		break;
+	case ISP_CORE_WB_MODE_DAY_LIGHT:
+		apical_mode = AWB_DAY_LIGHT;
+		break;
+	case ISP_CORE_WB_MODE_CLOUDY:
+		apical_mode = AWB_CLOUDY;
+		break;
+	case ISP_CORE_WB_MODE_INCANDESCENT:
+		apical_mode = AWB_INCANDESCENT;
+		break;
+	case ISP_CORE_WB_MODE_FLOURESCENT:
+		apical_mode = AWB_FLOURESCENT;
+		break;
+	case ISP_CORE_WB_MODE_TWILIGHT:
+		apical_mode = AWB_TWILIGHT;
+		break;
+	case ISP_CORE_WB_MODE_SHADE:
+		apical_mode = AWB_SHADE;
+		break;
+	case ISP_CORE_WB_MODE_WARM_FLOURESCENT:
+		apical_mode = AWB_WARM_FLOURESCENT;
+		break;
+	default:
+		break;
+	}
+	return apical_mode;
+}
+
+static int apical_wb_mode_to_isp(int apical_mode)
+{
+	int isp_mode = -1;
+	switch(apical_mode) {
+	case AWB_AUTO:
+		isp_mode = ISP_CORE_WB_MODE_AUTO;
+		break;
+	case AWB_MANUAL:
+		isp_mode = ISP_CORE_WB_MODE_MANUAL;
+		break;
+	case AWB_DAY_LIGHT:
+		isp_mode = ISP_CORE_WB_MODE_DAY_LIGHT;
+		break;
+	case AWB_CLOUDY:
+		isp_mode = ISP_CORE_WB_MODE_CLOUDY;
+		break;
+	case AWB_INCANDESCENT:
+		isp_mode = ISP_CORE_WB_MODE_INCANDESCENT;
+		break;
+	case AWB_FLOURESCENT:
+		isp_mode = ISP_CORE_WB_MODE_FLOURESCENT;
+		break;
+	case AWB_TWILIGHT:
+		isp_mode = ISP_CORE_WB_MODE_TWILIGHT;
+		break;
+	case AWB_SHADE:
+		isp_mode = ISP_CORE_WB_MODE_SHADE;
+		break;
+	case AWB_WARM_FLOURESCENT:
+		isp_mode = ISP_CORE_WB_MODE_WARM_FLOURESCENT;
+		break;
+	default:
+		break;
+	}
+	return isp_mode;
+}
+
+static int apical_isp_wb_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_wb_attr wb_attr;
+	apical_api_control_t api;
+	int apical_mode = 0;
+	int manual = 0;
+
+	unsigned char status = 0;
+	int reason = 0;
+
+	copy_from_user(&wb_attr, (const void __user*)control->value, sizeof(wb_attr));
+
+	apical_mode = isp_wb_mode_to_apical(wb_attr.mode);
+	if (-1 == apical_mode) {
+		printk("err: %s,%d mode = %d \n", __func__, __LINE__, wb_attr.mode);
+		goto err_mode;
+	}
+	if (wb_attr.mode == ISP_CORE_WB_MODE_MANUAL) {
+		manual = 1;
+	} else {
+		manual = 0;
+	}
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_SET;
+	api.id = AWB_MODE_ID;
+	api.value = apical_mode;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_set_wb_mode;
+	}
+	if (manual) {
+		api.type = TSYSTEM;
+		api.dir = COMMAND_SET;
+		api.id = SYSTEM_AWB_RED_GAIN;
+		api.value = wb_attr.rgain;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if (status != ISP_SUCCESS) {
+			printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+			goto err_set_wb_rgain;
+		}
+		api.type = TSYSTEM;
+		api.dir = COMMAND_SET;
+		api.id = SYSTEM_AWB_BLUE_GAIN;
+		api.value = wb_attr.bgain;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if (status != ISP_SUCCESS) {
+			printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+			goto err_set_wb_bgain;
+		}
+	}
+	return 0;
+
+err_set_wb_bgain:
+err_set_wb_rgain:
+err_set_wb_mode:
+err_mode:
+	return -1;
+}
+
+static int apical_isp_wb_statis_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_wb_attr wb_attr;
+
+	wb_attr.rgain = apical_isp_metering_awb_rg_read();
+	wb_attr.bgain = apical_isp_metering_awb_bg_read();
+	control->value = (wb_attr.rgain << 16) + wb_attr.bgain;
+	return 0;
+}
+
+static int apical_isp_rgb_coefft_wb_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_rgb_coefft_wb_attr rgb_coefft_wb_attr;
+
+	copy_from_user(&rgb_coefft_wb_attr, (const void __user*)control->value, sizeof(rgb_coefft_wb_attr));
+	apical_isp_matrix_rgb_coefft_wb_r_write(rgb_coefft_wb_attr.rgb_coefft_wb_r);
+	apical_isp_matrix_rgb_coefft_wb_g_write(rgb_coefft_wb_attr.rgb_coefft_wb_g);
+	apical_isp_matrix_rgb_coefft_wb_b_write(rgb_coefft_wb_attr.rgb_coefft_wb_b);
+	return 0;
+}
+
+
+static int apical_isp_rgb_coefft_wb_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_rgb_coefft_wb_attr rgb_coefft_wb_attr;
+
+	rgb_coefft_wb_attr.rgb_coefft_wb_r = apical_isp_matrix_rgb_coefft_wb_r_read();
+	rgb_coefft_wb_attr.rgb_coefft_wb_g = apical_isp_matrix_rgb_coefft_wb_g_read();
+	rgb_coefft_wb_attr.rgb_coefft_wb_b = apical_isp_matrix_rgb_coefft_wb_b_read();
+	copy_to_user((void __user*)control->value, &rgb_coefft_wb_attr, sizeof(rgb_coefft_wb_attr));
+	return 0;
+}
+
+
+static int apical_isp_wb_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_wb_attr wb_attr;
+	apical_api_control_t api;
+
+	unsigned char status = 0;
+	int reason = 0;
+	int isp_mode = 0;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+	api.id = AWB_MODE_ID;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_wb_mode;
+	}
+	isp_mode = apical_wb_mode_to_isp(reason);
+	if (-1 == isp_mode) {
+		printk("err: %s,%d isp wb mode :%d  \n", __func__, __LINE__, isp_mode);
+		goto err_get_wb_mode;
+	}
+	wb_attr.mode = isp_mode;
+
+	{
+		api.type = TSYSTEM;
+		api.dir = COMMAND_GET;
+		api.id = SYSTEM_AWB_RED_GAIN;
+		api.value = -1;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if (status != ISP_SUCCESS) {
+			printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+			goto err_get_wb_rgain;
+		}
+		wb_attr.rgain = reason;
+
+		api.type = TSYSTEM;
+		api.dir = COMMAND_GET;
+		api.id = SYSTEM_AWB_BLUE_GAIN;
+		api.value = -1;
+		status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+		if (status != ISP_SUCCESS) {
+			printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+			goto err_get_wb_bgain;
+		}
+		wb_attr.bgain = reason;
+	}
+	copy_to_user((void __user*)control->value, &wb_attr, sizeof(wb_attr));
+
+	return 0;
+
+err_get_wb_bgain:
+err_get_wb_rgain:
+err_get_wb_mode:
+	return -1;
+}
+
+static int apical_isp_max_again_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int reason = 0;
+
+	apical_api_control_t api;
+	api.type = TSYSTEM;
+	api.dir = COMMAND_SET;
+
+	api.id = SYSTEM_MAX_SENSOR_ANALOG_GAIN;
+	api.value = control->value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_set_max_again_bgain;
+	}
+
+	return 0;
+err_set_max_again_bgain:
+	return 0;
+}
+
+static int apical_isp_max_again_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int reason = 0;
+	apical_api_control_t api;
+	api.type = TSYSTEM;
+	api.dir = COMMAND_GET;
+
+	api.id = SYSTEM_MAX_SENSOR_ANALOG_GAIN;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_max_again_bgain;
+	}
+	control->value = reason;
+
+	return 0;
+err_get_max_again_bgain:
+	return 0;
+}
+
+static int apical_isp_max_dgain_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int reason = 0;
+
+	apical_api_control_t api;
+	api.type = TSYSTEM;
+	api.dir = COMMAND_SET;
+
+	api.id = SYSTEM_MAX_ISP_DIGITAL_GAIN;
+	api.value = control->value;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_set_max_dgain;
+	}
+
+	return 0;
+err_set_max_dgain:
+	return 0;
+}
+
+static int apical_isp_max_dgain_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int reason = 0;
+	apical_api_control_t api;
+	api.type = TSYSTEM;
+	api.dir = COMMAND_GET;
+
+	api.id = SYSTEM_MAX_ISP_DIGITAL_GAIN;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_max_dgain;
+	}
+	control->value = reason;
+
+	return 0;
+err_get_max_dgain:
+	return 0;
+}
+
+static int apical_isp_hi_light_depress_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	int ret = 0;
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	int strength = control->value;
+
+	struct v4l2_ctrl *wdr = tuning->ctrls.wdr;
+
+	LookupTable** table = NULL;
+	ISP_CORE_MODE_DN_E dn;
+	unsigned int rows = 0;
+	unsigned int cols = 0;
+	unsigned int width = 0;
+	unsigned int size = 0;
+	void *data = 0;
+
+	if(wdr->val == ISPCORE_MODULE_ENABLE){
+		printk("err: wdr enabled\n");
+		return -1;
+	}
+
+	dn = ctrls->daynight;
+	if (NULL == param) {
+		printk("err: param == NULL\n");
+		return -1;
+	}
+	table = param->isp_param[dn].calibrations;
+
+	rows = table[_CALIBRATION_AE_BALANCED_LINEAR]->rows;
+	cols = table[_CALIBRATION_AE_BALANCED_LINEAR]->cols;
+	width = table[_CALIBRATION_AE_BALANCED_LINEAR]->width;
+	size = rows*cols*width;
+
+	data = kzalloc(size, GFP_KERNEL);
+	if(!data){
+		printk("err: Failed to allocate isp table mem\n");
+		return -1;
+	}
+	memcpy(data, table[_CALIBRATION_AE_BALANCED_LINEAR]->ptr, size);
+	if (1 == width) {
+		uint8_t *v = data;
+		v[2] = strength;
+	} else if (2 == width) {
+		uint16_t *v = data;
+		v[2] = strength;
+	} else if (4 == width) {
+		uint32_t *v = data;
+		v[2] = strength;
+	} else {
+		printk("err: %s(%d),format error !\n", __func__, __LINE__);
+		kfree(data);
+		return -1;
+	}
+
+	status = apical_api_calibration(CALIBRATION_AE_BALANCED_LINEAR, COMMAND_SET, data, size, &ret);
+	if (0 != ret) {
+		kfree(data);
+		printk("err: %s,%d, status = %d, ret = %d\n", __func__, __LINE__, status, ret);
+		return -1;
+	}
+	kfree(data);
+
+	return 0;
+}
+
+static int apical_isp_hi_light_depress_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	unsigned char status = 0;
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+	int ret = 0;
+
+	struct v4l2_ctrl *wdr = tuning->ctrls.wdr;
+
+	LookupTable** table = NULL;
+	ISP_CORE_MODE_DN_E dn;
+	unsigned int rows = 0;
+	unsigned int cols = 0;
+	unsigned int width = 0;
+	unsigned int size = 0;
+	void *data = 0;
+
+	if(wdr->val == ISPCORE_MODULE_ENABLE){
+		printk("err: wdr enabled\n");
+		return -1;
+	}
+
+	dn = ctrls->daynight;
+	if (NULL == param) {
+		printk("err: param == NULL\n");
+		return -1;
+	}
+	table = param->isp_param[dn].calibrations;
+
+	rows = table[_CALIBRATION_AE_BALANCED_LINEAR]->rows;
+	cols = table[_CALIBRATION_AE_BALANCED_LINEAR]->cols;
+	width = table[_CALIBRATION_AE_BALANCED_LINEAR]->width;
+	size = rows*cols*width;
+
+	data = kzalloc(size, GFP_KERNEL);
+	if(!data){
+		printk("err: Failed to allocate isp table mem\n");
+		return -1;
+	}
+
+	status = apical_api_calibration(CALIBRATION_AE_BALANCED_LINEAR, COMMAND_GET, data, size, &ret);
+	if (0 != ret)
+		printk("err: %s,%d, status = %d, ret = %d\n", __func__, __LINE__, status, ret);
+
+	if (1 == width) {
+		uint8_t *v = data;
+		control->value = v[2];
+	} else if (2 == width) {
+		uint16_t *v = data;
+		control->value = v[2];
+	} else if (4 == width) {
+		uint32_t *v = data;
+		control->value = v[2];
+	} else {
+		printk("err: %s(%d),format error !\n", __func__, __LINE__);
+		kfree(data);
+		return -1;
+	}
+	kfree(data);
+
+	return 0;
+}
+
+struct isp_table_info {
+	unsigned int id;
+	unsigned int rows;
+	unsigned int cols;
+	unsigned int width;
+	unsigned int tsource;
+	void *ptr;
+};
+
+static int apical_isp_table_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+
+	int ret = ISP_SUCCESS;
+	unsigned int status = 0;
+	LookupTable** table = NULL;
+	ISP_CORE_MODE_DN_E dn;
+
+	unsigned int rows = 0;
+	unsigned int cols = 0;
+	unsigned int width = 0;
+	unsigned int size = 0;
+	unsigned int id = 0;
+	unsigned int tid = 0;
+	struct isp_table_info tinfo;
+	void *data = 0;
+
+	dn = ctrls->daynight;
+	if (NULL == param) {
+		goto err_isp_param;
+	}
+	table = param->isp_param[dn].calibrations;
+	copy_from_user(&tinfo, (const void __user*)control->value, sizeof(tinfo));
+	id = tinfo.id;
+
+	switch(id) {
+		case CALIBRATION_TEMPER_STRENGTH:
+			rows = table[_CALIBRATION_TEMPER_STRENGTH]->rows;
+			cols = table[_CALIBRATION_TEMPER_STRENGTH]->cols;
+			width = table[_CALIBRATION_TEMPER_STRENGTH]->width;
+			tid = _CALIBRATION_TEMPER_STRENGTH;
+			break;
+		case CALIBRATION_SINTER_STRENGTH_LINEAR:
+			rows = table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->rows;
+			cols = table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->cols;
+			width = table[_CALIBRATION_SINTER_STRENGTH_LINEAR]->width;
+			tid = _CALIBRATION_SINTER_STRENGTH_LINEAR;
+			break;
+		case CALIBRATION_DP_SLOPE_LINEAR:
+			rows = table[_CALIBRATION_DP_SLOPE_LINEAR]->rows;
+			cols = table[_CALIBRATION_DP_SLOPE_LINEAR]->cols;
+			width = table[_CALIBRATION_DP_SLOPE_LINEAR]->width;
+			tid = _CALIBRATION_DP_SLOPE_LINEAR;
+			break;
+		default:
+			printk("%s,%d, err id: %d\n", __func__, __LINE__, id);
+			ret = -EPERM;
+			break;
+	}
+	tinfo.rows = rows;
+	tinfo.cols = cols;
+	tinfo.width = width;
+	size = rows*cols*width;
+
+	copy_to_user((void __user*)control->value, &tinfo, sizeof(tinfo));
+	if (NULL != tinfo.ptr) {
+		if (0 == tinfo.tsource) {
+			data = kzalloc(size, GFP_KERNEL);
+			if(!data){
+				printk("Failed to allocate isp table mem\n");
+				return -1;
+			}
+			status = apical_api_calibration(id, COMMAND_GET, tinfo.ptr, size, &ret);
+			if (0 != ret)
+				printk("%s,%d, status = %d, ret = %d\n", __func__, __LINE__, status, ret);
+			copy_to_user((void __user*)tinfo.ptr, data, size);
+			kfree(data);
+		} else {
+			copy_to_user((void __user*)tinfo.ptr, table[tid]->ptr, size);
+		}
+	}
+	return 0;
+err_isp_param:
+	return -1;
+}
+
+static int apical_isp_table_s_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct video_device *video = core->tun;
+	TXispPrivParamManage *param = core->param;
+	image_tuning_vdrv_t *tuning = video_get_drvdata(video);
+	struct image_tuning_ctrls *ctrls = &(tuning->ctrls);
+
+	int ret = ISP_SUCCESS;
+	unsigned int status = 0;
+	LookupTable** table = NULL;
+	ISP_CORE_MODE_DN_E dn;
+
+	unsigned int rows = 0;
+	unsigned int cols = 0;
+	unsigned int width = 0;
+	unsigned int size = 0;
+	unsigned int id = 0;
+	struct isp_table_info tinfo;
+	void *data = 0;
+
+	if (NULL == param) {
+		goto err_isp_param;
+	}
+	dn = ctrls->daynight;
+	table = param->isp_param[dn].calibrations;
+	copy_from_user(&tinfo, (const void __user*)control->value, sizeof(tinfo));
+
+	id = tinfo.id;
+	rows = tinfo.rows;
+	cols = tinfo.cols;
+	width = tinfo.width;
+	size = rows*cols*width;
+
+	if (NULL != tinfo.ptr) {
+		data = kzalloc(size, GFP_KERNEL);
+		if(!data){
+			printk("Failed to allocate isp table mem\n");
+			return -1;
+		}
+		copy_from_user(data, (const void __user*)tinfo.ptr, size);
+		status = apical_api_calibration(id, COMMAND_SET, data, size, &ret);
+		if (0 != ret)
+			printk("%s,%d, status = %d, ret = %d\n", __func__, __LINE__, status, ret);
+		kfree(data);
+	} else {
+		printk("%s,%d, param err\n", __func__, __LINE__);
+	}
+	return 0;
+err_isp_param:
+	return -1;
+}
+
+struct isp_frame_done_info {
+	unsigned int timeout;
+	uint64_t cnt;
+	int reserved;
+};
+
+
+uint64_t frame_done_cnt = 0;
+DECLARE_WAIT_QUEUE_HEAD(frame_done_wq);
+atomic_t frame_done_cond = ATOMIC_INIT(0);
+
+int isp_frame_done_wait(int timeout, uint64_t *cnt)
+{
+	int ret = -1;
+	atomic_set(&frame_done_cond, 0);
+	ret = wait_event_interruptible_timeout(frame_done_wq, (1 == atomic_read(&frame_done_cond)), timeout);
+	*cnt = frame_done_cnt;
+	if (-ERESTARTSYS == ret)
+		return ret;
+	if (!ret)
+		return -ETIMEDOUT;
+	return 0;
+}
+
+void isp_frame_done_wakeup(void)
+{
+	frame_done_cnt++;
+	atomic_set(&frame_done_cond, 1);
+	wake_up(&frame_done_wq);
+}
+
+static int apical_isp_wait_frame_done(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	int ret = ISP_SUCCESS;
+	int timeout = 0;
+	uint64_t cnt = 0;
+	struct isp_frame_done_info info;
+
+	copy_from_user(&info, (const void __user*)control->value, sizeof(info));
+	timeout = info.timeout;
+
+	ret = isp_frame_done_wait(timeout, &cnt);
+	info.cnt = cnt;
+
+	copy_to_user((void __user*)control->value, &info, sizeof(info));
+	return ret;
+
+}
+
+static int apical_isp_ev_g_attr(struct tx_isp_core_device *core, struct v4l2_control *control)
+{
+	struct isp_core_ev_attr ev_attr;
+	apical_api_control_t api;
+
+	unsigned char status = 0;
+	int reason = 0;
+
+
+	api.type = TSYSTEM;
+	api.dir = COMMAND_GET;
+
+	api.id = SYSTEM_MANUAL_EXPOSURE_TIME;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_ev;
+	}
+	ev_attr.ev = reason;
+
+	api.id = SYSTEM_SENSOR_ANALOG_GAIN;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_again;
+	}
+	ev_attr.again = reason;
+
+	api.id = SYSTEM_ISP_DIGITAL_GAIN;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_dgain;
+	}
+	ev_attr.dgain = reason;
+
+	api.type = TALGORITHMS;
+	api.dir = COMMAND_GET;
+	api.id = AE_EXPOSURE_ID;
+	api.value = -1;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_expr;
+	}
+	ev_attr.expr_us = reason;
+
+	api.type = CALIBRATION;
+	api.id = EXPOSURE_LOG2_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_ev_log2;
+	}
+	ev_attr.ev_log2 = reason;
+
+	api.id = GAIN_LOG2_ID;
+	status = apical_command(api.type, api.id, api.value, api.dir, &reason);
+	if (status != ISP_SUCCESS) {
+		printk("err: %s,%d apical_command err \n", __func__, __LINE__);
+		goto err_get_gain_log2;
+	}
+	ev_attr.gain_log2 = reason;
+
+
+	copy_to_user((void __user*)control->value, &ev_attr, sizeof(ev_attr));
+
+	return 0;
+
+err_get_dgain:
+err_get_again:
+err_get_expr:
+err_get_ev:
+err_get_ev_log2:
+err_get_gain_log2:
+	return -1;
+}
+
+
+static int apical_isp_core_ops_g_ctrl(struct tx_isp_core_device *core, struct v4l2_control *ctrl)
+{
+	int ret = ISP_SUCCESS;
+
+	/* printk("%s[%d] ctrl->id = 0x%08x\n", __func__, __LINE__, ctrl->id); */
+	switch(ctrl->id){
+		case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_AF_MODE:
+			apical_isp_af_g_status(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_ATTR:
+			break;
+		case IMAGE_TUNING_CID_WB_STAINFO:
+			break;
+		case IMAGE_TUNING_CID_AE_ATTR:
+			ret = apical_isp_ae_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_STAINFO:
+			break;
+		case IMAGE_TUNING_CID_AF_ATTR:
+			break;
+		case IMAGE_TUNING_CID_AF_STAINFO:
+			break;
+		case IMAGE_TUNING_CID_TEMPER_STRENGTH:
+			ret = apical_isp_temper_dns_g_strength(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_TEMPER_ATTR:
+			ret = apical_isp_temper_dns_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_WDR_ATTR:
+			break;
+		case IMAGE_TUNING_CID_DIS_STAINFO:
+			break;
+		case IMAGE_TUNING_CID_FC_ATTR:
+			break;
+		case IMAGE_TUNING_CID_SHARP_ATTR:
+			break;
+		case IMAGE_TUNING_CID_DEMO_ATTR:
+			break;
+		case IMAGE_TUNING_CID_DRC_ATTR:
+			ret = apical_isp_drc_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_SHAD_ATTR:
+			break;
+		case IMAGE_TUNING_CID_CONTROL_FPS:
+			ret = apical_isp_fps_g_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_GET_TOTAL_GAIN:
+			ret = apical_isp_g_totalgain(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_DAY_OR_NIGHT:
+			ret = apical_isp_day_or_night_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_HVFLIP:
+			ret = apical_isp_hvflip_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_STRATEGY:
+			ret = apical_isp_ae_strategy_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_GAMMA_ATTR:
+			ret = apical_isp_gamma_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_SYSTEM_TAB:
+			ret = apical_isp_stab_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_EXPR_ATTR:
+			ret = apical_isp_expr_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_ROI:
+			ret = apical_isp_ae_g_roi(core, ctrl);;
+			break;
+		case IMAGE_TUNING_CID_WB_ATTR:
+			ret = apical_isp_wb_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_WB_STATIS_ATTR:
+			ret = apical_isp_wb_statis_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_RGB_COEFFT_WB_ATTR:
+			ret = apical_isp_rgb_coefft_wb_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_MAX_AGAIN_ATTR:
+			ret = apical_isp_max_again_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_MAX_DGAIN_ATTR:
+			ret = apical_isp_max_dgain_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_HILIGHT_DEPRESS_STRENGTH:
+			ret = apical_isp_hi_light_depress_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_COMP:
+			ret = apical_isp_ae_comp_g_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_ISP_TABLE_ATTR:
+			ret = apical_isp_table_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_ISP_WAIT_FRAME_ATTR:
+			ret = apical_isp_wait_frame_done(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_ISP_EV_ATTR:
+			ret = apical_isp_ev_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_CWF_SHIFT:
+		 	ret = apical_isp_awb_cwf_g_shift(core, ctrl);
+		 	break;
+		case IMAGE_TUNING_CID_AE_WEIGHT:
+		 	ret = apical_isp_ae_weight_g_attr(core, ctrl);
+		 	break;
+		case IMAGE_TUNING_CID_AWB_WEIGHT:
+		 	ret = apical_isp_awb_weight_g_attr(core, ctrl);
+		 	break;
+		case IMAGE_TUNING_CID_AE_HIST:
+		 	ret = apical_isp_ae_hist_g_attr(core, ctrl);
+		 	break;
+		case IMAGE_TUNING_CID_AWB_HIST:
+		 	ret = apical_isp_awb_hist_g_attr(core, ctrl);
+		 	break;
+		case IMAGE_TUNING_CID_AWB_ZONE:
+			ret = apical_isp_awb_zone_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_ZONE:
+			ret = apical_isp_ae_zone_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AF_ZONE:
+			ret = apical_isp_af_zone_g_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AF_HIST:
+			ret = apical_isp_af_hist_g_attr(core, ctrl);
+			break;
+		default:
+		 	ret = -EPERM;
+		 	break;
+	}
+	return ret;
+}
+
+static int apical_isp_core_ops_s_ctrl(struct tx_isp_core_device *core, struct v4l2_control *ctrl)
+{
+	int ret = ISP_SUCCESS;
+	switch (ctrl->id) {
+		case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		case IMAGE_TUNING_CID_AWB_ATTR:
+		case IMAGE_TUNING_CID_MWB_ATTR:
+			/*ret = apical_isp_wb_s_control(core, ctrl);*/
+			break;
+		case V4L2_CID_EXPOSURE_AUTO:
+			/*ret = apical_isp_ae_s_control(core, ctrl);*/
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_AF_MODE:
+		case IMAGE_TUNING_CID_AF_ATTR:
+			/*ret = apical_isp_af_s_control(core, ctrl);*/
+			break;
+		case V4L2_CID_3A_LOCK:
+			/*ret = apical_isp_3alock_s_control(core, ctrl);*/
+			break;
+		case V4L2_CID_HFLIP:
+			ret = apical_isp_hflip_s_control(core, ctrl);
+			break;
+		case V4L2_CID_VFLIP:
+			ret = apical_isp_vflip_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_SINTER_DNS:
+			ret = apical_isp_sinter_dns_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_SINTER_ATTR:
+			ret = apical_isp_sinter_dns_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_TEMPER_DNS:
+			ret = apical_isp_temper_dns_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_TEMPER_STRENGTH:
+			ret = apical_isp_temper_dns_s_strength(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_TEMPER_ATTR:
+			ret = apical_isp_temper_dns_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_WDR_FLT:
+			ret = apical_isp_wdr_lut_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_NOISE_PROFILE_ATTR:
+			ret = apical_isp_noise_profile_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_WDR:
+			ret = apical_isp_wdr_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_WDR_ATTR:
+			ret = apical_isp_wdr_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_ISP_PROCESS:
+			ret = apical_isp_bypass_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_ISP_FREEZE:
+			ret = apical_isp_freeze_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_TEST_PATTERN:
+			ret = apical_isp_test_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_BL:
+			ret = apical_isp_blacklevel_s_control(core, ctrl);
+			break;
+		case V4L2_CID_IMAGE_STABILIZATION:
+			ret = apical_isp_dis_s_control(core, ctrl);
+			break;
+		case V4L2_CID_POWER_LINE_FREQUENCY:
+			ret = apical_isp_flicker_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_SHAD:
+			ret = apical_isp_lens_shad_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_SHAD_ATTR:
+			ret = apical_isp_lens_shad_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_GE_ATTR:
+			ret = apical_isp_ge_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_DYNAMIC_DP:
+		case IMAGE_TUNING_CID_CUSTOM_GE:
+			ret = apical_isp_dynamic_dp_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_DYNAMIC_DP_ATTR:
+			ret = apical_isp_dynamic_dp_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_STATIC_DP:
+			ret = apical_isp_static_dp_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_STATIC_DP_ATTR:
+			ret = apical_isp_static_dp_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_ANTI_FOG:
+			ret = apical_isp_antifog_s_control(core, ctrl);
+			break;
+		case V4L2_CID_SCENE_MODE:
+			ret = apical_isp_scene_s_control(core, ctrl);
+			break;
+		case V4L2_CID_COLORFX:
+			ret = apical_isp_colorfx_s_control(core, ctrl);
+			break;
+		case V4L2_CID_SATURATION:
+			ret = apical_isp_sat_s_control(core, ctrl);
+			break;
+		case V4L2_CID_BRIGHTNESS:
+			ret = apical_isp_bright_s_control(core, ctrl);
+			break;
+		case V4L2_CID_CONTRAST:
+			ret = apical_isp_contrast_s_control(core, ctrl);
+			break;
+		case V4L2_CID_SHARPNESS:
+			ret = apical_isp_sharp_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_SHARP_ATTR:
+			ret = apical_isp_sharp_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_RESOLUTION:
+			ret = apical_isp_resolution_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_DRC:
+			ret = apical_isp_drc_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_DRC_ATTR:
+			ret = apical_isp_drc_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_DEMO_ATTR:
+			ret = apical_isp_demosaic_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_FC_ATTR:
+			ret = apical_isp_fc_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CONTROL_FPS:
+			ret = apical_isp_fps_s_control(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_DAY_OR_NIGHT:
+			ret = apical_isp_day_or_night_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_HVFLIP:
+			ret = apical_isp_hvflip_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_STRATEGY:
+			ret = apical_isp_ae_strategy_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_GAMMA_ATTR:
+			ret = apical_isp_gamma_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_SYSTEM_TAB:
+			ret = apical_isp_stab_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_EXPR_ATTR:
+			ret = apical_isp_expr_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_ROI:
+			ret = apical_isp_ae_s_roi(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_WB_ATTR:
+			ret = apical_isp_wb_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_RGB_COEFFT_WB_ATTR:
+			ret = apical_isp_rgb_coefft_wb_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_MAX_AGAIN_ATTR:
+			ret = apical_isp_max_again_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_MAX_DGAIN_ATTR:
+			ret = apical_isp_max_dgain_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_HILIGHT_DEPRESS_STRENGTH:
+			ret = apical_isp_hi_light_depress_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_COMP:
+			ret = apical_isp_ae_comp_s_ctrl(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_ISP_TABLE_ATTR:
+			ret = apical_isp_table_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_CWF_SHIFT:
+			ret = apical_isp_awb_cwf_s_shift(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_WEIGHT:
+			ret = apical_isp_ae_weight_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_WEIGHT:
+			ret = apical_isp_awb_weight_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AE_HIST:
+			ret = apical_isp_ae_hist_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AWB_HIST:
+			ret = apical_isp_awb_hist_s_attr(core, ctrl);
+			break;
+		case IMAGE_TUNING_CID_AF_HIST:
+			ret = apical_isp_af_hist_s_attr(core, ctrl);
+			break;
+		default:
+			ret = -EPERM;
+			break;
+	}
+	return ret;
+}
+
+int isp_core_ops_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(sd);
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	int ret = ISP_SUCCESS;
+
+	if(atomic_read(&core->state) < TX_ISP_STATE_START){
+		v4l2_err(v4l2_dev, "%s[%d] please enable video-in device firstly.\n",
+				__func__,__LINE__);
+		return -EPERM;
+	}
+	/* printk("%s[%d] ctrl->id = 0x%08x\n", __func__, __LINE__, ctrl->id); */
+	ret = apical_isp_core_ops_g_ctrl(core, ctrl);
+	return ret;
+}
+
+int isp_core_ops_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(sd);
+	struct v4l2_device *v4l2_dev = core->sd.v4l2_dev;
+	int ret = ISP_SUCCESS;
+
+	if(atomic_read(&core->state) < TX_ISP_STATE_START){
+		v4l2_err(v4l2_dev, "%s[%d] please enable video-in device firstly.\n",
+				__func__,__LINE__);
+		return -EPERM;
+	}
+	ret = apical_isp_core_ops_s_ctrl(core, ctrl);
+	return ret;
+}
+
+
+/*
+* the video_device_ops
+* its function is that setting these attributions of isp modules.
+*/
+
+static long image_tuning_vidioc_default(struct file *file, void *fh, bool valid_prio, unsigned int cmd, void *arg)
+{
+	image_tuning_vdrv_t *tuning = video_drvdata(file);
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(tuning->parent);
+	struct isp_image_tuning_default_ctrl *ctrl;
+	long ret = ISP_SUCCESS;
+
+	/* ISP must be runing */
+	if(atomic_read(&core->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+
+	/* the file must be opened firstly. */
+	if(atomic_read(&tuning->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+
+	ctrl = (struct isp_image_tuning_default_ctrl *)arg;
+	switch(cmd){
+		case VIDIOC_DEFAULT_CMD_ISP_TUNING:
+			if(ctrl->dir == TX_ISP_PRIVATE_IOCTL_SET)
+				ret = v4l2_subdev_call(tuning->parent, core, s_ctrl, &ctrl->control);
+			else
+				ret = v4l2_subdev_call(tuning->parent, core, g_ctrl, &ctrl->control);
+			break;
+		default :
+			ret = -EPERM;
+			break;
+	}
+	return ret;
+}
+
+/* --- controls ---------------------------------------------- */
+
+static inline int image_tuning_set_wb_ctrl(image_tuning_vdrv_t *tuning, struct v4l2_ctrl *ctrl)
+{
+	struct image_tuning_ctrls *ctrls = &tuning->ctrls;
+	struct v4l2_ctrl *aefwb_lock = ctrls->aefwb_lock;
+	struct v4l2_control control;
+
+	if(aefwb_lock->cur.val & V4L2_LOCK_WHITE_BALANCE){
+		return -EPERM;
+	}
+
+	control.id = ctrl->id;
+	return v4l2_subdev_call(tuning->parent, core, s_ctrl, &control);
+}
+
+static inline int image_tuning_set_ae_ctrl(image_tuning_vdrv_t *tuning, struct v4l2_ctrl *ctrl)
+{
+	struct image_tuning_ctrls *ctrls = &tuning->ctrls;
+	struct v4l2_ctrl *aefwb_lock = ctrls->aefwb_lock;
+	struct v4l2_control control;
+
+	if(aefwb_lock->cur.val & V4L2_LOCK_EXPOSURE){
+		return -EPERM;
+	}
+
+	control.id = ctrl->id;
+	return v4l2_subdev_call(tuning->parent, core, s_ctrl, &control);
+}
+
+static inline int image_tuning_set_af_ctrl(image_tuning_vdrv_t *tuning, struct v4l2_ctrl *ctrl)
+{
+	struct image_tuning_ctrls *ctrls = &tuning->ctrls;
+	struct v4l2_ctrl *aefwb_lock = ctrls->aefwb_lock;
+	struct v4l2_control control;
+
+	if(aefwb_lock->cur.val & V4L2_LOCK_FOCUS){
+		return -EPERM;
+	}
+
+	control.id = ctrl->id;
+	return v4l2_subdev_call(tuning->parent, core, s_ctrl, &control);
+}
+
+static int image_tuning_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	image_tuning_vdrv_t *tuning = ctrl_to_image_tuning(ctrl);
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(tuning->parent);
+	//	struct image_tuning_ctrls *ctrls = &tuning->ctrls;
+	struct v4l2_control control;
+
+	/* ISP must be runing */
+	if(atomic_read(&core->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+	/* the file must be opened firstly. */
+	if(atomic_read(&tuning->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+
+	//	printk("*** %s[%d] tuning = %p  id = 0x%08x ***\n", __func__,__LINE__, tuning, ctrl->id);
+	control.id = ctrl->id;
+	switch (ctrl->id) {
+		case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		case IMAGE_TUNING_CID_CUSTOM_AF_MODE:
+			v4l2_subdev_call(tuning->parent, core, g_ctrl, &control);
+			break;
+		default:
+			break;
+	}
+
+	return 0;
+}
+
+static int image_tuning_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	image_tuning_vdrv_t *tuning = ctrl_to_image_tuning(ctrl);
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(tuning->parent);
+	struct v4l2_control control;
+	int ret = ISP_SUCCESS;
+
+	/* ISP must be runing */
+	if(atomic_read(&core->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+	/* the file must be opened firstly. */
+	if(atomic_read(&tuning->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+	switch (ctrl->id) {
+		case V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE:
+			ret = image_tuning_set_wb_ctrl(tuning, ctrl);
+			break;
+		case V4L2_CID_EXPOSURE_AUTO:
+			ret = image_tuning_set_ae_ctrl(tuning, ctrl);
+			break;
+		case IMAGE_TUNING_CID_CUSTOM_AF_MODE:
+			ret = image_tuning_set_af_ctrl(tuning, ctrl);
+			break;
+		default:
+			control.id = ctrl->id;
+			control.value = (int)ctrl;
+			ret = v4l2_subdev_call(tuning->parent, core, s_ctrl, &control);
+			break;
+	}
+	return ret;
+}
+
+/* ------------------------------------------------------------------
+   File operations for the device
+   ------------------------------------------------------------------*/
+
+static const struct v4l2_ctrl_ops image_tuning_ctrl_ops = {
+	.g_volatile_ctrl = image_tuning_g_volatile_ctrl,
+	.s_ctrl = image_tuning_s_ctrl,
+};
+
+static const struct v4l2_ctrl_config ae_gain_ctrl_int32 = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_AE_GAIN,
+	.name = "The gain of AE",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0x0,
+	.max = 0x0000ffff,
+	.step = 1,
+	.def = 1 << 8,
+};
+
+static const struct v4l2_ctrl_config ae_compensation_ctrl_int32 = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_AE_COMP,
+	.name = "The compensation of AE",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 0x0,
+	.max = 0x000000ff,
+	.step = 1,
+	.def = 128,
+};
+
+static const char * const af_mode_menu_strings[] = {
+	"AF auto single",
+	"AF auto continuous",
+	"AF auto single macro",
+	"AF auto continuous macro",
+	"AF hyper focal",
+	"AF infinity",
+	"AF abort",
+	NULL,
+};
+
+static const struct v4l2_ctrl_config af_mode_ctrl_menu = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_AF_MODE,
+	.name = "AF mode",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = 6,
+	.def = 0,
+	.menu_skip_mask = ~0x7f,
+	.qmenu = af_mode_menu_strings,
+};
+
+static const char * const test_pattern_menu_strings[] = {
+	"disable",
+	"flat field",
+	"horizontal gradient",
+	"vertical gradient",
+	"vertical bar",
+	NULL,
+};
+
+static const struct v4l2_ctrl_config test_pattern_ctrl_menu = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_TEST_PATTERN,
+	.name = "Test pattern",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = 4,
+	.def = 0,
+	.menu_skip_mask = ~0x1f,
+	.qmenu = test_pattern_menu_strings,
+};
+
+static const char * const fog_menu_strings[] = {
+	"antifog disable",
+	"antifog strong",
+	"antifog medium",
+	"antifog weak",
+	NULL,
+};
+
+static const struct v4l2_ctrl_config fog_ctrl_menu = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_ANTI_FOG,
+	.name = "Anti fog",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = 3,
+	.def = 0,
+	.menu_skip_mask = ~0xf,
+	.qmenu = fog_menu_strings,
+};
+
+static const struct v4l2_ctrl_config ispprocess_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_ISP_PROCESS,
+	.name = "ISP Process",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config ispfreeze_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_ISP_FREEZE,
+	.name = "Freeze FW",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config blacklevel_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_BL,
+	.name = "Black level",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config shading_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_SHAD,
+	.name = "Lens shading",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config ddp_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_DYNAMIC_DP,
+	.name = "Dynamic Defect pixels",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config sdp_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_STATIC_DP,
+	.name = "Static Defect pixels",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+
+static const struct v4l2_ctrl_config sinter_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_SINTER_DNS,
+	.name = "Sinter denoise",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config ge_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_GE,
+	.name = "Green Equalist",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 1,
+};
+
+static const struct v4l2_ctrl_config wdr_lut_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_WDR_FLT,
+	.name = "WDR Companded frontend LUT",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 0,
+};
+
+static const struct v4l2_ctrl_config wdr_ctrl_bool = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_WDR,
+	.name = "Wide Dynamic Range",
+	.type = V4L2_CTRL_TYPE_BOOLEAN,
+	.min = 0,
+	.max = 1,
+	.step = 1,
+	.def = 0,
+};
+
+static const char * const temper_menu_strings[] = {
+	"Disable Temper",
+	"Auto Temper",
+	"Manual set the strength of Temper",
+	NULL,
+};
+
+static const struct v4l2_ctrl_config temper_ctrl_menu = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_TEMPER_DNS,
+	.name = "Temper denoise",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = 2,
+	.def = 1,
+	.menu_skip_mask = ~0x7,
+	.qmenu = temper_menu_strings,
+};
+
+static const char * const drc_menu_strings[] = {
+	"Manual set the strength of DRC",
+	"Unlimit",
+	"High",
+	"Medium",
+	"Low",
+	"Disable DRC",
+	NULL,
+};
+
+static const struct v4l2_ctrl_config drc_ctrl_menu = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_DRC,
+	.name = "RAW Dynamic range compression",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = 5,
+	.def = 3,
+	.menu_skip_mask = ~0x3f,
+	.qmenu = drc_menu_strings,
+};
+
+static const char * const resolution_menu_strings[] = {
+	"Full resolution, fps max",
+	"Preview resolution, fps max",
+	NULL,
+};
+
+static const struct v4l2_ctrl_config resolution_ctrl_menu = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_RESOLUTION,
+	.name = "sensor resolution",
+	.type = V4L2_CTRL_TYPE_MENU,
+	.min = 0,
+	.max = 2,
+	.def = 0,
+	.menu_skip_mask = ~0x3,
+	.qmenu = resolution_menu_strings,
+};
+
+static const s64 fps_ctrl_int_menu_values[] = {
+	25, 30,
+};
+
+static const struct v4l2_ctrl_config fps_ctrl_int32 = {
+	.ops = &image_tuning_ctrl_ops,
+	.id = IMAGE_TUNING_CID_CUSTOM_FPS,
+	.name = "Tun FPS",
+	.type = V4L2_CTRL_TYPE_INTEGER,
+	.min = 5,
+	.max = 30,
+	.step = 1,
+	.def = 25,
+};
+
+
+static const struct v4l2_ioctl_ops image_tuning_v4l2_ioctl_ops = {
+	/* Priority handling */
+	//	.vidioc_s_priority		= image_tuning_vidioc_s_priority,
+	//	.vidioc_g_priority		= image_tuning_vidioc_g_priority,
+	/* For other private ioctls */
+	.vidioc_default			= image_tuning_vidioc_default,
+};
+
+static int image_tuning_v4l2_open(struct file *file)
+{
+	image_tuning_vdrv_t *tuning = video_drvdata(file);
+	struct tx_isp_core_device *core = sd_to_tx_isp_core_device(tuning->parent);
+	struct tx_isp_video_in *vin = &core->vin;
+	int ret = ISP_SUCCESS;
+	printk("###### %s %d #######\n",__func__,__LINE__);
+	/* ISP must be runing */
+	if(atomic_read(&core->state) < TX_ISP_STATE_START){
+		return -EPERM;
+	}
+
+	if(atomic_read(&tuning->state) != TX_ISP_STATE_STOP){
+		return -EBUSY;
+	}
+	tuning->wdr_buffer_size = vin->vi_max_width * vin->vi_max_height * 4;
+	tuning->temper_buffer_size = vin->vi_max_width * vin->vi_max_height * 4;
+
+	if(tuning->temper_buffer_size <= ispmem_size && ispmem_base != -1){
+		tuning->temper_paddr = ispmem_base;
+		/* config temper dma */
+		apical_isp_temper_frame_buffer_bank0_base_write(tuning->temper_paddr);
+		apical_isp_temper_frame_buffer_bank1_base_write(tuning->temper_paddr);
+		/* apical_isp_temper_frame_buffer_bank1_base_write(tuning->temper_paddr + (tuning->temper_buffer_size)); */
+		apical_isp_temper_frame_buffer_frame_write_cancel_write(0);
+		apical_isp_temper_frame_buffer_frame_read_cancel_write(0);
+		apical_isp_temper_frame_buffer_frame_write_on_write(1);
+		apical_isp_temper_frame_buffer_frame_read_on_write(1);
+	}else{
+		tuning->temper_paddr = 0;
+		tuning->temper_buffer_size = 0;
+	}
+
+	if(tuning->wdr_buffer_size <= (ispmem_size - tuning->temper_buffer_size) && ispmem_base != -1){
+		tuning->wdr_paddr = ispmem_base + tuning->wdr_buffer_size;
+		/*config WDR dma */
+		apical_isp_frame_stitch_frame_buffer_bank0_base_write(tuning->wdr_paddr);
+		apical_isp_frame_stitch_frame_buffer_bank1_base_write(tuning->wdr_paddr);
+	//	apical_isp_frame_stitch_frame_buffer_bank1_base_write(tuning->wdr_paddr + (tuning->wdr_buffer_size >> 1));
+	}else{
+		tuning->wdr_paddr = 0;
+		tuning->wdr_buffer_size = 0;
+	}
+
+	file->private_data = &tuning->fh;
+	//	fh->prio = V4L2_PRIORITY_DEFAULT;
+	//	v4l2_prio_open(&camdev->prio, &tuning->fh.prio);
+
+	atomic_set(&tuning->state, TX_ISP_STATE_START);
+	/* update isp config from bin file */
+	v4l2_ctrl_handler_setup(&tuning->ctrls.handler);
+	{
+		TXispPrivParamManage *param = core->param;
+		if (NULL != param) {
+			tuning->ctrls.daynight = ISP_CORE_RUNING_MODE_DAY_MODE;
+			core->isp_daynight_switch = 1;
+		}
+	}
+	frame_done_cnt = 0;
+	return ret;
+}
+
+static int image_tuning_v4l2_close(struct file *file)
+{
+	image_tuning_vdrv_t *tuning = video_drvdata(file);
+
+	if(atomic_read(&tuning->state) != TX_ISP_STATE_START){
+		return 0;
+	}
+
+	atomic_set(&tuning->state, TX_ISP_STATE_STOP);
+	//	v4l2_prio_close(&camdev->prio, tuning->fh.prio);
+	return 0;
+}
+
+static struct v4l2_file_operations image_tuning_v4l2_fops = {
+	.owner 		= THIS_MODULE,
+	.open 		= image_tuning_v4l2_open,
+	.release 	= image_tuning_v4l2_close,
+	.unlocked_ioctl	= video_ioctl2,
+};
+
+static struct video_device image_tuning_vdev = {
+	.name = "isp image_tuning",
+	.minor = -1,
+	.release = video_device_release,
+	.fops = &image_tuning_v4l2_fops,
+	.ioctl_ops = &image_tuning_v4l2_ioctl_ops,
+};
+
+struct video_device *tx_isp_image_tuning_device_register(struct v4l2_subdev *parent)
+{
+	struct v4l2_device *v4l2_dev;
+	image_tuning_vdrv_t *tuning = NULL;
+	struct video_device *vfd = NULL;
+	struct image_tuning_ctrls *ctrls;
+	struct v4l2_ctrl_handler *handler;
+	const struct v4l2_ctrl_ops *ops = &image_tuning_ctrl_ops;
+	int ret = ISP_SUCCESS;
+
+	if(!parent || !parent->v4l2_dev){
+		return NULL;
+	}
+
+	v4l2_dev = parent->v4l2_dev;
+	tuning = (image_tuning_vdrv_t *)kzalloc(sizeof(*tuning), GFP_KERNEL);
+	if(!tuning){
+		v4l2_err(v4l2_dev,"Failed to allocate isp image tuning device\n");
+		return NULL;
+	}
+	memset(tuning, 0, sizeof(*tuning));
+
+	vfd = video_device_alloc();
+	if (!vfd) {
+		v4l2_err(v4l2_dev,"Failed to allocate video device\n");
+		goto failed_video_alloc;
+	}
+	tuning->parent = parent;
+	spin_lock_init(&tuning->slock);
+	mutex_init(&tuning->mlock);
+
+	ctrls = &tuning->ctrls;
+	handler = &ctrls->handler;
+	v4l2_ctrl_handler_init(handler, 38);
+
+	ctrls->wb_mode = v4l2_ctrl_new_std_menu(handler, ops,
+			V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE,
+			9, ~0x37f, V4L2_WHITE_BALANCE_AUTO);
+
+	ctrls->wb_temperature = v4l2_ctrl_new_std(handler, ops, V4L2_CID_WHITE_BALANCE_TEMPERATURE,
+			0, 25500, 100, 0);
+	ctrls->wb_temperature->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	ctrls->exp_mode = v4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_EXPOSURE_AUTO, 3,
+			~0x3, V4L2_EXPOSURE_AUTO);
+
+	ctrls->manual_exp = v4l2_ctrl_new_std(handler, ops, V4L2_CID_EXPOSURE_ABSOLUTE,
+			0, 0x0fffffff, 1, 1);
+
+	ctrls->exp_gain = v4l2_ctrl_new_custom(handler, &ae_gain_ctrl_int32, NULL);
+	ctrls->exp_compensation = v4l2_ctrl_new_custom(handler, &ae_compensation_ctrl_int32, NULL);
+	ctrls->af_mode = v4l2_ctrl_new_custom(handler, &af_mode_ctrl_menu, NULL);
+
+	ctrls->af_status = v4l2_ctrl_new_std(handler, ops, V4L2_CID_AUTO_FOCUS_STATUS,
+			0, 0x7, 0, 0);
+	ctrls->af_status->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	ctrls->hflip = v4l2_ctrl_new_std(handler, ops, V4L2_CID_HFLIP,
+			0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(handler, ops, V4L2_CID_VFLIP,
+			0, 1, 1, 0);
+
+	ctrls->dis = v4l2_ctrl_new_std(handler, ops, V4L2_CID_IMAGE_STABILIZATION,
+			0, 1, 1, 0);
+
+	ctrls->flicker = v4l2_ctrl_new_std_menu(handler, ops,
+			V4L2_CID_POWER_LINE_FREQUENCY, 3,
+			~0x7, V4L2_CID_POWER_LINE_FREQUENCY_DISABLED);
+
+	/* Add support for NIGHT_PORTRAIT option */
+	ctrls->scene = v4l2_ctrl_new_std_menu(handler, ops,
+			V4L2_CID_SCENE_MODE, V4L2_SCENE_MODE_TEXT + 1,
+			~0x7bfd, V4L2_SCENE_MODE_NONE);
+
+	ctrls->colorfx = v4l2_ctrl_new_std_menu(handler, ops, V4L2_CID_COLORFX,
+						V4L2_COLORFX_SET_CBCR, ~0x20f, V4L2_COLORFX_NONE);
+
+	ctrls->saturation = v4l2_ctrl_new_std(handler, ops, V4L2_CID_SATURATION,
+			0, 0x7fffffff, 1, 128);
+	ctrls->brightness = v4l2_ctrl_new_std(handler, ops, V4L2_CID_BRIGHTNESS,
+			0, 0x7fffffff, 1, 128);
+	ctrls->contrast = v4l2_ctrl_new_std(handler, ops, V4L2_CID_CONTRAST,
+			0, 0x7fffffff, 1, 128);
+
+	ctrls->sharpness = v4l2_ctrl_new_std(handler, ops, V4L2_CID_SHARPNESS,
+			0, 0x7fffffff, 1, 128);
+
+	ctrls->aefwb_lock = v4l2_ctrl_new_std(handler, ops,
+			V4L2_CID_3A_LOCK, 0, 0x7, 0, 0);
+
+	/* init the ctrls of isp modules */
+	ctrls->sinter = v4l2_ctrl_new_custom(handler, &sinter_ctrl_bool, NULL);
+	ctrls->fog = v4l2_ctrl_new_custom(handler, &fog_ctrl_menu, NULL);
+	ctrls->isp_process = v4l2_ctrl_new_custom(handler, &ispprocess_ctrl_bool, NULL);
+	ctrls->freeze_fw = v4l2_ctrl_new_custom(handler, &ispfreeze_ctrl_bool, NULL);
+	ctrls->black_level = v4l2_ctrl_new_custom(handler, &blacklevel_ctrl_bool, NULL);
+	ctrls->lens_shad = v4l2_ctrl_new_custom(handler, &shading_ctrl_bool, NULL);
+	ctrls->static_dp = v4l2_ctrl_new_custom(handler, &sdp_ctrl_bool, NULL);
+	ctrls->dynamic_dp = v4l2_ctrl_new_custom(handler, &ddp_ctrl_bool, NULL);
+	ctrls->green_eq = v4l2_ctrl_new_custom(handler, &ge_ctrl_bool, NULL);
+	ctrls->raw_drc = v4l2_ctrl_new_custom(handler, &drc_ctrl_menu, NULL);
+	ctrls->test_pattern = v4l2_ctrl_new_custom(handler, &test_pattern_ctrl_menu, NULL);
+
+	ctrls->resolution = v4l2_ctrl_new_custom(handler, &resolution_ctrl_menu, NULL);
+	ctrls->temper = v4l2_ctrl_new_custom(handler, &temper_ctrl_menu, NULL);
+	ctrls->wdr_lut = v4l2_ctrl_new_custom(handler, &wdr_lut_ctrl_bool, NULL);
+	ctrls->wdr = v4l2_ctrl_new_custom(handler, &wdr_ctrl_bool, NULL);
+
+
+//	ctrls->fps = v4l2_ctrl_new_custom(handler, &fps_ctrl_int32, NULL);
+	if (handler->error) {
+		goto handler_error;
+	}
+
+	v4l2_ctrl_auto_cluster(2, &ctrls->wb_mode,
+			V4L2_WHITE_BALANCE_MANUAL, false);
+
+	v4l2_ctrl_auto_cluster(4, &ctrls->exp_mode,
+			V4L2_EXPOSURE_MANUAL, true);
+
+	v4l2_ctrl_cluster(2, &ctrls->af_mode);
+
+	v4l2_ctrl_cluster(2, &ctrls->dynamic_dp);
+
+	memcpy(vfd, &image_tuning_vdev, sizeof(image_tuning_vdev));
+	vfd->lock = &tuning->mlock;
+	vfd->v4l2_dev = v4l2_dev;
+	/* vfd->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG; */
+	vfd->ctrl_handler = handler;
+
+	set_bit(V4L2_FL_USE_FH_PRIO, &(vfd->flags)); // add lately
+
+	tuning->video = vfd;
+
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, -1);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev,"Failed to register video device\n");
+		goto failed_register;
+	}
+
+	video_set_drvdata(vfd, tuning);
+
+	atomic_set(&tuning->state, TX_ISP_STATE_STOP);
+	return vfd;
+
+failed_register:
+	v4l2_ctrl_handler_free(handler);
+handler_error:
+	video_device_release(vfd);
+failed_video_alloc:
+	kfree(tuning);
+	return NULL;
+}
+void tx_isp_image_tuning_device_release(struct video_device *vfd)
+{
+	v4l2_ctrl_handler_free(vfd->ctrl_handler);
+	video_unregister_device(vfd);
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-core-tuning.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,831 @@
+#ifndef __TX_ISP_CORE_TUNING_H__
+#define __TX_ISP_CORE_TUNING_H__
+
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-ctrls.h>
+#include <tx-isp-common.h>
+#include "tx-isp-core.h"
+
+#define	WEIGHT_ZONE_NUM (15*15)
+#define	ZONE_H_NUM (15)
+#define	ZONE_V_NUM (15)
+
+typedef enum isp_core_module_ops_mode {
+	ISPCORE_MODULE_DISABLE,
+	ISPCORE_MODULE_ENABLE,
+	ISPCORE_MODULE_BUTT,			/**<  */
+} ISPMODULE_OPS_MODE_E;
+
+typedef enum isp_core_module_ops_type {
+	ISPCORE_MODULE_AUTO,
+	ISPCORE_MODULE_MANUAL,
+} ISPMODULE_OPS_TYPE_E;
+/*
+ * select which zones are used to gather isp's statistics.
+ * the region of interest is defined as rectangle with top-left coordinates(startx, starty)
+ * and bottom-right coordinates(endx, endy).
+ */
+union isp_core_zone_select{
+	struct {
+		unsigned int startx :8;
+		unsigned int starty :8;
+		unsigned int endx   :8;
+		unsigned int endy   :8;
+	};
+	unsigned int val;
+};
+
+struct isp_core_awb_attr{
+	union isp_core_zone_select zone_sel;
+	unsigned short low_color_temp;
+	unsigned short high_color_temp;
+	unsigned char weight[WEIGHT_ZONE_NUM];
+};
+
+struct isp_core_mwb_attr{
+	unsigned short red_gain;
+	unsigned short blue_gain;
+};
+
+struct isp_core_wb_zone_info{
+	unsigned short red_green;
+	unsigned short blue_green;
+	unsigned int sum;
+};
+
+typedef enum isp_core_wb_statistic_mode {
+	ISPCORE_WB_STA_GR_GB,
+	ISPCORE_WB_STA_RG_BG,
+} ISPCORE_WB_STA_MODE_E;
+
+struct isp_core_wb_statistic_info{
+	ISPCORE_WB_STA_MODE_E sta_mode;
+	unsigned short gr_gain;
+	unsigned short gb_gain;
+	unsigned short awb_sum;
+	unsigned short cb_max;
+	unsigned short cb_min;
+	unsigned short cr_max;
+	unsigned short cr_min;
+	unsigned short white_level;
+	unsigned short black_level;
+	struct isp_core_wb_zone_info zonesta[WEIGHT_ZONE_NUM];
+};
+
+struct isp_core_ae_attr {
+	unsigned short gain;
+	unsigned short comp;
+	unsigned char exp_hist_thresh[4];
+	union isp_core_zone_select zone_sel;
+	unsigned char weight[WEIGHT_ZONE_NUM];
+};
+
+struct isp_core_ae_statistic_info {
+	unsigned char exp_statistic[WEIGHT_ZONE_NUM][5];
+	unsigned char exp_hist_256value[256];
+	unsigned char exp_hist_5value[5];
+	unsigned char ave_lum;
+};
+
+struct isp_core_af_attr {
+	unsigned short af_threshold;
+	unsigned short af_threshold_alt;
+	unsigned char af_metrics_shift;
+	unsigned char  af_low_range;
+	unsigned char  af_high_range;
+	unsigned char  af_intensity_mode;
+	unsigned char  af_np_offset;
+	union isp_core_zone_select zone_sel;
+};
+
+struct isp_core_af_statistic_info {
+	unsigned short af_metrics;
+	unsigned short af_metrics_alt;
+	unsigned short af_threshold;
+	unsigned short af_intensity;
+	unsigned short af_intensity_zone;
+	unsigned char  af_intensity_mode;
+	unsigned char  af_np_offset;
+};
+
+/* the rule of elements is rr, rg, rb, gr, gg, gb, br, bg, bb */
+struct isp_core_ccm_attr {
+	unsigned short high_ccm_linear[9];
+	unsigned short middle_ccm_linear[9];
+	unsigned short low_ccm_linear[9];
+	unsigned short high_ccm_hdr[9];
+	unsigned short middle_ccm_hdr[9];
+	unsigned short low_ccm_hdr[9];
+};
+
+typedef struct isp_core_ccm_saturation_attr {
+	unsigned char targer_sat;
+	unsigned char sat_linear[8];
+	unsigned char sat_hdr[8];
+} ISPCORE_CCM_SAT_S;
+
+/* demosaic module */
+struct isp_core_false_color_attr {
+	unsigned char strength;
+	unsigned char alias_strength;
+	unsigned char alias_thresh;
+};
+
+typedef enum imp_isp_tuning_modules_ops_mode {
+	IMPISP_TUNING_OPS_MODE_DISABLE,			/**<  */
+	IMPISP_TUNING_OPS_MODE_ENABLE,			/**<  */
+	IMPISP_TUNING_OPS_MODE_BUTT,			/**<  */
+} IMPISP_TUNING_OPS_MODE_E;
+
+struct isp_core_sharpness_attr {
+#if 1
+	IMPISP_TUNING_OPS_MODE_E enable;
+	unsigned char target_sharp;
+	unsigned char sharp_d[4];
+	unsigned char sharp_ud[4];
+#else
+	unsigned char demo_strength_d;
+	unsigned char demo_strength_ud;
+	unsigned short demo_threshold;
+	unsigned char fr_enable;
+	unsigned char fr_strength;
+	unsigned char ds1_enable;
+	unsigned char ds1_strength;
+	unsigned char ds2_enable;
+	unsigned char ds2_strength;
+#endif
+};
+
+struct isp_core_demosaic_attr {
+	unsigned char vh_slope;
+	unsigned char aa_slope;
+	unsigned char va_slope;
+	unsigned char uu_slope;
+	unsigned char sat_slope;
+	unsigned char dmsc_config;
+	unsigned short vh_thresh;
+	unsigned short aa_thresh;
+	unsigned short va_thresh;
+	unsigned short uu_thresh;
+	unsigned short sat_thresh;
+	unsigned short vh_offset;
+	unsigned short aa_offset;
+	unsigned short va_offset;
+	unsigned short uu_offset;
+	unsigned short sat_offset;
+};
+
+
+#define ISP_RAW_GAMMA_FE0_SIZE 33
+#define ISP_RAW_GAMMA_FE1_SIZE 257
+typedef struct isp_core_raw_gamma_attr {
+	ISPMODULE_OPS_MODE_E mode;
+	unsigned short gamma_fe_0[ISP_RAW_GAMMA_FE0_SIZE];
+	unsigned short gamma_fe_1[ISP_RAW_GAMMA_FE1_SIZE];
+} ISPCORE_RAW_GAMMA_ATTR_S;
+
+
+#define ISP_RGB_GAMMA_SIZE 129
+typedef struct isp_core_rgb_gamma_attr {
+	ISPMODULE_OPS_MODE_E mode;
+	unsigned short gamma_linear[ISP_RGB_GAMMA_SIZE];
+	unsigned short gamma_hdr[ISP_RGB_GAMMA_SIZE];
+} ISPCORE_RGB_GAMMMA_ATTR_S;
+
+typedef enum {
+	ISPMODULE_DRC_MANUAL,
+	ISPMODULE_DRC_UNLIMIT,
+	ISPMODULE_DRC_HIGH,
+	ISPMODULE_DRC_MEDIUM,
+	ISPMODULE_DRC_LOW,
+	ISPMODULE_DRC_DISABLE,
+} ISPMODULE_DRC_MODE;
+
+/* iridix */
+struct isp_core_drc_attr {
+	ISPMODULE_DRC_MODE mode;
+	unsigned char strength;
+	unsigned char slope_max;
+	unsigned char slope_min;
+	unsigned short black_level;
+	unsigned short white_level;
+};
+
+enum isp_core_mesh_shading_scale {
+	ISP_MESH_SHADING_0_2 = 0x00,
+	ISP_MESH_SHADING_0_4,
+	ISP_MESH_SHADING_0_8,
+	ISP_MESH_SHADING_0_16,
+	ISP_MESH_SHADING_1_2,
+	ISP_MESH_SHADING_1_3,
+	ISP_MESH_SHADING_1_5,
+	ISP_MESH_SHADING_1_9,
+	ISP_MESH_SHADING_BUTT,
+};
+
+enum isp_core_mesh_shading_tab_format {
+	ISP_MESH_SHADING_TAB_1 = 0x00,
+	ISP_MESH_SHADING_TAB_2,
+	ISP_MESH_SHADING_TAB_4,
+	ISP_MESH_SHADING_TAB_BUTT,
+};
+
+typedef enum isp_core_shading_page_index {
+	ISPCORE_SHADING_PAGE_0,
+	ISPCORE_SHADING_PAGE_1,
+	ISPCORE_SHADING_PAGE_2,
+} ISPCORE_SHADING_PAGE_INDEX_E;
+
+union isp_core_mesh_shading_tab {
+	unsigned char mesh_tab_1[64*64];
+	struct mesh_table_2 {
+		unsigned char ls0;
+		unsigned char ls1;
+	} tab_2[32*64];
+	struct mesh_table_4 {
+		unsigned char ls0;
+		unsigned char ls1;
+		unsigned char ls2;
+		unsigned char ls3;
+	} tab_3[32*32];
+	unsigned int regs[1024];
+};
+
+enum isp_core_mesh_sources_blend {
+	/* enum = LBa and LBb */
+	ISP_MESH_S_LS0_LS1,
+	ISP_MESH_S_LS1_LS2,
+	ISP_MESH_S_LS2_LS3,
+	ISP_MESH_S_LS3_LS0,
+	ISP_MESH_S_LS0_LS2,
+	ISP_MESH_S_LS1_LS3,
+};
+/*
+@ mesh_scale :select format of coefficient
+@ mesh_page_x :select page of mesh tables
+@ mesh_bank_x :select light sources blended
+@ mesh_alpha_bank_x : the alpha of blending different light sources.
+	final blend coefficient = (a * LSb coefficient + (255 - a) * LSa cofficient) / 255
+*/
+struct isp_core_shading_attr {
+	ISPMODULE_OPS_MODE_E mode;
+	enum isp_core_mesh_shading_scale mesh_scale;
+	enum isp_core_mesh_shading_tab_format	mesh_mode;
+	ISPCORE_SHADING_PAGE_INDEX_E r_page;
+	ISPCORE_SHADING_PAGE_INDEX_E g_page;
+	ISPCORE_SHADING_PAGE_INDEX_E b_page;
+	enum isp_core_mesh_sources_blend mesh_alpha_bank_r;
+	enum isp_core_mesh_sources_blend mesh_alpha_bank_g;
+	enum isp_core_mesh_sources_blend mesh_alpha_bank_b;
+	unsigned char mesh_alpha_r;
+	unsigned char mesh_alpha_g;
+	unsigned char mesh_alpha_b;
+	unsigned char update_page;
+	union isp_core_mesh_shading_tab page0;
+	union isp_core_mesh_shading_tab page1;
+	union isp_core_mesh_shading_tab page2;
+};
+
+
+/* green equalization */
+struct isp_core_green_eq_attr {
+	ISPMODULE_OPS_MODE_E mode;
+	unsigned char strength;
+	unsigned char threshold;
+	unsigned char slope;
+	unsigned char sensitivity;
+};
+
+struct isp_core_dynamic_defect_pixel_attr {
+	ISPMODULE_OPS_MODE_E mode;
+	ISPMODULE_OPS_MODE_E dark_pixels;
+	ISPMODULE_OPS_MODE_E bright_pixels;
+	unsigned char d_threshold;
+	unsigned char d_slope;
+	unsigned short hpdev_thresh;
+	unsigned short line_thresh;
+	unsigned char hp_blend;
+};
+
+struct isp_core_static_defect_pixel_attr {
+	ISPMODULE_OPS_MODE_E mode;
+#if 0
+	unsigned char show_reference;
+	unsigned char show_defect_pixels;
+	unsigned char detect_trigger;
+	unsigned char threshold;
+	unsigned char slope;
+	unsigned short bad_pixel_count;
+	unsigned int bad_pixel_table[1024];
+#endif
+};
+
+struct isp_core_sinter_attr{
+	ISPMODULE_OPS_MODE_E mode;
+	ISPMODULE_OPS_TYPE_E type;
+#if 1
+	unsigned char manual_strength;
+#else
+	unsigned char thresh_short;
+	unsigned char thresh_long;
+	unsigned char v_thresh[2];
+	unsigned char h_thresh[2];
+	unsigned char strength[2];
+	unsigned char rm_enable;
+	unsigned short rm_center_x;
+	unsigned short rm_center_y;
+	unsigned short rm_center_mult;
+#endif
+};
+
+typedef enum isp_core_temper_mode_enum{
+	ISPCORE_TEMPER_MODE_DISABLE,
+	ISPCORE_TEMPER_MODE_AUTO,
+	ISPCORE_TEMPER_MODE_MANUAL,
+} ISP_CORE_TEMPER_MODE;
+
+struct isp_core_temper_attr{
+	/* ISP_CORE_TEMPER_MODE mode; */
+#if 1
+	unsigned char manual_strength;
+#else
+	unsigned char thresh_short;
+	unsigned char thresh_long;
+	unsigned char recursion;
+#endif
+};
+
+struct isp_core_wdr_attr {
+	unsigned char stitch_correct;
+	unsigned short short_thresh;
+	unsigned short long_thresh;
+	unsigned short exp_ratio;
+	unsigned short stitch_err_thresh;
+	unsigned short stitch_err_limit;
+	unsigned short black_level_long;
+	unsigned short black_level_short;
+	unsigned short black_level_out;
+};
+
+/* noise profile raw fronted */
+#define ISPCORE_NOISE_PROFILE_SIZE 128
+struct isp_core_noise_profile_attr{
+	unsigned short exp_thresh;
+	unsigned char short_ratio;
+	unsigned char long_ratio;
+	unsigned char noise_profile_offet;
+	unsigned char noise_profile_reflect;
+	unsigned char noise_pfile_linear[ISPCORE_NOISE_PROFILE_SIZE];
+	unsigned char noise_pfile_hdr[ISPCORE_NOISE_PROFILE_SIZE];
+};
+
+struct isp_core_gamma_attr{
+	unsigned short gamma[129];
+};
+
+struct isp_core_weight_attr{
+	unsigned char weight[15][15];
+};
+
+struct isp_core_ae_sta_info{
+	unsigned char ae_histhresh[4];
+	unsigned short ae_hist[5];
+	unsigned char ae_stat_nodeh;
+	unsigned char ae_stat_nodev;
+};
+
+struct awb_sta_info{
+	unsigned short r_gain;
+	unsigned short b_gain;
+	unsigned int awb_sum;
+};
+
+enum awb_stats_mode{
+	ISPCORE_AWB_STATS_LEGACY_MODE = 0,    /**<  */
+	ISPCORE_AWB_STATS_CURRENT_MODE = 1,    /**<  */
+	ISPCORE_AWB_STATS_MODE_BUTT,
+};
+
+struct isp_core_awb_sta_info{
+	struct awb_sta_info awb_stat;
+	enum awb_stats_mode awb_stats_mode;
+	unsigned short awb_whitelevel;
+	unsigned short awb_blacklevel;
+	unsigned short cr_ref_max;
+	unsigned short cr_ref_min;
+	unsigned short cb_ref_max;
+	unsigned short cb_ref_min;
+	unsigned char awb_stat_nodeh;
+	unsigned char awb_stat_nodev;
+};
+
+struct isp_wb_zone{
+	struct isp_core_wb_zone_info awb_sta_zone[ZONE_H_NUM][ZONE_V_NUM];
+};
+
+struct isp_ae_zone{
+	unsigned short ae_sta_zone[ZONE_H_NUM * ZONE_V_NUM];
+};
+
+struct af_sta_info{
+	unsigned short af_metrics;
+	unsigned short af_metrics_alt;
+	unsigned short af_thresh_read;
+	unsigned short af_intensity_read;
+	unsigned short af_intensity_zone;
+	unsigned int   af_total_pixels;
+	unsigned int   af_counted_pixels;
+};
+
+struct isp_core_af_sta_info{
+	struct af_sta_info af_stat;
+	unsigned char af_metrics_shift;
+	unsigned short af_thresh;
+	unsigned short af_thresh_alt;
+	unsigned char  af_stat_nodeh;
+	unsigned char  af_stat_nodev;
+	unsigned char  af_np_offset;
+	unsigned char  af_intensity_mode;
+	unsigned char  af_skipx;
+	unsigned char  af_offsetx;
+	unsigned char  af_skipy;
+	unsigned char  af_offsety;
+	unsigned char  af_scale_top;
+	unsigned char  af_scale_bottom;
+};
+
+typedef struct _system_tab_ctrl{
+	bool ctrl_global_freeze_firmware ;
+	bool ctrl_global_manual_exposure ;
+	bool ctrl_global_manual_exposure_ratio ;
+	bool ctrl_global_manual_integration_time ;
+	bool ctrl_global_manual_sensor_analog_gain ;
+	bool ctrl_global_manual_sensor_digital_gain ;
+	bool ctrl_global_manual_isp_digital_gain ;
+	bool ctrl_global_manual_directional_sharpening ;
+	bool ctrl_global_manual_un_directional_sharpening ;
+	bool ctrl_global_manual_iridix ;
+	bool ctrl_global_manual_sinter ;
+	bool ctrl_global_manual_temper ;
+	bool ctrl_global_manual_awb ;
+	bool ctrl_global_antiflicker_enable ;
+	bool ctrl_global_slow_frame_rate_enable ;
+	bool ctrl_global_manual_saturation ;
+	bool ctrl_global_manual_exposure_time;
+	bool ctrl_global_exposure_dark_target;
+	bool ctrl_global_exposure_bright_target;
+	bool ctrl_global_exposure_ratio;
+	bool ctrl_global_max_exposure_ratio;
+	bool ctrl_global_integration_time;
+	bool ctrl_global_max_integration_time;
+	bool ctrl_global_sensor_analog_gain;
+	bool ctrl_global_max_sensor_analog_gain;
+	bool ctrl_global_sensor_digital_gain;
+	bool ctrl_global_max_sensor_digital_gain;
+	bool ctrl_global_isp_digital_gain;
+	bool ctrl_global_max_isp_digital_gain;
+	bool ctrl_global_directional_sharpening_target;
+	bool ctrl_global_maximum_directional_sharpening;
+	bool ctrl_global_minimum_directional_sharpening;
+	bool ctrl_global_un_directional_sharpening_target;
+	bool ctrl_global_maximum_un_directional_sharpening;
+	bool ctrl_global_minimum_un_directional_sharpening;
+	bool ctrl_global_iridix_strength_target;
+	bool ctrl_global_maximum_iridix_strength;
+	bool ctrl_global_minimum_iridix_strength;
+	bool ctrl_global_sinter_threshold_target;
+	bool ctrl_global_maximum_sinter_strength;
+	bool ctrl_global_minimum_sinter_strength;
+	bool ctrl_global_temper_threshold_target;
+	bool ctrl_global_maximum_temper_strength;
+	bool ctrl_global_minimum_temper_strength;
+	bool ctrl_global_awb_red_gain;
+	bool ctrl_global_awb_blue_gain;
+	bool ctrl_global_saturation_target;
+	bool ctrl_global_anti_flicker_frequency ;
+	bool ctrl_global_ae_compensation;
+	bool ctrl_global_calibrate_bad_pixels ;
+	bool ctrl_global_dis_x ;
+	bool ctrl_global_dis_y ;
+} system_tab_ctrl;
+
+struct isp_core_stab_attr{
+	system_tab stab;
+	system_tab_ctrl stab_ctrl;
+};
+
+/* expr */
+enum isp_core_expr_mode {
+	ISP_CORE_EXPR_MODE_AUTO,
+	ISP_CORE_EXPR_MODE_MANUAL,
+};
+
+enum isp_core_expr_unit {
+	ISP_CORE_EXPR_UNIT_LINE,
+	ISP_CORE_EXPR_UNIT_US,
+};
+
+union isp_core_expr_attr{
+	struct {
+		enum isp_core_expr_mode mode;
+		enum isp_core_expr_unit unit;
+		unsigned short time;
+	} s_attr;
+	struct {
+		enum isp_core_expr_mode mode;
+		unsigned short integration_time;
+		unsigned short integration_time_min;
+		unsigned short integration_time_max;
+		unsigned short one_line_expr_in_us;
+	} g_attr;
+};
+
+/* awb */
+enum isp_core_wb_mode {
+	ISP_CORE_WB_MODE_AUTO = 0,
+	ISP_CORE_WB_MODE_MANUAL,
+	ISP_CORE_WB_MODE_DAY_LIGHT,
+	ISP_CORE_WB_MODE_CLOUDY,
+	ISP_CORE_WB_MODE_INCANDESCENT,
+	ISP_CORE_WB_MODE_FLOURESCENT,
+	ISP_CORE_WB_MODE_TWILIGHT,
+	ISP_CORE_WB_MODE_SHADE,
+	ISP_CORE_WB_MODE_WARM_FLOURESCENT,
+};
+
+struct isp_core_wb_attr {
+		enum isp_core_wb_mode mode;
+		unsigned short rgain;
+		unsigned short bgain;
+};
+
+struct isp_core_rgb_coefft_wb_attr {
+		unsigned short rgb_coefft_wb_r;
+		unsigned short rgb_coefft_wb_g;
+		unsigned short rgb_coefft_wb_b;
+};
+
+/* ev */
+struct isp_core_ev_attr {
+	unsigned int ev;
+	unsigned int expr_us;
+	unsigned int ev_log2;
+	unsigned int again;
+	unsigned int dgain;
+	unsigned int gain_log2;
+};
+
+/* mve */
+struct isp_core_dis_statistic_info {
+};
+
+/* the defination of mode of isp during the day or night */
+typedef enum isp_core_mode_day_and_night {
+	ISP_CORE_RUNING_MODE_DAY_MODE,
+	ISP_CORE_RUNING_MODE_NIGHT_MODE,
+	ISP_CORE_RUNING_MODE_BUTT,
+} ISP_CORE_MODE_DN_E;
+
+/* The defination of strategy of AE */
+typedef enum {
+	IMPISP_AE_STRATEGY_SPLIT_BALANCED = 0,
+	IMPISP_AE_STRATEGY_SPLIT_INTEGRATION_PRIORITY = 1,
+	IMPISP_AE_STRATEGY_BUTT,
+} ISP_CORE_AE_STRATEGY_E;
+
+int isp_core_ops_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+int isp_core_ops_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+
+/*
+* it is defined as follows that is v4l2-ctrls.
+*/
+
+/* isp core tuning */
+enum isp_image_tuning_cmd_id {
+	IMAGE_TUNING_CID_CUSTOM_BASE = (V4L2_CID_USER_BASE | 0xe000),
+	IMAGE_TUNING_CID_CUSTOM_AE_GAIN = IMAGE_TUNING_CID_CUSTOM_BASE,
+	IMAGE_TUNING_CID_CUSTOM_AE_COMP,
+	IMAGE_TUNING_CID_CUSTOM_AF_MODE,
+	IMAGE_TUNING_CID_CUSTOM_ANTI_FOG,
+	IMAGE_TUNING_CID_CUSTOM_RESOLUTION,
+	IMAGE_TUNING_CID_CUSTOM_FPS,
+	IMAGE_TUNING_CID_CUSTOM_TEST_PATTERN,		//test pattern
+	IMAGE_TUNING_CID_CUSTOM_ISP_PROCESS, 		//isp process
+	IMAGE_TUNING_CID_CUSTOM_ISP_FREEZE, 		//isp process
+	IMAGE_TUNING_CID_CUSTOM_BL,			//black level
+	IMAGE_TUNING_CID_CUSTOM_SHAD,			//lens shading
+	IMAGE_TUNING_CID_CUSTOM_SINTER_DNS,		//sinter denoise
+	IMAGE_TUNING_CID_CUSTOM_TEMPER_DNS,		//temper denoise
+	IMAGE_TUNING_CID_CUSTOM_DYNAMIC_DP,		//dynamic defect pixels
+	IMAGE_TUNING_CID_CUSTOM_GE,			//green equalist
+	IMAGE_TUNING_CID_CUSTOM_STATIC_DP,		//static defect pixels
+	IMAGE_TUNING_CID_CUSTOM_DRC,			//raw dynamic range compression
+	IMAGE_TUNING_CID_CUSTOM_WDR_FLT,		//WDR companded frontend lookup table
+	IMAGE_TUNING_CID_CUSTOM_WDR,			//sharpen
+	IMAGE_TUNING_CID_CUSTOM_BUTT,			//the end
+};
+
+enum isp_image_tuning_private_cmd_id {
+	IMAGE_TUNING_CID_AWB_ATTR = V4L2_CID_PRIVATE_BASE,
+	IMAGE_TUNING_CID_AWB_CWF_SHIFT,
+	IMAGE_TUNING_CID_MWB_ATTR,
+	IMAGE_TUNING_CID_WB_STAINFO,
+	IMAGE_TUNING_CID_WB_ATTR,
+	IMAGE_TUNING_CID_WB_STATIS_ATTR,
+	IMAGE_TUNING_CID_AWB_WEIGHT,
+	IMAGE_TUNING_CID_AWB_HIST,
+	IMAGE_TUNING_CID_AWB_RGB_COEFFT_WB_ATTR,
+	IMAGE_TUNING_CID_AWB_ZONE,
+	IMAGE_TUNING_CID_AE_ATTR = V4L2_CID_PRIVATE_BASE + 0x20,
+	IMAGE_TUNING_CID_AE_STAINFO,
+	IMAGE_TUNING_CID_AE_STRATEGY,
+	IMAGE_TUNING_CID_AE_COMP,
+	IMAGE_TUNING_CID_AE_ROI,
+	IMAGE_TUNING_CID_EXPR_ATTR,
+	IMAGE_TUNING_CID_ISP_EV_ATTR,
+	IMAGE_TUNING_CID_GET_TOTAL_GAIN,
+	IMAGE_TUNING_CID_MAX_AGAIN_ATTR,
+	IMAGE_TUNING_CID_MAX_DGAIN_ATTR,
+	IMAGE_TUNING_CID_HILIGHT_DEPRESS_STRENGTH,
+	IMAGE_TUNING_CID_GAMMA_ATTR,
+	IMAGE_TUNING_CID_SYSTEM_TAB,
+	IMAGE_TUNING_CID_AE_WEIGHT,
+	IMAGE_TUNING_CID_AE_HIST,
+	IMAGE_TUNING_CID_AE_ZONE,
+	IMAGE_TUNING_CID_AF_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 2,
+	IMAGE_TUNING_CID_AF_STAINFO,
+	IMAGE_TUNING_CID_AF_HIST,
+	IMAGE_TUNING_CID_AF_ZONE,
+	IMAGE_TUNING_CID_DYNAMIC_DP_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 3,
+	IMAGE_TUNING_CID_STATIC_DP_ATTR,
+	IMAGE_TUNING_CID_NOISE_PROFILE_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 4,
+	IMAGE_TUNING_CID_SINTER_ATTR ,
+	IMAGE_TUNING_CID_TEMPER_STRENGTH,
+	IMAGE_TUNING_CID_TEMPER_ATTR,
+	IMAGE_TUNING_CID_DRC_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 5,
+	IMAGE_TUNING_CID_WDR_ATTR,
+	IMAGE_TUNING_CID_SHARP_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 6,
+	IMAGE_TUNING_CID_DEMO_ATTR,
+	IMAGE_TUNING_CID_FC_ATTR,
+	IMAGE_TUNING_CID_CONTROL_FPS= V4L2_CID_PRIVATE_BASE + 0x20 * 7,
+	IMAGE_TUNING_CID_DAY_OR_NIGHT,
+	IMAGE_TUNING_CID_HVFLIP,
+	IMAGE_TUNING_CID_CCM_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 8,
+	IMAGE_TUNING_CID_SHAD_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 9,
+	IMAGE_TUNING_CID_GE_ATTR = V4L2_CID_PRIVATE_BASE + 0x20 * 10,
+	IMAGE_TUNING_CID_DIS_STAINFO = V4L2_CID_PRIVATE_BASE + 0x20 * 11,
+	IMAGE_TUNING_CID_ISP_TABLE_ATTR,
+	IMAGE_TUNING_CID_ISP_WAIT_FRAME_ATTR,
+};
+
+struct image_tuning_ctrls {
+	struct v4l2_ctrl_handler handler;
+
+	/* Auto white balance control cluster */
+	struct {
+		struct v4l2_ctrl *wb_mode;
+		struct v4l2_ctrl *wb_temperature;
+		struct isp_core_awb_attr awb_attr;
+		struct isp_core_mwb_attr mwb_attr;
+		struct isp_core_wb_statistic_info wb_info;
+	};
+
+	/* Auto/manual exposure control cluster */
+	struct {
+		struct v4l2_ctrl *exp_mode;
+		struct v4l2_ctrl *manual_exp;
+		struct v4l2_ctrl *exp_gain;
+		struct v4l2_ctrl *exp_compensation;
+		struct isp_core_ae_attr ae_attr;
+		struct isp_core_ae_statistic_info ae_info;
+	};
+
+	/* Auto focus control cluster */
+	struct {
+		struct v4l2_ctrl *af_mode;
+		struct v4l2_ctrl *af_status;
+		struct isp_core_af_attr af_attr;
+		struct isp_core_af_statistic_info af_info;
+	};
+
+	/* AE/AWB/AF lock/unlock */
+	struct v4l2_ctrl *aefwb_lock;
+
+	/* Enable - vertically flip */
+	struct v4l2_ctrl *vflip;
+	/* Enable - horizontally flip */
+	struct v4l2_ctrl *hflip;
+
+	/* Enable Sinter denoise module */
+	struct v4l2_ctrl *sinter;
+	struct isp_core_sinter_attr sinter_attr;
+
+	/* Enable Temper denoise module */
+	struct v4l2_ctrl *temper;
+	struct isp_core_temper_attr temper_attr;
+
+	/* Enable Iridix -- RAW Dynamic range compression module */
+	struct v4l2_ctrl *raw_drc;
+	struct isp_core_drc_attr drc_attr;
+
+	/* Enable WDR Companded fronted LUT module */
+	struct v4l2_ctrl *wdr_lut;
+	/* Enable Wide Dynamic Range module */
+	struct v4l2_ctrl *wdr;
+	struct isp_core_wdr_attr wdr_attr;
+
+	/* Enable ISP Process module */
+	struct v4l2_ctrl *isp_process;
+	struct v4l2_ctrl *freeze_fw;
+	/* test pattern control */
+	struct v4l2_ctrl *test_pattern;
+	/* Enable Black level module */
+	struct v4l2_ctrl *black_level;
+
+	/* Enable - digital image stabilization */
+	struct v4l2_ctrl *dis;
+	struct isp_core_dis_statistic_info dis_info;
+
+	/* Adjust - a power line frequency filter to avoid flicker */
+	struct v4l2_ctrl *flicker;
+	/* Enable Len shading module */
+	struct v4l2_ctrl *lens_shad;
+	struct isp_core_shading_attr shad_attr;
+
+	/* Enable Static Defect pixels module */
+	struct v4l2_ctrl *static_dp;
+	struct isp_core_static_defect_pixel_attr sdp_attr;
+
+	/* Enable Dynamic Defect pixels module */
+	struct v4l2_ctrl *dynamic_dp;
+	struct isp_core_dynamic_defect_pixel_attr ddp_attr;
+	/* Enable Green Equalist module */
+	struct v4l2_ctrl *green_eq;
+	struct isp_core_green_eq_attr ge_attr;
+
+	/* Adjust demosaic module  */
+	struct isp_core_demosaic_attr demo_attr;
+	struct isp_core_false_color_attr fc_attr;
+	struct v4l2_ctrl *sharpness;
+	struct isp_core_sharpness_attr sharp_attr;
+	/* Noise Profile RAW frontend */
+	struct isp_core_noise_profile_attr np_attr;
+
+
+	/* Enable - Anti fog */
+	struct v4l2_ctrl *fog;
+
+	/* Adjust - contrast */
+	struct v4l2_ctrl *contrast;
+	/* Adjust - saturation */
+	struct v4l2_ctrl *saturation;
+
+	/* Adjust - brightness */
+	struct v4l2_ctrl *brightness;
+
+	/* ISP image scene */
+	struct v4l2_ctrl *scene;
+	/* ISP image effect */
+	struct v4l2_ctrl *colorfx;
+
+	/* sensor output resolution  */
+	struct v4l2_ctrl *resolution;
+	/* sensor output fps */
+	struct v4l2_ctrl *fps;
+	/* The mode of isp day and night */
+	ISP_CORE_MODE_DN_E daynight;
+
+};
+
+/**
+ * struct fimc_isp - FIMC-IS ISP data structure
+ * @parent: pointer to ISP CORE device
+ * @video: the ISP block image tuning device
+ * @ctrl: v4l2 controls handler
+ * @mlock: mutex serializing video device and the subdev operations
+ * @state: driver state flags
+ */
+typedef struct tx_isp_image_tuning_video_driver {
+	struct v4l2_subdev 		*parent;
+	struct video_device 		*video;
+	struct image_tuning_ctrls	ctrls;
+	unsigned int			temper_buffer_size;
+	unsigned int 			temper_paddr;
+	unsigned int			wdr_buffer_size;
+	unsigned int 			wdr_paddr;
+
+	spinlock_t 			slock;
+	struct mutex			mlock;
+	atomic_t 			state;
+	struct tx_isp_driver_fh		fh;
+} image_tuning_vdrv_t;
+
+#define ctrl_to_image_tuning(_ctrl) \
+	container_of(ctrl->handler, image_tuning_vdrv_t, ctrls.handler)
+
+struct video_device *tx_isp_image_tuning_device_register(struct v4l2_subdev *parent);
+void tx_isp_image_tuning_device_release(struct video_device *vfd);
+
+
+
+#endif //__TX_ISP_CORE_TUNING_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,264 @@
+#include "tx-isp-load-parameters.h"
+
+/*****************************************************
+	the struct of ISP parameters data is as follow:
+	|-------------------|
+	|      version      |
+	|-------------------|
+	| parameter0 header |
+	|-------------------|
+	| parameter0 data   |
+	|-------------------|
+	| parameter1 header |
+	|-------------------|
+	| parameter1 data   |
+	|-------------------|
+
+	The parameter0 is the data of  apcial_static_calibrations and apcial_dynamic_calibrations.
+	The parameter1 is the data of customer initializations.
+
+*****************************************************/
+extern uint32_t get_dynamic_calibrations( ApicalCalibrations *c );
+extern uint32_t get_static_calibrations( ApicalCalibrations * c );
+extern void init_tx_isp_customer_parameter(TXispPrivCustomerParamer *m);
+
+static TXispPrivParamManage *manager = NULL;
+static ApicalCalibrations tmp_isp_param;			//the struct of private0 manager.
+
+static const unsigned int crc_table[8] = {
+	0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL,
+	0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L,
+};
+
+static unsigned int crc32(const unsigned int *p, unsigned int len)
+{
+	int i = 0;
+	unsigned int crc = crc_table[0];
+	for(i = 0; i < len; i++){
+		crc ^= *p++;
+		crc = crc ^ crc_table[crc & 0x7];
+	}
+
+	return crc;
+}
+
+static void full_the_tables_space(TXispPrivParamManage *m)
+{
+	int index = 0;
+	ApicalCalibrations *isp_param = m->isp_param;
+	LookupTable *param_table = m->param_table;
+	for(index = 0; index < _CALIBRATION_TOTAL_SIZE; index++){
+		isp_param[TX_ISP_PRIV_PARAM_DAY_MODE].calibrations[index] = &param_table[index<<1];
+		isp_param[TX_ISP_PRIV_PARAM_NIGHT_MODE].calibrations[index] = &param_table[(index << 1)+1];
+	}
+}
+
+static inline TXispPrivParamManage * malloc_tx_isp_priv_param_manage(void)
+{
+	int index = 0;
+//	LookupTable** c = NULL;
+	TXispPrivParamManage *m = kmalloc(sizeof(*m), GFP_KERNEL);
+	if(!m)
+		return NULL;
+
+	memset(m, 0, sizeof(*m));
+	snprintf(m->version, sizeof(m->version), "%s", TX_ISP_VERSION_ID);
+	for(index = 0; index < TX_ISP_PRIV_PARAM_MAX_INDEX; index++){
+		snprintf(m->headers[index].flag, TX_ISP_PRIV_PARAM_FLAG_SIZE, "header%d", index);
+	}
+
+	/* calibrate the memory size of apical_static and apcial_dynamic */
+	get_dynamic_calibrations(&tmp_isp_param);
+	get_static_calibrations(&tmp_isp_param);
+	full_the_tables_space(m);
+	return m;
+}
+
+void free_tx_isp_priv_param_manage(void)
+{
+	if(manager){
+		manager->customer = NULL;
+		init_tx_isp_customer_parameter(manager->customer);
+		if(manager->data)
+			kfree(manager->data);
+		if(manager->fw_data)
+			kfree(manager->fw_data);
+		kfree(manager);
+		manager = NULL;
+	}
+}
+
+TXispPrivParamManage* load_tx_isp_parameters(struct tx_isp_sensor_attribute *attr)
+{
+	unsigned int ret = 0;
+	int index = 0;
+	struct file *file = NULL;
+	struct inode *inode = NULL;
+	mm_segment_t old_fs;
+	loff_t fsize;
+	loff_t *pos;
+
+	char file_name[64];
+	char *cursor = NULL;
+	char *fw_cursor = NULL;
+	unsigned int size = 0;
+	LookupTable** c = NULL;
+	LookupTable** c_day = NULL;
+	LookupTable** c_night = NULL;
+	LookupTable* tmp = NULL;
+	TXispPrivParamHeader *header = NULL;
+
+	if(!attr)
+		return NULL;
+
+	if(manager == NULL){
+		manager = malloc_tx_isp_priv_param_manage();
+		if(manager == NULL){
+			printk("Failed to kmalloc TXispPrivParamManage\n");
+			return NULL;
+		}
+	}
+	/* open file */
+	snprintf(file_name, sizeof(file_name), "/etc/sensor/%s.bin", attr->name);
+	file = filp_open(file_name, O_RDONLY, 0);
+	if (file < 0 || IS_ERR(file)) {
+		printk("ISP: open %s file for isp calibrate read failed\n", file_name);
+		ret = -1;
+		goto failed_open_file;
+	}
+
+	/* read file */
+	inode = file->f_dentry->d_inode;
+	fsize = inode->i_size;
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	pos = &(file->f_pos);
+
+	/* check version and first header */
+
+	if(manager->data == NULL){
+		manager->data = kmalloc(fsize, GFP_KERNEL);
+		if(manager->data == NULL){
+			printk("%s[%d]: Failed to alloc %lld KB buffer!\n",__func__,__LINE__, fsize >> 10);
+			ret = -1;
+			goto failed_malloc_data;
+		}
+		manager->data_size = fsize;
+	}
+	if(manager->data_size < fsize){
+		printk("The size of file has been modify!\n");
+		ret = -1;
+		goto failed_check_total_size;
+	}
+	vfs_read(file, manager->data, fsize, pos);
+	filp_close(file, NULL);
+	set_fs(old_fs);
+
+	cursor = manager->data;
+	if(strncmp(manager->version, cursor, TX_ISP_VERSION_SIZE)){
+		ret = -1;
+		printk("####################################################################\n");
+		printk("#### The version of %s.bin doesn't match with driver! ####\n",attr->name);
+		printk("#### The version of %s.bin is %s, the driver is %s ####\n",attr->name, manager->version, cursor);
+		printk("####################################################################\n");
+		goto failed_check_version;
+	}
+	cursor += TX_ISP_VERSION_SIZE;
+	header = &manager->headers[TX_ISP_PRIV_PARAM_BASE_INDEX];
+	if(strncmp((char *)header, cursor, TX_ISP_PRIV_PARAM_FLAG_SIZE)){
+		ret = -1;
+		printk("####################################################################\n");
+		printk("#### The first flag of %s.bin doesn't match with driver! ####\n",attr->name);
+		printk("####################################################################\n");
+		goto failed_check_header0;
+	}
+	header->size = ((TXispPrivParamHeader *)cursor)->size;
+	header->crc = ((TXispPrivParamHeader *)cursor)->crc;
+	if(manager->fw_data == NULL){
+		manager->fw_data = kmalloc(header->size >> 1, GFP_KERNEL);
+		if(manager->fw_data == NULL){
+			printk("%s[%d]: Failed to alloc %d KB buffer!\n",__func__,__LINE__, header->size >> 11);
+			ret = -1;
+			goto failed_malloc_fw_data;
+		}
+	}
+	cursor += sizeof(TXispPrivParamHeader);
+	if(header->crc != crc32((unsigned int*)cursor, header->size / 4)){
+			printk("%s[%d]: Failed to CRC sensor setting!\n",__func__,__LINE__);
+			ret = -1;
+			goto failed_crc_header0;
+	}
+
+	fw_cursor = manager->fw_data;
+	manager->base_buf = cursor;
+	c = tmp_isp_param.calibrations;
+	c_day = manager->isp_param[TX_ISP_PRIV_PARAM_DAY_MODE].calibrations;
+	c_night = manager->isp_param[TX_ISP_PRIV_PARAM_NIGHT_MODE].calibrations;
+	for(index = 0; index < _CALIBRATION_TOTAL_SIZE; index++){
+		if(c[index] && c[index]->ptr){
+			tmp = (LookupTable *)cursor;
+			/* copy the parameters of isp during the day */
+			c_day[index]->ptr = cursor + sizeof(LookupTable);
+			c_day[index]->rows = tmp->rows;
+			c_day[index]->cols = tmp->cols;
+			c_day[index]->width = tmp->width;
+			size = c_day[index]->rows * c_day[index]->cols * c_day[index]->width;
+			cursor += size + sizeof(LookupTable);
+
+			c[index]->ptr = fw_cursor;
+			c[index]->rows = tmp->rows;
+			c[index]->cols = tmp->cols;
+			c[index]->width = tmp->width;
+			memcpy(c[index]->ptr, c_day[index]->ptr, size);  //update the default parameters.
+			fw_cursor += size;
+			/* copy the parameters of isp during the night */
+			tmp = (LookupTable *)cursor;
+			c_night[index]->ptr = cursor + sizeof(LookupTable);
+			c_night[index]->rows = tmp->rows;
+			c_night[index]->cols = tmp->cols;
+			c_night[index]->width = tmp->width;
+			cursor += size + sizeof(LookupTable);
+		}
+	}
+
+	/* check private1 header and set parameter */
+	header = &manager->headers[TX_ISP_PRIV_PARAM_CUSTOM_INDEX];
+	if(strncmp(header->flag, cursor, TX_ISP_PRIV_PARAM_FLAG_SIZE)){
+		ret = -1;
+		printk("####################################################################\n");
+		printk("#### The second flag of %s.bin doesn't match with driver! ####\n",attr->name);
+		printk("####################################################################\n");
+		goto failed_check_header1;
+	}
+	header->size = ((TXispPrivParamHeader *)cursor)->size;
+	header->crc = ((TXispPrivParamHeader *)cursor)->crc;
+//	printk("## %s %d custom size = %d ##\n", __func__,__LINE__,header->size);
+	if(header->size == 0){
+		manager->customer_buf = NULL;
+		manager->customer = NULL;
+	}else{
+		manager->customer_buf = cursor + sizeof(TXispPrivParamHeader);
+		manager->customer = manager->customer_buf;
+		cursor += sizeof(TXispPrivParamHeader);
+		if(header->crc != crc32((unsigned int*)cursor, header->size / 4)){
+			printk("%s[%d]: Failed to CRC sensor setting!\n",__func__,__LINE__);
+			ret = -1;
+			goto failed_crc_header1;
+		}
+	}
+
+	init_tx_isp_customer_parameter(manager->customer);
+	return manager;
+failed_crc_header1:
+failed_check_header1:
+failed_crc_header0:
+failed_malloc_fw_data:
+failed_check_header0:
+failed_check_version:
+failed_check_total_size:
+failed_malloc_data:
+	filp_close(file, NULL);
+	set_fs(old_fs);
+failed_open_file:
+	return NULL;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/apical-isp/tx-isp-load-parameters.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,141 @@
+#ifndef __TX_ISP_LOAD_PARAMETERS_H__
+#define __TX_ISP_LOAD_PARAMETERS_H__
+#include <linux/fs.h>
+#include <tx-isp-common.h>
+#include <apical-isp/apical_calibrations_id.h>
+
+#define TX_ISP_VERSION_SIZE 8
+#define TX_ISP_VERSION_ID "1.38"
+#define TX_ISP_PRIV_PARAM_FLAG_SIZE	8
+
+enum __tx_isp_private_parameters_index {
+	TX_ISP_PRIV_PARAM_BASE_INDEX,
+	TX_ISP_PRIV_PARAM_CUSTOM_INDEX,
+	TX_ISP_PRIV_PARAM_MAX_INDEX,
+};
+typedef struct __tx_isp_private_parameters_header{
+	char flag[TX_ISP_PRIV_PARAM_FLAG_SIZE];
+	unsigned int size;		/* the memory size of the parameter array */
+	unsigned int crc;
+} TXispPrivParamHeader;
+
+enum __tx_isp_private_parameters_mode {
+	TX_ISP_PRIV_PARAM_DAY_MODE,
+	TX_ISP_PRIV_PARAM_NIGHT_MODE,
+	TX_ISP_PRIV_PARAM_BUTT_MODE,
+};
+
+#define CONTRAST_CURVES_MAXNUM 10
+typedef unsigned char contrast_curves[CONTRAST_CURVES_MAXNUM][2];
+
+typedef struct __tx_isp_private_customer_paramters{
+	union {
+		struct {
+			unsigned int 				: 2;
+			unsigned int sensor_offset	: 1;
+			unsigned int digital_gain	: 1;
+			unsigned int gamma_fe		: 1;
+			unsigned int raw_front		: 1;
+			unsigned int defect_pixel	: 1;
+			unsigned int frame_stitch	: 1;
+			unsigned int gamma_fe_pos	: 1;
+			unsigned int sinter		: 1;
+			unsigned int temper		: 1;
+			unsigned int order		: 1;
+			unsigned int wb_module	: 1;
+			unsigned int 			: 1;
+			unsigned int mesh		: 1;
+			unsigned int iridix		: 1;
+			unsigned int 			: 1;
+			unsigned int matrix		: 1;
+			unsigned int fr_crop		: 1;
+			unsigned int fr_gamma		: 1;
+			unsigned int fr_sharpen		: 1;
+			unsigned int 			: 3;
+			unsigned int ds1_crop		: 1;
+			unsigned int ds1_scaler		: 1;
+			unsigned int ds1_gamma		: 1;
+			unsigned int ds1_sharpen	: 1;
+			unsigned int 			: 4;
+		};
+		unsigned int top;
+	};
+	/* green equalization */
+	unsigned int ge_strength;
+	unsigned int ge_threshold;
+	unsigned int ge_slope;
+	unsigned int ge_sensitivity;
+	/* defect pixel correct configuration */
+	unsigned int dp_module;
+	unsigned int hpdev_threshold;
+	unsigned int line_threshold;
+	unsigned int hp_blend;
+	/* demosaic configuration */
+	unsigned int dmsc_vh_slope;
+	unsigned int dmsc_aa_slope;
+	unsigned int dmsc_va_slope;
+	unsigned int dmsc_uu_slope;
+	unsigned int dmsc_sat_slope;
+	unsigned int dmsc_vh_threshold;
+	unsigned int dmsc_aa_threshold;
+	unsigned int dmsc_va_threshold;
+	unsigned int dmsc_uu_threshold;
+	unsigned int dmsc_sat_threshold;
+	unsigned int dmsc_vh_offset;
+	unsigned int dmsc_aa_offset;
+	unsigned int dmsc_va_offset;
+	unsigned int dmsc_uu_offset;
+	unsigned int dmsc_sat_offset;
+	unsigned int dmsc_luminance_thresh;
+	unsigned int dmsc_np_offset;
+	unsigned int dmsc_config;
+	unsigned int dmsc_ac_threshold;
+	unsigned int dmsc_ac_slope;
+	unsigned int dmsc_ac_offset;
+	unsigned int dmsc_fc_slope;
+	unsigned int dmsc_fc_alias_slope;
+	unsigned int dmsc_fc_alias_thresh;
+	struct {
+		unsigned int dmsc_np_off : 6;
+		unsigned int dmsc_np_reflect : 1;
+		unsigned int : 25;
+	};
+	/* Temper */
+	unsigned int temper_recursion_limit;
+	/* WDR configuration */
+	unsigned int wdr_short_thresh;
+	unsigned int wdr_long_thresh;
+	unsigned int wdr_expo_ratio_thresh;
+	unsigned int wdr_stitch_correct;
+	unsigned int wdr_stitch_error_thresh;
+	unsigned int wdr_stitch_error_limit;
+	unsigned int wdr_stitch_bl_long;
+	unsigned int wdr_stitch_bl_short;
+	unsigned int wdr_stitch_bl_output;
+	/* other configuration */
+	unsigned int max_isp_dgain;
+	unsigned int max_sensor_again;
+
+	unsigned char sharpness;
+	unsigned char saturation;
+	unsigned char brightness;
+	/* the parameters is contrast curve */
+	contrast_curves contrast;
+} TXispPrivCustomerParamer;
+
+typedef struct __tx_isp_private_parameters_manage {
+	char version[TX_ISP_VERSION_SIZE];
+	TXispPrivParamHeader headers[TX_ISP_PRIV_PARAM_MAX_INDEX];
+	void *data;								//the base address of all data.
+	unsigned int data_size;
+	void *fw_data;								//the base address of isp FW parameters.
+	ApicalCalibrations isp_param[TX_ISP_PRIV_PARAM_BUTT_MODE];			//the struct of private0 manager.
+	LookupTable param_table[_CALIBRATION_TOTAL_SIZE * TX_ISP_PRIV_PARAM_BUTT_MODE];
+	void *base_buf;							//the address of private0 data.
+	TXispPrivCustomerParamer *customer;				//the struct of private1 pointer.
+	void *customer_buf;							//the address of private1 data.
+} TXispPrivParamManage;
+
+TXispPrivParamManage* load_tx_isp_parameters(struct tx_isp_sensor_attribute *attr);
+void free_tx_isp_priv_param_manage(void);
+#endif //__TX_ISP_LOAD_PARAMETERS_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,115 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_CALIBRATIONS_H__
+#define __APICAL_CALIBRATIONS_H__
+
+//#include "log.h"
+#include "apical_types.h"
+#include "apical_calibrations_id.h"
+
+
+#define CALIBRATION_BASE_SET 0
+#define CALIBRATION_PREVIEW_SET 1
+
+/**
+ *   Initialize a current set of settings for apical ISP.
+ *
+ *   This function MUST be called before any access to ISP LUTS.
+ *   It initializes a pointer on a structure with ISP settings.
+ *   You can update this function to use any predefined set you need.
+ *
+ *   @param c_set - which set of calibrations to use base or preview.
+ *
+ *   @return SUCCESS - pointer on ISP settings has been initialized properly
+ *           FAIL - failed initialization. Firmware cannot continue to run
+ */
+int32_t init_isp_set( uint32_t c_set ) ;
+
+
+/**
+ *   Returns 1 if the preview set is available
+ *
+ *   A firmware build can support a specific set of calibrations for each resolution.
+ *   This function returns true if there are two calibrations sets
+ *   which are supported by firmware.
+ *   For example if returned value is 0 this mean that only CALIBRATION_BASE_SET can be used for any resolution
+ *   If firmware supports more than one set then defines CALIBRATION_BASE_SET should be used
+ *   for full resolution picture and CALIBRATION_PREVIEW_SET should be used for preview resolution.
+ *
+ *
+ *   @return 1 - preview set is supported by firmware
+ *           0 - only base set is available for all resolutions
+ */
+uint32_t preview_set_supported( void ) ;
+
+
+/**
+ *   Get current settings for apical ISP.
+ *
+ *   This function returns a pointer on current set of ISP settings. Apical ISP library uses
+ *   this function each time it needs an access to predefined ISP LUT.
+ *   You can update a returned pointer to change ISP settings in real-time.
+ *
+ *   @return a valid pointer on ISP settings
+ */
+ApicalCalibrations* get_current_set( void ) ;
+
+
+LookupTable* _GET_LOOKUP_PTR( uint32_t idx ) ;
+
+const void* _GET_LUT_PTR( uint32_t idx ) ;
+
+uint8_t* _GET_UCHAR_PTR( uint32_t idx ) ;
+
+uint16_t* _GET_USHORT_PTR( uint32_t idx ) ;
+
+uint32_t* _GET_UINT_PTR( uint32_t idx ) ;
+
+modulation_entry_t* _GET_MOD_ENTRY16_PTR( uint32_t idx ) ;
+
+modulation_entry_32_t* _GET_MOD_ENTRY32_PTR( uint32_t idx ) ;
+
+uint32_t _GET_ROWS( uint32_t idx ) ;
+
+uint32_t _GET_COLS( uint32_t idx ) ;
+
+uint32_t _GET_LEN( uint32_t idx ) ;
+
+uint32_t _GET_WIDTH( uint32_t idx ) ;
+
+uint32_t _GET_SIZE( uint32_t idx ) ;
+
+
+/**
+ *   Get a current settings index for hdr lut table.
+ *
+ *   This function returns an index on a hdr lut table for the current wdr mode.
+ *   There are two possible scenarious. First one when we should have a separate
+ *   lut for every of four wdr modes i.e. for linear, fs_lin, native and fs_hdr.
+ *   A second scenario when we have one lut for linear mode and one lut for all
+ *   other modes. It is the main reason why we need this function. It should
+ *   distinguish luts by start_idx parameter and return a valid index for the current
+ *   wdr mode.
+ *
+ *   @param start_idx - a start index of the desired lut table from ECalibrationID
+ *                      see apical_calibrations.h
+ *   @param mode - a hdr mode you would like to get a lut for. Must be one from EWDRModeID
+ *                 see apical_calibrations.h
+ *
+ *   @return  non zero value - a valid LUT index in calibrations array
+ *            -1 - if desired lut doesn't exist
+ */
+int32_t _GET_HDR_TABLE_INDEX( uint32_t start_idx, uint32_t mode ) ;
+
+
+#endif // __APICAL_CALIBRATIONS_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations_id.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations_id.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations_id.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_calibrations_id.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,375 @@
+#ifndef __APICAL_ISP_CALIBRATIONS_H__
+#define __APICAL_ISP_CALIBRATIONS_H__
+
+
+// ------------------------------------------------------------------------------ //
+//     This confidential and proprietary software/information may be used only    //
+//        as authorized by a licensing agreement from Apical Limited              //
+//                                                                                //
+//                   (C) COPYRIGHT 2014 Apical Limited                            //
+//                          ALL RIGHTS RESERVED                                   //
+//                                                                                //
+//      The entire notice above must be reproduced on all authorized              //
+//       copies and copies may only be made to the extent permitted               //
+//             by a licensing agreement from Apical Limited.                      //
+//                                                                                //
+// ------------------------------------------------------------------------------ //
+
+#include "apical_types.h"
+
+enum EWDRModeID {
+	WDR_MODE_LINEAR = 0,
+	WDR_MODE_FS_HDR,
+	WDR_MODE_NATIVE,
+	WDR_MODE_FS_LIN,
+	WDR_MODE_COUNT
+} ;
+
+
+#define WDR_MODE_POSITION ( WDR_MODE_FS_HDR )
+
+// when you describe luts for WDR modes
+// use START and STOP dummy defines to avoid a collision with
+// other lut indexes
+enum ECalibrationID {
+	// isp calibrations
+	_CALIBRATION_LUTS_START_INDEX = 0, // do not change this. MUST be always zero.
+	// noise profile lut
+	_CALIBRATION_NOISE_PROFILE_START,
+	_CALIBRATION_NOISE_PROFILE_LINEAR  = _CALIBRATION_NOISE_PROFILE_START + WDR_MODE_LINEAR,
+	_CALIBRATION_NOISE_PROFILE_FS_HDR  = _CALIBRATION_NOISE_PROFILE_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_NOISE_PROFILE_NATIVE  = _CALIBRATION_NOISE_PROFILE_START + WDR_MODE_NATIVE,
+	_CALIBRATION_NOISE_PROFILE_FS_LIN  = _CALIBRATION_NOISE_PROFILE_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_NOISE_PROFILE_STOP    = _CALIBRATION_NOISE_PROFILE_START + WDR_MODE_COUNT,
+	// demosaic
+	_CALIBRATION_DEMOSAIC_START,
+	_CALIBRATION_DEMOSAIC_LINEAR  = _CALIBRATION_DEMOSAIC_START + WDR_MODE_LINEAR,
+	_CALIBRATION_DEMOSAIC_FS_HDR  = _CALIBRATION_DEMOSAIC_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_DEMOSAIC_NATIVE  = _CALIBRATION_DEMOSAIC_START + WDR_MODE_NATIVE,
+	_CALIBRATION_DEMOSAIC_FS_LIN  = _CALIBRATION_DEMOSAIC_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_DEMOSAIC_STOP    = _CALIBRATION_DEMOSAIC_START + WDR_MODE_COUNT,
+	// gamma linear
+	_CALIBRATION_GAMMA_START,
+	_CALIBRATION_GAMMA_LINEAR  = _CALIBRATION_GAMMA_START + WDR_MODE_LINEAR,
+	_CALIBRATION_GAMMA_FS_HDR  = _CALIBRATION_GAMMA_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_GAMMA_NATIVE  = _CALIBRATION_GAMMA_START + WDR_MODE_NATIVE,
+	_CALIBRATION_GAMMA_FS_LIN  = _CALIBRATION_GAMMA_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_GAMMA_STOP    = _CALIBRATION_GAMMA_START + WDR_MODE_COUNT,
+	// gamma be 0
+	_CALIBRATION_GAMMA_BE_0_START,
+	_CALIBRATION_GAMMA_BE_0_FS_HDR  = _CALIBRATION_GAMMA_BE_0_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_GAMMA_BE_0_NATIVE  = _CALIBRATION_GAMMA_BE_0_START + WDR_MODE_NATIVE,
+	_CALIBRATION_GAMMA_BE_0_FS_LIN  = _CALIBRATION_GAMMA_BE_0_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_GAMMA_BE_0_STOP    = _CALIBRATION_GAMMA_BE_0_START + WDR_MODE_COUNT,
+	// gamma be 1
+	_CALIBRATION_GAMMA_BE_1_START,
+	_CALIBRATION_GAMMA_BE_1_LINEAR  = _CALIBRATION_GAMMA_BE_1_START + WDR_MODE_LINEAR,
+	_CALIBRATION_GAMMA_BE_1_FS_HDR  = _CALIBRATION_GAMMA_BE_1_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_GAMMA_BE_1_NATIVE  = _CALIBRATION_GAMMA_BE_1_START + WDR_MODE_NATIVE,
+	_CALIBRATION_GAMMA_BE_1_FS_LIN  = _CALIBRATION_GAMMA_BE_1_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_GAMMA_BE_1_STOP    = _CALIBRATION_GAMMA_BE_1_START + WDR_MODE_COUNT,
+	// gamme fe 0
+	_CALIBRATION_GAMMA_FE_0_START,
+	_CALIBRATION_GAMMA_FE_0_LINEAR  = _CALIBRATION_GAMMA_FE_0_START + WDR_MODE_LINEAR,
+	_CALIBRATION_GAMMA_FE_0_FS_HDR  = _CALIBRATION_GAMMA_FE_0_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_GAMMA_FE_0_NATIVE  = _CALIBRATION_GAMMA_FE_0_START + WDR_MODE_NATIVE,
+	_CALIBRATION_GAMMA_FE_0_FS_LIN  = _CALIBRATION_GAMMA_FE_0_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_GAMMA_FE_0_STOP    = _CALIBRATION_GAMMA_FE_0_START + WDR_MODE_COUNT,
+	// gamma fe 1
+	_CALIBRATION_GAMMA_FE_1_START,
+	_CALIBRATION_GAMMA_FE_1_LINEAR  = _CALIBRATION_GAMMA_FE_1_START + WDR_MODE_LINEAR,
+	_CALIBRATION_GAMMA_FE_1_FS_HDR  = _CALIBRATION_GAMMA_FE_1_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_GAMMA_FE_1_NATIVE  = _CALIBRATION_GAMMA_FE_1_START + WDR_MODE_NATIVE,
+	_CALIBRATION_GAMMA_FE_1_FS_LIN  = _CALIBRATION_GAMMA_FE_1_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_GAMMA_FE_1_STOP    = _CALIBRATION_GAMMA_FE_1_START + WDR_MODE_COUNT,
+	// iridix exposure value limits
+	_CALIBRATION_IRIDIX_EV_LIM_NO_STR_START,
+	_CALIBRATION_IRIDIX_EV_LIM_NO_STR_LINEAR = _CALIBRATION_IRIDIX_EV_LIM_NO_STR_START + WDR_MODE_LINEAR,
+	_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_HDR = _CALIBRATION_IRIDIX_EV_LIM_NO_STR_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_IRIDIX_EV_LIM_NO_STR_NATIVE = _CALIBRATION_IRIDIX_EV_LIM_NO_STR_START + WDR_MODE_NATIVE,
+	_CALIBRATION_IRIDIX_EV_LIM_NO_STR_FS_LIN = _CALIBRATION_IRIDIX_EV_LIM_NO_STR_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_IRIDIX_EV_LIM_NO_STR_STOP   = _CALIBRATION_IRIDIX_EV_LIM_NO_STR_START + WDR_MODE_COUNT,
+	// auto exposure correction
+	_CALIBRATION_AE_CORRECTION_START,
+	_CALIBRATION_AE_CORRECTION_LINEAR = _CALIBRATION_AE_CORRECTION_START + WDR_MODE_LINEAR,
+	_CALIBRATION_AE_CORRECTION_FS_HDR = _CALIBRATION_AE_CORRECTION_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_AE_CORRECTION_NATIVE = _CALIBRATION_AE_CORRECTION_START + WDR_MODE_NATIVE,
+	_CALIBRATION_AE_CORRECTION_FS_LIN = _CALIBRATION_AE_CORRECTION_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_AE_CORRECTION_STOP   = _CALIBRATION_AE_CORRECTION_START + WDR_MODE_COUNT,
+	// sinter strength 0
+	_CALIBRATION_SINTER_STRENGTH_START,
+	_CALIBRATION_SINTER_STRENGTH_LINEAR = _CALIBRATION_SINTER_STRENGTH_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SINTER_STRENGTH_FS_HDR = _CALIBRATION_SINTER_STRENGTH_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SINTER_STRENGTH_NATIVE = _CALIBRATION_SINTER_STRENGTH_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SINTER_STRENGTH_FS_LIN = _CALIBRATION_SINTER_STRENGTH_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SINTER_STRENGTH_STOP   = _CALIBRATION_SINTER_STRENGTH_START + WDR_MODE_COUNT,
+	// sinter strength 1
+	_CALIBRATION_SINTER_STRENGTH1_START,
+	_CALIBRATION_SINTER_STRENGTH1_LINEAR = _CALIBRATION_SINTER_STRENGTH1_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SINTER_STRENGTH1_FS_HDR = _CALIBRATION_SINTER_STRENGTH1_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SINTER_STRENGTH1_NATIVE = _CALIBRATION_SINTER_STRENGTH1_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SINTER_STRENGTH1_FS_LIN = _CALIBRATION_SINTER_STRENGTH1_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SINTER_STRENGTH1_STOP   = _CALIBRATION_SINTER_STRENGTH1_START + WDR_MODE_COUNT,
+	// sinter thresh 1
+	_CALIBRATION_SINTER_THRESH1_START,
+	_CALIBRATION_SINTER_THRESH1_LINEAR = _CALIBRATION_SINTER_THRESH1_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SINTER_THRESH1_FS_HDR = _CALIBRATION_SINTER_THRESH1_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SINTER_THRESH1_NATIVE = _CALIBRATION_SINTER_THRESH1_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SINTER_THRESH1_FS_LIN = _CALIBRATION_SINTER_THRESH1_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SINTER_THRESH1_STOP   = _CALIBRATION_SINTER_THRESH1_START + WDR_MODE_COUNT,
+	// thresh 4
+	_CALIBRATION_SINTER_THRESH4_START,
+	_CALIBRATION_SINTER_THRESH4_LINEAR = _CALIBRATION_SINTER_THRESH4_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SINTER_THRESH4_FS_HDR = _CALIBRATION_SINTER_THRESH4_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SINTER_THRESH4_NATIVE = _CALIBRATION_SINTER_THRESH4_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SINTER_THRESH4_FS_LIN = _CALIBRATION_SINTER_THRESH4_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SINTER_THRESH4_STOP   = _CALIBRATION_SINTER_THRESH4_START + WDR_MODE_COUNT,
+	// sharpening alt d
+	_CALIBRATION_SHARP_ALT_D_START,
+	_CALIBRATION_SHARP_ALT_D_LINEAR = _CALIBRATION_SHARP_ALT_D_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHARP_ALT_D_FS_HDR = _CALIBRATION_SHARP_ALT_D_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SHARP_ALT_D_NATIVE = _CALIBRATION_SHARP_ALT_D_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SHARP_ALT_D_FS_LIN = _CALIBRATION_SHARP_ALT_D_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SHARP_ALT_D_STOP   = _CALIBRATION_SHARP_ALT_D_START + WDR_MODE_COUNT,
+	// sharpening alt ud
+	_CALIBRATION_SHARP_ALT_UD_START,
+	_CALIBRATION_SHARP_ALT_UD_LINEAR = _CALIBRATION_SHARP_ALT_UD_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHARP_ALT_UD_FS_HDR = _CALIBRATION_SHARP_ALT_UD_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SHARP_ALT_UD_NATIVE = _CALIBRATION_SHARP_ALT_UD_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SHARP_ALT_UD_FS_LIN = _CALIBRATION_SHARP_ALT_UD_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SHARP_ALT_UD_STOP   = _CALIBRATION_SHARP_ALT_UD_START + WDR_MODE_COUNT,
+	// sharpening alt du
+	_CALIBRATION_SHARP_ALT_DU_START,
+	_CALIBRATION_SHARP_ALT_DU_LINEAR = _CALIBRATION_SHARP_ALT_DU_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHARP_ALT_DU_FS_HDR = _CALIBRATION_SHARP_ALT_DU_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SHARP_ALT_DU_NATIVE = _CALIBRATION_SHARP_ALT_DU_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SHARP_ALT_DU_FS_LIN = _CALIBRATION_SHARP_ALT_DU_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SHARP_ALT_DU_STOP   = _CALIBRATION_SHARP_ALT_DU_START + WDR_MODE_COUNT,
+	// demosaic noise profile offset
+	_CALIBRATION_DEMOSAIC_NP_OFFSET_START,
+	_CALIBRATION_DEMOSAIC_NP_OFFSET_LINEAR = _CALIBRATION_DEMOSAIC_NP_OFFSET_START + WDR_MODE_LINEAR,
+	_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_HDR = _CALIBRATION_DEMOSAIC_NP_OFFSET_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_DEMOSAIC_NP_OFFSET_NATIVE = _CALIBRATION_DEMOSAIC_NP_OFFSET_START + WDR_MODE_NATIVE,
+	_CALIBRATION_DEMOSAIC_NP_OFFSET_FS_LIN = _CALIBRATION_DEMOSAIC_NP_OFFSET_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_DEMOSAIC_NP_OFFSET_STOP   = _CALIBRATION_DEMOSAIC_NP_OFFSET_START + WDR_MODE_COUNT,
+	// demosaic noise profile offset
+	_CALIBRATION_SATURATION_STRENGTH_START,
+	_CALIBRATION_SATURATION_STRENGTH_LINEAR = _CALIBRATION_SATURATION_STRENGTH_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SATURATION_STRENGTH_FS_HDR = _CALIBRATION_SATURATION_STRENGTH_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_SATURATION_STRENGTH_NATIVE = _CALIBRATION_SATURATION_STRENGTH_START + WDR_MODE_NATIVE,
+	_CALIBRATION_SATURATION_STRENGTH_FS_LIN = _CALIBRATION_SATURATION_STRENGTH_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_SATURATION_STRENGTH_STOP   = _CALIBRATION_SATURATION_STRENGTH_START + WDR_MODE_COUNT,
+	// iridix strength
+	_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_START,
+	_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_LINEAR = _CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_START + WDR_MODE_LINEAR,
+	_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_WDR    = _CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_START + WDR_MODE_POSITION,
+	_CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_STOP   = _CALIBRATION_IRIDIX_STRENGTH_MAXIMUM_START + WDR_MODE_COUNT,
+	// sinter sad
+	_CALIBRATION_SINTER_SAD_START,
+	_CALIBRATION_SINTER_SAD_LINEAR = _CALIBRATION_SINTER_SAD_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SINTER_SAD_WDR    = _CALIBRATION_SINTER_SAD_START + WDR_MODE_POSITION,
+	_CALIBRATION_SINTER_SAD_STOP   = _CALIBRATION_SINTER_SAD_START + WDR_MODE_COUNT,
+	// sharpen fr
+	_CALIBRATION_SHARPEN_FR_START,
+	_CALIBRATION_SHARPEN_FR_LINEAR = _CALIBRATION_SHARPEN_FR_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHARPEN_FR_WDR    = _CALIBRATION_SHARPEN_FR_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHARPEN_FR_STOP   = _CALIBRATION_SHARPEN_FR_START + WDR_MODE_COUNT,
+	// sharpen ds1
+	_CALIBRATION_SHARPEN_DS1_START,
+	_CALIBRATION_SHARPEN_DS1_LINEAR = _CALIBRATION_SHARPEN_DS1_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHARPEN_DS1_WDR    = _CALIBRATION_SHARPEN_DS1_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHARPEN_DS1_STOP   = _CALIBRATION_SHARPEN_DS1_START + WDR_MODE_COUNT,
+	// sharpen ds2
+	_CALIBRATION_SHARPEN_DS2_START,
+	_CALIBRATION_SHARPEN_DS2_LINEAR = _CALIBRATION_SHARPEN_DS2_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHARPEN_DS2_WDR    = _CALIBRATION_SHARPEN_DS2_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHARPEN_DS2_STOP   = _CALIBRATION_SHARPEN_DS2_START + WDR_MODE_COUNT,
+	// black level for r channel
+	_CALIBRATION_BLACK_LEVEL_R_START,
+	_CALIBRATION_BLACK_LEVEL_R_LINEAR = _CALIBRATION_BLACK_LEVEL_R_START + WDR_MODE_LINEAR,
+	_CALIBRATION_BLACK_LEVEL_R_FS_HDR = _CALIBRATION_BLACK_LEVEL_R_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_BLACK_LEVEL_R_NATIVE = _CALIBRATION_BLACK_LEVEL_R_START + WDR_MODE_NATIVE,
+	_CALIBRATION_BLACK_LEVEL_R_FS_LIN = _CALIBRATION_BLACK_LEVEL_R_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_BLACK_LEVEL_R_STOP   = _CALIBRATION_BLACK_LEVEL_R_START + WDR_MODE_COUNT,
+	// black level for b channel
+	_CALIBRATION_BLACK_LEVEL_B_START,
+	_CALIBRATION_BLACK_LEVEL_B_LINEAR = _CALIBRATION_BLACK_LEVEL_B_START + WDR_MODE_LINEAR,
+	_CALIBRATION_BLACK_LEVEL_B_FS_HDR = _CALIBRATION_BLACK_LEVEL_B_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_BLACK_LEVEL_B_NATIVE = _CALIBRATION_BLACK_LEVEL_B_START + WDR_MODE_NATIVE,
+	_CALIBRATION_BLACK_LEVEL_B_FS_LIN = _CALIBRATION_BLACK_LEVEL_B_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_BLACK_LEVEL_B_STOP   = _CALIBRATION_BLACK_LEVEL_B_START + WDR_MODE_COUNT,
+	// black level for gb channel
+	_CALIBRATION_BLACK_LEVEL_GB_START,
+	_CALIBRATION_BLACK_LEVEL_GB_LINEAR = _CALIBRATION_BLACK_LEVEL_GB_START + WDR_MODE_LINEAR,
+	_CALIBRATION_BLACK_LEVEL_GB_FS_HDR = _CALIBRATION_BLACK_LEVEL_GB_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_BLACK_LEVEL_GB_NATIVE = _CALIBRATION_BLACK_LEVEL_GB_START + WDR_MODE_NATIVE,
+	_CALIBRATION_BLACK_LEVEL_GB_FS_LIN = _CALIBRATION_BLACK_LEVEL_GB_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_BLACK_LEVEL_GB_STOP   = _CALIBRATION_BLACK_LEVEL_GB_START + WDR_MODE_COUNT,
+	// black level for gr channel
+	_CALIBRATION_BLACK_LEVEL_GR_START,
+	_CALIBRATION_BLACK_LEVEL_GR_LINEAR = _CALIBRATION_BLACK_LEVEL_GR_START + WDR_MODE_LINEAR,
+	_CALIBRATION_BLACK_LEVEL_GR_FS_HDR = _CALIBRATION_BLACK_LEVEL_GR_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_BLACK_LEVEL_GR_NATIVE = _CALIBRATION_BLACK_LEVEL_GR_START + WDR_MODE_NATIVE,
+	_CALIBRATION_BLACK_LEVEL_GR_FS_LIN = _CALIBRATION_BLACK_LEVEL_GR_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_BLACK_LEVEL_GR_STOP   = _CALIBRATION_BLACK_LEVEL_GR_START + WDR_MODE_COUNT,
+	// dp slope
+	_CALIBRATION_DP_SLOPE_START,
+	_CALIBRATION_DP_SLOPE_LINEAR  = _CALIBRATION_DP_SLOPE_START + WDR_MODE_LINEAR,
+	_CALIBRATION_DP_SLOPE_FS_HDR  = _CALIBRATION_DP_SLOPE_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_DP_SLOPE_NATIVE  = _CALIBRATION_DP_SLOPE_START + WDR_MODE_NATIVE,
+	_CALIBRATION_DP_SLOPE_FS_LIN  = _CALIBRATION_DP_SLOPE_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_DP_SLOPE_FS_STOP = _CALIBRATION_DP_SLOPE_START + WDR_MODE_COUNT,
+	// dp threshold
+	_CALIBRATION_DP_THRESHOLD_START,
+	_CALIBRATION_DP_THRESHOLD_LINEAR = _CALIBRATION_DP_THRESHOLD_START + WDR_MODE_LINEAR,
+	_CALIBRATION_DP_THRESHOLD_FS_HDR = _CALIBRATION_DP_THRESHOLD_START + WDR_MODE_FS_HDR,
+	_CALIBRATION_DP_THRESHOLD_NATIVE = _CALIBRATION_DP_THRESHOLD_START + WDR_MODE_NATIVE,
+	_CALIBRATION_DP_THRESHOLD_FS_LIN = _CALIBRATION_DP_THRESHOLD_START + WDR_MODE_FS_LIN,
+	_CALIBRATION_DP_THRESHOLD_FS_STOP= _CALIBRATION_DP_THRESHOLD_START + WDR_MODE_COUNT,
+	// AE_balanced calibration
+	_CALIBRATION_AE_BALANCED_START,
+	_CALIBRATION_AE_BALANCED_LINEAR = _CALIBRATION_AE_BALANCED_START + WDR_MODE_LINEAR,
+	_CALIBRATION_AE_BALANCED_WDR    = _CALIBRATION_AE_BALANCED_START + WDR_MODE_POSITION,
+	_CALIBRATION_AE_BALANCED_STOP   = _CALIBRATION_AE_BALANCED_START + WDR_MODE_COUNT,
+	//AWB LUX Lut calibration
+	_CALIBRATION_EVTOLUX_EV_LUT_START,
+	_CALIBRATION_EVTOLUX_EV_LUT_LINEAR=_CALIBRATION_EVTOLUX_EV_LUT_START+WDR_MODE_LINEAR,
+	_CALIBRATION_EVTOLUX_EV_LUT_FS_HDR=_CALIBRATION_EVTOLUX_EV_LUT_START+WDR_MODE_FS_HDR,
+	_CALIBRATION_EVTOLUX_EV_LUT_NATIVE=_CALIBRATION_EVTOLUX_EV_LUT_START+WDR_MODE_NATIVE,
+	_CALIBRATION_EVTOLUX_EV_LUT_FS_LIN=_CALIBRATION_EVTOLUX_EV_LUT_START+ WDR_MODE_FS_LIN,
+	_CALIBRATION_EVTOLUX_EV_LUT_STOP=_CALIBRATION_EVTOLUX_EV_LUT_START+WDR_MODE_COUNT,
+	// mesh shading for linear and wdr modes
+	_CALIBRATION_SHADING_LS_A_R_START,
+	_CALIBRATION_SHADING_LS_A_R_LINEAR = _CALIBRATION_SHADING_LS_A_R_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_A_R_WDR    = _CALIBRATION_SHADING_LS_A_R_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_A_R_STOP   = _CALIBRATION_SHADING_LS_A_R_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_A_G_START,
+	_CALIBRATION_SHADING_LS_A_G_LINEAR = _CALIBRATION_SHADING_LS_A_G_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_A_G_WDR    = _CALIBRATION_SHADING_LS_A_G_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_A_G_STOP   = _CALIBRATION_SHADING_LS_A_G_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_A_B_START,
+	_CALIBRATION_SHADING_LS_A_B_LINEAR = _CALIBRATION_SHADING_LS_A_B_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_A_B_WDR    = _CALIBRATION_SHADING_LS_A_B_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_A_B_STOP   = _CALIBRATION_SHADING_LS_A_B_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_TL84_R_START,
+	_CALIBRATION_SHADING_LS_TL84_R_LINEAR = _CALIBRATION_SHADING_LS_TL84_R_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_TL84_R_WDR    = _CALIBRATION_SHADING_LS_TL84_R_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_TL84_R_STOP   = _CALIBRATION_SHADING_LS_TL84_R_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_TL84_G_START,
+	_CALIBRATION_SHADING_LS_TL84_G_LINEAR = _CALIBRATION_SHADING_LS_TL84_G_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_TL84_G_WDR    = _CALIBRATION_SHADING_LS_TL84_G_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_TL84_G_STOP   = _CALIBRATION_SHADING_LS_TL84_G_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_TL84_B_START,
+	_CALIBRATION_SHADING_LS_TL84_B_LINEAR = _CALIBRATION_SHADING_LS_TL84_B_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_TL84_B_WDR    = _CALIBRATION_SHADING_LS_TL84_B_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_TL84_B_STOP   = _CALIBRATION_SHADING_LS_TL84_B_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_D65_R_START,
+	_CALIBRATION_SHADING_LS_D65_R_LINEAR = _CALIBRATION_SHADING_LS_D65_R_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_D65_R_WDR    = _CALIBRATION_SHADING_LS_D65_R_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_D65_R_STOP   = _CALIBRATION_SHADING_LS_D65_R_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_D65_G_START,
+	_CALIBRATION_SHADING_LS_D65_G_LINEAR = _CALIBRATION_SHADING_LS_D65_G_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_D65_G_WDR    = _CALIBRATION_SHADING_LS_D65_G_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_D65_G_STOP   = _CALIBRATION_SHADING_LS_D65_G_START + WDR_MODE_COUNT,
+
+	_CALIBRATION_SHADING_LS_D65_B_START,
+	_CALIBRATION_SHADING_LS_D65_B_LINEAR = _CALIBRATION_SHADING_LS_D65_B_START + WDR_MODE_LINEAR,
+	_CALIBRATION_SHADING_LS_D65_B_WDR    = _CALIBRATION_SHADING_LS_D65_B_START + WDR_MODE_POSITION,
+	_CALIBRATION_SHADING_LS_D65_B_STOP   = _CALIBRATION_SHADING_LS_D65_B_START + WDR_MODE_COUNT,
+
+	// non hdr settings
+	_CALIBRATION_STITCHING_ERROR_THRESH,
+	_CALIBRATION_MESH_SHADING_STRENGTH,
+	_CALIBRATION_IRIDIX_RGB2REC709,
+	_CALIBRATION_IRIDIX_REC709TORGB,
+	_CALIBRATION_TEMPER_STRENGTH,
+	_CALIBRATION_AE_EXPOSURE_CORRECTION,
+	_CALIBRATION_IRIDIX_ASYMMETRY,
+	_CALIBRATION_IRIDIX_BLACK_PRC,
+	_CALIBRATION_IRIDIX_GAIN_MAX,
+	_CALIBRATION_IRIDIX_MIN_MAX_STR,
+	_CALIBRATION_IRIDIX_EV_LIM_FULL_STR,
+	_CALIBRATION_LUXLOW_LUT,
+	_CALIBRATION_MT_ABSOLUTE_LS_A_CCM_LINEAR,
+	_CALIBRATION_MESH_COLOR_TEMPERATURE,
+	_CALIBRATION_RGHIGH_LUT_MIN,
+	_CALIBRATION_CT30POS,
+	_CALIBRATION_MESH_LS_WEIGHT,
+	_CALIBRATION_AWB_WARMING_LS_D50,
+	_CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_LINEAR,
+	_CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_LINEAR,
+	_CALIBRATION_CT65POS,
+	_CALIBRATION_AUTO_WB,
+	_CALIBRATION_AWB_WARMING_LS_A,
+	_CALIBRATION_CT_RG_POS_CALC,
+	_CALIBRATION_RGHIGH_LUT_MAX,
+	_CALIBRATION_RG_POS,
+	_CALIBRATION_LUXLOW_LUT_STEP,
+	_CALIBRATION_CT_BG_POS_CALC,
+	_CALIBRATION_RGLOW_LUT_STEP,
+	_CALIBRATION_WB_STRENGTH,
+	_CALIBRATION_LUXLOW_LUT_MIN,
+	_CALIBRATION_SKIN_TONE_CCM,
+	_CALIBRATION_STATIC_WB,
+	_CALIBRATION_AWB_WARMING_LS_D40,
+	_CALIBRATION_COLOR_TEMP,
+	_CALIBRATION_RGLOW_LUT_MIN,
+	_CALIBRATION_MT_ABSOLUTE_LS_D40_CCM_HDR,
+	_CALIBRATION_MESH_RGBG_WEIGHT,
+	_CALIBRATION_LIGHT_SRC,
+	_CALIBRATION_RGLOW_LUT_MAX,
+	_CALIBRATION_CT40POS,
+	_CALIBRATION_MT_ABSOLUTE_LS_A_CCM_HDR,
+	_CALIBRATION_EVTOLUX_LUX_LUT,
+	_CALIBRATION_LUXHIGH_LUT_STEP,
+	_CALIBRATION_RGHIGH_LUT,
+	_CALIBRATION_LUXLOW_LUT_MAX,
+	_CALIBRATION_SKY_LUX_TH,
+	_CALIBRATION_RGLOW_LUT,
+	_CALIBRATION_MT_ABSOLUTE_LS_D50_CCM_HDR,
+	_CALIBRATION_LUXHIGH_LUT_MIN,
+	_CALIBRATION_BG_POS,
+	_CALIBRATION_LUXHIGH_LUT_MAX,
+	_CALIBRATION_LUXHIGH_LUT,
+	_CALIBRATION_RGHIGH_LUT_STEP,
+	_CALIBRATION_AWB_SCENE_PRESETS,
+	_CALIBRATION_CNR_UV_DELTA12_SLOPE,
+	_CALIBRATION_AF_MIN_TABLE,
+	_CALIBRATION_AF_MAX_TABLE,
+	_CALIBRATION_AF_WINDOW_RESIZE_TABLE,
+	_CALIBRATION_EXP_RATIO_TABLE,
+	_CALIBRATION_IRIDIX_STRENGTH_TABLE,
+	_CALIBRATION_AWB_AVG_COEF,
+	_CALIBRATION_IRIDIX_AVG_COEF,
+	_CALIBRATION_AE_EXPOSURE_AVG_COEF,
+	_CALIBRATION_CCM_ONE_GAIN_THRESHOLD,
+	_CALIBRATION_NP_LUT_MEAN,
+	_CALIBRATION_EVTOLUX_PROBABILITY_ENABLE,
+	_CALIBRATION_DEFECT_PIXELS,
+	_CALIBRATION_FLASH_RG,
+	_CALIBRATION_FLASH_BG,
+	_CALIBRATION_AF_LMS,
+	_CALIBRATION_SINTER_RADIAL_LUT,
+	_CALIBRATION_SINTER_RADIAL_PARAMS,
+	_CALIBRATION_GDC_CONFIG,
+	_CALIBRATION_BLACK_LEVEL_FS,
+	_CALIBRATION_RGB2YUV_CONVERSION,
+	_CALIBRATION_TOTAL_SIZE
+} ;
+
+
+
+typedef struct _ApicalCalibrations {
+	LookupTable* calibrations[ _CALIBRATION_TOTAL_SIZE ] ;
+} ApicalCalibrations ;
+
+
+#endif // __APICAL_ISP_CALIBRATIONS_H__
+
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_configuration.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_configuration.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_configuration.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_configuration.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,28 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_CONFIGURATION_H__
+#define __APICAL_CONFIGURATION_H__
+
+
+#include "apical_isp_io.h"
+#include "apical_types.h"
+#include "apical_ext_config.h"
+#include "apical_firmware_config.h"
+#include "apical_sensor_config.h"
+#include "apical_isp_config.h"
+#if APICAL_ISP_PROFILING
+#include "apical_profiler.h"
+#endif
+
+
+#endif /* __APICAL_CONFIGURATION_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_defect_pixel_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_defect_pixel_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_defect_pixel_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_defect_pixel_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_DEFECT_PIXEL_MEM_CONFIG_H__
+#define __APICAL_DEFECT_PIXEL_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'defect_pixel_mem' of module 'defect_pixel_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_DEFECT_PIXEL_MEM_BASE_ADDR (0xc000L)
+#define APICAL_DEFECT_PIXEL_MEM_SIZE (0x4000)
+
+#define APICAL_DEFECT_PIXEL_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_DEFECT_PIXEL_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-4095), data (32-bit)
+static __inline void apical_defect_pixel_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0xc000L + (index << 2), data);
+}
+static __inline uint32_t apical_defect_pixel_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0xc000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_DEFECT_PIXEL_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_gamma_rgb_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_gamma_rgb_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_gamma_rgb_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_gamma_rgb_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_DS1_GAMMA_RGB_MEM_CONFIG_H__
+#define __APICAL_DS1_GAMMA_RGB_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'ds1_gamma_rgb_mem' of module 'gamma_rgb_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_DS1_GAMMA_RGB_MEM_BASE_ADDR (0x11000L)
+#define APICAL_DS1_GAMMA_RGB_MEM_SIZE (0x400)
+
+#define APICAL_DS1_GAMMA_RGB_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_DS1_GAMMA_RGB_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-128), data (32-bit)
+static __inline void apical_ds1_gamma_rgb_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x11000L + (index << 2), data);
+}
+static __inline uint32_t apical_ds1_gamma_rgb_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x11000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_DS1_GAMMA_RGB_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_sharpen_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_sharpen_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_sharpen_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds1_sharpen_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_DS1_SHARPEN_MEM_CONFIG_H__
+#define __APICAL_DS1_SHARPEN_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'ds1_sharpen_mem' of module 'sharpen_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_DS1_SHARPEN_MEM_BASE_ADDR (0x11800L)
+#define APICAL_DS1_SHARPEN_MEM_SIZE (0x800)
+
+#define APICAL_DS1_SHARPEN_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_DS1_SHARPEN_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-511), data (32-bit)
+static __inline void apical_ds1_sharpen_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x11800L + (index << 2), data);
+}
+static __inline uint32_t apical_ds1_sharpen_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x11800L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_DS1_SHARPEN_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_gamma_rgb_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_gamma_rgb_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_gamma_rgb_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_gamma_rgb_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_DS2_GAMMA_RGB_MEM_CONFIG_H__
+#define __APICAL_DS2_GAMMA_RGB_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'ds2_gamma_rgb_mem' of module 'gamma_rgb_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_DS2_GAMMA_RGB_MEM_BASE_ADDR (0x12000L)
+#define APICAL_DS2_GAMMA_RGB_MEM_SIZE (0x400)
+
+#define APICAL_DS2_GAMMA_RGB_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_DS2_GAMMA_RGB_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-128), data (32-bit)
+static __inline void apical_ds2_gamma_rgb_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x12000L + (index << 2), data);
+}
+static __inline uint32_t apical_ds2_gamma_rgb_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x12000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_DS2_GAMMA_RGB_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_sharpen_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_sharpen_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_sharpen_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ds2_sharpen_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_DS2_SHARPEN_MEM_CONFIG_H__
+#define __APICAL_DS2_SHARPEN_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'ds2_sharpen_mem' of module 'sharpen_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_DS2_SHARPEN_MEM_BASE_ADDR (0x12800L)
+#define APICAL_DS2_SHARPEN_MEM_SIZE (0x800)
+
+#define APICAL_DS2_SHARPEN_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_DS2_SHARPEN_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-511), data (32-bit)
+static __inline void apical_ds2_sharpen_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x12800L + (index << 2), data);
+}
+static __inline uint32_t apical_ds2_sharpen_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x12800L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_DS2_SHARPEN_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ext_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ext_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_ext_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_ext_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,2781 @@
+#ifndef __APICAL_EXT_CONFIG_H__
+#define __APICAL_EXT_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'ext' of module 'ext_config'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_BASE_ADDR (0x40000L)
+#define APICAL_EXT_SIZE (0x200)
+
+// ------------------------------------------------------------------------------ //
+// Group: Sync
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frame size and sync timing
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Offset X
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset in pixels from v-sync reference to start of active video
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_OFFSET_X_DEFAULT (0x000)
+#define APICAL_EXT_SYNC_OFFSET_X_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_offset_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40000L);
+	APICAL_WRITE_32(0x40000L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_ext_sync_offset_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40000L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Offset Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset in lines from v-sync reference to start of active video
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_OFFSET_Y_DEFAULT (0x000)
+#define APICAL_EXT_SYNC_OFFSET_Y_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_offset_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40000L);
+	APICAL_WRITE_32(0x40000L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
+}
+static __inline uint16_t apical_ext_sync_offset_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40000L) & 0xfff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Total Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Total frame width including horizontal blanking
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_TOTAL_WIDTH_DEFAULT (0x672)
+#define APICAL_EXT_SYNC_TOTAL_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_total_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40004L);
+	APICAL_WRITE_32(0x40004L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sync_total_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40004L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Total Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Total frame height including vertical blanking
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_TOTAL_HEIGHT_DEFAULT (0x2EE)
+#define APICAL_EXT_SYNC_TOTAL_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_total_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40004L);
+	APICAL_WRITE_32(0x40004L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_total_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40004L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Active Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_ACTIVE_WIDTH_DEFAULT (0x500)
+#define APICAL_EXT_SYNC_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40008L);
+	APICAL_WRITE_32(0x40008L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sync_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40008L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Active Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_ACTIVE_HEIGHT_DEFAULT (0x2D0)
+#define APICAL_EXT_SYNC_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40008L);
+	APICAL_WRITE_32(0x40008L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40008L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H Front Porch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal sync front porch (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_H_FRONT_PORCH_DEFAULT (0x048)
+#define APICAL_EXT_SYNC_H_FRONT_PORCH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_h_front_porch_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4000cL);
+	APICAL_WRITE_32(0x4000cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_ext_sync_h_front_porch_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4000cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V Front Porch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical sync front porch (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_V_FRONT_PORCH_DEFAULT (0x003)
+#define APICAL_EXT_SYNC_V_FRONT_PORCH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_v_front_porch_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4000cL);
+	APICAL_WRITE_32(0x4000cL, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
+}
+static __inline uint16_t apical_ext_sync_v_front_porch_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4000cL) & 0xfff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H-Sync Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal sync width (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_H_SYNC_WIDTH_DEFAULT (0x50)
+#define APICAL_EXT_SYNC_H_SYNC_WIDTH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_h_sync_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40010L);
+	APICAL_WRITE_32(0x40010L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_ext_sync_h_sync_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40010L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V-Sync Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical sync width (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_V_SYNC_WIDTH_DEFAULT (0x5)
+#define APICAL_EXT_SYNC_V_SYNC_WIDTH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_v_sync_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40010L);
+	APICAL_WRITE_32(0x40010L, (((uint32_t) (data & 0xfff)) << 16) | (curr & 0xf000ffff));
+}
+static __inline uint16_t apical_ext_sync_v_sync_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40010L) & 0xfff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_CONTROL_DEFAULT (0x8D)
+#define APICAL_EXT_SYNC_CONTROL_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_sync_control_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40014L);
+	APICAL_WRITE_32(0x40014L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_sync_control_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40014L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H Sync Out Pol
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal sync out polarity (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_H_SYNC_OUT_POL_DEFAULT (0x0)
+#define APICAL_EXT_SYNC_H_SYNC_OUT_POL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_h_sync_out_pol_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40014L);
+	APICAL_WRITE_32(0x40014L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_ext_sync_h_sync_out_pol_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40014L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V Sync Out Pol
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical sync out polarity (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_V_SYNC_OUT_POL_DEFAULT (0x0)
+#define APICAL_EXT_SYNC_V_SYNC_OUT_POL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_v_sync_out_pol_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40014L);
+	APICAL_WRITE_32(0x40014L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_ext_sync_v_sync_out_pol_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40014L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: DVI Tx Clock Edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// DVI output clock edge: 0=falling 1=rising
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_DVI_TX_CLOCK_EDGE_DEFAULT (0)
+#define APICAL_EXT_SYNC_DVI_TX_CLOCK_EDGE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_dvi_tx_clock_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_ext_sync_dvi_tx_clock_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: DVI Rx Clock Edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Video input clock phase: 0=0 1=90 2=180 3=270
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_DVI_RX_CLOCK_EDGE_DEFAULT (2)
+#define APICAL_EXT_SYNC_DVI_RX_CLOCK_EDGE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_ext_sync_dvi_rx_clock_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
+}
+static __inline uint8_t apical_ext_sync_dvi_rx_clock_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x6) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H Sync In Pol
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_H_SYNC_IN_POL_DEFAULT (0)
+#define APICAL_EXT_SYNC_H_SYNC_IN_POL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_h_sync_in_pol_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_ext_sync_h_sync_in_pol_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V Sync In Pol
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_V_SYNC_IN_POL_DEFAULT (0)
+#define APICAL_EXT_SYNC_V_SYNC_IN_POL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_v_sync_in_pol_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_ext_sync_v_sync_in_pol_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Field Mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_FIELD_MODE_DEFAULT (0)
+#define APICAL_EXT_SYNC_FIELD_MODE_DATASIZE (2)
+#define APICAL_EXT_SYNC_FIELD_MODE_SAME_AS_EXTERNAL (0)
+#define APICAL_EXT_SYNC_FIELD_MODE_ADJUST_WITH_ACTIVELINE (1)
+#define APICAL_EXT_SYNC_FIELD_MODE_ADJUST_WITH_VSYNC (2)
+#define APICAL_EXT_SYNC_FIELD_MODE_RESERVED (3)
+
+// args: data (2-bit)
+static __inline void apical_ext_sync_field_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x3)) << 12) | (curr & 0xffffcfff));
+}
+static __inline uint8_t apical_ext_sync_field_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x3000) >> 12);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Auto Pos
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_AUTO_POS_DEFAULT (0)
+#define APICAL_EXT_SYNC_AUTO_POS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_auto_pos_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x1)) << 14) | (curr & 0xffffbfff));
+}
+static __inline uint8_t apical_ext_sync_auto_pos_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x4000) >> 14);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Auto Size
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_AUTO_SIZE_DEFAULT (0)
+#define APICAL_EXT_SYNC_AUTO_SIZE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_auto_size_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40020L);
+	APICAL_WRITE_32(0x40020L, (((uint32_t) (data & 0x1)) << 15) | (curr & 0xffff7fff));
+}
+static __inline uint8_t apical_ext_sync_auto_size_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40020L) & 0x8000) >> 15);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max line length
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_MAX_LINE_LENGTH_DEFAULT (0xfff)
+#define APICAL_EXT_SYNC_MAX_LINE_LENGTH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_max_line_length_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_ext_sync_max_line_length_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40030L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max line length dis y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_MAX_LINE_LENGTH_DIS_Y_DEFAULT (0xfff)
+#define APICAL_EXT_SYNC_MAX_LINE_LENGTH_DIS_Y_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_ext_sync_max_line_length_dis_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4003cL);
+	APICAL_WRITE_32(0x4003cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_ext_sync_max_line_length_dis_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4003cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Input field toggle
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_INPUT_FIELD_TOGGLE_DEFAULT (0)
+#define APICAL_EXT_SYNC_INPUT_FIELD_TOGGLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_input_field_toggle_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_ext_sync_input_field_toggle_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Input field polarity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_INPUT_FIELD_POLARITY_DEFAULT (0)
+#define APICAL_EXT_SYNC_INPUT_FIELD_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_input_field_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_ext_sync_input_field_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output field manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_OUTPUT_FIELD_MANUAL_DEFAULT (0)
+#define APICAL_EXT_SYNC_OUTPUT_FIELD_MANUAL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_output_field_manual_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_ext_sync_output_field_manual_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output field value
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_OUTPUT_FIELD_VALUE_DEFAULT (0)
+#define APICAL_EXT_SYNC_OUTPUT_FIELD_VALUE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_output_field_value_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_ext_sync_output_field_value_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Jumbo Frame mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_JUMBO_FRAME_MODE_DEFAULT (0)
+#define APICAL_EXT_SYNC_JUMBO_FRAME_MODE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_jumbo_frame_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 19) | (curr & 0xfff7ffff));
+}
+static __inline uint8_t apical_ext_sync_jumbo_frame_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x80000) >> 19);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mask enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enable masking of frame edges based on the values of Mask x and Mask y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_MASK_ENABLE_DEFAULT (0)
+#define APICAL_EXT_SYNC_MASK_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_mask_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 22) | (curr & 0xffbfffff));
+}
+static __inline uint8_t apical_ext_sync_mask_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x400000) >> 22);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mask auto
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Calculate mask size based on offsets
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_MASK_AUTO_DEFAULT (0)
+#define APICAL_EXT_SYNC_MASK_AUTO_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_sync_mask_auto_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40030L);
+	APICAL_WRITE_32(0x40030L, (((uint32_t) (data & 0x1)) << 23) | (curr & 0xff7fffff));
+}
+static __inline uint8_t apical_ext_sync_mask_auto_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40030L) & 0x800000) >> 23);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dis offset x
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_DIS_OFFSET_X_DEFAULT (0)
+#define APICAL_EXT_SYNC_DIS_OFFSET_X_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_sync_dis_offset_x_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40034L);
+	APICAL_WRITE_32(0x40034L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_sync_dis_offset_x_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40034L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dis offset y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_DIS_OFFSET_Y_DEFAULT (0)
+#define APICAL_EXT_SYNC_DIS_OFFSET_Y_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_sync_dis_offset_y_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40034L);
+	APICAL_WRITE_32(0x40034L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_sync_dis_offset_y_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40034L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Scale y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_SCALE_Y_DEFAULT (0)
+#define APICAL_EXT_SYNC_SCALE_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_scale_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40034L);
+	APICAL_WRITE_32(0x40034L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_scale_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40034L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Skew x
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_SKEW_X_DEFAULT (0)
+#define APICAL_EXT_SYNC_SKEW_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_skew_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40038L);
+	APICAL_WRITE_32(0x40038L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sync_skew_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40038L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mask x
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_MASK_X_DEFAULT (0)
+#define APICAL_EXT_SYNC_MASK_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_mask_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40038L);
+	APICAL_WRITE_32(0x40038L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_mask_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40038L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mask y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_MASK_Y_DEFAULT (0)
+#define APICAL_EXT_SYNC_MASK_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_mask_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4003cL);
+	APICAL_WRITE_32(0x4003cL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_mask_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4003cL) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: TG Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// sensor TG full line length
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_TG_WIDTH_DEFAULT (2401)
+#define APICAL_EXT_SYNC_TG_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_tg_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40040L);
+	APICAL_WRITE_32(0x40040L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sync_tg_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40040L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: TG Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// sensor TG full frame height
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_TG_HEIGHT_DEFAULT (1125)
+#define APICAL_EXT_SYNC_TG_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_tg_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40040L);
+	APICAL_WRITE_32(0x40040L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_tg_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40040L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Temper Active Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_TEMPER_ACTIVE_WIDTH_DEFAULT (0x500)
+#define APICAL_EXT_SYNC_TEMPER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_temper_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40048L);
+	APICAL_WRITE_32(0x40048L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sync_temper_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40048L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Temper Active Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYNC_TEMPER_ACTIVE_HEIGHT_DEFAULT (0x2D0)
+#define APICAL_EXT_SYNC_TEMPER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sync_temper_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40048L);
+	APICAL_WRITE_32(0x40048L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sync_temper_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40048L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Group: System CCM
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// System reference CCM
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Coefft R-R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for red-red multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_R_R_DEFAULT (0x01D0)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_R_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_r_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40080L);
+	APICAL_WRITE_32(0x40080L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_r_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40080L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft R-G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for red-green multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_R_G_DEFAULT (0x8150)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_R_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_r_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40080L);
+	APICAL_WRITE_32(0x40080L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_r_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40080L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft R-B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for red-blue multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_R_B_DEFAULT (0x0080)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_R_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_r_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40084L);
+	APICAL_WRITE_32(0x40084L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_r_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40084L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft G-R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for green-red multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_G_R_DEFAULT (0x8050)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_G_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_g_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40084L);
+	APICAL_WRITE_32(0x40084L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_g_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40084L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft G-G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for green-green multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_G_G_DEFAULT (0x01A0)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_G_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_g_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40088L);
+	APICAL_WRITE_32(0x40088L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_g_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40088L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft G-B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for green-blue multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_G_B_DEFAULT (0x8050)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_G_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_g_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40088L);
+	APICAL_WRITE_32(0x40088L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_g_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40088L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft B-R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for blue-red multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_B_R_DEFAULT (0x8030)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_B_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_b_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4008cL);
+	APICAL_WRITE_32(0x4008cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_b_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4008cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft B-G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for blue-green multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_B_G_DEFAULT (0x80C0)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_B_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_b_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4008cL);
+	APICAL_WRITE_32(0x4008cL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_b_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4008cL) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft B-B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for blue-blue multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_B_B_DEFAULT (0x01F0)
+#define APICAL_EXT_SYSTEM_CCM_COEFFT_B_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_ccm_coefft_b_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40090L);
+	APICAL_WRITE_32(0x40090L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_system_ccm_coefft_b_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40090L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Exposure Status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Exposure status registers
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Analog gain status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Analog gain status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_ANALOG_GAIN_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_ANALOG_GAIN_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_exposure_status_analog_gain_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a8L);
+	APICAL_WRITE_32(0x400a8L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_exposure_status_analog_gain_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400a8L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coarse digital gain status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Coarse digital gain status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_COARSE_DIGITAL_GAIN_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_COARSE_DIGITAL_GAIN_STATUS_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_exposure_status_coarse_digital_gain_status_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_exposure_status_coarse_digital_gain_status_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400a0L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Fine digital gain status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Fine digital gain status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_FINE_DIGITAL_GAIN_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_FINE_DIGITAL_GAIN_STATUS_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_ext_exposure_status_fine_digital_gain_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0x3ff)) << 16) | (curr & 0xfc00ffff));
+}
+static __inline uint16_t apical_ext_exposure_status_fine_digital_gain_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400a0L) & 0x3ff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long integration time status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Long integration time status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_LONG_INTEGRATION_TIME_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_LONG_INTEGRATION_TIME_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_exposure_status_long_integration_time_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a4L);
+	APICAL_WRITE_32(0x400a4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_exposure_status_long_integration_time_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400a4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Short integration time status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Short integration time status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_SHORT_INTEGRATION_TIME_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_SHORT_INTEGRATION_TIME_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_exposure_status_short_integration_time_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a4L);
+	APICAL_WRITE_32(0x400a4L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_exposure_status_short_integration_time_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400a4L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Average brightness status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Average brightness status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_AVERAGE_BRIGHTNESS_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_AVERAGE_BRIGHTNESS_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_exposure_status_average_brightness_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a8L);
+	APICAL_WRITE_32(0x400a8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_exposure_status_average_brightness_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400a8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Illumination status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor Illumination status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_ILLUMINATION_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_ILLUMINATION_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_exposure_status_illumination_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400acL);
+	APICAL_WRITE_32(0x400acL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_exposure_status_illumination_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400acL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Exposure Ratio status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor Illumination status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_EXPOSURE_RATIO_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_EXPOSURE_RATIO_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_exposure_status_exposure_ratio_status_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400acL);
+	APICAL_WRITE_32(0x400acL, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_exposure_status_exposure_ratio_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400acL) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Anti-flicker status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_ANTI_FLICKER_STATUS_DEFAULT (0x0)
+#define APICAL_EXT_EXPOSURE_STATUS_ANTI_FLICKER_STATUS_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_exposure_status_anti_flicker_status_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_exposure_status_anti_flicker_status_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400a0L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Short overexposed
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Short overexposed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_SHORT_OVEREXPOSED_DEFAULT (0)
+#define APICAL_EXT_EXPOSURE_STATUS_SHORT_OVEREXPOSED_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_exposure_status_short_overexposed_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_ext_exposure_status_short_overexposed_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400a0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Short underexposed
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Short underexposed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_SHORT_UNDEREXPOSED_DEFAULT (0)
+#define APICAL_EXT_EXPOSURE_STATUS_SHORT_UNDEREXPOSED_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_exposure_status_short_underexposed_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_ext_exposure_status_short_underexposed_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400a0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long overexposed
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Long overexposed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_LONG_OVEREXPOSED_DEFAULT (0)
+#define APICAL_EXT_EXPOSURE_STATUS_LONG_OVEREXPOSED_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_exposure_status_long_overexposed_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_ext_exposure_status_long_overexposed_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400a0L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long underexposed
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Long underexposed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_EXPOSURE_STATUS_LONG_UNDEREXPOSED_DEFAULT (0)
+#define APICAL_EXT_EXPOSURE_STATUS_LONG_UNDEREXPOSED_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_exposure_status_long_underexposed_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400a0L);
+	APICAL_WRITE_32(0x400a0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_ext_exposure_status_long_underexposed_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400a0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sensor Access
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Indirect access to sensor registers
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Custom sensor addr0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor address register 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_ADDR0_DEFAULT (0xFFFF)
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_ADDR0_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sensor_access_custom_sensor_addr0_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400b0L);
+	APICAL_WRITE_32(0x400b0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sensor_access_custom_sensor_addr0_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400b0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Custom sensor data0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor data register 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_DATA0_DEFAULT (0x0)
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_DATA0_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sensor_access_custom_sensor_data0_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400b0L);
+	APICAL_WRITE_32(0x400b0L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sensor_access_custom_sensor_data0_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400b0L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Custom sensor addr1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor address register 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_ADDR1_DEFAULT (0xFFFF)
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_ADDR1_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sensor_access_custom_sensor_addr1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400b4L);
+	APICAL_WRITE_32(0x400b4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sensor_access_custom_sensor_addr1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400b4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Custom sensor data1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor data register 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_DATA1_DEFAULT (0x0)
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_DATA1_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sensor_access_custom_sensor_data1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400b4L);
+	APICAL_WRITE_32(0x400b4L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sensor_access_custom_sensor_data1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400b4L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Custom sensor addr2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor address register 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_ADDR2_DEFAULT (0xFFFF)
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_ADDR2_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sensor_access_custom_sensor_addr2_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400b8L);
+	APICAL_WRITE_32(0x400b8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_sensor_access_custom_sensor_addr2_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400b8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Custom sensor data2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor data register 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_DATA2_DEFAULT (0x0)
+#define APICAL_EXT_SENSOR_ACCESS_CUSTOM_SENSOR_DATA2_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_sensor_access_custom_sensor_data2_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x400b8L);
+	APICAL_WRITE_32(0x400b8L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_sensor_access_custom_sensor_data2_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x400b8L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Group: General Purpose
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Miscellaneous registers
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: gpi
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Status of push buttons
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_GPI_DEFAULT (0x0)
+#define APICAL_EXT_GENERAL_PURPOSE_GPI_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline uint8_t apical_ext_general_purpose_gpi_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c0L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: illumination target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// debug register 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_ILLUMINATION_TARGET_DEFAULT (0xFF)
+#define APICAL_EXT_GENERAL_PURPOSE_ILLUMINATION_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_general_purpose_illumination_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400c4L);
+	APICAL_WRITE_32(0x400c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_general_purpose_illumination_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: equilibrium point
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// debug register 2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_EQUILIBRIUM_POINT_DEFAULT (0x0)
+#define APICAL_EXT_GENERAL_PURPOSE_EQUILIBRIUM_POINT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_general_purpose_equilibrium_point_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400c4L);
+	APICAL_WRITE_32(0x400c4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_general_purpose_equilibrium_point_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: iris rate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// debug register 3
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_IRIS_RATE_DEFAULT (0xFF)
+#define APICAL_EXT_GENERAL_PURPOSE_IRIS_RATE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_general_purpose_iris_rate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400c8L);
+	APICAL_WRITE_32(0x400c8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_general_purpose_iris_rate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: debug 4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// debug register 4
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_DEBUG_4_DEFAULT (0xFF)
+#define APICAL_EXT_GENERAL_PURPOSE_DEBUG_4_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_general_purpose_debug_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400c8L);
+	APICAL_WRITE_32(0x400c8L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_general_purpose_debug_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c8L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: debug 5
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// debug register 5
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_DEBUG_5_DEFAULT (0xFF)
+#define APICAL_EXT_GENERAL_PURPOSE_DEBUG_5_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_general_purpose_debug_5_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400c8L);
+	APICAL_WRITE_32(0x400c8L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_general_purpose_debug_5_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c8L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: debug 6
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// debug register 6
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_DEBUG_6_DEFAULT (0xFF)
+#define APICAL_EXT_GENERAL_PURPOSE_DEBUG_6_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_general_purpose_debug_6_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400c8L);
+	APICAL_WRITE_32(0x400c8L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_general_purpose_debug_6_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400c8L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: misc control
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 32 bit control output
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_GENERAL_PURPOSE_MISC_CONTROL_DEFAULT (0x00000001)
+#define APICAL_EXT_GENERAL_PURPOSE_MISC_CONTROL_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_ext_general_purpose_misc_control_write(uint32_t data) {
+	APICAL_WRITE_32(0x400ccL, data);
+}
+static __inline uint32_t apical_ext_general_purpose_misc_control_read(void) {
+	return APICAL_READ_32(0x400ccL);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Flash interface
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Flash controller
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Trigger Select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Xenon flash trigger mode: 0 - Manual, 1 - from sensor, 2 - from timing generator, 3 - reserved
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_TRIGGER_SELECT_DEFAULT (00)
+#define APICAL_EXT_FLASH_INTERFACE_TRIGGER_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_ext_flash_interface_trigger_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400d0L);
+	APICAL_WRITE_32(0x400d0L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_ext_flash_interface_trigger_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d0L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sensor strobe polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 - invert sensor strobe
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_SENSOR_STROBE_POLARITY_DEFAULT (0)
+#define APICAL_EXT_FLASH_INTERFACE_SENSOR_STROBE_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_flash_interface_sensor_strobe_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400d0L);
+	APICAL_WRITE_32(0x400d0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_ext_flash_interface_sensor_strobe_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d0L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF LED Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Turn on AF LED
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_AF_LED_ENABLE_DEFAULT (00)
+#define APICAL_EXT_FLASH_INTERFACE_AF_LED_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_flash_interface_af_led_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400d0L);
+	APICAL_WRITE_32(0x400d0L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_ext_flash_interface_af_led_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d0L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Charge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Charge the flash module
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_CHARGE_DEFAULT (00)
+#define APICAL_EXT_FLASH_INTERFACE_CHARGE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_flash_interface_charge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400d0L);
+	APICAL_WRITE_32(0x400d0L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_ext_flash_interface_charge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d0L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Flash trigger
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 - invert sensor strobe
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_FLASH_TRIGGER_DEFAULT (00)
+#define APICAL_EXT_FLASH_INTERFACE_FLASH_TRIGGER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_flash_interface_flash_trigger_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400d0L);
+	APICAL_WRITE_32(0x400d0L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_ext_flash_interface_flash_trigger_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d0L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Flash ready
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 - flash is charged
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_FLASH_READY_DEFAULT (0x0)
+#define APICAL_EXT_FLASH_INTERFACE_FLASH_READY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_ext_flash_interface_flash_ready_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Flash strobe
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// strobe signal from sensor module
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_FLASH_INTERFACE_FLASH_STROBE_DEFAULT (0x0)
+#define APICAL_EXT_FLASH_INTERFACE_FLASH_STROBE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_ext_flash_interface_flash_strobe_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400d4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Group: System
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_ADDR_MIN 0x40100L
+#define APICAL_EXT_SYSTEM_ADDR_MAX 0x401f7L
+// ------------------------------------------------------------------------------ //
+// High-level interface to the ISP
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Flags1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_FLAGS1_DEFAULT (0x0)
+#define APICAL_EXT_SYSTEM_FLAGS1_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_flags1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_flags1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Freeze Firmware
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Disables firmware and stops updating the ISP
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_FREEZE_FIRMWARE_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_FREEZE_FIRMWARE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_freeze_firmware_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_ext_system_freeze_firmware_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Exposure
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual exposure: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_EXPOSURE_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_EXPOSURE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_exposure_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_ext_system_manual_exposure_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Exposure Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual exposure ratio control
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_EXPOSURE_RATIO_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_EXPOSURE_RATIO_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_exposure_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_ext_system_manual_exposure_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Integration Time
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual Integration time control: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_INTEGRATION_TIME_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_INTEGRATION_TIME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_integration_time_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_ext_system_manual_integration_time_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Sensor Analog Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual control of sensor analog gain: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_SENSOR_ANALOG_GAIN_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_SENSOR_ANALOG_GAIN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_sensor_analog_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_ext_system_manual_sensor_analog_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Sensor Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual control of sensor digital gain: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_SENSOR_DIGITAL_GAIN_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_SENSOR_DIGITAL_GAIN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_sensor_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_ext_system_manual_sensor_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual ISP Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual control of ISP digital gain: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_ISP_DIGITAL_GAIN_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_ISP_DIGITAL_GAIN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_isp_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_ext_system_manual_isp_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Directional Sharpening
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual control of directional sharpening strength: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_DIRECTIONAL_SHARPENING_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_DIRECTIONAL_SHARPENING_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_directional_sharpening_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_ext_system_manual_directional_sharpening_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Flags2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_FLAGS2_DEFAULT (0x0)
+#define APICAL_EXT_SYSTEM_FLAGS2_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_flags2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_flags2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Un-Directional Sharpening
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual control of un-directional sharpening strength: 0=auto 1=manual
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_UN_DIRECTIONAL_SHARPENING_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_UN_DIRECTIONAL_SHARPENING_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_un_directional_sharpening_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_ext_system_manual_un_directional_sharpening_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Iridix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual iridix control - iridix strength target controls iridix strength directly
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_IRIDIX_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_IRIDIX_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_iridix_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_ext_system_manual_iridix_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Sinter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual sinter control - sinter strength target controls sinter strength directly
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_SINTER_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_SINTER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_sinter_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_ext_system_manual_sinter_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Temper
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual temper control - temper strength target controls temper strength directly
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_TEMPER_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_TEMPER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_temper_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_ext_system_manual_temper_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual AWB control
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_AWB_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_MANUAL_AWB_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_awb_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 12) | (curr & 0xffffefff));
+}
+static __inline uint8_t apical_ext_system_manual_awb_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x1000) >> 12);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Antiflicker Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables the Anti Flicker function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_ANTIFLICKER_ENABLE_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_ANTIFLICKER_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_antiflicker_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 13) | (curr & 0xffffdfff));
+}
+static __inline uint8_t apical_ext_system_antiflicker_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x2000) >> 13);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Slow Frame Rate Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables slow frame rates.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SLOW_FRAME_RATE_ENABLE_DEFAULT (1)
+#define APICAL_EXT_SYSTEM_SLOW_FRAME_RATE_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_slow_frame_rate_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 14) | (curr & 0xffffbfff));
+}
+static __inline uint8_t apical_ext_system_slow_frame_rate_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x4000) >> 14);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Saturation
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables manual saturation control
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_SATURATION_DEFAULT (1)
+#define APICAL_EXT_SYSTEM_MANUAL_SATURATION_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_manual_saturation_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40100L);
+	APICAL_WRITE_32(0x40100L, (((uint32_t) (data & 0x1)) << 15) | (curr & 0xffff7fff));
+}
+static __inline uint8_t apical_ext_system_manual_saturation_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40100L) & 0x8000) >> 15);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame rates
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_FRAME_RATES_DEFAULT (0x0)
+#define APICAL_EXT_SYSTEM_FRAME_RATES_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_frame_rates_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40104L);
+	APICAL_WRITE_32(0x40104L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_frame_rates_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40104L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Set fps Base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0000 Force the system to use 60fps as the base frame rate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0001 Force the system to use 50fps as the base frame rate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0010 Force the system to use 30fps as the base frame rate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0011 Force the system to use 25fps as the base frame rate
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SET_FPS_BASE_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_SET_FPS_BASE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_ext_system_set_fps_base_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40104L);
+	APICAL_WRITE_32(0x40104L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_ext_system_set_fps_base_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40104L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Set 1001 rate divider
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Set 1/1.001 rate multiplier to achieve 29.97 FPS
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SET_1001_RATE_DIVIDER_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_SET_1001_RATE_DIVIDER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_set_1001_rate_divider_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40104L);
+	APICAL_WRITE_32(0x40104L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_ext_system_set_1001_rate_divider_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40104L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Half pixel clock
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Corrects internal interface dividers to match the case when pixel clock is slowed down
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_HALF_PIXEL_CLOCK_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_HALF_PIXEL_CLOCK_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_half_pixel_clock_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40104L);
+	APICAL_WRITE_32(0x40104L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_ext_system_half_pixel_clock_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40104L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Calibrate flag
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CALIBRATE_FLAG_DEFAULT (0x0)
+#define APICAL_EXT_SYSTEM_CALIBRATE_FLAG_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_calibrate_flag_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40108L);
+	APICAL_WRITE_32(0x40108L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_calibrate_flag_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40108L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Calibrate Bad Pixels
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Start calibration algorithm for defect pixel correction, bit will be cleared by FW when finished
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_CALIBRATE_BAD_PIXELS_DEFAULT (0)
+#define APICAL_EXT_SYSTEM_CALIBRATE_BAD_PIXELS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_ext_system_calibrate_bad_pixels_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40108L);
+	APICAL_WRITE_32(0x40108L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_ext_system_calibrate_bad_pixels_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40108L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Manual Exposure Time
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sensor integration time (in lines) for manual exposure
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MANUAL_EXPOSURE_TIME_DEFAULT (0x00000000)
+#define APICAL_EXT_SYSTEM_MANUAL_EXPOSURE_TIME_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_ext_system_manual_exposure_time_write(uint32_t data) {
+	APICAL_WRITE_32(0x4010cL, data);
+}
+static __inline uint32_t apical_ext_system_manual_exposure_time_read(void) {
+	return APICAL_READ_32(0x4010cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Exposure Dark Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets dark histogram target.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_EXPOSURE_DARK_TARGET_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_EXPOSURE_DARK_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_exposure_dark_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40110L);
+	APICAL_WRITE_32(0x40110L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_exposure_dark_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40110L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Exposure Bright Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets bright histogram target.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_EXPOSURE_BRIGHT_TARGET_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_EXPOSURE_BRIGHT_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_exposure_bright_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40110L);
+	APICAL_WRITE_32(0x40110L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_exposure_bright_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40110L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Exposure Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Ratio between short and long exposure. A ratio of one gives standard non-wdr mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_EXPOSURE_RATIO_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_EXPOSURE_RATIO_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_exposure_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40110L);
+	APICAL_WRITE_32(0x40110L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_exposure_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40110L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Max Exposure Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum Ratio between short and long exposure in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAX_EXPOSURE_RATIO_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MAX_EXPOSURE_RATIO_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_max_exposure_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40110L);
+	APICAL_WRITE_32(0x40110L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_max_exposure_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40110L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Integration Time
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Manual sensor integration time (in lines)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_INTEGRATION_TIME_DEFAULT (0x0002)
+#define APICAL_EXT_SYSTEM_INTEGRATION_TIME_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_integration_time_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40114L);
+	APICAL_WRITE_32(0x40114L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_ext_system_integration_time_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40114L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Max Integration Time
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum sensor integration time (in lines) for both manual and auto exposure
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAX_INTEGRATION_TIME_DEFAULT (0xFFFF)
+#define APICAL_EXT_SYSTEM_MAX_INTEGRATION_TIME_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_ext_system_max_integration_time_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x40114L);
+	APICAL_WRITE_32(0x40114L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_ext_system_max_integration_time_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x40114L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sensor Analog Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Manual sensor analog gain.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SENSOR_ANALOG_GAIN_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_SENSOR_ANALOG_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_sensor_analog_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40118L);
+	APICAL_WRITE_32(0x40118L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_sensor_analog_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40118L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Max Sensor Analog Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum sensor analogue gain that can be applied.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAX_SENSOR_ANALOG_GAIN_DEFAULT (0x35)
+#define APICAL_EXT_SYSTEM_MAX_SENSOR_ANALOG_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_max_sensor_analog_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40118L);
+	APICAL_WRITE_32(0x40118L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_max_sensor_analog_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40118L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sensor Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Manual sensor digital gain.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SENSOR_DIGITAL_GAIN_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_SENSOR_DIGITAL_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_sensor_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4011cL);
+	APICAL_WRITE_32(0x4011cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_sensor_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4011cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Max Sensor Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum sensor digital gain that can be applied.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAX_SENSOR_DIGITAL_GAIN_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MAX_SENSOR_DIGITAL_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_max_sensor_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4011cL);
+	APICAL_WRITE_32(0x4011cL, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_max_sensor_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4011cL) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ISP Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Manual ISP digital gain.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_ISP_DIGITAL_GAIN_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_ISP_DIGITAL_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_isp_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40120L);
+	APICAL_WRITE_32(0x40120L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_isp_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40120L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Max ISP Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum ISP digital gain that can be applied.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAX_ISP_DIGITAL_GAIN_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MAX_ISP_DIGITAL_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_max_isp_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40120L);
+	APICAL_WRITE_32(0x40120L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_max_isp_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40120L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Directional Sharpening Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Directional sharpening target. In manual mode this directly sets the directional sharpening strength.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DIRECTIONAL_SHARPENING_TARGET_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_DIRECTIONAL_SHARPENING_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_directional_sharpening_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40124L);
+	APICAL_WRITE_32(0x40124L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_directional_sharpening_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40124L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Maximum Directional Sharpening
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum directional sharpening in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAXIMUM_DIRECTIONAL_SHARPENING_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MAXIMUM_DIRECTIONAL_SHARPENING_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_maximum_directional_sharpening_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40124L);
+	APICAL_WRITE_32(0x40124L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_maximum_directional_sharpening_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40124L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Minimum Directional Sharpening
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum directional sharpening in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MINIMUM_DIRECTIONAL_SHARPENING_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MINIMUM_DIRECTIONAL_SHARPENING_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_minimum_directional_sharpening_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40124L);
+	APICAL_WRITE_32(0x40124L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_minimum_directional_sharpening_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40124L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Un-Directional Sharpening Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Un-directional sharpening target. In manual mode this directly sets the un-directional sharpening strength.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_UN_DIRECTIONAL_SHARPENING_TARGET_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_UN_DIRECTIONAL_SHARPENING_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_un_directional_sharpening_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40128L);
+	APICAL_WRITE_32(0x40128L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_un_directional_sharpening_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40128L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Maximum Un-Directional Sharpening
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum un-directional sharpening in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAXIMUM_UN_DIRECTIONAL_SHARPENING_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MAXIMUM_UN_DIRECTIONAL_SHARPENING_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_maximum_un_directional_sharpening_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40128L);
+	APICAL_WRITE_32(0x40128L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_maximum_un_directional_sharpening_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40128L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Minimum Un-Directional Sharpening
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum un-directional sharpening in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MINIMUM_UN_DIRECTIONAL_SHARPENING_DEFAULT (0x08)
+#define APICAL_EXT_SYSTEM_MINIMUM_UN_DIRECTIONAL_SHARPENING_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_minimum_un_directional_sharpening_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40128L);
+	APICAL_WRITE_32(0x40128L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_minimum_un_directional_sharpening_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40128L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Iridix Strength Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Manual setting for Iridix strength
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_IRIDIX_STRENGTH_TARGET_DEFAULT (0x80)
+#define APICAL_EXT_SYSTEM_IRIDIX_STRENGTH_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_iridix_strength_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4012cL);
+	APICAL_WRITE_32(0x4012cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_iridix_strength_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4012cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Maximum Iridix Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum iridix strength in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAXIMUM_IRIDIX_STRENGTH_DEFAULT (0x80)
+#define APICAL_EXT_SYSTEM_MAXIMUM_IRIDIX_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_maximum_iridix_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4012cL);
+	APICAL_WRITE_32(0x4012cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_maximum_iridix_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4012cL) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Minimum Iridix Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum iridix strength in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MINIMUM_IRIDIX_STRENGTH_DEFAULT (0x80)
+#define APICAL_EXT_SYSTEM_MINIMUM_IRIDIX_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_minimum_iridix_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4012cL);
+	APICAL_WRITE_32(0x4012cL, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_minimum_iridix_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4012cL) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sinter Threshold Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Overall strength of Sinter noise-reduction effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SINTER_THRESHOLD_TARGET_DEFAULT (0x18)
+#define APICAL_EXT_SYSTEM_SINTER_THRESHOLD_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_sinter_threshold_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40130L);
+	APICAL_WRITE_32(0x40130L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_sinter_threshold_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40130L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Maximum Sinter Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum sinter strength in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAXIMUM_SINTER_STRENGTH_DEFAULT (0x18)
+#define APICAL_EXT_SYSTEM_MAXIMUM_SINTER_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_maximum_sinter_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40130L);
+	APICAL_WRITE_32(0x40130L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_maximum_sinter_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40130L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Minimum Sinter Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum sinter strength in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MINIMUM_SINTER_STRENGTH_DEFAULT (0x18)
+#define APICAL_EXT_SYSTEM_MINIMUM_SINTER_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_minimum_sinter_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40130L);
+	APICAL_WRITE_32(0x40130L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_minimum_sinter_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40130L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Temper Threshold Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Overall strength of Temper noise-reduction effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_TEMPER_THRESHOLD_TARGET_DEFAULT (0x24)
+#define APICAL_EXT_SYSTEM_TEMPER_THRESHOLD_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_temper_threshold_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40134L);
+	APICAL_WRITE_32(0x40134L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_temper_threshold_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40134L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Maximum Temper Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum temper strength in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MAXIMUM_TEMPER_STRENGTH_DEFAULT (0x24)
+#define APICAL_EXT_SYSTEM_MAXIMUM_TEMPER_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_maximum_temper_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40134L);
+	APICAL_WRITE_32(0x40134L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_maximum_temper_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40134L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Minimum Temper Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum temper strength in all modes.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_MINIMUM_TEMPER_STRENGTH_DEFAULT (0x24)
+#define APICAL_EXT_SYSTEM_MINIMUM_TEMPER_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_minimum_temper_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40134L);
+	APICAL_WRITE_32(0x40134L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_minimum_temper_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40134L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB Red Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Red channel strength multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_AWB_RED_GAIN_DEFAULT (0xA0)
+#define APICAL_EXT_SYSTEM_AWB_RED_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_awb_red_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40138L);
+	APICAL_WRITE_32(0x40138L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_awb_red_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40138L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB Blue Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Blue channel strength multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_AWB_BLUE_GAIN_DEFAULT (0xA0)
+#define APICAL_EXT_SYSTEM_AWB_BLUE_GAIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_awb_blue_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40138L);
+	APICAL_WRITE_32(0x40138L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_awb_blue_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40138L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Anti-flicker frequency
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//Anti-flicker frequency, in integer format.
+//A value of 0  means no Anti-flicker, this is the default setting as anti-flicker reduces the choice of integration times.
+//A value of 50 should be used for 50Hz lamp flicker (exposure ratio MUST be set to 1).
+//A value of 60 should be used for 60Hz lamp flicker (exposure ratio MUST be set to 1).
+//Any other values are also allowed, but not practical and not being tested.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_ANTI_FLICKER_FREQUENCY_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_ANTI_FLICKER_FREQUENCY_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_anti_flicker_frequency_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40138L);
+	APICAL_WRITE_32(0x40138L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_anti_flicker_frequency_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40138L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Slow Frame Rate Divider
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//Slow frame rate limit multiplier, in 4.4 fixed-point format.
+//A value of 1.0 (0x10) means no slow frame rate allowed.
+//A value of 2.0 (0x20) means frame rate can be slowed down by 2x maximum.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SLOW_FRAME_RATE_DIVIDER_DEFAULT (0x10)
+#define APICAL_EXT_SYSTEM_SLOW_FRAME_RATE_DIVIDER_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_slow_frame_rate_divider_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4013cL);
+	APICAL_WRITE_32(0x4013cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_slow_frame_rate_divider_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4013cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AE compensation
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Shifts AE target
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_AE_COMPENSATION_DEFAULT (0x80)
+#define APICAL_EXT_SYSTEM_AE_COMPENSATION_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_ae_compensation_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40140L);
+	APICAL_WRITE_32(0x40140L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_ae_compensation_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40140L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Saturation Target
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Saturation target, this value used directly when Manual Saturation is used
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_SATURATION_TARGET_DEFAULT (0x80)
+#define APICAL_EXT_SYSTEM_SATURATION_TARGET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_saturation_target_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40144L);
+	APICAL_WRITE_32(0x40144L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_saturation_target_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40144L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_0_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_0_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f0L);
+	APICAL_WRITE_32(0x401f0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_debug_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f0L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_1_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_1_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f0L);
+	APICAL_WRITE_32(0x401f0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_debug_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f0L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_2_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_2_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f0L);
+	APICAL_WRITE_32(0x401f0L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_debug_2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f0L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 3
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_3_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_3_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_3_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f0L);
+	APICAL_WRITE_32(0x401f0L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_debug_3_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f0L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 4
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_4_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_4_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f4L);
+	APICAL_WRITE_32(0x401f4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_ext_system_debug_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 5
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_5_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_5_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_5_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f4L);
+	APICAL_WRITE_32(0x401f4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_ext_system_debug_5_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 6
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_6_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_6_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_6_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f4L);
+	APICAL_WRITE_32(0x401f4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_ext_system_debug_6_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Debug 7
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_EXT_SYSTEM_DEBUG_7_DEFAULT (0x00)
+#define APICAL_EXT_SYSTEM_DEBUG_7_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_ext_system_debug_7_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x401f4L);
+	APICAL_WRITE_32(0x401f4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_ext_system_debug_7_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x401f4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_EXT_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_firmware_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_firmware_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_firmware_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_firmware_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,319 @@
+/*-----------------------------------------------------------------------------
+     This confidential and proprietary software/information may be used only
+        as authorized by a licensing agreement from Apical Limited
+
+                   (C) COPYRIGHT 2011 - 2015 Apical Limited
+                          ALL RIGHTS RESERVED
+
+      The entire notice above must be reproduced on all authorized
+       copies and copies may only be made to the extent permitted
+             by a licensing agreement from Apical Limited.
+-----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_FIRMWARE_CONFIG_H__
+#define __APICAL_FIRMWARE_CONFIG_H__
+
+#define APICAL_IRQ_DS1_OUTPUT_END 13
+#define APICAL_IRQ_DS2_OUTPUT_END 14
+
+#define RGGB_ORDER_NORMAL 0
+#define APICAL_IRQ_FRAME_WRITER_FR 5
+#define ISP_HAS_CONNECTION_SOCKET_PORT 0
+#define LENS_SPI_CONTROL_MASK 0
+#define WB_BL_FS_HDR {0*16,0},{3*16,0},{0*16,0},{3*16,0},{0*16,0},{3*16,0},{0*16,0},{3*16,0}
+#define WHITE_TARGET_LINEAR 8
+#define FW_DOESNT_CONTROL_FRAME_BUFFER_BANK 1
+#define RAW_FE_HP_BLEND 0
+#define ISP_HAS_MATRIX_YUV_FSM 1
+#define ISP_HAS_FPGA_INPUT_PORT 0
+#define SENSOR_DEFAULT_MODE SENSOR_SEQUENCE_FULL_RES_MAX_FPS
+#define IPS_HAS_NP_RAW_FE 0
+#define ISP_SYNC_HIGH_FREQ 0
+#define ISP_HAS_DS 0
+#define AF_BRACKET_TOL 0
+#define FW_FR_OUTPUT_FORMAT_PIPE PIPE_OUT_RGB
+#define IRIDIX_STRENGTH_MAXIMUM_WDR 255
+#define ISP_PROCESS_NUM_EVENTS_QUANT 5
+#define APICAL_IRQ_FRAME_START 7
+#define ISP_HAS_CONNECTION_BUFFER 0
+#define AF_TEN_CM_VAL 0
+#define MIPI_GPLL_FULL_SET 0
+#define ISP_HAS_CAF 0
+#define SRC_DELIVERY 1
+#define RAW_FE_LINE_THRES 0
+#define AF_INFINITY_VAL 0
+#define IRIDIX_PRE_POST_GAMMA_LEN 65
+#define ISP_HAS_DOWNSCALER 0
+#define ISP_DS1_HEIGHT 1080
+#define APICAL_IRQ_AWB_STATS 4
+#define SD_CAPTURE_RGB_FROM_FR 1
+#define BLACK_TARGET_HDR 0x80
+#define ISP_HAS_AE_BALANCED_FSM 1
+#define CONNECTION_BUFFER_SIZE 4096
+#define WB_BL_NATIVE {0*16,0},{3*16,0},{0*16,0},{3*16,0},{0*16,0},{3*16,0},{0*16,0},{3*16,0}
+#define SYSTEM_MINIMUM_TEMPER_STRENGTH_DEFAULT 70
+#define WHITE_BALANCE_MULT_COMPENSATION 1
+#define ISP_HAS_CONNECTION_UART 0
+#define RGGB_ORDER_MIRROR 2
+#define CAF_FIRST_FOCUS_AGGRESSIVE 0
+#define APICAL_SDCARD_SUPPORT 0
+#define SYMMETRICAL_AE_HYSTERESIS 1
+#define FW_DS2_OUTPUT_FORMAT_PIPE PIPE_OUT_RGB
+#define APICAL_IRQ_FPGA_DMA_READER 11
+#define ISP_VERT_ZONES_MAX 15
+#define ISP_HAS_CONNECTION_DEBUG 1
+#define ISP_HAS_DEFECT_PIXEL_FSM 1
+#define WDR_SWITCH_EXPOSURE_CORRECTION -226863
+#define ISP_CALIBRATION isp_calibrations
+#define AF_DEBUG_MANUAL_CONTROL 0
+#define APICAL_IRQ_FPGA_FRAME_START 8
+#define SYSTEM_MAXIMUM_UN_DIRECTIONAL_SHARPENING_DEFAULT 20
+#define ISP_HAS_NP_RAW_FE 1
+#define SYSTEM_MINIMUM_UN_DIRECTIONAL_SHARPENING_DEFAULT 5
+#define ISP_HAS_GENERAL_FSM 1
+#define ISP_HAS_SHADING_STRENGTH 1
+#define ISP_BIST_SEQ_NUM 1
+#define ISP_BIST_ARRAY {0}
+#define AF_DEBUG_CONTROL 0
+#define ISP_HAS_DOUBLE_DS 1
+#define ISP_HAS_SECOND_SHARPENING 0
+#define SINTER_RADIAL_CENTER_X 0
+#define KERNEL_MODULE 1
+#define HISTOGRAM_BANDS 5
+#define ISP_BIST_SEED_NUM 1
+#define ISP_HAS_DOUBLE_RAW_FRONTEND 0
+#define ISP_HAS_AXI_FRAME_GRABBER 0
+#define OVEREXPOSE_TO_KEEP_ANTIFLICKER 0
+#define APICAL_FW_SHP_DETECTED_MAXIMUM 4096
+#define SD_CAPTURE_FRAME_MAX 5
+#define WDR_SWITCH_THRESHOLD 64
+#define AF_INIT_MOVE_BACK_TO_MIN 0
+#define IRIDIX_MAX_GAIN_LIMIT 4<<8
+#define SYSTEM_EXPOSURE_RATIO_DEFAULT 8
+#define ISP_WDR_SWITCH 1
+#define IRIDIX_STRENGTH_MAXIMUM_LINEAR 255
+#define CAF_STARTING_STEP 0
+#define SD_CAPTURE_CHANGE_FOCUS 0
+#define FS_OUTPUT_BL 2336
+#define SENSOR_HW_INTERFACE ApicalDefault
+#define EXP_RATIO_BY_AE 0
+#define APICAL_EXT_SYSTEM_AWB_THRESH_HIGH_DEFAULT 0x200
+#define MIPI_AUTOTUNE_DISABLE 0
+#define IRIDIX_BLACK_PRC 0
+#define INCREMENT_OFFSET 256
+#define SYSTEM_ANTIFLICKER_ENABLE_DEFAULT 0
+#define ISP_TOTAL_SINTER_CONTROL_IN_MANUAL_MODE 0
+#define ISP_HAS_MESH_SHADING 0
+#define ISP_HAS_DMA_FRAME_GRABBER 1
+#define APICAL_EVENT_QUEUE_SIZE 256
+#define CAF_CHANGE_SENSITIVITY 0
+#define RAW_FE_SIGMA_IN 0
+#define ISP_HAS_FLASH 0
+#define ISP_SEQ_JSON linear.jsonfs_hdr.json
+#define AF_WARMUP_TIMES 3
+#define ISP_HAS_OUT_FRAME_BUFFER 0
+#define EXPOSURE_CORRECTION_COR ''
+#define LENS_BUS 0
+#define ISP_HAS_4HIST 0
+#define ISP_HAS_CONNECTION_CHARDEV 0
+#define ISP_HAS_IRIDIX 1
+#define APICAL_IRQ_FRAME_WRITER_DS2 12
+#define IRIDIX_EV_LIM_FULL_STR 0
+#define SYSTEM_MINIMUM_DIRECTIONAL_SHARPENING_DEFAULT 20
+#define ISP_HAS_GAIN 1
+#define ISP_DS2_WIDTH 1280
+#define FILTER_LONG_INT_TIME 0
+#define CAF_SCENE_WATCH_LEN 0
+#define APICAL_IRQ_FPGA_FRAME_END 9
+#define ISP_HAS_MESH_SHADIG_LIGHT_SWITCHING 1
+#define MIPI_GPLL_PREVIEW_SET 0
+#define IRIDIX_BYPASS_MAX_STR_CLIP 0
+#define ZIPFS_SUPPORT 0
+#define SENSOR_BINARY_SEQUENCE 1
+#define ISP_HAS_FLASH_FSM 1
+#define AF_FIFTY_CM_VAL 0
+#define ISP_ASIC_BUILD 1
+#define EXPOSURE_DRIVES_LONG_INTEGRATION_TIME 0
+#define ISP_DISPLAY_MODE 1080
+#define ISP_HAS_FRAME_BUFFER 1
+#define IRIDIX_STRENGTH_BY_EXP_RATIO 1
+#define LENS_BUS_ADDRESS 0
+#define FLASH_DEFECT_PIXELS_FILE_NAME "defect_pixels_table.dat"
+#define ISP_HAS_GAMMA_FE 1
+#define LED_FLASH_OUTPUT_PORT 1
+#define ISP_HAS_WDR_MUX 0
+#define BYPASS_AF_INTENSITY_NORM_MODE_WRITE 0
+#define ISP_HAS_FULLHIST 1
+#define MIPI_LANES 0
+#define CAF_STARTING_WINDOW_SIZE 0x5555ABAB
+#define ISP_RAW_GE 1
+#define APICAL_NUMBER_OF_SENSORS 1
+#define FW_DS1_OUTPUT_FORMAT_PIPE PIPE_OUT_RGB
+#define ISP_HAS_CMOS_FSM 1
+#define CAF_BRACKET_TOL 0
+#define ISP_RGB_HISTOGRAM 0
+#define ISP_HAS_WDR_FS 1
+#define APICAL_IRQ_AF_STATS 2
+#define ISP_HAS_CROP_FSM 1
+#define USE_BLACK_CALIBRATION 1
+#define AF_USE_QUAD_IN_CAF 0
+#define AF_MAX_TABLE 0
+#define AF_MIN_TABLE 0
+#define BLACK_LEVEL_SHIFT_DG 4
+#define SYSTEM_MAX_SENSOR_ANALOG_GAIN_DEFAULT 117
+#define ISP_HAS_IRIDIX_COMPENSATION 1
+#define AF_MIN 0
+#define AF_INC_FACTOR 0
+#define IRIDIX_WHITE_LEVEL APICAL_ISP_IRIDIX_WHITE_LEVEL_DEFAULT
+#define WDR_AUTO_SWITCH_TO WDR_MODE_LINEAR
+#define HAS_MESH_SHADING 0
+#define AF_MAX 0
+#define ISP_DS1_WIDTH 1920
+#define WHITE_TARGET_HDR 8
+#define SYSTEM_MAX_EXPOSURE_RATIO_DEFAULT 16
+#define MANUAL_RAW_FE_SETTINGS 1
+#define ISP_HAS_AWB_MESH_NBP_FSM 1
+#define ISP_WDR_FS_TOOGLE_LONG_FIRST 0
+#define AF_CONVERGE_CRIT 0
+#define CAF_CHANGE_SENSITIVITY_AF2 0
+#define ISP_HAS_NOISE_REDUCTION_FSM 1
+#define ISP_HAS_SHARPENING_FSM 1
+#define LOG2_GAIN_SHIFT 16
+#define MESH_SHADING_STRENGTH_VALUES {3*256,0x1000},{5*256,0}
+#define SENSOR_CROP_OFFSET 0
+#define APICAL_EXT_SYSTEM_AWB_THRESH_LOW_DEFAULT 0x100
+#define ISP_API_LOCATION api_smbl_2ds_fs.xml
+#define CONNECTION_IN_THREAD 0
+#define IRIDIX_HAS_PRE_POST_GAMMA_LUT_LINEAR 1
+#define ISP_INPUT_BITS 12
+#define AF_RANGE 0
+#define CAF_INC_FACTOR 0
+#define ISP_HAS_API 1
+#define APICAL_IRQ_GDC 15
+#define SENSOR_NAME IMX222
+#define ISP_HAS_BRAME_BUFFER 0
+#define FW_OUTPUT_FORMAT DMA_FORMAT_A2R10G10B10
+#define ISP_HAS_IRIDIX_HIST_FSM 1
+#define ISP_HAS_GAMMA_RGB 1
+#define FILTER_AWB_COEFF 8
+#define SYSTEM_AE_COMPENSATION_DEFAULT 128
+#define ISP_SYNC_ENA_PIXEL_CLOCK_REVERTED 1
+#define APICAL_IRQ_AF2_STATS 1
+#define ISP_HAS_SINTER_RADIAL_LUT 0
+#define FILTER_AE_RATIO 0
+#define APICAL_FW_PARAMETER_BLACK_COUNT_DOWN_TIME_INTERVAL 100
+#define FIRMWARE_HAS_WDR 0
+#define HISTOGRAM_TARGET_POINT ISP_FULL_HISTOGRAM_SIZE/2
+#define FW_THREAD_NUMBER 0
+#define ANALOG_GAIN_LAST_PRIORITY 0
+#define ISP_HAS_UART_CONTROL 0
+#define SYSTEM_MAXIMUM_SINTER_STRENGTH_DEFAULT 20
+#define MIPI_GENERATES_CLK 0
+#define BLACK_TARGET_LINEAR 0x40
+#define FW_ZONE_AE 0
+#define MESH_SHADING_HEIGHT 0
+#define APICAL_IRQ_FPGA_WDR_BUF 10
+#define WDR_SWITCH_FRAMES 20
+#define ISP_PIPELINE_BITS 12
+#define CCM_ONE_GAIN_THRESHOLD 255
+#define IRIDIX_EV_LIM_NO_STR 0
+#define ISP_HAS_COLOR_MATRIX_FSM 1
+#define KEEP_VIDEO_RATIO 0
+#define SYSTEM_MAXIMUM_IRIDIX_STRENGTH_DEFAULT 128
+#define WDR_SWITCH_THRESHOLD_HISTERESIS 0
+#define SYSTEM_MAX_ISP_DIGITAL_GAIN_DEFAULT 32
+#define AE_AVG_COEFF 0
+#define WB_BL_FS_LIN {0*16,0},{3*16,0},{0*16,0},{3*16,0},{0*16,0},{3*16,0},{0*16,0},{3*16,0}
+#define SINTER_RADIAL_CENTER_X_PREVIEW 0
+#define AE_CENTER_ZONES 0x4040c0c0
+#define CAF_MAX_STEP 0
+#define IRIDIX_ASYMMETRY_LUT_LENGTH 0
+#define SYSTEM_MINIMUM_IRIDIX_STRENGTH_DEFAULT 0
+#define AF_INIT_MOVE 0
+#define ISP_HAS_SATURATION_STRENGTH 1
+#define ZIPFS_DYNAMIC_CALIBRATIONS_FILE_NAME "apical_dynamic_calibrations.dat"
+#define ISP_HAS_SINTER 1
+#define ISP_HAS_GDC 0
+#define ISP_METERING_READ_OFFSET 256
+#define ISP_HAS_DOUBLE_DECOMPANDER 1
+#define SYSTEM_ANTI_FLICKER_FREQUENCY_DEFAULT 50
+#define ISP_GET_EXPOSURE_DELAY 0
+#define MESH_SHADING_WIDTH 0
+#define ISP_FS_BYPASS 0
+#define ISP_HAS_DECOMPANDER 0
+#define AE_COMPENSATION 0x80
+#define ISP_FULL_HISTOGRAM_SIZE 256
+#define RESTRICTED_SOURCES 1
+#define AF_START_LOC 0
+#define SINTER_RADIAL_CENTER_Y_PREVIEW 0
+#define CALIBRATION_PREVIEW_SET_SUPPORT 0
+#define SD_CAPTURE_RGB_ONLY 0
+#define APICAL_IRQ_AE_STATS 3
+#define ISP_HAS_CNR 0
+#define ISP_HAS_CONNECTION_SOCKET 0
+#define APICAL_ISP_PROFILING 0
+#define SYSTEM_MAXIMUM_DIRECTIONAL_SHARPENING_DEFAULT 40
+#define APICAL_IRQ_FRAME_WRITER_DS 6
+#define BLACK_LEVEL_SHIFT_WB 0
+#define ISP_EXPOSURE_FP_STATS 1
+#define CM_SATURATION_TARGET 0x80
+#define ANALOG_GAIN_ACCURACY (1<<(LOG2_GAIN_SHIFT-4))
+#define ISP_MBL 1
+#define EXPOSURE_CORRECTION_EXP ''
+#define TOOLCHAINS ''
+#define MIPI_LPLL_PREVIEW_SET 0
+#define CNR_UV_DELTA12_SLOPE {0,0}
+#define SINTER_RADIAL_LUT_PREVIEW 0
+#define AF_MECH_END 0
+#define SENSOR_CALIBRATION default
+#define ISP_HAS_FPGA_WRAPPER 1
+#define FILTER_AE_EXP_TARGET_COEFF 4
+#define FW_LOG_LEVEL LOG_NOTHING
+#define APICAL_IRQ_FRAME_END 0
+#define SENSOR_SEQUENCE_ELEMENT_SIZE_BYTES 1
+#define FILTER_SHORT_INT_TIME 0
+#define ISP_HAS_ZOOM_LENS 0
+#define SYSTEM_MANUAL_EXPOSURE_RATIO_DEFAULT 0
+#define SYSTEM_MAX_SENSOR_DIGITAL_GAIN_DEFAULT 0
+#define ZOOM_MIN 0
+#define ISP_HAS_AWB_WARMING_LIGHT_SWITCHING 0
+#define ISP_HAS_ANTIFOG 1
+#define IRIDIX_STRENGTH_TARGET 128
+#define CAF_HAS_WINDOW_RESIZING 0
+#define ANALOG_GAIN_RESERVE 0
+#define CAF_MOVEMENT_SENSITIVITY 0
+#define IRIDIX_HAS_CUSTOM_ASYMMETRY 1
+#define ZIPFS_STATIC_CALIBRATIONS_FILE_NAME "apical_static_calibrations.dat"
+#define MIPI_LPLL_FULL_SET 0
+#define ISP_HAS_WDR_FRAME_BUFFER 1
+#define ISP_HAS_AF 0
+#define CAF_WINDOW_RESIZING {0,0}
+#define DVI_OUTPUT 1
+#define ISP_HOR_ZONES_MAX 15
+#define AF_HYPER_FOCUS_VAL 0
+#define ISP_HAS_IRIDIX_SPECIAL_SETTINGS 1
+#define ISP_BYPASS_MIRROR 1
+#define SINTER_RADIAL_CENTER_Y 0
+#define MAX_EXPOSURE_RATIO 16*64
+#define CAF_MEDIAN 0
+#define SYSTEM_MINIMUM_SINTER_STRENGTH_DEFAULT 1
+#define ISP_HAS_DIS_FSM 1
+#define FILTER_IRIDIX_STR 0
+#define SINTER_RADIAL_LUT 0
+#define SENSOR_HAS_FLASH 0
+#define ISP_HAS_MVE 1
+#define ISP_JTAG_CAPTURE 0
+#define RAW_FE_HPDEV_THRES 2048
+#define ISP_WDR_DEFAULT_MODE WDR_MODE_LINEAR
+#define ISP_HAS_SENSOR_FSM 1
+#define AF_CLOSEST_VAL 0
+#define ISP_HW_HAS_SSRAM16 1
+#define ISP_HAS_GAMMA_BE 0
+#define ISP_DS2_HEIGHT 720
+#define ISP_HAS_AWB_MESH_NBP_SD 0
+#define IRIDIX_GAIN_MAX 0
+#define ISP_HAS_TEMPER 3
+#define ZOOM_MAX 0
+#define SYSTEM_MAXIMUM_TEMPER_STRENGTH_DEFAULT 95
+#define IRIDIX_MIN_MAX_STR 15
+#endif
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_flash_timer_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_flash_timer_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_flash_timer_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_flash_timer_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,2282 @@
+#ifndef __APICAL_FLASH_TIMER_CONFIG_H__
+#define __APICAL_FLASH_TIMER_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'flash_timer' of module 'flash_timer'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_BASE_ADDR (0x2000L)
+#define APICAL_FLASH_TIMER_SIZE (0x200)
+
+// ------------------------------------------------------------------------------ //
+// Group: Flash Timer
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Number of channels
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of channels instantiated
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_NUMBER_OF_CHANNELS_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_NUMBER_OF_CHANNELS_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_number_of_channels_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2000L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: API revision
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// API revision
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_API_REVISION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_API_REVISION_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_api_revision_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2000L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Input status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Status of inputs
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_INPUT_STATUS_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_INPUT_STATUS_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_input_status_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2008L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Start flag0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Firmware start flag 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_START_FLAG0_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_START_FLAG0_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_start_flag0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2008L);
+	APICAL_WRITE_32(0x2008L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_start_flag0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2008L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Start flag1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Firmware start flag 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_START_FLAG1_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_START_FLAG1_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_start_flag1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2008L);
+	APICAL_WRITE_32(0x2008L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_start_flag1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2008L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output0 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output0 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT0_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT0_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output0_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2020L);
+	APICAL_WRITE_32(0x2020L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output0_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2020L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output0 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT0_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT0_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output0_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2020L);
+	APICAL_WRITE_32(0x2020L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output0_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2020L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output0 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output0 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT0_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT0_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output0_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2020L) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output1 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output1 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT1_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT1_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output1_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2024L);
+	APICAL_WRITE_32(0x2024L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output1_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2024L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output1 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT1_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT1_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output1_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2024L);
+	APICAL_WRITE_32(0x2024L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output1_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2024L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output1 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output1 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT1_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT1_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output1_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2024L) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output2 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output2 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT2_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT2_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output2_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2028L);
+	APICAL_WRITE_32(0x2028L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output2_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2028L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output2 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT2_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT2_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output2_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2028L);
+	APICAL_WRITE_32(0x2028L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output2_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2028L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output2 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output2 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT2_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT2_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output2_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2028L) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output3 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output3 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT3_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT3_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output3_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x202cL);
+	APICAL_WRITE_32(0x202cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output3_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x202cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output3 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output3
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT3_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT3_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output3_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x202cL);
+	APICAL_WRITE_32(0x202cL, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output3_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x202cL) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output3 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output3 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT3_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT3_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output3_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x202cL) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output4 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output4 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT4_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT4_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output4_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2030L);
+	APICAL_WRITE_32(0x2030L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output4_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2030L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output4 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output4
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT4_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT4_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output4_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2030L);
+	APICAL_WRITE_32(0x2030L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output4_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2030L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output4 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output4 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT4_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT4_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output4_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2030L) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output5 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output5 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT5_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT5_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output5_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2034L);
+	APICAL_WRITE_32(0x2034L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output5_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2034L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output5 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output5
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT5_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT5_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output5_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2034L);
+	APICAL_WRITE_32(0x2034L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output5_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2034L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output5 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output5 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT5_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT5_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output5_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2034L) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output6 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output6 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT6_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT6_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output6_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2038L);
+	APICAL_WRITE_32(0x2038L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output6_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2038L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output6 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output6
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT6_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT6_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output6_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2038L);
+	APICAL_WRITE_32(0x2038L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output6_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2038L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output6 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output6 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT6_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT6_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output6_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2038L) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output7 sources
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source mask for output7 (bits 0-7 inputs, bits 8-15 timers)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT7_SOURCES_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT7_SOURCES_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_flash_timer_flash_timer_output7_sources_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x203cL);
+	APICAL_WRITE_32(0x203cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_flash_timer_flash_timer_output7_sources_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x203cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output7 polarity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Inversion on output7
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT7_POLARITY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT7_POLARITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_output7_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x203cL);
+	APICAL_WRITE_32(0x203cL, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_output7_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x203cL) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output7 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// State of output7 pin
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT7_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_OUTPUT7_STATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_output7_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x203cL) & 0x80000000) >> 31);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2040L);
+	APICAL_WRITE_32(0x2040L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2040L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2040L);
+	APICAL_WRITE_32(0x2040L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2040L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2040L);
+	APICAL_WRITE_32(0x2040L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2040L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2040L);
+	APICAL_WRITE_32(0x2040L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2040L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2040L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2044L);
+	APICAL_WRITE_32(0x2044L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2044L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2044L);
+	APICAL_WRITE_32(0x2044L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2044L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2044L);
+	APICAL_WRITE_32(0x2044L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2044L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2044L);
+	APICAL_WRITE_32(0x2044L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer0_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2044L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x2048L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer0_delay_read(void) {
+	return APICAL_READ_32(0x2048L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer0_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x204cL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer0_duration_read(void) {
+	return APICAL_READ_32(0x204cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer0 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer0 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER0_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer0_counter_read(void) {
+	return APICAL_READ_32(0x2050L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2060L);
+	APICAL_WRITE_32(0x2060L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2060L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2060L);
+	APICAL_WRITE_32(0x2060L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2060L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2060L);
+	APICAL_WRITE_32(0x2060L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2060L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2060L);
+	APICAL_WRITE_32(0x2060L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2060L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2060L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2064L);
+	APICAL_WRITE_32(0x2064L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2064L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2064L);
+	APICAL_WRITE_32(0x2064L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2064L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2064L);
+	APICAL_WRITE_32(0x2064L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2064L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2064L);
+	APICAL_WRITE_32(0x2064L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer1_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2064L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x2068L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer1_delay_read(void) {
+	return APICAL_READ_32(0x2068L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer1_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x206cL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer1_duration_read(void) {
+	return APICAL_READ_32(0x206cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer1 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer1 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER1_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer1_counter_read(void) {
+	return APICAL_READ_32(0x2070L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2080L);
+	APICAL_WRITE_32(0x2080L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2080L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2080L);
+	APICAL_WRITE_32(0x2080L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2080L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2080L);
+	APICAL_WRITE_32(0x2080L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2080L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2080L);
+	APICAL_WRITE_32(0x2080L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2080L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2080L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2084L);
+	APICAL_WRITE_32(0x2084L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2084L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2084L);
+	APICAL_WRITE_32(0x2084L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2084L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2084L);
+	APICAL_WRITE_32(0x2084L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2084L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2084L);
+	APICAL_WRITE_32(0x2084L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer2_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2084L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x2088L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer2_delay_read(void) {
+	return APICAL_READ_32(0x2088L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer2_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x208cL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer2_duration_read(void) {
+	return APICAL_READ_32(0x208cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer2 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer2 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER2_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer2_counter_read(void) {
+	return APICAL_READ_32(0x2090L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a0L);
+	APICAL_WRITE_32(0x20a0L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a0L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a0L);
+	APICAL_WRITE_32(0x20a0L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a0L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a0L);
+	APICAL_WRITE_32(0x20a0L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a0L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a0L);
+	APICAL_WRITE_32(0x20a0L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a0L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a0L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a4L);
+	APICAL_WRITE_32(0x20a4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a4L);
+	APICAL_WRITE_32(0x20a4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a4L);
+	APICAL_WRITE_32(0x20a4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20a4L);
+	APICAL_WRITE_32(0x20a4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer3_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20a4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x20a8L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer3_delay_read(void) {
+	return APICAL_READ_32(0x20a8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer3_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x20acL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer3_duration_read(void) {
+	return APICAL_READ_32(0x20acL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer3 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer3 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER3_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer3_counter_read(void) {
+	return APICAL_READ_32(0x20b0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c0L);
+	APICAL_WRITE_32(0x20c0L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c0L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c0L);
+	APICAL_WRITE_32(0x20c0L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c0L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c0L);
+	APICAL_WRITE_32(0x20c0L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c0L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c0L);
+	APICAL_WRITE_32(0x20c0L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c0L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c0L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c4L);
+	APICAL_WRITE_32(0x20c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c4L);
+	APICAL_WRITE_32(0x20c4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c4L);
+	APICAL_WRITE_32(0x20c4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20c4L);
+	APICAL_WRITE_32(0x20c4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer4_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20c4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x20c8L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer4_delay_read(void) {
+	return APICAL_READ_32(0x20c8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer4_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x20ccL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer4_duration_read(void) {
+	return APICAL_READ_32(0x20ccL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer4 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer4 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER4_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer4_counter_read(void) {
+	return APICAL_READ_32(0x20d0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e0L);
+	APICAL_WRITE_32(0x20e0L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e0L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e0L);
+	APICAL_WRITE_32(0x20e0L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e0L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e0L);
+	APICAL_WRITE_32(0x20e0L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e0L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e0L);
+	APICAL_WRITE_32(0x20e0L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e0L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e0L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e4L);
+	APICAL_WRITE_32(0x20e4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e4L);
+	APICAL_WRITE_32(0x20e4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e4L);
+	APICAL_WRITE_32(0x20e4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20e4L);
+	APICAL_WRITE_32(0x20e4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer5_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20e4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x20e8L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer5_delay_read(void) {
+	return APICAL_READ_32(0x20e8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer5_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x20ecL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer5_duration_read(void) {
+	return APICAL_READ_32(0x20ecL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer5 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer5 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER5_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer5_counter_read(void) {
+	return APICAL_READ_32(0x20f0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2100L);
+	APICAL_WRITE_32(0x2100L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2100L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2100L);
+	APICAL_WRITE_32(0x2100L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2100L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2100L);
+	APICAL_WRITE_32(0x2100L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2100L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2100L);
+	APICAL_WRITE_32(0x2100L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2100L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2100L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2104L);
+	APICAL_WRITE_32(0x2104L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2104L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2104L);
+	APICAL_WRITE_32(0x2104L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2104L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2104L);
+	APICAL_WRITE_32(0x2104L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2104L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2104L);
+	APICAL_WRITE_32(0x2104L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer6_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2104L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x2108L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer6_delay_read(void) {
+	return APICAL_READ_32(0x2108L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer6_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x210cL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer6_duration_read(void) {
+	return APICAL_READ_32(0x210cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer6 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer6 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER6_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer6_counter_read(void) {
+	return APICAL_READ_32(0x2110L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 trigger software
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 trigger source on firmware flags
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_SOFTWARE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_SOFTWARE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_trigger_software_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2120L);
+	APICAL_WRITE_32(0x2120L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_trigger_software_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2120L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 mode: 0-new event restarts, 1-new event ignored until timer finishes, 2-new event is stored and cause retrigger at the end of interval, 3-pulse count mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_MODE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2120L);
+	APICAL_WRITE_32(0x2120L, (((uint32_t) (data & 0x3)) << 16) | (curr & 0xfffcffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2120L) & 0x30000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 software reset: 1-timer is held at 0, triggers are reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_RESET_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2120L);
+	APICAL_WRITE_32(0x2120L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2120L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 pause
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 counter pause: 1-counting is paused, triggers are still working
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_PAUSE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_PAUSE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_pause_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2120L);
+	APICAL_WRITE_32(0x2120L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_pause_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2120L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 state
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 status: 0-inactive, 1-initial delay, 2-active
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_STATE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_STATE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_state_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2120L) & 0xc0000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 trigger input rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 trigger source on rising edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_INPUT_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_INPUT_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_trigger_input_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2124L);
+	APICAL_WRITE_32(0x2124L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_trigger_input_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2124L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 trigger input falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 trigger source on falling edge of input channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_INPUT_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_INPUT_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_trigger_input_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2124L);
+	APICAL_WRITE_32(0x2124L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_trigger_input_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2124L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 trigger timer rising edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 trigger source on rising edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_TIMER_RISING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_TIMER_RISING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_trigger_timer_rising_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2124L);
+	APICAL_WRITE_32(0x2124L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_trigger_timer_rising_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2124L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 trigger timer falling edge
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 trigger source on falling edge of timer channels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_TIMER_FALLING_EDGE_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_TRIGGER_TIMER_FALLING_EDGE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_trigger_timer_falling_edge_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2124L);
+	APICAL_WRITE_32(0x2124L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_flash_timer_flash_timer_timer7_trigger_timer_falling_edge_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2124L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 delay between trigger and output activation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_DELAY_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_DELAY_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_delay_write(uint32_t data) {
+	APICAL_WRITE_32(0x2128L, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer7_delay_read(void) {
+	return APICAL_READ_32(0x2128L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 duration
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 duration of output pulse (FFFFFFF is infinite, reset only by software or rettrigger)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_DURATION_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_DURATION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_flash_timer_flash_timer_timer7_duration_write(uint32_t data) {
+	APICAL_WRITE_32(0x212cL, data);
+}
+static __inline uint32_t apical_flash_timer_flash_timer_timer7_duration_read(void) {
+	return APICAL_READ_32(0x212cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timer7 counter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Timer7 counter status (internal 33 bit counter state saturated to 32 bits)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_COUNTER_DEFAULT (0x0)
+#define APICAL_FLASH_TIMER_FLASH_TIMER_TIMER7_COUNTER_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_flash_timer_flash_timer_timer7_counter_read(void) {
+	return APICAL_READ_32(0x2130L);
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_FLASH_TIMER_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_fpga_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_fpga_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_fpga_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_fpga_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,663 @@
+#ifndef __APICAL_FPGA_CONFIG_H__
+#define __APICAL_FPGA_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'fpga' of module 'ip_config_fpga'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_BASE_ADDR (0x20000L)
+#define APICAL_FPGA_SIZE (0x1000)
+
+// ------------------------------------------------------------------------------ //
+// Group: Fpga Top
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Active Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_TOP_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_FPGA_FPGA_TOP_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_fpga_fpga_top_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20010L);
+	APICAL_WRITE_32(0x20010L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_fpga_fpga_top_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20010L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Active Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_TOP_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_FPGA_FPGA_TOP_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_fpga_fpga_top_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20014L);
+	APICAL_WRITE_32(0x20014L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_fpga_fpga_top_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20014L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Output sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Output selector: 0-ISP debug output 1-frame reader
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_TOP_OUTPUT_SEL_DEFAULT (1)
+#define APICAL_FPGA_FPGA_TOP_OUTPUT_SEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_fpga_top_output_sel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20020L);
+	APICAL_WRITE_32(0x20020L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_fpga_fpga_top_output_sel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20020L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Fpga Sync
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frame size and sync timing
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Offset X
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset in pixels from v-sync reference to start of active video
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_OFFSET_X_DEFAULT (0x000)
+#define APICAL_FPGA_FPGA_SYNC_OFFSET_X_DATASIZE (13)
+
+// args: data (13-bit)
+static __inline void apical_fpga_fpga_sync_offset_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20040L);
+	APICAL_WRITE_32(0x20040L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
+}
+static __inline uint16_t apical_fpga_fpga_sync_offset_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20040L) & 0x1fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Offset Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset in lines from v-sync reference to start of active video
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_OFFSET_Y_DEFAULT (0x000)
+#define APICAL_FPGA_FPGA_SYNC_OFFSET_Y_DATASIZE (13)
+
+// args: data (13-bit)
+static __inline void apical_fpga_fpga_sync_offset_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20040L);
+	APICAL_WRITE_32(0x20040L, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
+}
+static __inline uint16_t apical_fpga_fpga_sync_offset_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20040L) & 0x1fff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Total Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Total frame width including horizontal blanking
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_TOTAL_WIDTH_DEFAULT (0x672)
+#define APICAL_FPGA_FPGA_SYNC_TOTAL_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_fpga_fpga_sync_total_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20044L);
+	APICAL_WRITE_32(0x20044L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_fpga_fpga_sync_total_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20044L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Total Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Total frame height including vertical blanking
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_TOTAL_HEIGHT_DEFAULT (0x2EE)
+#define APICAL_FPGA_FPGA_SYNC_TOTAL_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_fpga_fpga_sync_total_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20044L);
+	APICAL_WRITE_32(0x20044L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_fpga_fpga_sync_total_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20044L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H Front Porch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal sync front porch (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_H_FRONT_PORCH_DEFAULT (0x048)
+#define APICAL_FPGA_FPGA_SYNC_H_FRONT_PORCH_DATASIZE (13)
+
+// args: data (13-bit)
+static __inline void apical_fpga_fpga_sync_h_front_porch_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2004cL);
+	APICAL_WRITE_32(0x2004cL, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
+}
+static __inline uint16_t apical_fpga_fpga_sync_h_front_porch_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2004cL) & 0x1fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V Front Porch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical sync front porch (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_V_FRONT_PORCH_DEFAULT (0x003)
+#define APICAL_FPGA_FPGA_SYNC_V_FRONT_PORCH_DATASIZE (13)
+
+// args: data (13-bit)
+static __inline void apical_fpga_fpga_sync_v_front_porch_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2004cL);
+	APICAL_WRITE_32(0x2004cL, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
+}
+static __inline uint16_t apical_fpga_fpga_sync_v_front_porch_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2004cL) & 0x1fff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H-Sync Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal sync width (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_H_SYNC_WIDTH_DEFAULT (0x50)
+#define APICAL_FPGA_FPGA_SYNC_H_SYNC_WIDTH_DATASIZE (13)
+
+// args: data (13-bit)
+static __inline void apical_fpga_fpga_sync_h_sync_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20050L);
+	APICAL_WRITE_32(0x20050L, (((uint32_t) (data & 0x1fff)) << 0) | (curr & 0xffffe000));
+}
+static __inline uint16_t apical_fpga_fpga_sync_h_sync_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20050L) & 0x1fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V-Sync Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical sync width (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_V_SYNC_WIDTH_DEFAULT (0x5)
+#define APICAL_FPGA_FPGA_SYNC_V_SYNC_WIDTH_DATASIZE (13)
+
+// args: data (13-bit)
+static __inline void apical_fpga_fpga_sync_v_sync_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20050L);
+	APICAL_WRITE_32(0x20050L, (((uint32_t) (data & 0x1fff)) << 16) | (curr & 0xe000ffff));
+}
+static __inline uint16_t apical_fpga_fpga_sync_v_sync_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20050L) & 0x1fff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: H Sync Pol
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal sync out polarity (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_H_SYNC_POL_DEFAULT (1)
+#define APICAL_FPGA_FPGA_SYNC_H_SYNC_POL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_fpga_sync_h_sync_pol_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20054L);
+	APICAL_WRITE_32(0x20054L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_fpga_fpga_sync_h_sync_pol_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20054L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: V Sync Pol
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical sync out polarity (for DVI out)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FPGA_SYNC_V_SYNC_POL_DEFAULT (1)
+#define APICAL_FPGA_FPGA_SYNC_V_SYNC_POL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_fpga_sync_v_sync_pol_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20054L);
+	APICAL_WRITE_32(0x20054L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_fpga_fpga_sync_v_sync_pol_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20054L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Frame Reader
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_FORMAT_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_READER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_fpga_frame_reader_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20100L);
+	APICAL_WRITE_32(0x20100L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_fpga_frame_reader_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20100L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rbase load
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_RBASE_LOAD_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_READER_RBASE_LOAD_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_frame_reader_rbase_load_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2010cL);
+	APICAL_WRITE_32(0x2010cL, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_fpga_frame_reader_rbase_load_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2010cL) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rbase load sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selector for rbase_load strobe: 0-field, 1-configuration bit rbase_load
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_RBASE_LOAD_SEL_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_READER_RBASE_LOAD_SEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_frame_reader_rbase_load_sel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2010cL);
+	APICAL_WRITE_32(0x2010cL, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_fpga_frame_reader_rbase_load_sel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2010cL) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rbase
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_RBASE_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_READER_RBASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_fpga_frame_reader_rbase_write(uint32_t data) {
+	APICAL_WRITE_32(0x20110L, data);
+}
+static __inline uint32_t apical_fpga_frame_reader_rbase_read(void) {
+	return APICAL_READ_32(0x20110L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Indicates offset in bytes from the start of one line to the next line. Should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_FPGA_FRAME_READER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_fpga_frame_reader_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0x20114L, data);
+}
+static __inline uint32_t apical_fpga_frame_reader_line_offset_read(void) {
+	return APICAL_READ_32(0x20114L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_AXI_PORT_ENABLE_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_READER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_frame_reader_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20104L);
+	APICAL_WRITE_32(0x20104L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_fpga_frame_reader_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20104L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: config
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_CONFIG_DEFAULT (0x0000)
+#define APICAL_FPGA_FRAME_READER_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_fpga_frame_reader_config_write(uint32_t data) {
+	APICAL_WRITE_32(0x20120L, data);
+}
+static __inline uint32_t apical_fpga_frame_reader_config_read(void) {
+	return APICAL_READ_32(0x20120L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_READER_STATUS_DEFAULT (0x0000)
+#define APICAL_FPGA_FRAME_READER_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_reader_status_read(void) {
+	return APICAL_READ_32(0x20124L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Frame Stats
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: stats reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_STATS_RESET_DEFAULT (0)
+#define APICAL_FPGA_FRAME_STATS_STATS_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_frame_stats_stats_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20180L);
+	APICAL_WRITE_32(0x20180L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_fpga_frame_stats_stats_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20180L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: stats hold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_STATS_HOLD_DEFAULT (0)
+#define APICAL_FPGA_FRAME_STATS_STATS_HOLD_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_frame_stats_stats_hold_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20184L);
+	APICAL_WRITE_32(0x20184L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_fpga_frame_stats_stats_hold_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20184L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_MIN_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_width_min_read(void) {
+	return APICAL_READ_32(0x20190L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_MAX_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_width_max_read(void) {
+	return APICAL_READ_32(0x20194L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_SUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_width_sum_read(void) {
+	return APICAL_READ_32(0x20198L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_NUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_WIDTH_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_width_num_read(void) {
+	return APICAL_READ_32(0x2019cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_MIN_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_height_min_read(void) {
+	return APICAL_READ_32(0x201a0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_MAX_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_height_max_read(void) {
+	return APICAL_READ_32(0x201a4L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_SUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_height_sum_read(void) {
+	return APICAL_READ_32(0x201a8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_NUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_ACTIVE_HEIGHT_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_active_height_num_read(void) {
+	return APICAL_READ_32(0x201acL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_HBLANK_MIN_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_HBLANK_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_hblank_min_read(void) {
+	return APICAL_READ_32(0x201b0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_HBLANK_MAX_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_HBLANK_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_hblank_max_read(void) {
+	return APICAL_READ_32(0x201b4L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_HBLANK_SUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_HBLANK_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_hblank_sum_read(void) {
+	return APICAL_READ_32(0x201b8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_HBLANK_NUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_HBLANK_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_hblank_num_read(void) {
+	return APICAL_READ_32(0x201bcL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_VBLANK_MIN_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_VBLANK_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_vblank_min_read(void) {
+	return APICAL_READ_32(0x201c0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_VBLANK_MAX_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_VBLANK_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_vblank_max_read(void) {
+	return APICAL_READ_32(0x201c4L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_VBLANK_SUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_VBLANK_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_vblank_sum_read(void) {
+	return APICAL_READ_32(0x201c8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_FRAME_STATS_VBLANK_NUM_DEFAULT (0x0)
+#define APICAL_FPGA_FRAME_STATS_VBLANK_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_fpga_frame_stats_vblank_num_read(void) {
+	return APICAL_READ_32(0x201ccL);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Horizontal Shift
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// :Pixel resolution shift offset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_HORIZONTAL_SHIFT_OFFSET_DEFAULT (0x0)
+#define APICAL_FPGA_HORIZONTAL_SHIFT_OFFSET_DATASIZE (5)
+
+// args: data (5-bit)
+static __inline void apical_fpga_horizontal_shift_offset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20170L);
+	APICAL_WRITE_32(0x20170L, (((uint32_t) (data & 0x1f)) << 0) | (curr & 0xffffffe0));
+}
+static __inline uint8_t apical_fpga_horizontal_shift_offset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20170L) & 0x1f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FPGA_HORIZONTAL_SHIFT_ENABLE_DEFAULT (0x0)
+#define APICAL_FPGA_HORIZONTAL_SHIFT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_fpga_horizontal_shift_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x20170L);
+	APICAL_WRITE_32(0x20170L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_fpga_horizontal_shift_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x20170L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_FPGA_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_gamma_rgb_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_gamma_rgb_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_gamma_rgb_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_gamma_rgb_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_FR_GAMMA_RGB_MEM_CONFIG_H__
+#define __APICAL_FR_GAMMA_RGB_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'fr_gamma_rgb_mem' of module 'gamma_rgb_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FR_GAMMA_RGB_MEM_BASE_ADDR (0x10400L)
+#define APICAL_FR_GAMMA_RGB_MEM_SIZE (0x400)
+
+#define APICAL_FR_GAMMA_RGB_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_FR_GAMMA_RGB_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-128), data (32-bit)
+static __inline void apical_fr_gamma_rgb_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x10400L + (index << 2), data);
+}
+static __inline uint32_t apical_fr_gamma_rgb_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x10400L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_FR_GAMMA_RGB_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_sharpen_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_sharpen_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_sharpen_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_fr_sharpen_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_FR_SHARPEN_MEM_CONFIG_H__
+#define __APICAL_FR_SHARPEN_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'fr_sharpen_mem' of module 'sharpen_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_FR_SHARPEN_MEM_BASE_ADDR (0x10800L)
+#define APICAL_FR_SHARPEN_MEM_SIZE (0x800)
+
+#define APICAL_FR_SHARPEN_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_FR_SHARPEN_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-511), data (32-bit)
+static __inline void apical_fr_sharpen_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x10800L + (index << 2), data);
+}
+static __inline uint32_t apical_fr_sharpen_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x10800L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_FR_SHARPEN_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe0_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe0_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe0_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe0_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_GAMMA_FE0_MEM_CONFIG_H__
+#define __APICAL_GAMMA_FE0_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'gamma_fe0_mem' of module 'gamma_fe0_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_GAMMA_FE0_MEM_BASE_ADDR (0x2800L)
+#define APICAL_GAMMA_FE0_MEM_SIZE (0x100)
+
+#define APICAL_GAMMA_FE0_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_GAMMA_FE0_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-32), data (32-bit)
+static __inline void apical_gamma_fe0_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x2800L + (index << 2), data);
+}
+static __inline uint32_t apical_gamma_fe0_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x2800L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_GAMMA_FE0_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe1_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe1_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe1_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_gamma_fe1_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_GAMMA_FE1_MEM_CONFIG_H__
+#define __APICAL_GAMMA_FE1_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'gamma_fe1_mem' of module 'gamma_fe1_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_GAMMA_FE1_MEM_BASE_ADDR (0x3000L)
+#define APICAL_GAMMA_FE1_MEM_SIZE (0x800)
+
+#define APICAL_GAMMA_FE1_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_GAMMA_FE1_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-256), data (32-bit)
+static __inline void apical_gamma_fe1_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x3000L + (index << 2), data);
+}
+static __inline uint32_t apical_gamma_fe1_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x3000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_GAMMA_FE1_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,265 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_H__
+#define __APICAL_H__
+
+
+#include "apical_types.h"
+#include "apical_firmware_config.h"
+#include "apical_sensor_config.h"
+#include "apical_calibrations.h"
+
+typedef struct __apical_isp_register_value{
+	unsigned int addr;
+	unsigned int value;
+} apical_isp_regval_t;
+
+#define ISP_MODULE_BYPASS_ENABLE 1
+#define ISP_MODULE_BYPASS_DISABLE 0
+typedef union _apical_isp_top_contrl{
+	struct bitmap {
+		unsigned int test_gen		: 1;
+		unsigned int mirror		: 1;
+		unsigned int sensor_offset	: 1;
+		unsigned int dig_gain		: 1;
+		unsigned int gamma_fe		: 1;
+		unsigned int raw_front		: 1;
+		unsigned int defect_pixel	: 1;
+		unsigned int frame_stitch	: 1;
+		unsigned int gamma_fe_pos	: 1;
+		unsigned int sinter		: 1;
+		unsigned int temper		: 1;
+		unsigned int order		: 1;
+		unsigned int wb			: 1;
+		unsigned int radial		: 1;
+		unsigned int mesh		: 1;
+		unsigned int iridix		: 1;
+		unsigned int demosaic		: 1;
+		unsigned int matrix		: 1;
+		unsigned int fr_crop		: 1;
+		unsigned int fr_gamma		: 1;
+		unsigned int fr_sharpen		: 1;
+		unsigned int fr_logo		: 1;
+		unsigned int fr_csc		: 1;
+		unsigned int 			: 1;
+		unsigned int ds1_crop		: 1;
+		unsigned int ds1_scaler		: 1;
+		unsigned int ds1_gamma		: 1;
+		unsigned int ds1_sharpen	: 1;
+		unsigned int ds1_logo		: 1;
+		unsigned int ds1_csc		: 1;
+		unsigned int ds1_dma		: 1;
+		unsigned int 			: 1;
+		unsigned int ds2_scaler_source	: 1;
+		unsigned int ds2_crop		: 1;
+		unsigned int ds2_scaler		: 1;
+		unsigned int ds2_gamma		: 1;
+		unsigned int ds2_sharpen	: 1;
+		unsigned int ds2_logo		: 1;
+		unsigned int ds2_csc		: 1;
+		unsigned int 			: 2;
+		unsigned int raw_bypass		: 1;
+		unsigned int debug		: 2;
+		unsigned int 			: 1;
+		unsigned int proc_bypass_mode	: 2;
+		unsigned int  			: 17;
+	} bits;
+	struct topregs {
+		unsigned int low;
+		unsigned int high;
+	} reg;
+} apical_isp_top_ctl_t;
+
+enum apical_isp_top_ctl_bit {
+	TEST_GEN_BIT,
+	MIRROR_BIT,
+	SENSOR_OFFSET_BIT,
+	DIG_GAIN_BIT,
+	GAMMA_FE_BIT,
+	RAW_FRONT_BIT,
+	DEFECT_PIXEL_BIT,
+	FRAME_STITCH_BIT,
+	GAMMA_FE_POS_BIT,
+	SINTER_BIT,
+	TEMPER_BIT,
+	ORDER_BIT,
+	WB_BIT,
+	RADIAL_BIT,
+	MESH_BIT,
+	IRIDIX_BIT,
+	DEMOSAIC_BIT,
+	MATRIX_BIT,
+	FR_CROP_BIT,
+	FR_GAMMA_BIT,
+	FR_SHARPEN_BIT,
+	FR_LOGO_BIT,
+	FR_CSC_BIT,
+
+	DS1_CROP_BIT,
+	DS1_SCALER_BIT,
+	DS1_GAMMA_BIT,
+	DS1_SHARPEN_BIT,
+	DS1_LOGO_BIT,
+	DS1_CSC_BIT,
+	DS1_DMA_BIT,
+
+	DS2_SCALER_SOURCE_BIT,
+	DS2_CROP_BIT,
+	DS2_SCALER_BIT,
+	DS2_GAMMA_BIT,
+	DS2_SHARPEN_BIT,
+	DS2_LOGO_BIT,
+	DS2_CSC_BIT,
+
+	RAW_BYPASS_BIT,
+	DEBUG_BIT,
+
+	PROC_BYPASS_MODE_BIT,
+};
+
+
+
+typedef struct _metadata_t
+{
+	uint8_t format;
+	uint16_t width;
+	uint16_t height;
+	uint16_t line_size;
+	uint32_t exposure;
+	uint32_t int_time;
+	uint32_t again;
+	uint32_t dgain;
+	uint32_t isp_dgain;
+	int8_t dis_offset_x;
+	int8_t dis_offset_y;
+} metadata_t;
+
+typedef struct _sytem_tab{
+	uint8_t global_freeze_firmware ;
+	uint8_t  global_manual_exposure ;
+	uint8_t  global_manual_exposure_ratio ;
+	uint8_t  global_manual_integration_time ;
+	uint8_t  global_manual_sensor_analog_gain ;
+	uint8_t  global_manual_sensor_digital_gain ;
+	uint8_t  global_manual_isp_digital_gain ;
+	uint8_t  global_manual_directional_sharpening ;
+	uint8_t  global_manual_un_directional_sharpening ;
+	uint8_t  global_manual_iridix ;
+	uint8_t  global_manual_sinter ;
+	uint8_t  global_manual_temper ;
+	uint8_t  global_manual_awb ;
+	uint8_t  global_antiflicker_enable ;
+	uint8_t  global_slow_frame_rate_enable ;
+	uint8_t  global_manual_saturation ;
+	uint32_t  global_manual_exposure_time;
+	uint8_t  global_exposure_dark_target;
+	uint8_t  global_exposure_bright_target;
+	uint8_t  global_exposure_ratio;
+	uint8_t  global_max_exposure_ratio;
+	uint16_t  global_integration_time;
+	uint16_t  global_max_integration_time;
+	uint8_t  global_sensor_analog_gain;
+	uint8_t  global_max_sensor_analog_gain;
+	uint8_t  global_sensor_digital_gain;
+	uint8_t  global_max_sensor_digital_gain;
+	uint8_t  global_isp_digital_gain;
+	uint8_t  global_max_isp_digital_gain;
+	uint8_t  global_directional_sharpening_target;
+	uint8_t  global_maximum_directional_sharpening;
+	uint8_t  global_minimum_directional_sharpening;
+	uint8_t  global_un_directional_sharpening_target;
+	uint8_t  global_maximum_un_directional_sharpening;
+	uint8_t  global_minimum_un_directional_sharpening;
+	uint8_t  global_iridix_strength_target;
+	uint8_t  global_maximum_iridix_strength;
+	uint8_t  global_minimum_iridix_strength;
+	uint8_t  global_sinter_threshold_target;
+	uint8_t  global_maximum_sinter_strength;
+	uint8_t  global_minimum_sinter_strength;
+	uint8_t  global_temper_threshold_target;
+	uint8_t  global_maximum_temper_strength;
+	uint8_t  global_minimum_temper_strength;
+	uint8_t  global_awb_red_gain;
+	uint8_t  global_awb_blue_gain;
+	uint8_t  global_saturation_target;
+	uint8_t  global_anti_flicker_frequency ;
+	uint8_t  global_ae_compensation;
+	uint8_t  global_calibrate_bad_pixels ;
+	uint16_t  global_dis_x ;
+	uint16_t  global_dis_y ;
+} system_tab;
+
+extern system_tab stab ;
+typedef void (*buffer_callback_t)(uint32_t addr, const metadata_t *metadata);
+
+#define DMA_FORMAT_DISABLE 0
+#define DMA_FORMAT_RGB32 1
+#define DMA_FORMAT_A2R10G10B10 2
+#define DMA_FORMAT_RGB565 3
+#define DMA_FORMAT_RGB24 4
+#define DMA_FORMAT_RAW16 6
+#define DMA_FORMAT_RAW12 7
+#define DMA_FORMAT_AYUV 8
+#define DMA_FORMAT_Y410 9
+#define DMA_FORMAT_YUY2 10
+#define DMA_FORMAT_UYVY 11
+#define DMA_FORMAT_Y210 12
+#define DMA_FORMAT_NV12_Y (13|0x000)
+#define DMA_FORMAT_NV12_UV (13|0x40)
+#define DMA_FORMAT_NV12_VU (13|0x80)
+#define DMA_FORMAT_YV12_Y (14|0x000)
+#define DMA_FORMAT_YV12_U (14|0x100)
+#define DMA_FORMAT_YV12_V (14|0x200)
+
+void apical_init(void);
+
+void apical_init_calibrations( uint32_t mode ) ;
+
+void apical_process(void);
+
+#if ISP_HAS_TEMPER
+void apical_frame_buffer_configure_temper(uint32_t buf_base_addr);
+#endif
+
+void apical_frame_buffer_configure_all(uint32_t start_addr, uint32_t fr_buf_size, uint16_t fr_format, buffer_callback_t fr_callback
+#if ISP_HAS_DOWNSCALER || ISP_HAS_DOUBLE_DS
+		,uint32_t ds_buf_size
+		,uint16_t ds_format
+		,buffer_callback_t ds_callback
+#endif
+#if ISP_HAS_DOUBLE_DS
+		,uint32_t ds2_buf_size
+		,uint16_t ds2_format
+		,buffer_callback_t ds2_callback
+#endif
+
+		);
+
+void apical_change_resolution(uint32_t exposure_correction);
+#if ISP_HAS_CONNECTION_SOCKET
+/* please call these routines from the platform specific code to setup socket routines */
+struct apical_socket_f *apical_socket_f_impl(void);
+void apical_socket_set_f_impl(struct apical_socket_f *f);
+#endif // ISP_HAS_CONNECTION_SOCKET
+#define ISP_HAS_STREAM_CONNECTION (ISP_HAS_CONNECTION_SOCKET || ISP_HAS_CONNECTION_BUFFER || ISP_HAS_CONNECTION_UART || ISP_HAS_CONNECTION_CHARDEV)
+
+
+#define BUS_ERROR_RESET	-1
+#define BUS_ERROR_FATAL	-2
+
+void apical_connection_init(void);
+void apical_connection_process(void);
+void apical_connection_destroy(void);
+
+
+#endif /* __APICAL_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_histogram_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_histogram_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_histogram_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_histogram_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_HISTOGRAM_MEM_CONFIG_H__
+#define __APICAL_HISTOGRAM_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'histogram_mem' of module 'histogram_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_HISTOGRAM_MEM_BASE_ADDR (0x10000L)
+#define APICAL_HISTOGRAM_MEM_SIZE (0x400)
+
+#define APICAL_HISTOGRAM_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_HISTOGRAM_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-255), data (32-bit)
+static __inline void apical_histogram_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x10000L + (index << 2), data);
+}
+static __inline uint32_t apical_histogram_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x10000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_HISTOGRAM_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt1_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt1_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt1_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt1_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_I_HFILT1_MEM_CONFIG_H__
+#define __APICAL_I_HFILT1_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'i_hfilt1_mem' of module 'scaler_hfilt_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_I_HFILT1_MEM_BASE_ADDR (0x14000L)
+#define APICAL_I_HFILT1_MEM_SIZE (0x1000)
+
+#define APICAL_I_HFILT1_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_I_HFILT1_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-255), data (32-bit)
+static __inline void apical_i_hfilt1_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x14000L + (index << 2), data);
+}
+static __inline uint32_t apical_i_hfilt1_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x14000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_I_HFILT1_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt2_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt2_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt2_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_hfilt2_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_I_HFILT2_MEM_CONFIG_H__
+#define __APICAL_I_HFILT2_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'i_hfilt2_mem' of module 'scaler_hfilt_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_I_HFILT2_MEM_BASE_ADDR (0x18000L)
+#define APICAL_I_HFILT2_MEM_SIZE (0x1000)
+
+#define APICAL_I_HFILT2_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_I_HFILT2_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-255), data (32-bit)
+static __inline void apical_i_hfilt2_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x18000L + (index << 2), data);
+}
+static __inline uint32_t apical_i_hfilt2_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x18000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_I_HFILT2_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_interface_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_interface_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_interface_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_interface_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,19 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_INTERFACE_CONFIG_H__
+#define __APICAL_INTERFACE_CONFIG_H__
+
+
+#define APICAL_MIPI_BOARD 0
+#define APICAL_MIPI_I2C_ADDR 0
+#endif
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,16908 @@
+#ifndef __APICAL_ISP_CONFIG_H__
+#define __APICAL_ISP_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'isp' of module 'ip_config'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_BASE_ADDR (0x0L)
+#define APICAL_ISP_SIZE (0x2000)
+
+#define APICAL_ISP_MAX_ADDR (0x1ffff)
+
+// ------------------------------------------------------------------------------ //
+// Group: ID
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: API
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_ID_API_DEFAULT (0x0)
+#define APICAL_ISP_ID_API_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_id_api_read(void) {
+	return APICAL_READ_32(0x0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Product
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_ID_PRODUCT_DEFAULT (0x0)
+#define APICAL_ISP_ID_PRODUCT_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_id_product_read(void) {
+	return APICAL_READ_32(0x4L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Version
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_ID_VERSION_DEFAULT (0x0)
+#define APICAL_ISP_ID_VERSION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_id_version_read(void) {
+	return APICAL_READ_32(0x8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Revision
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_ID_REVISION_DEFAULT (0x0)
+#define APICAL_ISP_ID_REVISION_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_id_revision_read(void) {
+	return APICAL_READ_32(0xcL);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Top
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Miscellaneous top-level ISP controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Active Width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_TOP_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_top_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x10L);
+	APICAL_WRITE_32(0x10L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_top_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x10L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Active Height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_TOP_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_top_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x14L);
+	APICAL_WRITE_32(0x14L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_top_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x14L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: RGGB start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Starting color of the rggb pattern
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_RGGB_START_DEFAULT (0x0)
+#define APICAL_ISP_TOP_RGGB_START_DATASIZE (2)
+#define APICAL_ISP_TOP_RGGB_START_R_GR_GB_B (0)
+#define APICAL_ISP_TOP_RGGB_START_GR_R_B_GB (1)
+#define APICAL_ISP_TOP_RGGB_START_GB_B_R_GR (2)
+#define APICAL_ISP_TOP_RGGB_START_B_GB_GR_R (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_rggb_start_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x18L);
+	APICAL_WRITE_32(0x18L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_top_rggb_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x18L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Flush hblank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal blanking interval during regeneration (0=measured input interval)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_FLUSH_HBLANK_DEFAULT (0x20)
+#define APICAL_ISP_TOP_FLUSH_HBLANK_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_top_flush_hblank_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x28L);
+	APICAL_WRITE_32(0x28L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_top_flush_hblank_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x28L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Config Buffer Mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Select ISP configuration double-buffering mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_CONFIG_BUFFER_MODE_DEFAULT (0)
+#define APICAL_ISP_TOP_CONFIG_BUFFER_MODE_DATASIZE (2)
+#define APICAL_ISP_TOP_CONFIG_BUFFER_MODE_DISABLED_CONFIG_UPDATES_IMMEDIATELY (0)
+#define APICAL_ISP_TOP_CONFIG_BUFFER_MODE_BLOCKED_CONFIG_NEVER_UPDATES (1)
+#define APICAL_ISP_TOP_CONFIG_BUFFER_MODE_LOCAL_MODULE_CONFIG_UPDATES_DURING_LOCAL_VERTICAL_BLANKING (2)
+#define APICAL_ISP_TOP_CONFIG_BUFFER_MODE_GLOBAL_ALL_MODULE_CONFIG_UPDATED_DURING_ISP_VERTICAL_BLANKING (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_config_buffer_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x30L);
+	APICAL_WRITE_32(0x30L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_top_config_buffer_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x30L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass video test gen
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass video test generator
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_VIDEO_TEST_GEN_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_VIDEO_TEST_GEN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_video_test_gen_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_top_bypass_video_test_gen_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass mirror
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass horizontal mirror
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_MIRROR_DEFAULT (1)
+#define APICAL_ISP_TOP_BYPASS_MIRROR_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_mirror_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_top_bypass_mirror_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass sensor offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass frontend black level adjustment
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_SENSOR_OFFSET_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_SENSOR_OFFSET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_sensor_offset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_top_bypass_sensor_offset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass digital gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass digital gain module
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DIGITAL_GAIN_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DIGITAL_GAIN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_digital_gain_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_top_bypass_digital_gain_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass gamma fe
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass WDR companded frontend lookup table
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_GAMMA_FE_DEFAULT (1)
+#define APICAL_ISP_TOP_BYPASS_GAMMA_FE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_gamma_fe_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_top_bypass_gamma_fe_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass RAW frontend
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass RAW frontend (green equalization and dynamic defect pixel)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_RAW_FRONTEND_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_RAW_FRONTEND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_raw_frontend_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_top_bypass_raw_frontend_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass defect pixel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass static defect pixel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DEFECT_PIXEL_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DEFECT_PIXEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_defect_pixel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_top_bypass_defect_pixel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass frame stitch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass frame stitching logic
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_FRAME_STITCH_DEFAULT (1)
+#define APICAL_ISP_TOP_BYPASS_FRAME_STITCH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_frame_stitch_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_top_bypass_frame_stitch_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Gamma fe position
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass temper
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_GAMMA_FE_POSITION_DEFAULT (1)
+#define APICAL_ISP_TOP_GAMMA_FE_POSITION_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_gamma_fe_position_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_top_gamma_fe_position_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass sinter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass sinter
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_SINTER_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_SINTER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_sinter_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_top_bypass_sinter_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass temper
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass temper
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_TEMPER_DEFAULT (1)
+#define APICAL_ISP_TOP_BYPASS_TEMPER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_temper_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_top_bypass_temper_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Order Sinter Temper
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_ORDER_SINTER_TEMPER_DEFAULT (0)
+#define APICAL_ISP_TOP_ORDER_SINTER_TEMPER_DATASIZE (1)
+#define APICAL_ISP_TOP_ORDER_SINTER_TEMPER_SINTER_BEFORE_TEMPER (0)
+#define APICAL_ISP_TOP_ORDER_SINTER_TEMPER_SINTER_AFTER_TEMPER (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_order_sinter_temper_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_top_order_sinter_temper_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass white balance
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass static white balance
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_WHITE_BALANCE_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_WHITE_BALANCE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_white_balance_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 12) | (curr & 0xffffefff));
+}
+static __inline uint8_t apical_isp_top_bypass_white_balance_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x1000) >> 12);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass radial shading
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Radial Shading
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_RADIAL_SHADING_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_RADIAL_SHADING_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_radial_shading_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 13) | (curr & 0xffffdfff));
+}
+static __inline uint8_t apical_isp_top_bypass_radial_shading_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x2000) >> 13);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass mesh shading
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Mesh Shading
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_MESH_SHADING_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_MESH_SHADING_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_mesh_shading_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 14) | (curr & 0xffffbfff));
+}
+static __inline uint8_t apical_isp_top_bypass_mesh_shading_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x4000) >> 14);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass iridix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Iridix
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_IRIDIX_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_IRIDIX_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_iridix_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 15) | (curr & 0xffff7fff));
+}
+static __inline uint8_t apical_isp_top_bypass_iridix_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x8000) >> 15);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass demosaic
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass demosaic module (output RAW data)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DEMOSAIC_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DEMOSAIC_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_demosaic_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_isp_top_bypass_demosaic_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass color matrix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass color matrix
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_COLOR_MATRIX_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_COLOR_MATRIX_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_color_matrix_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_isp_top_bypass_color_matrix_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass fr crop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass crop (full resolution)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_FR_CROP_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_FR_CROP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_fr_crop_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 18) | (curr & 0xfffbffff));
+}
+static __inline uint8_t apical_isp_top_bypass_fr_crop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass fr gamma RGB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass gamma table  (full resolution)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_FR_GAMMA_RGB_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_FR_GAMMA_RGB_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_fr_gamma_rgb_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 19) | (curr & 0xfff7ffff));
+}
+static __inline uint8_t apical_isp_top_bypass_fr_gamma_rgb_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x80000) >> 19);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass fr sharpen
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass sharpen  (full resolution)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_FR_SHARPEN_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_FR_SHARPEN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_fr_sharpen_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_isp_top_bypass_fr_sharpen_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass fr logo
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Logo (full resolution)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_FR_LOGO_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_FR_LOGO_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_fr_logo_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 21) | (curr & 0xffdfffff));
+}
+static __inline uint8_t apical_isp_top_bypass_fr_logo_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x200000) >> 21);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass fr cs conv
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Colour Space Conversion (full resolution)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_FR_CS_CONV_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_FR_CS_CONV_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_fr_cs_conv_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 22) | (curr & 0xffbfffff));
+}
+static __inline uint8_t apical_isp_top_bypass_fr_cs_conv_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x400000) >> 22);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds1 crop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass crop (down scaled output 1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS1_CROP_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS1_CROP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds1_crop_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 24) | (curr & 0xfeffffff));
+}
+static __inline uint8_t apical_isp_top_bypass_ds1_crop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x1000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds1 scaler
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Down Scaler 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS1_SCALER_DEFAULT (1)
+#define APICAL_ISP_TOP_BYPASS_DS1_SCALER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds1_scaler_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 25) | (curr & 0xfdffffff));
+}
+static __inline uint8_t apical_isp_top_bypass_ds1_scaler_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x2000000) >> 25);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds1 gamma RGB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass gamma table  (down scaled output 1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS1_GAMMA_RGB_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS1_GAMMA_RGB_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds1_gamma_rgb_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 26) | (curr & 0xfbffffff));
+}
+static __inline uint8_t apical_isp_top_bypass_ds1_gamma_rgb_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x4000000) >> 26);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds1 sharpen
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass sharpen  (down scaled output 1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS1_SHARPEN_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS1_SHARPEN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds1_sharpen_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 27) | (curr & 0xf7ffffff));
+}
+static __inline uint8_t apical_isp_top_bypass_ds1_sharpen_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x8000000) >> 27);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds1 logo
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Logo (down scaled output 1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS1_LOGO_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS1_LOGO_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds1_logo_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 28) | (curr & 0xefffffff));
+}
+static __inline uint8_t apical_isp_top_bypass_ds1_logo_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x10000000) >> 28);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds1 cs conv
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Colour Space Conversion (down scaled output 1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS1_CS_CONV_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS1_CS_CONV_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds1_cs_conv_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 29) | (curr & 0xdfffffff));
+}
+static __inline uint8_t apical_isp_top_bypass_ds1_cs_conv_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x20000000) >> 29);
+}
+// ------------------------------------------------------------------------------ //
+// Register: DS1 DMA source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source for DS1 DMA data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_DS1_DMA_SOURCE_DEFAULT (0)
+#define APICAL_ISP_TOP_DS1_DMA_SOURCE_DATASIZE (1)
+#define APICAL_ISP_TOP_DS1_DMA_SOURCE_COLOR_SPACE_CONVERTOR (0)
+#define APICAL_ISP_TOP_DS1_DMA_SOURCE_INPUT_RAW_DATA (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_ds1_dma_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40L);
+	APICAL_WRITE_32(0x40L, (((uint32_t) (data & 0x1)) << 30) | (curr & 0xbfffffff));
+}
+static __inline uint8_t apical_isp_top_ds1_dma_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40L) & 0x40000000) >> 30);
+}
+// ------------------------------------------------------------------------------ //
+// Register: DS2 scaler source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Source selector for DS2 scaler
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_DS2_SCALER_SOURCE_DEFAULT (0)
+#define APICAL_ISP_TOP_DS2_SCALER_SOURCE_DATASIZE (1)
+#define APICAL_ISP_TOP_DS2_SCALER_SOURCE_COLOR_MATRIX (0)
+#define APICAL_ISP_TOP_DS2_SCALER_SOURCE_DS1_SCALER_OUTPUT_CHAINING (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_ds2_scaler_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_top_ds2_scaler_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds2 crop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass crop (down scaled output 2)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS2_CROP_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS2_CROP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds2_crop_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_top_bypass_ds2_crop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds2 scaler
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Down Scaler 2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS2_SCALER_DEFAULT (1)
+#define APICAL_ISP_TOP_BYPASS_DS2_SCALER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds2_scaler_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_top_bypass_ds2_scaler_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds2 gamma RGB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass gamma table  (down scaled output 2)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS2_GAMMA_RGB_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS2_GAMMA_RGB_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds2_gamma_rgb_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_top_bypass_ds2_gamma_rgb_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds2 sharpen
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass sharpen  (down scaled output 2)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS2_SHARPEN_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS2_SHARPEN_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds2_sharpen_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_top_bypass_ds2_sharpen_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds2 logo
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Logo (down scaled output 2)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS2_LOGO_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS2_LOGO_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds2_logo_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_top_bypass_ds2_logo_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Bypass ds2 cs conv
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bypass Colour Space Conversion (down scaled output 2)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_BYPASS_DS2_CS_CONV_DEFAULT (0)
+#define APICAL_ISP_TOP_BYPASS_DS2_CS_CONV_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_bypass_ds2_cs_conv_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_top_bypass_ds2_cs_conv_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ISP RAW bypass
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//   Used to select between sensor raw input or RGB888 or YUV422 input
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_ISP_RAW_BYPASS_DEFAULT (0)
+#define APICAL_ISP_TOP_ISP_RAW_BYPASS_DATASIZE (1)
+#define APICAL_ISP_TOP_ISP_RAW_BYPASS_SELECT_PROCESSED__NORMAL_ISP_PROCESSING_WITH_IMAGE_SENSOR_RAW_DATA (0)
+#define APICAL_ISP_TOP_ISP_RAW_BYPASS_BYPASS_ISP_RAW_PROCESSING_FOR_RGB888_OR_YUV422_INPUTSPASS_INPUT_RGB_OR_YUV_DATA_TO_BACKEND__DATA_IS_REINSERTED_INTO_PIPELINE_AFTER_DEMOSAIC_BLOCK__CROP_SCALING_GAMMA_AND_COLOR_SPACE_CONVERSION_ARE_AVAILABLE_FOR_RGB888_INPUT_ONLY (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_isp_raw_bypass_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_top_isp_raw_bypass_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ISP debug select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Debug port source select.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_ISP_DEBUG_SELECT_DEFAULT (0)
+#define APICAL_ISP_TOP_ISP_DEBUG_SELECT_DATASIZE (2)
+#define APICAL_ISP_TOP_ISP_DEBUG_SELECT_DOWN_SCALED_STREAMED_VIDEO_1 (0)
+#define APICAL_ISP_TOP_ISP_DEBUG_SELECT_DOWN_SCALED_STREAMED_VIDEO_2 (1)
+#define APICAL_ISP_TOP_ISP_DEBUG_SELECT_FULL_RESOLUTION_STREAMED_VIDEO_AFTER_BYPASS_MUX (2)
+#define APICAL_ISP_TOP_ISP_DEBUG_SELECT_INPUT_VIDEO_INTO_INPUT_PORT (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_isp_debug_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x3)) << 10) | (curr & 0xfffff3ff));
+}
+static __inline uint8_t apical_isp_top_isp_debug_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0xc00) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ISP processing bypass mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		ISP bypass modes.  For debug purposes only. Should be set to 0 during normal operation.
+//		Used to bypass entire ISP after input port.  Data is sent to input of full resolution DMA Writer.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_ISP_PROCESSING_BYPASS_MODE_DEFAULT (0)
+#define APICAL_ISP_TOP_ISP_PROCESSING_BYPASS_MODE_DATASIZE (2)
+#define APICAL_ISP_TOP_ISP_PROCESSING_BYPASS_MODE_FULL_PROCESSING (0)
+#define APICAL_ISP_TOP_ISP_PROCESSING_BYPASS_MODE_BYPASS_ENTIRE_ISP_PROCESSING_AND_OUTPUT_MOST_SIGNIFICANT_BITS_OF_RAW_SENSOR_DATA_IN_ALL_CHANNELS (1)
+#define APICAL_ISP_TOP_ISP_PROCESSING_BYPASS_MODE_BYPASS_ENTIRE_ISP_PROCESSING_AND_OUTPUT_RAW_SENSOR_DATA_IN_CHANNEL_1_AND_MOST_SIGNIFICANT_BITS_OF_CHANNEL_2 (2)
+#define APICAL_ISP_TOP_ISP_PROCESSING_BYPASS_MODE_BYPASS_ENTIRE_ISP_PROCESSING_AND_OUTPUT_8_BIT_RGB_INPUT_AS_10_BIT_RGB_DATA (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_isp_processing_bypass_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44L);
+	APICAL_WRITE_32(0x44L, (((uint32_t) (data & 0x3)) << 13) | (curr & 0xffff9fff));
+}
+static __inline uint8_t apical_isp_top_isp_processing_bypass_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44L) & 0x6000) >> 13);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AE switch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AE tap in the pipeline.  Location of AE statistic collection.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_AE_SWITCH_DEFAULT (0)
+#define APICAL_ISP_TOP_AE_SWITCH_DATASIZE (3)
+#define APICAL_ISP_TOP_AE_SWITCH_AFTER_STATIC_WHITE_BALANCE (0)
+#define APICAL_ISP_TOP_AE_SWITCH_AFTER_TPG (1)
+#define APICAL_ISP_TOP_AE_SWITCH_AFTER_SHADING (2)
+#define APICAL_ISP_TOP_AE_SWITCH_AFTER_FRONTEND_LOOKUP_TABLE (3)
+#define APICAL_ISP_TOP_AE_SWITCH_LONG_EXPOSURE (4)
+#define APICAL_ISP_TOP_AE_SWITCH_SHORT_EXPOSURE (5)
+#define APICAL_ISP_TOP_AE_SWITCH_BEFORE_TEMPER (6)
+#define APICAL_ISP_TOP_AE_SWITCH_DISABLED (7)
+
+// args: data (3-bit)
+static __inline void apical_isp_top_ae_switch_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x48L);
+	APICAL_WRITE_32(0x48L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_top_ae_switch_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x48L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB switch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AWB tap in the pipeline.  Location of AWB statistics collection.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_AWB_SWITCH_DEFAULT (0)
+#define APICAL_ISP_TOP_AWB_SWITCH_DATASIZE (2)
+#define APICAL_ISP_TOP_AWB_SWITCH_IMMEDIATELY_BEFORE_COLOUR_MATRIX (0)
+#define APICAL_ISP_TOP_AWB_SWITCH_IMMEDIATELY_AFTER_COLOUR_MATRIX (1)
+#define APICAL_ISP_TOP_AWB_SWITCH_DISABLED (2)
+#define APICAL_ISP_TOP_AWB_SWITCH_DISABLED3 (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_awb_switch_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4cL);
+	APICAL_WRITE_32(0x4cL, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_top_awb_switch_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4cL) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF switch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AF tap in the pipeline
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_AF_SWITCH_DEFAULT (0)
+#define APICAL_ISP_TOP_AF_SWITCH_DATASIZE (2)
+#define APICAL_ISP_TOP_AF_SWITCH_DEMOSAIC (0)
+#define APICAL_ISP_TOP_AF_SWITCH_SHARPEN (1)
+#define APICAL_ISP_TOP_AF_SWITCH_DISABLED (2)
+#define APICAL_ISP_TOP_AF_SWITCH_DISABLED3 (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_af_switch_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x50L);
+	APICAL_WRITE_32(0x50L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_top_af_switch_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x50L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MVE switch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// MVE tap in the pipeline.  Location of DIS correlation value calculations
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_MVE_SWITCH_DEFAULT (0)
+#define APICAL_ISP_TOP_MVE_SWITCH_DATASIZE (2)
+#define APICAL_ISP_TOP_MVE_SWITCH_END_OF_PIPELINE (0)
+#define APICAL_ISP_TOP_MVE_SWITCH_BEFORE_DEMOSAIC (1)
+#define APICAL_ISP_TOP_MVE_SWITCH_BEFORE_DEFECT_PIXEL (2)
+#define APICAL_ISP_TOP_MVE_SWITCH_DISABLED (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_top_mve_switch_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x54L);
+	APICAL_WRITE_32(0x54L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_top_mve_switch_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x54L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Histogram switch
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AE global histogram tap in the pipeline.  Location of statistics gathering for 256 bin global histogram
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_DEFAULT (0)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_DATASIZE (3)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_SAME_AS_AE (0)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_AFTER_TPG (1)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_AFTER_SHADING (2)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_AFTER_FRONTEND_LOOKUP_TABLE (3)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_LONG_EXPOSURE (4)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_SHORT_EXPOSURE (5)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_BEFORE_TEMPER (6)
+#define APICAL_ISP_TOP_HISTOGRAM_SWITCH_DISABLED (7)
+
+// args: data (3-bit)
+static __inline void apical_isp_top_histogram_switch_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x58L);
+	APICAL_WRITE_32(0x58L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_top_histogram_switch_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x58L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Field Status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Status of field signal
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_FIELD_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_TOP_FIELD_STATUS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_top_field_status_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7cL) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Global FSM reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= synchronous reset of FSMs in design (faster recovery after broken frame)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_GLOBAL_FSM_RESET_DEFAULT (0x0)
+#define APICAL_ISP_TOP_GLOBAL_FSM_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_global_fsm_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x78L);
+	APICAL_WRITE_32(0x78L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_top_global_fsm_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x78L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VCKE override
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= override VCKE to flush the pipeline (recovery after broken frame)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TOP_VCKE_OVERRIDE_DEFAULT (0x0)
+#define APICAL_ISP_TOP_VCKE_OVERRIDE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_top_vcke_override_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x78L);
+	APICAL_WRITE_32(0x78L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_top_vcke_override_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x78L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Interrupts
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt controller
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt0 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT0_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT0_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt0_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x80L);
+	APICAL_WRITE_32(0x80L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt0_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x80L) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt1 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT1_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT1_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt1_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x80L);
+	APICAL_WRITE_32(0x80L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt1_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x80L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt2 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT2_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT2_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt2_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x84L);
+	APICAL_WRITE_32(0x84L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt2_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x84L) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt3 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT3_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT3_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt3_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x84L);
+	APICAL_WRITE_32(0x84L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt3_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x84L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt4 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT4_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT4_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt4_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x88L);
+	APICAL_WRITE_32(0x88L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt4_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x88L) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt5 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT5_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT5_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt5_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x88L);
+	APICAL_WRITE_32(0x88L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt5_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x88L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt6 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT6_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT6_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt6_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8cL);
+	APICAL_WRITE_32(0x8cL, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt6_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8cL) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt7 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT7_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT7_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt7_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8cL);
+	APICAL_WRITE_32(0x8cL, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt7_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8cL) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt8 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT8_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT8_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt8_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x90L);
+	APICAL_WRITE_32(0x90L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt8_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x90L) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt9 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT9_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT9_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt9_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x90L);
+	APICAL_WRITE_32(0x90L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt9_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x90L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt10 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT10_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT10_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt10_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x94L);
+	APICAL_WRITE_32(0x94L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt10_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x94L) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt11 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT11_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT11_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt11_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x94L);
+	APICAL_WRITE_32(0x94L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt11_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x94L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt12 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT12_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT12_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt12_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x98L);
+	APICAL_WRITE_32(0x98L, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt12_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x98L) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt13 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT13_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT13_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt13_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x98L);
+	APICAL_WRITE_32(0x98L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt13_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x98L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt14 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT14_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT14_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt14_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9cL);
+	APICAL_WRITE_32(0x9cL, (((uint32_t) (data & 0x3f)) << 0) | (curr & 0xffffffc0));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt14_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9cL) & 0x3f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt15 source
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt source selector. See ISP guide for interrupt definitions and valid values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT15_SOURCE_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT15_SOURCE_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_interrupts_interrupt15_source_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9cL);
+	APICAL_WRITE_32(0x9cL, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_interrupts_interrupt15_source_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9cL) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt event flags.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT_STATUS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_interrupts_interrupt_status_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xa0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Interrupt clear
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Interrupt event clear register writing 0-1 transition will clear the corresponding status bits.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INTERRUPTS_INTERRUPT_CLEAR_DEFAULT (0x0)
+#define APICAL_ISP_INTERRUPTS_INTERRUPT_CLEAR_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_interrupts_interrupt_clear_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xa4L);
+	APICAL_WRITE_32(0xa4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_interrupts_interrupt_clear_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xa4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Input port
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls video input port.
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: preset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 	  Allows selection of various input port presets for standard sensor inputs.  See ISP Guide for details of available presets.
+//0-14: Frequently used presets.  If using one of available presets, remaining bits in registers 0x100 and 0x104 are not used.
+//15:   Input port configured according to registers in 0x100 and 0x104.  Consult Apical support for special input port requirements.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_PRESET_DEFAULT (2)
+#define APICAL_ISP_INPUT_PORT_PRESET_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_input_port_preset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_input_port_preset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vs_use field
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VS_USE_FIELD_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VS_USE_FIELD_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_VS_USE_FIELD_USE_VSYNC_I_PORT_FOR_VERTICAL_SYNC (0)
+#define APICAL_ISP_INPUT_PORT_VS_USE_FIELD_USE_FIELD_I_PORT_FOR_VERTICAL_SYNC (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_vs_use_field_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_input_port_vs_use_field_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vs toggle
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VS_TOGGLE_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VS_TOGGLE_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_VS_TOGGLE_VSYNC_IS_PULSETYPE (0)
+#define APICAL_ISP_INPUT_PORT_VS_TOGGLE_VSYNC_IS_TOGGLETYPE_FIELD_SIGNAL (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_vs_toggle_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_input_port_vs_toggle_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vs polarity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_HORIZONTAL_COUNTER_RESET_ON_RISING_EDGE (0)
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_HORIZONTAL_COUNTER_RESET_ON_FALLING_EDGE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_vs_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_input_port_vs_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vs_polarity acl
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_ACL_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_ACL_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_ACL_DONT_INVERT_POLARITY_FOR_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_VS_POLARITY_ACL_INVERT_POLARITY_FOR_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_vs_polarity_acl_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_input_port_vs_polarity_acl_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hs_use acl
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HS_USE_ACL_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HS_USE_ACL_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HS_USE_ACL_USE_HSYNC_I_PORT_FOR_ACTIVELINE (0)
+#define APICAL_ISP_INPUT_PORT_HS_USE_ACL_USE_ACL_I_PORT_FOR_ACTIVELINE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hs_use_acl_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 12) | (curr & 0xffffefff));
+}
+static __inline uint8_t apical_isp_input_port_hs_use_acl_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x1000) >> 12);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vc_c select
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VC_C_SELECT_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VC_C_SELECT_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_VC_C_SELECT_VERTICAL_COUNTER_COUNTS_ON_HS (0)
+#define APICAL_ISP_INPUT_PORT_VC_C_SELECT_VERTICAL_COUNTER_COUNTS_ON_HORIZONTAL_COUNTER_OVERFLOW_OR_RESET (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_vc_c_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 14) | (curr & 0xffffbfff));
+}
+static __inline uint8_t apical_isp_input_port_vc_c_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x4000) >> 14);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vc_r select
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VC_R_SELECT_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VC_R_SELECT_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_VC_R_SELECT_VERTICAL_COUNTER_IS_RESET_ON_EDGE_OF_VS (0)
+#define APICAL_ISP_INPUT_PORT_VC_R_SELECT_VERTICAL_COUNTER_IS_RESET_AFTER_TIMEOUT_ON_HS (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_vc_r_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 15) | (curr & 0xffff7fff));
+}
+static __inline uint8_t apical_isp_input_port_vc_r_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x8000) >> 15);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hs_xor vs
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HS_XOR_VS_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HS_XOR_VS_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HS_XOR_VS_NORMAL_MODE (0)
+#define APICAL_ISP_INPUT_PORT_HS_XOR_VS_HVALID__HSYNC_XOR_VSYNC (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hs_xor_vs_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_isp_input_port_hs_xor_vs_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hs polarity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_DONT_INVERT_POLARITY_OF_HS_FOR_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_INVERT_POLARITY_OF_HS_FOR_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hs_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_isp_input_port_hs_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hs_polarity acl
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_ACL_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_ACL_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_ACL_DONT_INVERT_POLARITY_OF_HS_FOR_HS_GATE (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_ACL_INVERT_POLARITY_OF_HS_FOR_HS_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hs_polarity_acl_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 18) | (curr & 0xfffbffff));
+}
+static __inline uint8_t apical_isp_input_port_hs_polarity_acl_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hs_polarity hs
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_HS_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_HS_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_HS_HORIZONTAL_COUNTER_IS_RESET_ON_RISING_EDGE_OF_HS (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_HS_HORIZONTAL_COUNTER_IS_RESET_ON_VSYNC_EG_WHEN_HSYNC_IS_NOT_AVAILABLE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hs_polarity_hs_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 19) | (curr & 0xfff7ffff));
+}
+static __inline uint8_t apical_isp_input_port_hs_polarity_hs_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x80000) >> 19);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hs_polarity vc
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_VC_DEFAULT (1)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_VC_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_VC_VERTICAL_COUNTER_INCREMENTS_ON_RISING_EDGE_OF_HS (0)
+#define APICAL_ISP_INPUT_PORT_HS_POLARITY_VC_VERTICAL_COUNTER_INCREMENTS_ON_FALLING_EDGE_OF_HS (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hs_polarity_vc_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 20) | (curr & 0xffefffff));
+}
+static __inline uint8_t apical_isp_input_port_hs_polarity_vc_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x100000) >> 20);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hc_r select
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HC_R_SELECT_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HC_R_SELECT_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HC_R_SELECT_VERTICAL_COUNTER_IS_RESET_ON_RISING_EDGE_OF_HS (0)
+#define APICAL_ISP_INPUT_PORT_HC_R_SELECT_VERTICAL_COUNTER_IS_RESET_ON_RISING_EDGE_OF_VS (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hc_r_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 23) | (curr & 0xff7fffff));
+}
+static __inline uint8_t apical_isp_input_port_hc_r_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x800000) >> 23);
+}
+// ------------------------------------------------------------------------------ //
+// Register: acl polarity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_ACL_POLARITY_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_ACL_POLARITY_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_ACL_POLARITY_DONT_INVERT_ACL_I_FOR_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_ACL_POLARITY_INVERT_ACL_I_FOR_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_acl_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x100L);
+	APICAL_WRITE_32(0x100L, (((uint32_t) (data & 0x1)) << 24) | (curr & 0xfeffffff));
+}
+static __inline uint8_t apical_isp_input_port_acl_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x100L) & 0x1000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: field polarity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FIELD_POLARITY_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FIELD_POLARITY_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FIELD_POLARITY_DONT_INVERT_FIELD_I_FOR_FIELD_GATE (0)
+#define APICAL_ISP_INPUT_PORT_FIELD_POLARITY_INVERT_FIELD_I_FOR_FIELD_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_field_polarity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_input_port_field_polarity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: field toggle
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FIELD_TOGGLE_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FIELD_TOGGLE_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FIELD_TOGGLE_FIELD_IS_PULSETYPE (0)
+#define APICAL_ISP_INPUT_PORT_FIELD_TOGGLE_FIELD_IS_TOGGLETYPE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_field_toggle_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_input_port_field_toggle_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: aclg window0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW0_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW0_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW0_EXCLUDE_WINDOW0_SIGNAL_IN_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW0_INCLUDE_WINDOW0_SIGNAL_IN_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_aclg_window0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_input_port_aclg_window0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: aclg hsync
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_ACLG_HSYNC_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_HSYNC_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_ACLG_HSYNC_EXCLUDE_HSYNC_SIGNAL_IN_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_HSYNC_INCLUDE_HSYNC_SIGNAL_IN_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_aclg_hsync_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_input_port_aclg_hsync_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: aclg window2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW2_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW2_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW2_EXCLUDE_WINDOW2_SIGNAL_IN_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_WINDOW2_INCLUDE_WINDOW2_SIGNAL_IN_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_aclg_window2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_input_port_aclg_window2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: aclg acl
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_ACLG_ACL_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_ACL_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_ACLG_ACL_EXCLUDE_ACL_I_SIGNAL_IN_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_ACL_INCLUDE_ACL_I_SIGNAL_IN_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_aclg_acl_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_input_port_aclg_acl_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: aclg vsync
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_ACLG_VSYNC_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_VSYNC_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_ACLG_VSYNC_EXCLUDE_VSYNC_SIGNAL_IN_ACL_GATE (0)
+#define APICAL_ISP_INPUT_PORT_ACLG_VSYNC_INCLUDE_VSYNC_SIGNAL_IN_ACL_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_aclg_vsync_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 12) | (curr & 0xffffefff));
+}
+static __inline uint8_t apical_isp_input_port_aclg_vsync_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x1000) >> 12);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hsg window1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW1_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW1_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW1_EXCLUDE_WINDOW1_SIGNAL_IN_HS_GATE (0)
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW1_INCLUDE_WINDOW1_SIGNAL_IN_HS_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hsg_window1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_isp_input_port_hsg_window1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hsg hsync
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HSG_HSYNC_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HSG_HSYNC_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HSG_HSYNC_EXCLUDE_HSYNC_SIGNAL_IN_HS_GATE (0)
+#define APICAL_ISP_INPUT_PORT_HSG_HSYNC_INCLUDE_HSYNC_SIGNAL_IN_HS_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hsg_hsync_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_isp_input_port_hsg_hsync_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hsg vsync
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HSG_VSYNC_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HSG_VSYNC_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HSG_VSYNC_EXCLUDE_VSYNC_SIGNAL_IN_HS_GATE (0)
+#define APICAL_ISP_INPUT_PORT_HSG_VSYNC_INCLUDE_VSYNC_SIGNAL_IN_HS_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hsg_vsync_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 18) | (curr & 0xfffbffff));
+}
+static __inline uint8_t apical_isp_input_port_hsg_vsync_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hsg window2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW2_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW2_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW2_EXCLUDE_WINDOW2_SIGNAL_IN_HS_GATE (0)
+#define APICAL_ISP_INPUT_PORT_HSG_WINDOW2_INCLUDE_WINDOW2_SIGNAL_IN_HS_GATE_MASK_OUT_SPURIOUS_HS_DURING_BLANK (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_hsg_window2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 19) | (curr & 0xfff7ffff));
+}
+static __inline uint8_t apical_isp_input_port_hsg_window2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x80000) >> 19);
+}
+// ------------------------------------------------------------------------------ //
+// Register: fieldg vsync
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FIELDG_VSYNC_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FIELDG_VSYNC_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FIELDG_VSYNC_EXCLUDE_VSYNC_SIGNAL_IN_FIELD_GATE (0)
+#define APICAL_ISP_INPUT_PORT_FIELDG_VSYNC_INCLUDE_VSYNC_SIGNAL_IN_FIELD_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_fieldg_vsync_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 24) | (curr & 0xfeffffff));
+}
+static __inline uint8_t apical_isp_input_port_fieldg_vsync_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x1000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: fieldg window2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FIELDG_WINDOW2_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FIELDG_WINDOW2_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FIELDG_WINDOW2_EXCLUDE_WINDOW2_SIGNAL_IN_FIELD_GATE (0)
+#define APICAL_ISP_INPUT_PORT_FIELDG_WINDOW2_INCLUDE_WINDOW2_SIGNAL_IN_FIELD_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_fieldg_window2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 25) | (curr & 0xfdffffff));
+}
+static __inline uint8_t apical_isp_input_port_fieldg_window2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x2000000) >> 25);
+}
+// ------------------------------------------------------------------------------ //
+// Register: fieldg field
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FIELDG_FIELD_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FIELDG_FIELD_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FIELDG_FIELD_EXCLUDE_FIELD_I_SIGNAL_IN_FIELD_GATE (0)
+#define APICAL_ISP_INPUT_PORT_FIELDG_FIELD_INCLUDE_FIELD_I_SIGNAL_IN_FIELD_GATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_fieldg_field_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 26) | (curr & 0xfbffffff));
+}
+static __inline uint8_t apical_isp_input_port_fieldg_field_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x4000000) >> 26);
+}
+// ------------------------------------------------------------------------------ //
+// Register: field mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FIELD_MODE_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FIELD_MODE_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FIELD_MODE_PULSE_FIELD (0)
+#define APICAL_ISP_INPUT_PORT_FIELD_MODE_TOGGLE_FIELD (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_field_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x104L);
+	APICAL_WRITE_32(0x104L, (((uint32_t) (data & 0x1)) << 27) | (curr & 0xf7ffffff));
+}
+static __inline uint8_t apical_isp_input_port_field_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x104L) & 0x8000000) >> 27);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hc limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// horizontal counter limit value (counts: 0,1,...hc_limit-1,hc_limit,0,1,...)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HC_LIMIT_DEFAULT (0xFFFF)
+#define APICAL_ISP_INPUT_PORT_HC_LIMIT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_hc_limit_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x108L);
+	APICAL_WRITE_32(0x108L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_hc_limit_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x108L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hc start0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// window0 start for ACL gate.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HC_START0_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HC_START0_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_hc_start0_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x10cL);
+	APICAL_WRITE_32(0x10cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_hc_start0_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x10cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hc size0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// window0 size for ACL gate.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HC_SIZE0_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HC_SIZE0_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_hc_size0_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x110L);
+	APICAL_WRITE_32(0x110L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_hc_size0_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x110L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hc start1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// window1 start for HS gate.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HC_START1_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HC_START1_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_hc_start1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x114L);
+	APICAL_WRITE_32(0x114L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_hc_start1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x114L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hc size1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// window1 size for HS gate.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_HC_SIZE1_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_HC_SIZE1_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_hc_size1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x118L);
+	APICAL_WRITE_32(0x118L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_hc_size1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x118L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vc limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// vertical counter limit value (counts: 0,1,...vc_limit-1,vc_limit,0,1,...)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VC_LIMIT_DEFAULT (0xFFFF)
+#define APICAL_ISP_INPUT_PORT_VC_LIMIT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_vc_limit_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x11cL);
+	APICAL_WRITE_32(0x11cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_vc_limit_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x11cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vc start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// window2 start for ACL gate.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VC_START_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VC_START_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_vc_start_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x120L);
+	APICAL_WRITE_32(0x120L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_vc_start_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x120L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vc size
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// window2 size for ACL gate.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_VC_SIZE_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_VC_SIZE_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_input_port_vc_size_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x124L);
+	APICAL_WRITE_32(0x124L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_input_port_vc_size_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x124L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// detected frame width.  Read only value.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FRAME_WIDTH_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FRAME_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_input_port_frame_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x128L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// detected frame height.  Read only value.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FRAME_HEIGHT_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FRAME_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_input_port_frame_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x12cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: freeze config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Used to freeze input port configuration.  Used when multiple register writes are required to change input port configuration.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_FREEZE_CONFIG_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_FREEZE_CONFIG_DATASIZE (1)
+#define APICAL_ISP_INPUT_PORT_FREEZE_CONFIG_NORMAL_OPERATION (0)
+#define APICAL_ISP_INPUT_PORT_FREEZE_CONFIG_HOLD_PREVIOUS_INPUT_PORT_CONFIG_STATE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_input_port_freeze_config_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x130L);
+	APICAL_WRITE_32(0x130L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_input_port_freeze_config_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x130L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: mode request
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Used to stop and start input port.  See ISP guide for further details.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_DATASIZE (3)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_SAFE_STOP (0)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_SAFE_START (1)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_URGENT_STOP (2)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_URGENT_START (3)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_RESERVED4 (4)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_SAFER_START (5)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_RESERVED6 (6)
+#define APICAL_ISP_INPUT_PORT_MODE_REQUEST_RESERVED7 (7)
+
+// args: data (3-bit)
+static __inline void apical_isp_input_port_mode_request_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x130L);
+	APICAL_WRITE_32(0x130L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_input_port_mode_request_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x130L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: mode status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//	  Used to monitor input port status:
+//	  bit 0: 1=running, 0=stopped, bits 1,2-reserved
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_INPUT_PORT_MODE_STATUS_DEFAULT (0)
+#define APICAL_ISP_INPUT_PORT_MODE_STATUS_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_input_port_mode_status_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x134L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: video test gen
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Video test generator controls.  See ISP Guide for further details
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: test_pattern_off on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Test pattern off-on: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_TEST_PATTERN_OFF_ON_DEFAULT (0)
+#define APICAL_ISP_VIDEO_TEST_GEN_TEST_PATTERN_OFF_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_video_test_gen_test_pattern_off_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9c0L);
+	APICAL_WRITE_32(0x9c0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_video_test_gen_test_pattern_off_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9c0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bayer_rgb_i sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bayer or rgb select for input video: 0=bayer, 1=rgb
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_BAYER_RGB_I_SEL_DEFAULT (0)
+#define APICAL_ISP_VIDEO_TEST_GEN_BAYER_RGB_I_SEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_video_test_gen_bayer_rgb_i_sel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9c0L);
+	APICAL_WRITE_32(0x9c0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_video_test_gen_bayer_rgb_i_sel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9c0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bayer_rgb_o sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bayer or rgb select for output video: 0=bayer, 1=rgb
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_BAYER_RGB_O_SEL_DEFAULT (0)
+#define APICAL_ISP_VIDEO_TEST_GEN_BAYER_RGB_O_SEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_video_test_gen_bayer_rgb_o_sel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9c0L);
+	APICAL_WRITE_32(0x9c0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_video_test_gen_bayer_rgb_o_sel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9c0L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: pattern type
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Pattern type select: 0=Flat field,1=Horizontal gradient,2=Vertical Gradient,3=Vertical Bars,4=Rectangle,5-255=Default white frame on black
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_PATTERN_TYPE_DEFAULT (0x03)
+#define APICAL_ISP_VIDEO_TEST_GEN_PATTERN_TYPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_video_test_gen_pattern_type_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9c4L);
+	APICAL_WRITE_32(0x9c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_video_test_gen_pattern_type_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9c4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: prbs rst on frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_PRBS_RST_ON_FRAME_DEFAULT (0)
+#define APICAL_ISP_VIDEO_TEST_GEN_PRBS_RST_ON_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_video_test_gen_prbs_rst_on_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x9c0L);
+	APICAL_WRITE_32(0x9c0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_video_test_gen_prbs_rst_on_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x9c0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: r backgnd
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Red background  value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_R_BACKGND_DEFAULT (0xFFFF)
+#define APICAL_ISP_VIDEO_TEST_GEN_R_BACKGND_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_r_backgnd_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9c8L);
+	APICAL_WRITE_32(0x9c8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_r_backgnd_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9c8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: g backgnd
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Green background value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_G_BACKGND_DEFAULT (0xFFFF)
+#define APICAL_ISP_VIDEO_TEST_GEN_G_BACKGND_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_g_backgnd_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9ccL);
+	APICAL_WRITE_32(0x9ccL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_g_backgnd_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9ccL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: b backgnd
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Blue background value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_B_BACKGND_DEFAULT (0xFFFF)
+#define APICAL_ISP_VIDEO_TEST_GEN_B_BACKGND_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_b_backgnd_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9d0L);
+	APICAL_WRITE_32(0x9d0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_b_backgnd_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9d0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: r foregnd
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Red foreground  value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_R_FOREGND_DEFAULT (0x8FFF)
+#define APICAL_ISP_VIDEO_TEST_GEN_R_FOREGND_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_r_foregnd_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9d4L);
+	APICAL_WRITE_32(0x9d4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_r_foregnd_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9d4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: g foregnd
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Green foreground value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_G_FOREGND_DEFAULT (0x8FFF)
+#define APICAL_ISP_VIDEO_TEST_GEN_G_FOREGND_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_g_foregnd_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9d8L);
+	APICAL_WRITE_32(0x9d8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_g_foregnd_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9d8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: b foregnd
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Blue foreground value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_B_FOREGND_DEFAULT (0x8FFF)
+#define APICAL_ISP_VIDEO_TEST_GEN_B_FOREGND_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_b_foregnd_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9dcL);
+	APICAL_WRITE_32(0x9dcL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_b_foregnd_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9dcL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rgb gradient
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// RGB gradient increment per pixel (0-15)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_RGB_GRADIENT_DEFAULT (0x3CAA)
+#define APICAL_ISP_VIDEO_TEST_GEN_RGB_GRADIENT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_rgb_gradient_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9e0L);
+	APICAL_WRITE_32(0x9e0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_rgb_gradient_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9e0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rgb_gradient start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// RGB gradient start value 16bit, MSB aligned to used width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_RGB_GRADIENT_START_DEFAULT (0x0000)
+#define APICAL_ISP_VIDEO_TEST_GEN_RGB_GRADIENT_START_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_video_test_gen_rgb_gradient_start_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9e4L);
+	APICAL_WRITE_32(0x9e4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_video_test_gen_rgb_gradient_start_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9e4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rect top
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Rectangle top line number 1-n
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_TOP_DEFAULT (0x0001)
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_TOP_DATASIZE (14)
+
+// args: data (14-bit)
+static __inline void apical_isp_video_test_gen_rect_top_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9e8L);
+	APICAL_WRITE_32(0x9e8L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
+}
+static __inline uint16_t apical_isp_video_test_gen_rect_top_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9e8L) & 0x3fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rect bot
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Rectangle bottom line number 1-n
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_BOT_DEFAULT (0x0100)
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_BOT_DATASIZE (14)
+
+// args: data (14-bit)
+static __inline void apical_isp_video_test_gen_rect_bot_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9ecL);
+	APICAL_WRITE_32(0x9ecL, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
+}
+static __inline uint16_t apical_isp_video_test_gen_rect_bot_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9ecL) & 0x3fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rect left
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Rectangle left pixel number 1-n
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_LEFT_DEFAULT (0x0001)
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_LEFT_DATASIZE (14)
+
+// args: data (14-bit)
+static __inline void apical_isp_video_test_gen_rect_left_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9f0L);
+	APICAL_WRITE_32(0x9f0L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
+}
+static __inline uint16_t apical_isp_video_test_gen_rect_left_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9f0L) & 0x3fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rect right
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Rectangle right pixel number 1-n
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_RIGHT_DEFAULT (0x0100)
+#define APICAL_ISP_VIDEO_TEST_GEN_RECT_RIGHT_DATASIZE (14)
+
+// args: data (14-bit)
+static __inline void apical_isp_video_test_gen_rect_right_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x9f8L);
+	APICAL_WRITE_32(0x9f8L, (((uint32_t) (data & 0x3fff)) << 0) | (curr & 0xffffc000));
+}
+static __inline uint16_t apical_isp_video_test_gen_rect_right_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x9f8L) & 0x3fff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: PRBS seed
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  PRBS seed. The PRBS LFSR is seeded with this value when reset on a frame boundary.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_VIDEO_TEST_GEN_PRBS_SEED_DEFAULT (0x000000)
+#define APICAL_ISP_VIDEO_TEST_GEN_PRBS_SEED_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_video_test_gen_prbs_seed_write(uint32_t data) {
+	APICAL_WRITE_32(0x9fcL, data);
+}
+static __inline uint32_t apical_isp_video_test_gen_prbs_seed_read(void) {
+	return APICAL_READ_32(0x9fcL);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sensor Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset subtraction for each color channel and exposure
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Black 00
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 00 (R)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_00_DEFAULT (0x00)
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_00_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_sensor_offset_black_00_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x140L);
+	APICAL_WRITE_32(0x140L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_sensor_offset_black_00_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x140L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black 01
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 01 (Gr)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_01_DEFAULT (0x00)
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_01_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_sensor_offset_black_01_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x144L);
+	APICAL_WRITE_32(0x144L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_sensor_offset_black_01_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x144L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black 10
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 10 (Gb)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_10_DEFAULT (0x00)
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_10_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_sensor_offset_black_10_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x148L);
+	APICAL_WRITE_32(0x148L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_sensor_offset_black_10_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x148L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black 11
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 11 (B)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_11_DEFAULT (0x00)
+#define APICAL_ISP_SENSOR_OFFSET_BLACK_11_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_sensor_offset_black_11_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x14cL);
+	APICAL_WRITE_32(0x14cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_sensor_offset_black_11_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x14cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Digital Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Digital gain for RAW sensor data
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Gain
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gain applied to data in 4.8 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DIGITAL_GAIN_GAIN_DEFAULT (0x100)
+#define APICAL_ISP_DIGITAL_GAIN_GAIN_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_digital_gain_gain_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1a0L);
+	APICAL_WRITE_32(0x1a0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_digital_gain_gain_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1a0L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data black level
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DIGITAL_GAIN_OFFSET_DEFAULT (0x000)
+#define APICAL_ISP_DIGITAL_GAIN_OFFSET_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_digital_gain_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1a4L);
+	APICAL_WRITE_32(0x1a4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_digital_gain_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1a4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Frontend LUT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frontend lookup (for companded WDR sensor inputs)
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frontend lookup0 enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_ENABLE_0_DEFAULT (0)
+#define APICAL_ISP_GAMMA_FE_ENABLE_0_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_gamma_fe_enable_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x188L);
+	APICAL_WRITE_32(0x188L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_gamma_fe_enable_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frontend lookup1 enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_ENABLE_1_DEFAULT (0)
+#define APICAL_ISP_GAMMA_FE_ENABLE_1_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_gamma_fe_enable_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x188L);
+	APICAL_WRITE_32(0x188L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_gamma_fe_enable_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Offset Mode 0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//          Lookup0 reflection mode for black offset region
+//          0 = Manual curve reflection
+//          1 = Automatic curve reflection
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_OFFSET_MODE_0_DEFAULT (0)
+#define APICAL_ISP_GAMMA_FE_OFFSET_MODE_0_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_gamma_fe_offset_mode_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x188L);
+	APICAL_WRITE_32(0x188L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_gamma_fe_offset_mode_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Offset Mode 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//          Lookup1 reflection mode for black offset region
+//          0 = Manual curve reflection
+//          1 = Automatic curve reflection
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_OFFSET_MODE_1_DEFAULT (0)
+#define APICAL_ISP_GAMMA_FE_OFFSET_MODE_1_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_gamma_fe_offset_mode_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x188L);
+	APICAL_WRITE_32(0x188L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_gamma_fe_offset_mode_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU priority
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Priority of CPU writes to LUTs
+//		0=low. CPU read/writes from/to the frontend LUTs are only executed when LUTs are not being accessed by ISP.  Normal operation.
+//		1=high. CPU read/writes from/to the frontend LUTs are always executed.  This may result in corrupt image data and invalid read back and is not recommended.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_MCU_PRIORITY_DEFAULT (0)
+#define APICAL_ISP_GAMMA_FE_MCU_PRIORITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_gamma_fe_mcu_priority_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x188L);
+	APICAL_WRITE_32(0x188L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_gamma_fe_mcu_priority_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU ready0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT0 status indicator.  When 1, LUT0 is ready to receive the data from CPU
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_MCU_READY0_DEFAULT (0x0)
+#define APICAL_ISP_GAMMA_FE_MCU_READY0_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_gamma_fe_mcu_ready0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU ready1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT1 status indicator.  When 1, LUT1 is ready to receive the data from CPU
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_GAMMA_FE_MCU_READY1_DEFAULT (0x0)
+#define APICAL_ISP_GAMMA_FE_MCU_READY1_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_gamma_fe_mcu_ready1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x188L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Group: RAW Frontend
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// RAW frontend processing
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: ge enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Green equalization enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_GE_ENABLE_DEFAULT (0)
+#define APICAL_ISP_RAW_FRONTEND_GE_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_raw_frontend_ge_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c0L);
+	APICAL_WRITE_32(0x1c0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_raw_frontend_ge_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1c0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: dp enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Dynamic Defect Pixel enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_DP_ENABLE_DEFAULT (0)
+#define APICAL_ISP_RAW_FRONTEND_DP_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_raw_frontend_dp_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c0L);
+	APICAL_WRITE_32(0x1c0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_raw_frontend_dp_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1c0L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: show dynamic defect pixel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Show Defect Pixel: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_SHOW_DYNAMIC_DEFECT_PIXEL_DEFAULT (0)
+#define APICAL_ISP_RAW_FRONTEND_SHOW_DYNAMIC_DEFECT_PIXEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_raw_frontend_show_dynamic_defect_pixel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c0L);
+	APICAL_WRITE_32(0x1c0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_raw_frontend_show_dynamic_defect_pixel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1c0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: dark disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Disable detection of dark pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_DARK_DISABLE_DEFAULT (0)
+#define APICAL_ISP_RAW_FRONTEND_DARK_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_raw_frontend_dark_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c0L);
+	APICAL_WRITE_32(0x1c0L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_raw_frontend_dark_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1c0L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bright disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Disable detection of bright pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_BRIGHT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_RAW_FRONTEND_BRIGHT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_raw_frontend_bright_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c0L);
+	APICAL_WRITE_32(0x1c0L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_raw_frontend_bright_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1c0L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ge strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls strength of Green equalization.  Set during calibration.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_GE_STRENGTH_DEFAULT (0x00)
+#define APICAL_ISP_RAW_FRONTEND_GE_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_raw_frontend_ge_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c4L);
+	APICAL_WRITE_32(0x1c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_raw_frontend_ge_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1c4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: debug sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Debug selection port
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_DEBUG_SEL_DEFAULT (0x0)
+#define APICAL_ISP_RAW_FRONTEND_DEBUG_SEL_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_raw_frontend_debug_sel_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1c8L);
+	APICAL_WRITE_32(0x1c8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_raw_frontend_debug_sel_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1c8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: dp threshold
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Defect pixel threshold.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_DP_THRESHOLD_DEFAULT (0x040)
+#define APICAL_ISP_RAW_FRONTEND_DP_THRESHOLD_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_dp_threshold_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1ccL);
+	APICAL_WRITE_32(0x1ccL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_dp_threshold_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1ccL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ge threshold
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// green equalization threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_GE_THRESHOLD_DEFAULT (0x400)
+#define APICAL_ISP_RAW_FRONTEND_GE_THRESHOLD_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_ge_threshold_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1d0L);
+	APICAL_WRITE_32(0x1d0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_ge_threshold_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1d0L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: dp slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope for HP Mask function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_DP_SLOPE_DEFAULT (0x200)
+#define APICAL_ISP_RAW_FRONTEND_DP_SLOPE_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_dp_slope_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1d4L);
+	APICAL_WRITE_32(0x1d4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_dp_slope_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1d4L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ge slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope for GE Mask function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_GE_SLOPE_DEFAULT (0x0AA)
+#define APICAL_ISP_RAW_FRONTEND_GE_SLOPE_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_ge_slope_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1d8L);
+	APICAL_WRITE_32(0x1d8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_ge_slope_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1d8L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: ge sens
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls the sensitivity of green equalization to edges.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_GE_SENS_DEFAULT (0x80)
+#define APICAL_ISP_RAW_FRONTEND_GE_SENS_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_raw_frontend_ge_sens_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1dcL);
+	APICAL_WRITE_32(0x1dcL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_raw_frontend_ge_sens_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1dcL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hpdev threshold
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls the aggressiveness of the dynamic defect pixel correction near edges.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_HPDEV_THRESHOLD_DEFAULT (0x266)
+#define APICAL_ISP_RAW_FRONTEND_HPDEV_THRESHOLD_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_hpdev_threshold_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1e0L);
+	APICAL_WRITE_32(0x1e0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_hpdev_threshold_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1e0L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: line thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls the directional nature of the dynamic defect pixel correction near edges..
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_LINE_THRESH_DEFAULT (0x150)
+#define APICAL_ISP_RAW_FRONTEND_LINE_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_line_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1e4L);
+	APICAL_WRITE_32(0x1e4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_line_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1e4L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hp blend
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Controls blending between non-directional and directional replacement values in dynamic defect pixel correction.
+//		0x00 Replace detected defects with non-directional replacement value
+//		0xFF Replace detected defects with directional replacement value
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_HP_BLEND_DEFAULT (0x00)
+#define APICAL_ISP_RAW_FRONTEND_HP_BLEND_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_raw_frontend_hp_blend_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1e8L);
+	APICAL_WRITE_32(0x1e8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_raw_frontend_hp_blend_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1e8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sigma In
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Manual override of noise estimation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_SIGMA_IN_DEFAULT (0x00)
+#define APICAL_ISP_RAW_FRONTEND_SIGMA_IN_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_raw_frontend_sigma_in_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x1ecL);
+	APICAL_WRITE_32(0x1ecL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_raw_frontend_sigma_in_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x1ecL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh Short
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for short exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_THRESH_SHORT_DEFAULT (0x00)
+#define APICAL_ISP_RAW_FRONTEND_THRESH_SHORT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_raw_frontend_thresh_short_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1f0L);
+	APICAL_WRITE_32(0x1f0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_raw_frontend_thresh_short_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1f0L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh Long
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for long exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RAW_FRONTEND_THRESH_LONG_DEFAULT (0x30)
+#define APICAL_ISP_RAW_FRONTEND_THRESH_LONG_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_raw_frontend_thresh_long_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x1f4L);
+	APICAL_WRITE_32(0x1f4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_raw_frontend_thresh_long_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x1f4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Defect Pixel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Detection and processing of static defect-pixels
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Pointer Reset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Reset static defect-pixel table pointer each frame - set this when defect-pixel table has been written from mcu
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_POINTER_RESET_DEFAULT (0)
+#define APICAL_ISP_DEFECT_PIXEL_POINTER_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_defect_pixel_pointer_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x200L);
+	APICAL_WRITE_32(0x200L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_defect_pixel_pointer_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x200L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Show Reference
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// For debug purposes.  Show reference values which are compared with actual values to detect bad pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_SHOW_REFERENCE_DEFAULT (0)
+#define APICAL_ISP_DEFECT_PIXEL_SHOW_REFERENCE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_defect_pixel_show_reference_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x200L);
+	APICAL_WRITE_32(0x200L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_defect_pixel_show_reference_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x200L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Correction enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DEFECT_PIXEL_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_defect_pixel_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x200L);
+	APICAL_WRITE_32(0x200L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_defect_pixel_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x200L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Overflow
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Table overflow flag
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_OVERFLOW_DEFAULT (0x0)
+#define APICAL_ISP_DEFECT_PIXEL_OVERFLOW_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_defect_pixel_overflow_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x200L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Show Static Defect Pixels
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Show which pixels have been detected as bad
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_SHOW_STATIC_DEFECT_PIXELS_DEFAULT (0)
+#define APICAL_ISP_DEFECT_PIXEL_SHOW_STATIC_DEFECT_PIXELS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_defect_pixel_show_static_defect_pixels_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x200L);
+	APICAL_WRITE_32(0x200L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_defect_pixel_show_static_defect_pixels_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x200L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Detection Trigger
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Starts detection on 0-1 transition
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_DETECTION_TRIGGER_DEFAULT (0)
+#define APICAL_ISP_DEFECT_PIXEL_DETECTION_TRIGGER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_defect_pixel_detection_trigger_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x200L);
+	APICAL_WRITE_32(0x200L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_defect_pixel_detection_trigger_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x200L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Defect Pixel Count
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of defect-pixels detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_DEFAULT (0x0)
+#define APICAL_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline uint16_t apical_isp_defect_pixel_defect_pixel_count_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x204L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Table Start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Address of first defect-pixel in defect-pixel store
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_TABLE_START_DEFAULT (0x0)
+#define APICAL_ISP_DEFECT_PIXEL_TABLE_START_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline uint16_t apical_isp_defect_pixel_table_start_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x208L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Defect Pixel Count In
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of defect-pixels in the written table
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_IN_DEFAULT (0x0)
+#define APICAL_ISP_DEFECT_PIXEL_DEFECT_PIXEL_COUNT_IN_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_defect_pixel_defect_pixel_count_in_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x20cL);
+	APICAL_WRITE_32(0x20cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_defect_pixel_defect_pixel_count_in_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x20cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: WDR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Dual-exposure wide-dynamic-range blending
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: WDR Mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects WDR mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_WDR_MODE_DEFAULT (3)
+#define APICAL_ISP_FRAME_STITCH_WDR_MODE_DATASIZE (2)
+#define APICAL_ISP_FRAME_STITCH_WDR_MODE_HALF_RATE_FRAME_SWITCH_ODD_FRAMES (0)
+#define APICAL_ISP_FRAME_STITCH_WDR_MODE_FULL_RATE_FRAME_SWITCH (1)
+#define APICAL_ISP_FRAME_STITCH_WDR_MODE_HALF_RATE_FRAME_SWITCH_EVEN_FRAMES (2)
+#define APICAL_ISP_FRAME_STITCH_WDR_MODE_FRAME_BUFFER_DISABLED (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_frame_stitch_wdr_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_frame_stitch_wdr_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long First
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//  Indicates exposure of first pixel in image: 0=short, 1=long.
+//  This applies to even fields (field input is zero).
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_LONG_FIRST_DEFAULT (1)
+#define APICAL_ISP_FRAME_STITCH_LONG_FIRST_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_long_first_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_frame_stitch_long_first_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Use Stitching Error
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_USE_STITCHING_ERROR_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_USE_STITCHING_ERROR_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_use_stitching_error_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_frame_stitch_use_stitching_error_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Use Long Override
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_USE_LONG_OVERRIDE_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_USE_LONG_OVERRIDE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_use_long_override_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_frame_stitch_use_long_override_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Use Max1 Intensity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_USE_MAX1_INTENSITY_DEFAULT (1)
+#define APICAL_ISP_FRAME_STITCH_USE_MAX1_INTENSITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_use_max1_intensity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 15) | (curr & 0xffff7fff));
+}
+static __inline uint8_t apical_isp_frame_stitch_use_max1_intensity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x8000) >> 15);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Use Max2 Intensity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_USE_MAX2_INTENSITY_DEFAULT (1)
+#define APICAL_ISP_FRAME_STITCH_USE_MAX2_INTENSITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_use_max2_intensity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 14) | (curr & 0xffffbfff));
+}
+static __inline uint8_t apical_isp_frame_stitch_use_max2_intensity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x4000) >> 14);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Use Log
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_USE_LOG_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_USE_LOG_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_use_log_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 13) | (curr & 0xffffdfff));
+}
+static __inline uint8_t apical_isp_frame_stitch_use_log_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x2000) >> 13);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable exp 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_ENABLE_EXP_0_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_ENABLE_EXP_0_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_enable_exp_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_isp_frame_stitch_enable_exp_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable exp 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_ENABLE_EXP_1_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_ENABLE_EXP_1_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_enable_exp_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x240L);
+	APICAL_WRITE_32(0x240L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_isp_frame_stitch_enable_exp_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x240L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Short Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data above this threshold will be taken from short exposure only
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_SHORT_THRESH_DEFAULT (0x0F00)
+#define APICAL_ISP_FRAME_STITCH_SHORT_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_frame_stitch_short_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x244L);
+	APICAL_WRITE_32(0x244L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_frame_stitch_short_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x244L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data below this threshold will be taken from long exposure only
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_LONG_THRESH_DEFAULT (0x0C00)
+#define APICAL_ISP_FRAME_STITCH_LONG_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_frame_stitch_long_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x248L);
+	APICAL_WRITE_32(0x248L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_frame_stitch_long_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x248L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Exposure Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets ratio between long and short exposures - this must match the actual exposure ratio on the sensor
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_EXPOSURE_RATIO_DEFAULT (0x100)
+#define APICAL_ISP_FRAME_STITCH_EXPOSURE_RATIO_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_frame_stitch_exposure_ratio_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x24cL);
+	APICAL_WRITE_32(0x24cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_frame_stitch_exposure_ratio_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x24cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Stitch Correct
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Allows adjustment for error in sensor exposure ratio for stitching area
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_STITCH_CORRECT_DEFAULT (0x80)
+#define APICAL_ISP_FRAME_STITCH_STITCH_CORRECT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_frame_stitch_stitch_correct_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x250L);
+	APICAL_WRITE_32(0x250L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_frame_stitch_stitch_correct_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x250L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Stitch Error Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets level for detection of stitching errors due to motion
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_STITCH_ERROR_THRESH_DEFAULT (0x0040)
+#define APICAL_ISP_FRAME_STITCH_STITCH_ERROR_THRESH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_frame_stitch_stitch_error_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x254L);
+	APICAL_WRITE_32(0x254L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_frame_stitch_stitch_error_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x254L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Stitch Error Limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets intensity level for long exposure below which stitching error detection is disabled
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_STITCH_ERROR_LIMIT_DEFAULT (0x0200)
+#define APICAL_ISP_FRAME_STITCH_STITCH_ERROR_LIMIT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_frame_stitch_stitch_error_limit_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x258L);
+	APICAL_WRITE_32(0x258L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_frame_stitch_stitch_error_limit_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x258L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black level Long
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black level for long exposure input
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_BLACK_LEVEL_LONG_DEFAULT (0x000)
+#define APICAL_ISP_FRAME_STITCH_BLACK_LEVEL_LONG_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_frame_stitch_black_level_long_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x260L);
+	APICAL_WRITE_32(0x260L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_frame_stitch_black_level_long_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x260L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black level Short
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black level for short exposure input
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_BLACK_LEVEL_SHORT_DEFAULT (0x00)
+#define APICAL_ISP_FRAME_STITCH_BLACK_LEVEL_SHORT_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_frame_stitch_black_level_short_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x264L);
+	APICAL_WRITE_32(0x264L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_frame_stitch_black_level_short_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x264L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black level Out
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black level for module output
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_BLACK_LEVEL_OUT_DEFAULT (0x000)
+#define APICAL_ISP_FRAME_STITCH_BLACK_LEVEL_OUT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_frame_stitch_black_level_out_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x268L);
+	APICAL_WRITE_32(0x268L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_frame_stitch_black_level_out_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x268L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Noise Profile RAW frontend
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile controls for RAW frontend
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Exp Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for determining long/short exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_EXP_THRESH_DEFAULT (0xFFFF)
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_EXP_THRESH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_noise_profile_raw_frontend_exp_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x270L);
+	APICAL_WRITE_32(0x270L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_noise_profile_raw_frontend_exp_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x270L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Short Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier applied to short exposure data for noise profile calculation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_SHORT_RATIO_DEFAULT (0x20)
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_SHORT_RATIO_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_noise_profile_raw_frontend_short_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x274L);
+	APICAL_WRITE_32(0x274L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_noise_profile_raw_frontend_short_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x274L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier applied to long exposure data for noise profile calculation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_LONG_RATIO_DEFAULT (0x04)
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_LONG_RATIO_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_noise_profile_raw_frontend_long_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x278L);
+	APICAL_WRITE_32(0x278L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_noise_profile_raw_frontend_long_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x278L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: NP off
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile black level offset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_NP_OFF_DEFAULT (0)
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_NP_OFF_DATASIZE (7)
+
+// args: data (7-bit)
+static __inline void apical_isp_noise_profile_raw_frontend_np_off_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x27cL);
+	APICAL_WRITE_32(0x27cL, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
+}
+static __inline uint8_t apical_isp_noise_profile_raw_frontend_np_off_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x27cL) & 0x7f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: NP off reflect
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//          Defines how values below black level are obtained.
+//          0: Repeat the first table entry.
+//          1: Reflect the noise profile curve below black level.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_NP_OFF_REFLECT_DEFAULT (0)
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_NP_OFF_REFLECT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_noise_profile_raw_frontend_np_off_reflect_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x27cL);
+	APICAL_WRITE_32(0x27cL, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_noise_profile_raw_frontend_np_off_reflect_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x27cL) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sinter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Spatial noise reduction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Config
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_CONFIG_DEFAULT (0x0)
+#define APICAL_ISP_SINTER_CONFIG_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_config_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_config_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sinter enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_ENABLE_DEFAULT (1)
+#define APICAL_ISP_SINTER_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_sinter_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_sinter_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: View Filter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// For debug purposes only. Set to zero for normal operation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_VIEW_FILTER_DEFAULT (0)
+#define APICAL_ISP_SINTER_VIEW_FILTER_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_sinter_view_filter_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_sinter_view_filter_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Scale Mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// For debug purposes only. Set to 3 for normal operation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_SCALE_MODE_DEFAULT (3)
+#define APICAL_ISP_SINTER_SCALE_MODE_DATASIZE (2)
+#define APICAL_ISP_SINTER_SCALE_MODE_USE_FILTER_0_ONLY (0)
+#define APICAL_ISP_SINTER_SCALE_MODE_USE_FILTERS_0_AND_2_ONLY (1)
+#define APICAL_ISP_SINTER_SCALE_MODE_USE_FILTERS_0_2_AND_4_ONLY (2)
+#define APICAL_ISP_SINTER_SCALE_MODE_USE_ALL_FILTERS (3)
+
+// args: data (2-bit)
+static __inline void apical_isp_sinter_scale_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
+}
+static __inline uint8_t apical_isp_sinter_scale_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0xc) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Filter select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sinter filter fine tuning.  Should not be modified from suggested values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_FILTER_SELECT_DEFAULT (0)
+#define APICAL_ISP_SINTER_FILTER_SELECT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_sinter_filter_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_sinter_filter_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Int select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Select intensity filter.  Should not be modified from suggested values.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_INT_SELECT_DEFAULT (0)
+#define APICAL_ISP_SINTER_INT_SELECT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_sinter_int_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_sinter_int_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rm_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		  Adjusts sinter strength radially from center to compensate for Lens shading correction.
+//		  enable: 0=off, 1=on
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_RM_ENABLE_DEFAULT (0)
+#define APICAL_ISP_SINTER_RM_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_sinter_rm_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_sinter_rm_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: int config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Intensity blending with mosaic raw
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_INT_CONFIG_DEFAULT (0x4)
+#define APICAL_ISP_SINTER_INT_CONFIG_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_sinter_int_config_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x280L);
+	APICAL_WRITE_32(0x280L, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
+}
+static __inline uint8_t apical_isp_sinter_int_config_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x280L) & 0xf00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rm_center_x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center x coordinate of shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_RM_CENTER_X_DEFAULT (0x280)
+#define APICAL_ISP_SINTER_RM_CENTER_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_sinter_rm_center_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x284L);
+	APICAL_WRITE_32(0x284L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_sinter_rm_center_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x284L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rm_center_y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center y coordinate of shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_RM_CENTER_Y_DEFAULT (0x168)
+#define APICAL_ISP_SINTER_RM_CENTER_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_sinter_rm_center_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x288L);
+	APICAL_WRITE_32(0x288L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_sinter_rm_center_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x288L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: rm_off_center_mult
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Normalizing factor which scales the radial table to the edge of the image.
+//		Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_RM_OFF_CENTER_MULT_DEFAULT (0x0100)
+#define APICAL_ISP_SINTER_RM_OFF_CENTER_MULT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_sinter_rm_off_center_mult_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x28cL);
+	APICAL_WRITE_32(0x28cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_sinter_rm_off_center_mult_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x28cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 0h
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Unused - no effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_0H_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_0H_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_0h_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x290L);
+	APICAL_WRITE_32(0x290L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_thresh_0h_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x290L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 1h
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for high horizontal spatial frequencies
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_1H_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_1H_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_1h_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x290L);
+	APICAL_WRITE_32(0x290L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_sinter_thresh_1h_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x290L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 2h
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Unused - no effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_2H_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_2H_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_2h_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x294L);
+	APICAL_WRITE_32(0x294L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_thresh_2h_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x294L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 4h
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for low horizontal spatial frequencies
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_4H_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_4H_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_4h_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x294L);
+	APICAL_WRITE_32(0x294L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_sinter_thresh_4h_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x294L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 0v
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Unused - no effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_0V_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_0V_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_0v_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x298L);
+	APICAL_WRITE_32(0x298L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_thresh_0v_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x298L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 1v
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for high vertical spatial frequencies
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_1V_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_1V_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_1v_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x298L);
+	APICAL_WRITE_32(0x298L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_sinter_thresh_1v_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x298L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 2v
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Unused - no effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_2V_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_2V_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_2v_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x29cL);
+	APICAL_WRITE_32(0x29cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_thresh_2v_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x29cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh 4v
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for low vertical spatial frequencies
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_4V_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_4V_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_4v_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x29cL);
+	APICAL_WRITE_32(0x29cL, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_sinter_thresh_4v_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x29cL) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh Short
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold adjustment for short exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_SHORT_DEFAULT (0x00)
+#define APICAL_ISP_SINTER_THRESH_SHORT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_short_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2a4L);
+	APICAL_WRITE_32(0x2a4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_thresh_short_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2a4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh Long
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold adjustment for long exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_THRESH_LONG_DEFAULT (0x30)
+#define APICAL_ISP_SINTER_THRESH_LONG_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_thresh_long_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2a8L);
+	APICAL_WRITE_32(0x2a8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_thresh_long_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2a8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength 0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Unused - no effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_STRENGTH_0_DEFAULT (0xFF)
+#define APICAL_ISP_SINTER_STRENGTH_0_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_strength_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2acL);
+	APICAL_WRITE_32(0x2acL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_strength_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2acL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise reduction effect for high spatial frequencies
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_STRENGTH_1_DEFAULT (0xFF)
+#define APICAL_ISP_SINTER_STRENGTH_1_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_strength_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2b0L);
+	APICAL_WRITE_32(0x2b0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_strength_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2b0L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Unused - no effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_STRENGTH_2_DEFAULT (0xFF)
+#define APICAL_ISP_SINTER_STRENGTH_2_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_strength_2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2b4L);
+	APICAL_WRITE_32(0x2b4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_strength_2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2b4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength 4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise reduction effect for low spatial frequencies
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_STRENGTH_4_DEFAULT (0xFF)
+#define APICAL_ISP_SINTER_STRENGTH_4_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_sinter_strength_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2b8L);
+	APICAL_WRITE_32(0x2b8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_sinter_strength_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2b8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Temper
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Temporal noise reduction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Temper enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_ENABLE_DEFAULT (0)
+#define APICAL_ISP_TEMPER_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_temper_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Log Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1=Normal operation, 0=disable logarithmic weighting function for debug
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_LOG_ENABLE_DEFAULT (1)
+#define APICAL_ISP_TEMPER_LOG_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_log_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_temper_log_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Show Alpha
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0=Normal operation, 1=output alpha channel for debug
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_SHOW_ALPHA_DEFAULT (0)
+#define APICAL_ISP_TEMPER_SHOW_ALPHA_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_show_alpha_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_temper_show_alpha_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Show AlphaAB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0=Normal operation, 1=output alpha channel for debug
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_SHOW_ALPHAAB_DEFAULT (0)
+#define APICAL_ISP_TEMPER_SHOW_ALPHAAB_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_show_alphaab_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_temper_show_alphaab_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mixer Select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Debug mixer select(Only active when Temper disabled): 0=Input video stream, 1=Frame buffer video stream
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_MIXER_SELECT_DEFAULT (0)
+#define APICAL_ISP_TEMPER_MIXER_SELECT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_mixer_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_temper_mixer_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Temper2 Mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0: 0=Temper3 mode 1=Temper2 mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_TEMPER2_MODE_DEFAULT (0)
+#define APICAL_ISP_TEMPER_TEMPER2_MODE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_temper2_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_temper_temper2_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame delay
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Extra output delay: 0=normal output 1=delayed by 1 frame
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_DELAY_DEFAULT (0)
+#define APICAL_ISP_TEMPER_FRAME_DELAY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_frame_delay_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c0L);
+	APICAL_WRITE_32(0x2c0L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_temper_frame_delay_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c0L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh Short
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for short exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_THRESH_SHORT_DEFAULT (0x00)
+#define APICAL_ISP_TEMPER_THRESH_SHORT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_temper_thresh_short_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c4L);
+	APICAL_WRITE_32(0x2c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_temper_thresh_short_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Thresh Long
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise threshold for long exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_THRESH_LONG_DEFAULT (0x30)
+#define APICAL_ISP_TEMPER_THRESH_LONG_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_temper_thresh_long_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2c8L);
+	APICAL_WRITE_32(0x2c8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_temper_thresh_long_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2c8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Recursion Limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Controls length of filter history. Low values result in longer history and stronger temporal filtering.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_RECURSION_LIMIT_DEFAULT (0x2)
+#define APICAL_ISP_TEMPER_RECURSION_LIMIT_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_temper_recursion_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2ccL);
+	APICAL_WRITE_32(0x2ccL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_temper_recursion_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2ccL) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Noise Profile
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile controls for Sinter and Temper
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Exp Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for determining long/short exposure data
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_EXP_THRESH_DEFAULT (0xFFFF)
+#define APICAL_ISP_NOISE_PROFILE_EXP_THRESH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_noise_profile_exp_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x2e0L);
+	APICAL_WRITE_32(0x2e0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_noise_profile_exp_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x2e0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Short Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier applied to short exposure data for noise profile calculation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_SHORT_RATIO_DEFAULT (0x20)
+#define APICAL_ISP_NOISE_PROFILE_SHORT_RATIO_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_noise_profile_short_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2e4L);
+	APICAL_WRITE_32(0x2e4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_noise_profile_short_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2e4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Long Ratio
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier applied to long exposure data for noise profile calculation
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_LONG_RATIO_DEFAULT (0x04)
+#define APICAL_ISP_NOISE_PROFILE_LONG_RATIO_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_noise_profile_long_ratio_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2e8L);
+	APICAL_WRITE_32(0x2e8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_noise_profile_long_ratio_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2e8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: NP off
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile black level offset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_NP_OFF_DEFAULT (0)
+#define APICAL_ISP_NOISE_PROFILE_NP_OFF_DATASIZE (7)
+
+// args: data (7-bit)
+static __inline void apical_isp_noise_profile_np_off_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2ecL);
+	APICAL_WRITE_32(0x2ecL, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
+}
+static __inline uint8_t apical_isp_noise_profile_np_off_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2ecL) & 0x7f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: NP off reflect
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//          Defines how values below black level are obtained.
+//          0: Repeat the first table entry.
+//          1: Reflect the noise profile curve below black level.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_NP_OFF_REFLECT_DEFAULT (0)
+#define APICAL_ISP_NOISE_PROFILE_NP_OFF_REFLECT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_noise_profile_np_off_reflect_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x2ecL);
+	APICAL_WRITE_32(0x2ecL, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_noise_profile_np_off_reflect_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x2ecL) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Group: White Balance
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Static white balance - independent gain for each color channel
+//
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Gain 00
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier for color channel 00 (R)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_WHITE_BALANCE_GAIN_00_DEFAULT (0x100)
+#define APICAL_ISP_WHITE_BALANCE_GAIN_00_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_white_balance_gain_00_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x300L);
+	APICAL_WRITE_32(0x300L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_white_balance_gain_00_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x300L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Gain 01
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier for color channel 01 (Gr)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_WHITE_BALANCE_GAIN_01_DEFAULT (0x100)
+#define APICAL_ISP_WHITE_BALANCE_GAIN_01_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_white_balance_gain_01_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x304L);
+	APICAL_WRITE_32(0x304L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_white_balance_gain_01_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x304L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Gain 10
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier for color channel 10 (Gb)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_WHITE_BALANCE_GAIN_10_DEFAULT (0x100)
+#define APICAL_ISP_WHITE_BALANCE_GAIN_10_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_white_balance_gain_10_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x308L);
+	APICAL_WRITE_32(0x308L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_white_balance_gain_10_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x308L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Gain 11
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Multiplier for color channel 11 (B)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_WHITE_BALANCE_GAIN_11_DEFAULT (0x100)
+#define APICAL_ISP_WHITE_BALANCE_GAIN_11_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_white_balance_gain_11_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x30cL);
+	APICAL_WRITE_32(0x30cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_white_balance_gain_11_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x30cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset subtraction for each color channel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Black 00
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 00 (R)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_OFFSET_BLACK_00_DEFAULT (0x00)
+#define APICAL_ISP_OFFSET_BLACK_00_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_offset_black_00_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x310L);
+	APICAL_WRITE_32(0x310L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_offset_black_00_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x310L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black 01
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 01 (Gr)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_OFFSET_BLACK_01_DEFAULT (0x00)
+#define APICAL_ISP_OFFSET_BLACK_01_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_offset_black_01_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x314L);
+	APICAL_WRITE_32(0x314L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_offset_black_01_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x314L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black 10
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 10 (Gb)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_OFFSET_BLACK_10_DEFAULT (0x00)
+#define APICAL_ISP_OFFSET_BLACK_10_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_offset_black_10_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x318L);
+	APICAL_WRITE_32(0x318L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_offset_black_10_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x318L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black 11
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Black offset for color channel 11 (B)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_OFFSET_BLACK_11_DEFAULT (0x00)
+#define APICAL_ISP_OFFSET_BLACK_11_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_offset_black_11_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x31cL);
+	APICAL_WRITE_32(0x31cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_offset_black_11_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x31cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Radial Shading
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Radial Lens shading correction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Lens shading correction enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_ENABLE_DEFAULT (0)
+#define APICAL_ISP_RADIAL_SHADING_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_radial_shading_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x340L);
+	APICAL_WRITE_32(0x340L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_radial_shading_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x340L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU priority
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Priority of CPU writes to radial shading LUTs
+//		0=low. CPU read/writes from/to the shading LUTs are only executed when LUTs are not being accessed by ISP.  Normal operation.
+//		1=high. CPU read/writes from/to the shading LUTs are always executed.  This may result in corrupt image data and invalid read back and is not recommended.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_MCU_PRIORITY_DEFAULT (0)
+#define APICAL_ISP_RADIAL_SHADING_MCU_PRIORITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_radial_shading_mcu_priority_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x340L);
+	APICAL_WRITE_32(0x340L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_radial_shading_mcu_priority_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x340L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU ready
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT is ready to receive the data from CPU
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_MCU_READY_DEFAULT (0x0)
+#define APICAL_ISP_RADIAL_SHADING_MCU_READY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_radial_shading_mcu_ready_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x340L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: centerR x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center x coordinate of the red shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_CENTERR_X_DEFAULT (0x3C0)
+#define APICAL_ISP_RADIAL_SHADING_CENTERR_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_centerr_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x344L);
+	APICAL_WRITE_32(0x344L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_centerr_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x344L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: centerR y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center y coordinate of the red shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_CENTERR_Y_DEFAULT (0x21C)
+#define APICAL_ISP_RADIAL_SHADING_CENTERR_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_centerr_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x348L);
+	APICAL_WRITE_32(0x348L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_centerr_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x348L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: centerG x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center x coordinate of the green shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_CENTERG_X_DEFAULT (0x3C0)
+#define APICAL_ISP_RADIAL_SHADING_CENTERG_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_centerg_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x34cL);
+	APICAL_WRITE_32(0x34cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_centerg_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x34cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: centerG y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center y coordinate of the green shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_CENTERG_Y_DEFAULT (0x21C)
+#define APICAL_ISP_RADIAL_SHADING_CENTERG_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_centerg_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x350L);
+	APICAL_WRITE_32(0x350L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_centerg_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x350L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: centerB x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center x coordinate of the blue shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_CENTERB_X_DEFAULT (0x3C0)
+#define APICAL_ISP_RADIAL_SHADING_CENTERB_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_centerb_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x354L);
+	APICAL_WRITE_32(0x354L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_centerb_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x354L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: centerB y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Center y coordinate of the blue shading map
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_CENTERB_Y_DEFAULT (0x21C)
+#define APICAL_ISP_RADIAL_SHADING_CENTERB_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_centerb_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x358L);
+	APICAL_WRITE_32(0x358L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_centerb_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x358L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: off center multR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Normalizing factor which scales the Red radial table to the edge of the image.
+//		Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_OFF_CENTER_MULTR_DEFAULT (0x06EA)
+#define APICAL_ISP_RADIAL_SHADING_OFF_CENTER_MULTR_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_off_center_multr_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x35cL);
+	APICAL_WRITE_32(0x35cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_off_center_multr_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x35cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: off center multG
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Normalizing factor which scales the green radial table to the edge of the image.
+//		Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_OFF_CENTER_MULTG_DEFAULT (0x06EA)
+#define APICAL_ISP_RADIAL_SHADING_OFF_CENTER_MULTG_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_off_center_multg_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x360L);
+	APICAL_WRITE_32(0x360L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_off_center_multg_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x360L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: off center multB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Normalizing factor which scales the blue radial table to the edge of the image.
+//		Calculated as 2^31/R^2 where R is the furthest distance from the center coordinate to the edge of the image in pixels.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_RADIAL_SHADING_OFF_CENTER_MULTB_DEFAULT (0x06EA)
+#define APICAL_ISP_RADIAL_SHADING_OFF_CENTER_MULTB_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_radial_shading_off_center_multb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x364L);
+	APICAL_WRITE_32(0x364L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_radial_shading_off_center_multb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x364L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Mesh Shading
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Mesh Lens shading correction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Lens shading correction enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_ENABLE_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_mesh_shading_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_mesh_shading_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh show
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Lens shading correction debug: 0=off, 1=on (show mesh data)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_SHOW_DEFAULT (1)
+#define APICAL_ISP_MESH_SHADING_MESH_SHOW_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_mesh_shading_mesh_show_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_show_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh scale
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Selects the precision and maximal gain range of mesh shading correction
+//		Gain range:	00->0..2; 01->0..4; 02->0..8; 03->0..16; 04->1..2; 05->1..3; 06-> 1..5; 07->1..9(float)
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_SCALE_DEFAULT (1)
+#define APICAL_ISP_MESH_SHADING_MESH_SCALE_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_mesh_shading_mesh_scale_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x7)) << 2) | (curr & 0xffffffe3));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_scale_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x1c) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh page R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects memory page for red pixels correction.  See ISP guide for further details
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_PAGE_R_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_PAGE_R_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_mesh_shading_mesh_page_r_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x3)) << 8) | (curr & 0xfffffcff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_page_r_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x300) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh page G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects memory page for green pixels correction.  See ISP guide for further details
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_PAGE_G_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_PAGE_G_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_mesh_shading_mesh_page_g_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x3)) << 10) | (curr & 0xfffff3ff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_page_g_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0xc00) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh page B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects memory page for blue pixels correction.  See ISP guide for further details
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_PAGE_B_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_PAGE_B_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_mesh_shading_mesh_page_b_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x3)) << 12) | (curr & 0xffffcfff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_page_b_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x3000) >> 12);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of horizontal nodes minus 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_WIDTH_DEFAULT (63)
+#define APICAL_ISP_MESH_SHADING_MESH_WIDTH_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_mesh_shading_mesh_width_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x3f)) << 16) | (curr & 0xffc0ffff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x3f0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of vertical nodes minus 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_HEIGHT_DEFAULT (63)
+#define APICAL_ISP_MESH_SHADING_MESH_HEIGHT_DATASIZE (6)
+
+// args: data (6-bit)
+static __inline void apical_isp_mesh_shading_mesh_height_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x380L);
+	APICAL_WRITE_32(0x380L, (((uint32_t) (data & 0x3f)) << 24) | (curr & 0xc0ffffff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x380L) & 0x3f000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh reload
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0-1 triggers cache reload
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_RELOAD_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_RELOAD_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_mesh_shading_mesh_reload_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x384L);
+	APICAL_WRITE_32(0x384L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_reload_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x384L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Sets alpha blending between mesh shading tables.
+//		0 = no alpha blending;
+//		1=2 banks (odd/even bytes)
+//		2=4 banks (one per 8 bit lane in each dword)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_MODE_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_MODE_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x390L);
+	APICAL_WRITE_32(0x390L, (((uint32_t) (data & 0x3)) << 0) | (curr & 0xfffffffc));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x390L) & 0x3) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha bank R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bank selection for R blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_BANK_R_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_BANK_R_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_bank_r_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x394L);
+	APICAL_WRITE_32(0x394L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_bank_r_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x394L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha bank G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bank selection for G blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved:
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_BANK_G_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_BANK_G_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_bank_g_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x394L);
+	APICAL_WRITE_32(0x394L, (((uint32_t) (data & 0x7)) << 8) | (curr & 0xfffff8ff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_bank_g_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x394L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha bank B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bank selection for B blend: 0: 0+1; 1: 1+2; 2: 2:3; 3: 3+0; 4:0+2; 5: 1+3; 6,7: reserved
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_BANK_B_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_BANK_B_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_bank_b_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x394L);
+	APICAL_WRITE_32(0x394L, (((uint32_t) (data & 0x7)) << 16) | (curr & 0xfff8ffff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_bank_b_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x394L) & 0x70000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Alpha blend coeff for R
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_R_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_R_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_r_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x398L);
+	APICAL_WRITE_32(0x398L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_r_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x398L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Alpha blend coeff for G
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_G_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_G_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_g_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x398L);
+	APICAL_WRITE_32(0x398L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_g_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x398L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh alpha B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Alpha blend coeff for B
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_B_DEFAULT (0)
+#define APICAL_ISP_MESH_SHADING_MESH_ALPHA_B_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mesh_shading_mesh_alpha_b_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x398L);
+	APICAL_WRITE_32(0x398L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_mesh_shading_mesh_alpha_b_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x398L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Mesh strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Mesh strength in 4.12 format, e.g. 0 - no correction, 4096 - correction to match mesh data. Can be used to reduce shading correction based on AE.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MESH_SHADING_MESH_STRENGTH_DEFAULT (0x1000)
+#define APICAL_ISP_MESH_SHADING_MESH_STRENGTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_mesh_shading_mesh_strength_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x39cL);
+	APICAL_WRITE_32(0x39cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_mesh_shading_mesh_strength_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x39cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Iridix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//Iridix is an adaptive, space-variant tone mapping engine.
+//It is used to maintain or enhance shadow detail while preserving highlights.
+//
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Control 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_CONTROL_0_DEFAULT (0x29)
+#define APICAL_ISP_IRIDIX_CONTROL_0_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_control_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_iridix_control_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_ENABLE_DEFAULT (0x0)
+#define APICAL_ISP_IRIDIX_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_iridix_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Max Type
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_MAX_TYPE_DEFAULT (0x0)
+#define APICAL_ISP_IRIDIX_MAX_TYPE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_max_type_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_iridix_max_type_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Set Black Level Amp 0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//            1=Ignore Black level (set to zero) in amplificator.
+//            0=Use Black level value.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_SET_BLACK_LEVEL_AMP_0_DEFAULT (0x0)
+#define APICAL_ISP_IRIDIX_SET_BLACK_LEVEL_AMP_0_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_set_black_level_amp_0_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_iridix_set_black_level_amp_0_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Rev percept LUT position
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_LUT_REV_PERCEPT_LUT_POSITION_DEFAULT (0x0)
+#define APICAL_ISP_IRIDIX_LUT_REV_PERCEPT_LUT_POSITION_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_lut_rev_percept_lut_position_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 6) | (curr & 0xffffffbf));
+}
+static __inline uint8_t apical_isp_iridix_lut_rev_percept_lut_position_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_CONTROL_1_DEFAULT (0x0)
+#define APICAL_ISP_IRIDIX_CONTROL_1_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_control_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_iridix_control_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Collect OVL
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_COLLECT_OVL_DEFAULT (0)
+#define APICAL_ISP_IRIDIX_COLLECT_OVL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_collect_ovl_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_iridix_collect_ovl_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Collect RND
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_COLLECT_RND_DEFAULT (1)
+#define APICAL_ISP_IRIDIX_COLLECT_RND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_collect_rnd_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_iridix_collect_rnd_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Stat Norm
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_STAT_NORM_DEFAULT (1)
+#define APICAL_ISP_IRIDIX_STAT_NORM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_stat_norm_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_iridix_stat_norm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Stat Mult
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_STAT_MULT_DEFAULT (1)
+#define APICAL_ISP_IRIDIX_STAT_MULT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_iridix_stat_mult_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c0L);
+	APICAL_WRITE_32(0x3c0L, (((uint32_t) (data & 0x3)) << 14) | (curr & 0xffff3fff));
+}
+static __inline uint8_t apical_isp_iridix_stat_mult_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c0L) & 0xc000) >> 14);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Strength of dynamic range compression. With other parameters at defaults, increases visibility of shadows
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_STRENGTH_DEFAULT (0x80)
+#define APICAL_ISP_IRIDIX_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c4L);
+	APICAL_WRITE_32(0x3c4L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_iridix_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c4L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Variance
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_VARIANCE_DEFAULT (0x0)
+#define APICAL_ISP_IRIDIX_VARIANCE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_variance_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c8L);
+	APICAL_WRITE_32(0x3c8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_iridix_variance_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Variance Space
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets the degree of spatial sensitivity of the algorithm
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_VARIANCE_SPACE_DEFAULT (0x2)
+#define APICAL_ISP_IRIDIX_VARIANCE_SPACE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_iridix_variance_space_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c8L);
+	APICAL_WRITE_32(0x3c8L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_iridix_variance_space_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c8L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Variance Intensity
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets the degree of luminance sensitivity of the algorithm
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_VARIANCE_INTENSITY_DEFAULT (0x1)
+#define APICAL_ISP_IRIDIX_VARIANCE_INTENSITY_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_iridix_variance_intensity_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c8L);
+	APICAL_WRITE_32(0x3c8L, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
+}
+static __inline uint8_t apical_isp_iridix_variance_intensity_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c8L) & 0xf0) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Slope Max
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Restricts the maximum slope (gain) which can be generated by the adaptive algorithm
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_SLOPE_MAX_DEFAULT (0x80)
+#define APICAL_ISP_IRIDIX_SLOPE_MAX_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_slope_max_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c8L);
+	APICAL_WRITE_32(0x3c8L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_iridix_slope_max_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c8L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Slope Min
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Restricts the minimum slope (gain) which can be generated by the adaptive algorithm
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_SLOPE_MIN_DEFAULT (0x40)
+#define APICAL_ISP_IRIDIX_SLOPE_MIN_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_slope_min_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3c8L);
+	APICAL_WRITE_32(0x3c8L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_iridix_slope_min_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3c8L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black Level
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix black level.  Values below this will not be affected by Iridix.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_BLACK_LEVEL_DEFAULT (0x000)
+#define APICAL_ISP_IRIDIX_BLACK_LEVEL_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_iridix_black_level_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x3d0L);
+	APICAL_WRITE_32(0x3d0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_iridix_black_level_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x3d0L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: White Level
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix white level.  Values above this will not be affected by Iridix.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_WHITE_LEVEL_DEFAULT (0xFFF)
+#define APICAL_ISP_IRIDIX_WHITE_LEVEL_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_iridix_white_level_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x3d4L);
+	APICAL_WRITE_32(0x3d4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_iridix_white_level_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x3d4L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Limit Ampl
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_LIMIT_AMPL_DEFAULT (0x00)
+#define APICAL_ISP_IRIDIX_LIMIT_AMPL_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_iridix_limit_ampl_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3d8L);
+	APICAL_WRITE_32(0x3d8L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_iridix_limit_ampl_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3d8L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Collection correction
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_COLLECTION_CORRECTION_DEFAULT (0x100)
+#define APICAL_ISP_IRIDIX_COLLECTION_CORRECTION_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_iridix_collection_correction_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x3dcL);
+	APICAL_WRITE_32(0x3dcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_iridix_collection_correction_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x3dcL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Rev Percept Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix lookup 1 enable: 0=off 1=on.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_REV_PERCEPT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_IRIDIX_REV_PERCEPT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_rev_percept_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3e0L);
+	APICAL_WRITE_32(0x3e0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_iridix_rev_percept_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3e0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Fwd Percept Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix lookup 2 enable: 0=off 1=on.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_FWD_PERCEPT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_IRIDIX_FWD_PERCEPT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_iridix_fwd_percept_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x3e0L);
+	APICAL_WRITE_32(0x3e0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_iridix_fwd_percept_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x3e0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Demosaic
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bayer Demosaic
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: VH Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope of vertical/horizontal blending threshold in 4.4 logarithmic format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_VH_SLOPE_DEFAULT (0xC0)
+#define APICAL_ISP_DEMOSAIC_VH_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_vh_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x400L);
+	APICAL_WRITE_32(0x400L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_vh_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x400L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AA Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope of angular blending threshold in 4.4 logarithmic format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_AA_SLOPE_DEFAULT (0xC0)
+#define APICAL_ISP_DEMOSAIC_AA_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_aa_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x404L);
+	APICAL_WRITE_32(0x404L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_aa_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x404L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VA Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope of VH-AA (VA) blending threshold in 4.4 logarithmic format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_VA_SLOPE_DEFAULT (0xAA)
+#define APICAL_ISP_DEMOSAIC_VA_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_va_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x408L);
+	APICAL_WRITE_32(0x408L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_va_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x408L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: UU Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope of undefined blending threshold in 4.4 logarithmic format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_UU_SLOPE_DEFAULT (0xAD)
+#define APICAL_ISP_DEMOSAIC_UU_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_uu_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x40cL);
+	APICAL_WRITE_32(0x40cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_uu_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x40cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sat Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope of saturation blending threshold in linear format 2.6
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_SAT_SLOPE_DEFAULT (0x5D)
+#define APICAL_ISP_DEMOSAIC_SAT_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_sat_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x410L);
+	APICAL_WRITE_32(0x410L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_sat_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x410L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VH Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for the range of vertical/horizontal blending
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_VH_THRESH_DEFAULT (0x131)
+#define APICAL_ISP_DEMOSAIC_VH_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_vh_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x414L);
+	APICAL_WRITE_32(0x414L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_vh_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x414L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AA Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for the range of angular blending
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_AA_THRESH_DEFAULT (0xA0)
+#define APICAL_ISP_DEMOSAIC_AA_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_aa_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x418L);
+	APICAL_WRITE_32(0x418L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_aa_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x418L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VA Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for the range of VA blending
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_VA_THRESH_DEFAULT (0x70)
+#define APICAL_ISP_DEMOSAIC_VA_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_va_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x41cL);
+	APICAL_WRITE_32(0x41cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_va_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x41cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: UU Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for the range of undefined blending
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_UU_THRESH_DEFAULT (0x171)
+#define APICAL_ISP_DEMOSAIC_UU_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_uu_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x420L);
+	APICAL_WRITE_32(0x420L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_uu_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x420L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sat Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for the range of saturation blending  in signed 2.9 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_SAT_THRESH_DEFAULT (0x171)
+#define APICAL_ISP_DEMOSAIC_SAT_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_sat_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x424L);
+	APICAL_WRITE_32(0x424L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_sat_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x424L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VH Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for vertical/horizontal blending threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_VH_OFFSET_DEFAULT (0x800)
+#define APICAL_ISP_DEMOSAIC_VH_OFFSET_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_vh_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x428L);
+	APICAL_WRITE_32(0x428L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_vh_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x428L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AA Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for angular blending threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_AA_OFFSET_DEFAULT (0x800)
+#define APICAL_ISP_DEMOSAIC_AA_OFFSET_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_aa_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x42cL);
+	APICAL_WRITE_32(0x42cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_aa_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x42cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VA Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for VA blending threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_VA_OFFSET_DEFAULT (0x800)
+#define APICAL_ISP_DEMOSAIC_VA_OFFSET_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_va_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x430L);
+	APICAL_WRITE_32(0x430L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_va_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x430L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: UU Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for undefined blending threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_UU_OFFSET_DEFAULT (0x000)
+#define APICAL_ISP_DEMOSAIC_UU_OFFSET_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_uu_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x434L);
+	APICAL_WRITE_32(0x434L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_uu_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x434L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Sat Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for saturation blending threshold in signed 2.9 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_SAT_OFFSET_DEFAULT (0x000)
+#define APICAL_ISP_DEMOSAIC_SAT_OFFSET_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_sat_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x438L);
+	APICAL_WRITE_32(0x438L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_sat_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x438L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: sharp_alt_d
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Directional sharp mask strength in signed 4.4 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_SHARP_ALT_D_DEFAULT (0x30)
+#define APICAL_ISP_DEMOSAIC_SHARP_ALT_D_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_sharp_alt_d_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x43cL);
+	APICAL_WRITE_32(0x43cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_sharp_alt_d_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x43cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: sharp_alt_ud
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Non-directional sharp mask strength in signed 4.4 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_SHARP_ALT_UD_DEFAULT (0x20)
+#define APICAL_ISP_DEMOSAIC_SHARP_ALT_UD_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_sharp_alt_ud_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x440L);
+	APICAL_WRITE_32(0x440L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_sharp_alt_ud_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x440L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: lum_thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Luminance threshold for directional sharpening
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_LUM_THRESH_DEFAULT (0x060)
+#define APICAL_ISP_DEMOSAIC_LUM_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_lum_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x444L);
+	APICAL_WRITE_32(0x444L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_lum_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x444L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: np_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile offset in logarithmic 4.4 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_NP_OFFSET_DEFAULT (0x00)
+#define APICAL_ISP_DEMOSAIC_NP_OFFSET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_np_offset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x448L);
+	APICAL_WRITE_32(0x448L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_np_offset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x448L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dmsc config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Debug output select. Set to 0x00 for normal operation.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_DMSC_CONFIG_DEFAULT (0x00)
+#define APICAL_ISP_DEMOSAIC_DMSC_CONFIG_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_dmsc_config_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x44cL);
+	APICAL_WRITE_32(0x44cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_dmsc_config_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x44cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AC Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold for the range of AC blending in signed 2.9 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_AC_THRESH_DEFAULT (0x1B3)
+#define APICAL_ISP_DEMOSAIC_AC_THRESH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_ac_thresh_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x450L);
+	APICAL_WRITE_32(0x450L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_ac_thresh_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x450L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AC Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope of AC blending threshold in linear format 2.6
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_AC_SLOPE_DEFAULT (0xCF)
+#define APICAL_ISP_DEMOSAIC_AC_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_ac_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x454L);
+	APICAL_WRITE_32(0x454L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_ac_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x454L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AC Offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for AC blending threshold in signed 2.9 format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_AC_OFFSET_DEFAULT (0x000)
+#define APICAL_ISP_DEMOSAIC_AC_OFFSET_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_demosaic_ac_offset_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x458L);
+	APICAL_WRITE_32(0x458L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_demosaic_ac_offset_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x458L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: FC Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope (strength) of false color correction
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_FC_SLOPE_DEFAULT (0x80)
+#define APICAL_ISP_DEMOSAIC_FC_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_fc_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x45cL);
+	APICAL_WRITE_32(0x45cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_fc_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x45cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: FC Alias Slope
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Slope (strength) of false colour correction after blending with saturation value in 2.6 unsigned format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_FC_ALIAS_SLOPE_DEFAULT (0x55)
+#define APICAL_ISP_DEMOSAIC_FC_ALIAS_SLOPE_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_fc_alias_slope_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x460L);
+	APICAL_WRITE_32(0x460L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_fc_alias_slope_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x460L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: FC Alias Thresh
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Threshold of false colour correction after blending with saturation valuet in in 0.8 unsigned format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_FC_ALIAS_THRESH_DEFAULT (0x00)
+#define APICAL_ISP_DEMOSAIC_FC_ALIAS_THRESH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_demosaic_fc_alias_thresh_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x464L);
+	APICAL_WRITE_32(0x464L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_demosaic_fc_alias_thresh_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x464L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: NP off
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile black level offset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_NP_OFF_DEFAULT (0)
+#define APICAL_ISP_DEMOSAIC_NP_OFF_DATASIZE (7)
+
+// args: data (7-bit)
+static __inline void apical_isp_demosaic_np_off_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x46cL);
+	APICAL_WRITE_32(0x46cL, (((uint32_t) (data & 0x7f)) << 0) | (curr & 0xffffff80));
+}
+static __inline uint8_t apical_isp_demosaic_np_off_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x46cL) & 0x7f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: NP off reflect
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//          Defines how values below black level are obtained.
+//          0: Repeat the first table entry.
+//          1: Reflect the noise profile curve below black level.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_NP_OFF_REFLECT_DEFAULT (0)
+#define APICAL_ISP_DEMOSAIC_NP_OFF_REFLECT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_demosaic_np_off_reflect_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x46cL);
+	APICAL_WRITE_32(0x46cL, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_demosaic_np_off_reflect_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x46cL) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Color Matrix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Color correction on RGB data using a 3x3 color matrix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Color matrix enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_ENABLE_DEFAULT (1)
+#define APICAL_ISP_MATRIX_RGB_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_matrix_rgb_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4a4L);
+	APICAL_WRITE_32(0x4a4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_matrix_rgb_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4a4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft R-R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for red-red multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_R_R_DEFAULT (0x0100)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_R_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_r_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x480L);
+	APICAL_WRITE_32(0x480L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_r_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x480L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft R-G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for red-green multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_R_G_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_R_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_r_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x484L);
+	APICAL_WRITE_32(0x484L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_r_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x484L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft R-B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for red-blue multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_R_B_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_R_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_r_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x488L);
+	APICAL_WRITE_32(0x488L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_r_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x488L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft G-R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for green-red multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_G_R_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_G_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_g_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x48cL);
+	APICAL_WRITE_32(0x48cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_g_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x48cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft G-G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for green-green multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_G_G_DEFAULT (0x0100)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_G_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_g_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x490L);
+	APICAL_WRITE_32(0x490L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_g_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x490L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft G-B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for green-blue multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_G_B_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_G_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_g_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x494L);
+	APICAL_WRITE_32(0x494L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_g_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x494L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft B-R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for blue-red multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_B_R_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_B_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_b_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x498L);
+	APICAL_WRITE_32(0x498L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_b_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x498L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft B-G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for blue-green multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_B_G_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_B_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_b_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x49cL);
+	APICAL_WRITE_32(0x49cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_b_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x49cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft B-B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for blue-blue multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_B_B_DEFAULT (0x0100)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_B_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_b_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4a0L);
+	APICAL_WRITE_32(0x4a0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_b_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4a0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft WB R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// gain for Red channel for antifog function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_WB_R_DEFAULT (0x0100)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_WB_R_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_wb_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4a8L);
+	APICAL_WRITE_32(0x4a8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_wb_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4a8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft WB G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// gain for Green channel for antifog function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_WB_G_DEFAULT (0x0100)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_WB_G_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_wb_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4acL);
+	APICAL_WRITE_32(0x4acL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_wb_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4acL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft WB B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// gain for Blue channel for antifog function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_WB_B_DEFAULT (0x0100)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_WB_B_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_matrix_rgb_coefft_wb_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4b0L);
+	APICAL_WRITE_32(0x4b0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_wb_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4b0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft fog offset R
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset R for antifog function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_FOG_OFFSET_R_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_FOG_OFFSET_R_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_matrix_rgb_coefft_fog_offset_r_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4b4L);
+	APICAL_WRITE_32(0x4b4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_fog_offset_r_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4b4L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft fog offset G
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset G for antifog function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_FOG_OFFSET_G_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_FOG_OFFSET_G_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_matrix_rgb_coefft_fog_offset_g_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4b8L);
+	APICAL_WRITE_32(0x4b8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_fog_offset_g_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4b8L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft fog offset B
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset B for antifog function
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MATRIX_RGB_COEFFT_FOG_OFFSET_B_DEFAULT (0x0000)
+#define APICAL_ISP_MATRIX_RGB_COEFFT_FOG_OFFSET_B_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_matrix_rgb_coefft_fog_offset_b_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4bcL);
+	APICAL_WRITE_32(0x4bcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_matrix_rgb_coefft_fog_offset_b_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4bcL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Crop FR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Crop for full resolution path
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable crop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Crop enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CROP_ENABLE_CROP_DEFAULT (0)
+#define APICAL_ISP_FR_CROP_ENABLE_CROP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_crop_enable_crop_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4c0L);
+	APICAL_WRITE_32(0x4c0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_crop_enable_crop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4c0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: start x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal offset from left side of image in pixels for output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CROP_START_X_DEFAULT (0x0000)
+#define APICAL_ISP_FR_CROP_START_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_crop_start_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4c4L);
+	APICAL_WRITE_32(0x4c4L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_crop_start_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4c4L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: start y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical offset from top of image in lines for output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CROP_START_Y_DEFAULT (0x0000)
+#define APICAL_ISP_FR_CROP_START_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_crop_start_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4c8L);
+	APICAL_WRITE_32(0x4c8L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_crop_start_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4c8L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: size x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// width of output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CROP_SIZE_X_DEFAULT (0xffff)
+#define APICAL_ISP_FR_CROP_SIZE_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_crop_size_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4ccL);
+	APICAL_WRITE_32(0x4ccL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_crop_size_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4ccL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: size y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// height of output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CROP_SIZE_Y_DEFAULT (0xffff)
+#define APICAL_ISP_FR_CROP_SIZE_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_crop_size_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x4d0L);
+	APICAL_WRITE_32(0x4d0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_crop_size_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x4d0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Gamma FR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gamma correction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gamma enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_GAMMA_RGB_ENABLE_DEFAULT (1)
+#define APICAL_ISP_FR_GAMMA_RGB_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_gamma_rgb_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4e0L);
+	APICAL_WRITE_32(0x4e0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_gamma_rgb_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU priority
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Priority of CPU port
+//		0=low. CPU read/writes from/to the LUTs are only executed when LUTs are not being accessed by ISP.  Normal operation.
+//		1=high. CPU read/writes from/to the LUTs are always executed.  This may result in corrupt image data and invalid read back and is not recommended.		0=low, 1=high
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_GAMMA_MCU_PRIORITY_DEFAULT (1)
+#define APICAL_ISP_FR_GAMMA_MCU_PRIORITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_gamma_mcu_priority_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4e0L);
+	APICAL_WRITE_32(0x4e0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_fr_gamma_mcu_priority_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU ready
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT is ready to receive the data from CPU
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_GAMMA_RGB_MCU_READY_DEFAULT (0x0)
+#define APICAL_ISP_FR_GAMMA_RGB_MCU_READY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_gamma_rgb_mcu_ready_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e0L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Gamma DS 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gamma correction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gamma enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_GAMMA_RGB_ENABLE_DEFAULT (1)
+#define APICAL_ISP_DS1_GAMMA_RGB_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_gamma_rgb_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4e4L);
+	APICAL_WRITE_32(0x4e4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_gamma_rgb_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU priority
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Priority of CPU port
+//		0=low. CPU read/writes from/to the LUTs are only executed when LUTs are not being accessed by ISP.  Normal operation.
+//		1=high. CPU read/writes from/to the LUTs are always executed.  This may result in corrupt image data and invalid read back and is not recommended.		0=low, 1=high
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_GAMMA_MCU_PRIORITY_DEFAULT (1)
+#define APICAL_ISP_DS1_GAMMA_MCU_PRIORITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_gamma_mcu_priority_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4e4L);
+	APICAL_WRITE_32(0x4e4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds1_gamma_mcu_priority_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU ready
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT is ready to receive the data from CPU
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_GAMMA_RGB_MCU_READY_DEFAULT (0x0)
+#define APICAL_ISP_DS1_GAMMA_RGB_MCU_READY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_gamma_rgb_mcu_ready_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e4L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Gamma DS 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gamma correction
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Gamma enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_GAMMA_RGB_ENABLE_DEFAULT (1)
+#define APICAL_ISP_DS2_GAMMA_RGB_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_gamma_rgb_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4e8L);
+	APICAL_WRITE_32(0x4e8L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_gamma_rgb_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e8L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU priority
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Priority of CPU port
+//		0=low. CPU read/writes from/to the LUTs are only executed when LUTs are not being accessed by ISP.  Normal operation.
+//		1=high. CPU read/writes from/to the LUTs are always executed.  This may result in corrupt image data and invalid read back and is not recommended.		0=low, 1=high
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_GAMMA_MCU_PRIORITY_DEFAULT (1)
+#define APICAL_ISP_DS2_GAMMA_MCU_PRIORITY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_gamma_mcu_priority_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x4e8L);
+	APICAL_WRITE_32(0x4e8L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds2_gamma_mcu_priority_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e8L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: MCU ready
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT is ready to receive the data from CPU
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_GAMMA_RGB_MCU_READY_DEFAULT (0x0)
+#define APICAL_ISP_DS2_GAMMA_RGB_MCU_READY_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_gamma_rgb_mcu_ready_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x4e8L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sharpen FR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Non-linear sharpening algorithm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sharpening enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_SHARPEN_ENABLE_DEFAULT (0)
+#define APICAL_ISP_FR_SHARPEN_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_sharpen_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x500L);
+	APICAL_WRITE_32(0x500L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_sharpen_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x500L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coring
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects LUT memory bank, value 00 connects bank 0 to sharpening and bank 1 to programming, value 01 swap banks
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_SHARPEN_CORING_DEFAULT (1)
+#define APICAL_ISP_FR_SHARPEN_CORING_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_fr_sharpen_coring_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x500L);
+	APICAL_WRITE_32(0x500L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
+}
+static __inline uint8_t apical_isp_fr_sharpen_coring_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x500L) & 0xc) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls strength of sharpening effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_SHARPEN_STRENGTH_DEFAULT (0x30)
+#define APICAL_ISP_FR_SHARPEN_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_sharpen_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x504L);
+	APICAL_WRITE_32(0x504L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_fr_sharpen_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x504L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control R
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_SHARPEN_CONTROL_R_DEFAULT (0x60)
+#define APICAL_ISP_FR_SHARPEN_CONTROL_R_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_sharpen_control_r_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x508L);
+	APICAL_WRITE_32(0x508L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_fr_sharpen_control_r_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x508L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control B
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_SHARPEN_CONTROL_B_DEFAULT (0x40)
+#define APICAL_ISP_FR_SHARPEN_CONTROL_B_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_sharpen_control_b_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x508L);
+	APICAL_WRITE_32(0x508L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_fr_sharpen_control_b_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x508L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Logo
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Logo Left
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets x coordinate of logo (in 16-pixel steps)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_LOGO_LOGO_LEFT_DEFAULT (0x08)
+#define APICAL_ISP_LOGO_LOGO_LEFT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_logo_logo_left_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x520L);
+	APICAL_WRITE_32(0x520L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_logo_logo_left_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x520L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Logo Top
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets y coordinate of logo (in 16-pixel steps)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_LOGO_LOGO_TOP_DEFAULT (0x08)
+#define APICAL_ISP_LOGO_LOGO_TOP_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_logo_logo_top_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x524L);
+	APICAL_WRITE_32(0x524L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_logo_logo_top_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x524L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Colour space conv FR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Conversion of RGB to YUV data using a 3x3 color matrix plus offsets
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable matrix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Color matrix enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_ENABLE_MATRIX_DEFAULT (0)
+#define APICAL_ISP_FR_CS_CONV_ENABLE_MATRIX_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_cs_conv_enable_matrix_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x570L);
+	APICAL_WRITE_32(0x570L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_cs_conv_enable_matrix_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x570L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable filter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Filter enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_ENABLE_FILTER_DEFAULT (0)
+#define APICAL_ISP_FR_CS_CONV_ENABLE_FILTER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_cs_conv_enable_filter_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x570L);
+	APICAL_WRITE_32(0x570L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_fr_cs_conv_enable_filter_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x570L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable horizontal downsample
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downsample enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DEFAULT (0)
+#define APICAL_ISP_FR_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_cs_conv_enable_horizontal_downsample_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x570L);
+	APICAL_WRITE_32(0x570L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_fr_cs_conv_enable_horizontal_downsample_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x570L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable vertical downsample
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downsample enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DEFAULT (0)
+#define APICAL_ISP_FR_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_cs_conv_enable_vertical_downsample_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x570L);
+	APICAL_WRITE_32(0x570L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_fr_cs_conv_enable_vertical_downsample_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x570L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 11
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_11_DEFAULT (0x002f)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_11_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_11_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x540L);
+	APICAL_WRITE_32(0x540L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_11_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x540L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 12
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_12_DEFAULT (0x009d)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_12_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_12_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x544L);
+	APICAL_WRITE_32(0x544L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_12_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x544L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 13
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_13_DEFAULT (0x0010)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_13_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_13_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x548L);
+	APICAL_WRITE_32(0x548L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_13_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x548L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 21
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_21_DEFAULT (0x801a)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_21_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_21_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x54cL);
+	APICAL_WRITE_32(0x54cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_21_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x54cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 22
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_22_DEFAULT (0x8057)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_22_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_22_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x550L);
+	APICAL_WRITE_32(0x550L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_22_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x550L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 23
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_23_DEFAULT (0x0070)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_23_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_23_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x554L);
+	APICAL_WRITE_32(0x554L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_23_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x554L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 31
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_31_DEFAULT (0x0070)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_31_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_31_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x558L);
+	APICAL_WRITE_32(0x558L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_31_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x558L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 32
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_32_DEFAULT (0x8066)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_32_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_32_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x55cL);
+	APICAL_WRITE_32(0x55cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_32_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x55cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 33
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_33_DEFAULT (0x800a)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_33_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_33_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x560L);
+	APICAL_WRITE_32(0x560L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_33_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x560L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_O1_DEFAULT (0x000)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_O1_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_o1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x564L);
+	APICAL_WRITE_32(0x564L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_o1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x564L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Cb
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_O2_DEFAULT (0x200)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_O2_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_o2_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x568L);
+	APICAL_WRITE_32(0x568L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_o2_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x568L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o3
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Cr
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_COEFFT_O3_DEFAULT (0x200)
+#define APICAL_ISP_FR_CS_CONV_COEFFT_O3_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_fr_cs_conv_coefft_o3_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x56cL);
+	APICAL_WRITE_32(0x56cL, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_coefft_o3_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x56cL) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip min Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimal value for Y.  Values below this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_CLIP_MIN_Y_DEFAULT (0x000)
+#define APICAL_ISP_FR_CS_CONV_CLIP_MIN_Y_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_clip_min_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x578L);
+	APICAL_WRITE_32(0x578L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_clip_min_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x578L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip max Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximal value for Y.  Values above this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_CLIP_MAX_Y_DEFAULT (0x3FF)
+#define APICAL_ISP_FR_CS_CONV_CLIP_MAX_Y_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_clip_max_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x57cL);
+	APICAL_WRITE_32(0x57cL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_clip_max_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x57cL) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip min UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimal value for Cb, Cr.  Values below this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_CLIP_MIN_UV_DEFAULT (0x000)
+#define APICAL_ISP_FR_CS_CONV_CLIP_MIN_UV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_clip_min_uv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x580L);
+	APICAL_WRITE_32(0x580L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_clip_min_uv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x580L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip max UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximal value for Cb, Cr.  Values above this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_CLIP_MAX_UV_DEFAULT (0x3FF)
+#define APICAL_ISP_FR_CS_CONV_CLIP_MAX_UV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_clip_max_uv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x584L);
+	APICAL_WRITE_32(0x584L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_clip_max_uv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x584L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask RY
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 1 (R or Y).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_DATA_MASK_RY_DEFAULT (0x3FF)
+#define APICAL_ISP_FR_CS_CONV_DATA_MASK_RY_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_data_mask_ry_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x588L);
+	APICAL_WRITE_32(0x588L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_data_mask_ry_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x588L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask GU
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 2 (G or U).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_DATA_MASK_GU_DEFAULT (0x3FF)
+#define APICAL_ISP_FR_CS_CONV_DATA_MASK_GU_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_data_mask_gu_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x58cL);
+	APICAL_WRITE_32(0x58cL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_data_mask_gu_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x58cL) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask BV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 3 (B or V).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_CS_CONV_DATA_MASK_BV_DEFAULT (0x3FF)
+#define APICAL_ISP_FR_CS_CONV_DATA_MASK_BV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_fr_cs_conv_data_mask_bv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x590L);
+	APICAL_WRITE_32(0x590L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_fr_cs_conv_data_mask_bv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x590L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Dither FR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable dither
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables dithering module
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DITHER_ENABLE_DITHER_DEFAULT (0x0)
+#define APICAL_ISP_FR_DITHER_ENABLE_DITHER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dither_enable_dither_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x5e0L);
+	APICAL_WRITE_32(0x5e0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_dither_enable_dither_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x5e0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dither amount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= dither to 9 bits; 1=dither to 8 bits; 2=dither to 7 bits; 3=dither to 6 bits
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DITHER_DITHER_AMOUNT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DITHER_DITHER_AMOUNT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_fr_dither_dither_amount_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x5e0L);
+	APICAL_WRITE_32(0x5e0L, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
+}
+static __inline uint8_t apical_isp_fr_dither_dither_amount_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x5e0L) & 0x6) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Shift mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= output is LSB aligned; 1=output is MSB aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DITHER_SHIFT_MODE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DITHER_SHIFT_MODE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dither_shift_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x5e0L);
+	APICAL_WRITE_32(0x5e0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_fr_dither_shift_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x5e0L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Crop DS 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Crop for down-scale path
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable crop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Crop enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CROP_ENABLE_CROP_DEFAULT (0)
+#define APICAL_ISP_DS1_CROP_ENABLE_CROP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_crop_enable_crop_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x600L);
+	APICAL_WRITE_32(0x600L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_crop_enable_crop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x600L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: start x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal offset from left side of image in pixels for output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CROP_START_X_DEFAULT (0x0000)
+#define APICAL_ISP_DS1_CROP_START_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_crop_start_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x604L);
+	APICAL_WRITE_32(0x604L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_crop_start_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x604L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: start y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical offset from top of image in lines for output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CROP_START_Y_DEFAULT (0x0000)
+#define APICAL_ISP_DS1_CROP_START_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_crop_start_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x608L);
+	APICAL_WRITE_32(0x608L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_crop_start_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x608L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: size x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// width of output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CROP_SIZE_X_DEFAULT (0xffff)
+#define APICAL_ISP_DS1_CROP_SIZE_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_crop_size_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x60cL);
+	APICAL_WRITE_32(0x60cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_crop_size_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x60cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: size y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// height of output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CROP_SIZE_Y_DEFAULT (0xffff)
+#define APICAL_ISP_DS1_CROP_SIZE_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_crop_size_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x610L);
+	APICAL_WRITE_32(0x610L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_crop_size_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x610L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sharpen DS1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Non-linear sharpening algorithm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sharpening enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SHARPEN_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS1_SHARPEN_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_sharpen_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x620L);
+	APICAL_WRITE_32(0x620L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_sharpen_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x620L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coring
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects LUT memory bank, value 00 connects bank 0 to sharpening and bank 1 to programming, value 01 swap banks
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SHARPEN_CORING_DEFAULT (1)
+#define APICAL_ISP_DS1_SHARPEN_CORING_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds1_sharpen_coring_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x620L);
+	APICAL_WRITE_32(0x620L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
+}
+static __inline uint8_t apical_isp_ds1_sharpen_coring_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x620L) & 0xc) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls strength of sharpening effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SHARPEN_STRENGTH_DEFAULT (0x30)
+#define APICAL_ISP_DS1_SHARPEN_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_sharpen_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x624L);
+	APICAL_WRITE_32(0x624L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds1_sharpen_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x624L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control R
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SHARPEN_CONTROL_R_DEFAULT (0x60)
+#define APICAL_ISP_DS1_SHARPEN_CONTROL_R_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_sharpen_control_r_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x628L);
+	APICAL_WRITE_32(0x628L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds1_sharpen_control_r_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x628L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control B
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SHARPEN_CONTROL_B_DEFAULT (0x40)
+#define APICAL_ISP_DS1_SHARPEN_CONTROL_B_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_sharpen_control_b_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x628L);
+	APICAL_WRITE_32(0x628L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_ds1_sharpen_control_b_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x628L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Down Scaler 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: IRQSTAT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downscaler status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_IRQSTAT_DEFAULT (0x00)
+#define APICAL_ISP_DS1_SCALER_IRQSTAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline uint8_t apical_isp_ds1_scaler_irqstat_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x640L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timeout IRQ
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//             0 : No timeout
+//             1 : Timeout on frame done
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_TIMEOUT_IRQ_DEFAULT (0x0)
+#define APICAL_ISP_DS1_SCALER_TIMEOUT_IRQ_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_timeout_irq_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x640L);
+	APICAL_WRITE_32(0x640L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1_scaler_timeout_irq_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x640L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Underflow IRQ
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//             0 : No underflow
+//             1 : FIFO underflow has occurred
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_UNDERFLOW_IRQ_DEFAULT (0x0)
+#define APICAL_ISP_DS1_SCALER_UNDERFLOW_IRQ_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_underflow_irq_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x640L);
+	APICAL_WRITE_32(0x640L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds1_scaler_underflow_irq_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x640L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Overflow IRQ
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//             0 : No overflow
+//             1 : FIFO overflow has occurred
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_OVERFLOW_IRQ_DEFAULT (0x0)
+#define APICAL_ISP_DS1_SCALER_OVERFLOW_IRQ_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_overflow_irq_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x640L);
+	APICAL_WRITE_32(0x640L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds1_scaler_overflow_irq_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x640L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clear Alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//Scaler control
+//IRQ CLR bit
+// 0 : In-active
+// 1 : Clear-off IRQ status to 0
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_DS1_SCALER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x644L);
+	APICAL_WRITE_32(0x644L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1_scaler_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x644L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timeout Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+// 0 : Timeout disabled.
+// 1 : Timeout enabled.  Automatic frame reset if frame has not completed after anticipated time.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_TIMEOUT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS1_SCALER_TIMEOUT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_timeout_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x644L);
+	APICAL_WRITE_32(0x644L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_ds1_scaler_timeout_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x644L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Field in toggle sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+// 0 : Input Field Type = pulse.
+// 1 : Input Field Type = toggle.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_FIELD_IN_TOGGLE_SEL_DEFAULT (0)
+#define APICAL_ISP_DS1_SCALER_FIELD_IN_TOGGLE_SEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_field_in_toggle_sel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x644L);
+	APICAL_WRITE_32(0x644L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_ds1_scaler_field_in_toggle_sel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x644L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: WIDTH
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Input frame width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_DS1_SCALER_WIDTH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_ds1_scaler_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x648L);
+	APICAL_WRITE_32(0x648L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_ds1_scaler_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x648L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: HEIGHT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Input frame height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_DS1_SCALER_HEIGHT_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_ds1_scaler_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x64cL);
+	APICAL_WRITE_32(0x64cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_ds1_scaler_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x64cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: OWIDTH
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Output frame width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_OWIDTH_DEFAULT (0x500)
+#define APICAL_ISP_DS1_SCALER_OWIDTH_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds1_scaler_owidth_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x650L);
+	APICAL_WRITE_32(0x650L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds1_scaler_owidth_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x650L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: OHEIGHT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Output frame height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_OHEIGHT_DEFAULT (0x2D0)
+#define APICAL_ISP_DS1_SCALER_OHEIGHT_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_ds1_scaler_oheight_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x654L);
+	APICAL_WRITE_32(0x654L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_ds1_scaler_oheight_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x654L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: HFILT_TINC
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal scaling factor equal to the
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_HFILT_TINC_DEFAULT (0x180000)
+#define APICAL_ISP_DS1_SCALER_HFILT_TINC_DATASIZE (24)
+
+// args: data (24-bit)
+static __inline void apical_isp_ds1_scaler_hfilt_tinc_write(uint32_t data) {
+	uint32_t curr = APICAL_READ_32(0x658L);
+	APICAL_WRITE_32(0x658L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
+}
+static __inline uint32_t apical_isp_ds1_scaler_hfilt_tinc_read(void) {
+	return (uint32_t)((APICAL_READ_32(0x658L) & 0xffffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: HFILT_COEFSET
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//HFILT Coeff. control.
+//HFILT_COEFSET[3:0] - Selects horizontal Coef set for scaler.
+// 0000 : use set 0
+// 0001 : use set 1
+// ......
+// 1111 : use set 15
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_HFILT_COEFSET_DEFAULT (0x00)
+#define APICAL_ISP_DS1_SCALER_HFILT_COEFSET_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds1_scaler_hfilt_coefset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x65cL);
+	APICAL_WRITE_32(0x65cL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds1_scaler_hfilt_coefset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x65cL) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VFILT_TINC
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// VFILT TINC
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_VFILT_TINC_DEFAULT (0x180000)
+#define APICAL_ISP_DS1_SCALER_VFILT_TINC_DATASIZE (24)
+
+// args: data (24-bit)
+static __inline void apical_isp_ds1_scaler_vfilt_tinc_write(uint32_t data) {
+	uint32_t curr = APICAL_READ_32(0x660L);
+	APICAL_WRITE_32(0x660L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
+}
+static __inline uint32_t apical_isp_ds1_scaler_vfilt_tinc_read(void) {
+	return (uint32_t)((APICAL_READ_32(0x660L) & 0xffffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VFILT_COEFSET
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//VFILT Coeff. control
+//FILT_COEFSET[3:0] - Selects vertical Coef set for scaler
+//0000 : use set 0
+//0001 : use set 1
+//......
+//1111 : use set 15
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_VFILT_COEFSET_DEFAULT (0x00)
+#define APICAL_ISP_DS1_SCALER_VFILT_COEFSET_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds1_scaler_vfilt_coefset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x664L);
+	APICAL_WRITE_32(0x664L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds1_scaler_vfilt_coefset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x664L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: IMGRST
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//Manual frame reset control
+//0 : In-active
+//1 : Set to 1 for synchronous reset of Hfilter/Vfilter blocks
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_SCALER_IMGRST_DEFAULT (0x00)
+#define APICAL_ISP_DS1_SCALER_IMGRST_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_scaler_imgrst_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x668L);
+	APICAL_WRITE_32(0x668L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_scaler_imgrst_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x668L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Colour space conv DS 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Conversion of RGB to YUV data using a 3x3 color matrix plus offsets
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable matrix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Color matrix enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_MATRIX_DEFAULT (0)
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_MATRIX_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_cs_conv_enable_matrix_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6b0L);
+	APICAL_WRITE_32(0x6b0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_cs_conv_enable_matrix_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6b0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable filter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Filter enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_FILTER_DEFAULT (0)
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_FILTER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_cs_conv_enable_filter_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6b0L);
+	APICAL_WRITE_32(0x6b0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds1_cs_conv_enable_filter_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6b0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable horizontal downsample
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downsample enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DEFAULT (0)
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_cs_conv_enable_horizontal_downsample_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6b0L);
+	APICAL_WRITE_32(0x6b0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds1_cs_conv_enable_horizontal_downsample_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6b0L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable vertical downsample
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downsample enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DEFAULT (0)
+#define APICAL_ISP_DS1_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_cs_conv_enable_vertical_downsample_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6b0L);
+	APICAL_WRITE_32(0x6b0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1_cs_conv_enable_vertical_downsample_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6b0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 11
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_11_DEFAULT (0x002f)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_11_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_11_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x680L);
+	APICAL_WRITE_32(0x680L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_11_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x680L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 12
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_12_DEFAULT (0x009d)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_12_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_12_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x684L);
+	APICAL_WRITE_32(0x684L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_12_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x684L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 13
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_13_DEFAULT (0x0010)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_13_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_13_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x688L);
+	APICAL_WRITE_32(0x688L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_13_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x688L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 21
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_21_DEFAULT (0x801a)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_21_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_21_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x68cL);
+	APICAL_WRITE_32(0x68cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_21_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x68cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 22
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_22_DEFAULT (0x8057)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_22_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_22_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x690L);
+	APICAL_WRITE_32(0x690L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_22_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x690L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 23
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_23_DEFAULT (0x0070)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_23_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_23_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x694L);
+	APICAL_WRITE_32(0x694L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_23_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x694L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 31
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_31_DEFAULT (0x0070)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_31_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_31_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x698L);
+	APICAL_WRITE_32(0x698L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_31_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x698L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 32
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_32_DEFAULT (0x8066)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_32_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_32_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x69cL);
+	APICAL_WRITE_32(0x69cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_32_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x69cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 33
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_33_DEFAULT (0x800a)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_33_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_33_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6a0L);
+	APICAL_WRITE_32(0x6a0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_33_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6a0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_O1_DEFAULT (0x000)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_O1_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_o1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6a4L);
+	APICAL_WRITE_32(0x6a4L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_o1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6a4L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Cb
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_O2_DEFAULT (0x200)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_O2_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_o2_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6a8L);
+	APICAL_WRITE_32(0x6a8L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_o2_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6a8L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o3
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Cr
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_O3_DEFAULT (0x200)
+#define APICAL_ISP_DS1_CS_CONV_COEFFT_O3_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds1_cs_conv_coefft_o3_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6acL);
+	APICAL_WRITE_32(0x6acL, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_coefft_o3_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6acL) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip min Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimal value for Y.  Values below this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MIN_Y_DEFAULT (0x000)
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MIN_Y_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_clip_min_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6b8L);
+	APICAL_WRITE_32(0x6b8L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_clip_min_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6b8L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip max Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximal value for Y.  Values above this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MAX_Y_DEFAULT (0x3FF)
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MAX_Y_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_clip_max_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6bcL);
+	APICAL_WRITE_32(0x6bcL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_clip_max_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6bcL) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip min UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimal value for Cb, Cr.  Values below this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MIN_UV_DEFAULT (0x000)
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MIN_UV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_clip_min_uv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6c0L);
+	APICAL_WRITE_32(0x6c0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_clip_min_uv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6c0L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip max UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximal value for Cb, Cr.  Values above this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MAX_UV_DEFAULT (0x3FF)
+#define APICAL_ISP_DS1_CS_CONV_CLIP_MAX_UV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_clip_max_uv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6c4L);
+	APICAL_WRITE_32(0x6c4L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_clip_max_uv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6c4L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask RY
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 1 (R or Y).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_DATA_MASK_RY_DEFAULT (0x3FF)
+#define APICAL_ISP_DS1_CS_CONV_DATA_MASK_RY_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_data_mask_ry_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6c8L);
+	APICAL_WRITE_32(0x6c8L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_data_mask_ry_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6c8L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask GU
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 2 (G or U).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_DATA_MASK_GU_DEFAULT (0x3FF)
+#define APICAL_ISP_DS1_CS_CONV_DATA_MASK_GU_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_data_mask_gu_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6ccL);
+	APICAL_WRITE_32(0x6ccL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_data_mask_gu_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6ccL) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask BV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 3 (B or V).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_CS_CONV_DATA_MASK_BV_DEFAULT (0x3FF)
+#define APICAL_ISP_DS1_CS_CONV_DATA_MASK_BV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds1_cs_conv_data_mask_bv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x6d0L);
+	APICAL_WRITE_32(0x6d0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds1_cs_conv_data_mask_bv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x6d0L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Dither DS 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable dither
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables dithering module
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DITHER_ENABLE_DITHER_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DITHER_ENABLE_DITHER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dither_enable_dither_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6e0L);
+	APICAL_WRITE_32(0x6e0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_dither_enable_dither_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6e0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dither amount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= dither to 9 bits; 1=dither to 8 bits; 2=dither to 7 bits; 3=dither to 6 bits
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DITHER_DITHER_AMOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DITHER_DITHER_AMOUNT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds1_dither_dither_amount_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6e0L);
+	APICAL_WRITE_32(0x6e0L, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
+}
+static __inline uint8_t apical_isp_ds1_dither_dither_amount_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6e0L) & 0x6) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Shift mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= output is LSB aligned; 1=output is MSB aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DITHER_SHIFT_MODE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DITHER_SHIFT_MODE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dither_shift_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x6e0L);
+	APICAL_WRITE_32(0x6e0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_ds1_dither_shift_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x6e0L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Crop DS 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  Crop for down-scale path
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable crop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Crop enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CROP_ENABLE_CROP_DEFAULT (0)
+#define APICAL_ISP_DS2_CROP_ENABLE_CROP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_crop_enable_crop_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x700L);
+	APICAL_WRITE_32(0x700L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_crop_enable_crop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x700L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: start x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal offset from left side of image in pixels for output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CROP_START_X_DEFAULT (0x0000)
+#define APICAL_ISP_DS2_CROP_START_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_crop_start_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x704L);
+	APICAL_WRITE_32(0x704L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_crop_start_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x704L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: start y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Vertical offset from top of image in lines for output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CROP_START_Y_DEFAULT (0x0000)
+#define APICAL_ISP_DS2_CROP_START_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_crop_start_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x708L);
+	APICAL_WRITE_32(0x708L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_crop_start_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x708L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: size x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// width of output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CROP_SIZE_X_DEFAULT (0xffff)
+#define APICAL_ISP_DS2_CROP_SIZE_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_crop_size_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x70cL);
+	APICAL_WRITE_32(0x70cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_crop_size_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x70cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: size y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// height of output crop window
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CROP_SIZE_Y_DEFAULT (0xffff)
+#define APICAL_ISP_DS2_CROP_SIZE_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_crop_size_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x710L);
+	APICAL_WRITE_32(0x710L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_crop_size_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x710L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sharpen DS2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Non-linear sharpening algorithm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sharpening enable: 0=off, 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SHARPEN_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS2_SHARPEN_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_sharpen_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x720L);
+	APICAL_WRITE_32(0x720L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_sharpen_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x720L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coring
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Selects LUT memory bank, value 00 connects bank 0 to sharpening and bank 1 to programming, value 01 swap banks
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SHARPEN_CORING_DEFAULT (1)
+#define APICAL_ISP_DS2_SHARPEN_CORING_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds2_sharpen_coring_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x720L);
+	APICAL_WRITE_32(0x720L, (((uint32_t) (data & 0x3)) << 2) | (curr & 0xfffffff3));
+}
+static __inline uint8_t apical_isp_ds2_sharpen_coring_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x720L) & 0xc) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Strength
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls strength of sharpening effect
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SHARPEN_STRENGTH_DEFAULT (0x30)
+#define APICAL_ISP_DS2_SHARPEN_STRENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_sharpen_strength_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x724L);
+	APICAL_WRITE_32(0x724L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds2_sharpen_strength_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x724L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control R
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SHARPEN_CONTROL_R_DEFAULT (0x60)
+#define APICAL_ISP_DS2_SHARPEN_CONTROL_R_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_sharpen_control_r_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x728L);
+	APICAL_WRITE_32(0x728L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds2_sharpen_control_r_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x728L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Control B
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SHARPEN_CONTROL_B_DEFAULT (0x40)
+#define APICAL_ISP_DS2_SHARPEN_CONTROL_B_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_sharpen_control_b_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x728L);
+	APICAL_WRITE_32(0x728L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_ds2_sharpen_control_b_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x728L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Down Scaler 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: IRQSTAT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downscaler status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_IRQSTAT_DEFAULT (0x00)
+#define APICAL_ISP_DS2_SCALER_IRQSTAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline uint8_t apical_isp_ds2_scaler_irqstat_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x740L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timeout IRQ
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//             0 : No timeout
+//             1 : Timeout on frame done
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_TIMEOUT_IRQ_DEFAULT (0x0)
+#define APICAL_ISP_DS2_SCALER_TIMEOUT_IRQ_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_scaler_timeout_irq_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x740L);
+	APICAL_WRITE_32(0x740L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds2_scaler_timeout_irq_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x740L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Underflow IRQ
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//             0 : No underflow
+//             1 : FIFO underflow has occurred
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_UNDERFLOW_IRQ_DEFAULT (0x0)
+#define APICAL_ISP_DS2_SCALER_UNDERFLOW_IRQ_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_scaler_underflow_irq_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x740L);
+	APICAL_WRITE_32(0x740L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds2_scaler_underflow_irq_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x740L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Overflow IRQ
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//             0 : No overflow
+//             1 : FIFO overflow has occurred
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_OVERFLOW_IRQ_DEFAULT (0x0)
+#define APICAL_ISP_DS2_SCALER_OVERFLOW_IRQ_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_scaler_overflow_irq_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x740L);
+	APICAL_WRITE_32(0x740L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds2_scaler_overflow_irq_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x740L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Timeout Enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+// 0 : Timeout disabled.
+// 1 : Timeout enabled.  Automatic frame reset if frame has not completed after anticipated time.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_TIMEOUT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS2_SCALER_TIMEOUT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_scaler_timeout_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x744L);
+	APICAL_WRITE_32(0x744L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_ds2_scaler_timeout_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x744L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Field in toggle sel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+// 0 : Input Field Type = pulse.
+// 1 : Input Field Type = toggle.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_FIELD_IN_TOGGLE_SEL_DEFAULT (0)
+#define APICAL_ISP_DS2_SCALER_FIELD_IN_TOGGLE_SEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_scaler_field_in_toggle_sel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x744L);
+	APICAL_WRITE_32(0x744L, (((uint32_t) (data & 0x1)) << 5) | (curr & 0xffffffdf));
+}
+static __inline uint8_t apical_isp_ds2_scaler_field_in_toggle_sel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x744L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: WIDTH
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Input frame width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_DS2_SCALER_WIDTH_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_ds2_scaler_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x748L);
+	APICAL_WRITE_32(0x748L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_ds2_scaler_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x748L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: HEIGHT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Input frame height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_DS2_SCALER_HEIGHT_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_ds2_scaler_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x74cL);
+	APICAL_WRITE_32(0x74cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_ds2_scaler_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x74cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: OWIDTH
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Output frame width in pixels
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_OWIDTH_DEFAULT (0x500)
+#define APICAL_ISP_DS2_SCALER_OWIDTH_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds2_scaler_owidth_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x750L);
+	APICAL_WRITE_32(0x750L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds2_scaler_owidth_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x750L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: OHEIGHT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Output frame height in lines
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_OHEIGHT_DEFAULT (0x2D0)
+#define APICAL_ISP_DS2_SCALER_OHEIGHT_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_ds2_scaler_oheight_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x754L);
+	APICAL_WRITE_32(0x754L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_ds2_scaler_oheight_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x754L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: HFILT_TINC
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Horizontal scaling factor equal to the
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_HFILT_TINC_DEFAULT (0x180000)
+#define APICAL_ISP_DS2_SCALER_HFILT_TINC_DATASIZE (24)
+
+// args: data (24-bit)
+static __inline void apical_isp_ds2_scaler_hfilt_tinc_write(uint32_t data) {
+	uint32_t curr = APICAL_READ_32(0x758L);
+	APICAL_WRITE_32(0x758L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
+}
+static __inline uint32_t apical_isp_ds2_scaler_hfilt_tinc_read(void) {
+	return (uint32_t)((APICAL_READ_32(0x758L) & 0xffffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: HFILT_COEFSET
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//HFILT Coeff. control.
+//HFILT_COEFSET[3:0] - Selects horizontal Coef set for scaler.
+// 0000 : use set 0
+// 0001 : use set 1
+// ......
+// 1111 : use set 15
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_HFILT_COEFSET_DEFAULT (0x00)
+#define APICAL_ISP_DS2_SCALER_HFILT_COEFSET_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds2_scaler_hfilt_coefset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x75cL);
+	APICAL_WRITE_32(0x75cL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds2_scaler_hfilt_coefset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x75cL) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VFILT_TINC
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// VFILT TINC
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_VFILT_TINC_DEFAULT (0x180000)
+#define APICAL_ISP_DS2_SCALER_VFILT_TINC_DATASIZE (24)
+
+// args: data (24-bit)
+static __inline void apical_isp_ds2_scaler_vfilt_tinc_write(uint32_t data) {
+	uint32_t curr = APICAL_READ_32(0x760L);
+	APICAL_WRITE_32(0x760L, (((uint32_t) (data & 0xffffff)) << 0) | (curr & 0xff000000));
+}
+static __inline uint32_t apical_isp_ds2_scaler_vfilt_tinc_read(void) {
+	return (uint32_t)((APICAL_READ_32(0x760L) & 0xffffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: VFILT_COEFSET
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//VFILT Coeff. control
+//FILT_COEFSET[3:0] - Selects vertical Coef set for scaler
+//0000 : use set 0
+//0001 : use set 1
+//......
+//1111 : use set 15
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_VFILT_COEFSET_DEFAULT (0x00)
+#define APICAL_ISP_DS2_SCALER_VFILT_COEFSET_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds2_scaler_vfilt_coefset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x764L);
+	APICAL_WRITE_32(0x764L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds2_scaler_vfilt_coefset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x764L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: IMGRST
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//Manual frame reset control
+//0 : In-active
+//1 : Set to 1 for synchronous reset of Hfilter/Vfilter blocks
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_SCALER_IMGRST_DEFAULT (0x00)
+#define APICAL_ISP_DS2_SCALER_IMGRST_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_scaler_imgrst_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x768L);
+	APICAL_WRITE_32(0x768L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_scaler_imgrst_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x768L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Colour space conv DS 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Conversion of RGB to YUV data using a 3x3 color matrix plus offsets
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable matrix
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Color matrix enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_MATRIX_DEFAULT (0)
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_MATRIX_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_cs_conv_enable_matrix_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7b0L);
+	APICAL_WRITE_32(0x7b0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_cs_conv_enable_matrix_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7b0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable filter
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Filter enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_FILTER_DEFAULT (0)
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_FILTER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_cs_conv_enable_filter_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7b0L);
+	APICAL_WRITE_32(0x7b0L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds2_cs_conv_enable_filter_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7b0L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable horizontal downsample
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downsample enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DEFAULT (0)
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_HORIZONTAL_DOWNSAMPLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_cs_conv_enable_horizontal_downsample_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7b0L);
+	APICAL_WRITE_32(0x7b0L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds2_cs_conv_enable_horizontal_downsample_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7b0L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Enable vertical downsample
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Downsample enable: 0=off 1=on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DEFAULT (0)
+#define APICAL_ISP_DS2_CS_CONV_ENABLE_VERTICAL_DOWNSAMPLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_cs_conv_enable_vertical_downsample_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7b0L);
+	APICAL_WRITE_32(0x7b0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds2_cs_conv_enable_vertical_downsample_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7b0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 11
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_11_DEFAULT (0x002f)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_11_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_11_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x780L);
+	APICAL_WRITE_32(0x780L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_11_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x780L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 12
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_12_DEFAULT (0x009d)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_12_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_12_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x784L);
+	APICAL_WRITE_32(0x784L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_12_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x784L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 13
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Y multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_13_DEFAULT (0x0010)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_13_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_13_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x788L);
+	APICAL_WRITE_32(0x788L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_13_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x788L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 21
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_21_DEFAULT (0x801a)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_21_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_21_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x78cL);
+	APICAL_WRITE_32(0x78cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_21_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x78cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 22
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_22_DEFAULT (0x8057)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_22_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_22_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x790L);
+	APICAL_WRITE_32(0x790L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_22_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x790L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 23
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Cb multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_23_DEFAULT (0x0070)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_23_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_23_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x794L);
+	APICAL_WRITE_32(0x794L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_23_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x794L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 31
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for R-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_31_DEFAULT (0x0070)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_31_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_31_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x798L);
+	APICAL_WRITE_32(0x798L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_31_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x798L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 32
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for G-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_32_DEFAULT (0x8066)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_32_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_32_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x79cL);
+	APICAL_WRITE_32(0x79cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_32_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x79cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft 33
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Matrix coefficient for B-Cr multiplier
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_33_DEFAULT (0x800a)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_33_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_33_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7a0L);
+	APICAL_WRITE_32(0x7a0L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_33_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7a0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_O1_DEFAULT (0x000)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_O1_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_o1_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7a4L);
+	APICAL_WRITE_32(0x7a4L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_o1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7a4L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Cb
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_O2_DEFAULT (0x200)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_O2_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_o2_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7a8L);
+	APICAL_WRITE_32(0x7a8L, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_o2_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7a8L) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Coefft o3
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Offset for Cr
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_O3_DEFAULT (0x200)
+#define APICAL_ISP_DS2_CS_CONV_COEFFT_O3_DATASIZE (11)
+
+// args: data (11-bit)
+static __inline void apical_isp_ds2_cs_conv_coefft_o3_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7acL);
+	APICAL_WRITE_32(0x7acL, (((uint32_t) (data & 0x7ff)) << 0) | (curr & 0xfffff800));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_coefft_o3_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7acL) & 0x7ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip min Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimal value for Y.  Values below this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MIN_Y_DEFAULT (0x000)
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MIN_Y_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_clip_min_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7b8L);
+	APICAL_WRITE_32(0x7b8L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_clip_min_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7b8L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip max Y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximal value for Y.  Values above this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MAX_Y_DEFAULT (0x3FF)
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MAX_Y_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_clip_max_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7bcL);
+	APICAL_WRITE_32(0x7bcL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_clip_max_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7bcL) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip min UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimal value for Cb, Cr.  Values below this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MIN_UV_DEFAULT (0x000)
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MIN_UV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_clip_min_uv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7c0L);
+	APICAL_WRITE_32(0x7c0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_clip_min_uv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7c0L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clip max UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximal value for Cb, Cr.  Values above this are clipped.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MAX_UV_DEFAULT (0x3FF)
+#define APICAL_ISP_DS2_CS_CONV_CLIP_MAX_UV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_clip_max_uv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7c4L);
+	APICAL_WRITE_32(0x7c4L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_clip_max_uv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7c4L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask RY
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 1 (R or Y).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_DATA_MASK_RY_DEFAULT (0x3FF)
+#define APICAL_ISP_DS2_CS_CONV_DATA_MASK_RY_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_data_mask_ry_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7c8L);
+	APICAL_WRITE_32(0x7c8L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_data_mask_ry_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7c8L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask GU
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 2 (G or U).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_DATA_MASK_GU_DEFAULT (0x3FF)
+#define APICAL_ISP_DS2_CS_CONV_DATA_MASK_GU_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_data_mask_gu_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7ccL);
+	APICAL_WRITE_32(0x7ccL, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_data_mask_gu_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7ccL) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Data mask BV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Data mask for channel 3 (B or V).  Bit-wise and of this value and video data.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_CS_CONV_DATA_MASK_BV_DEFAULT (0x3FF)
+#define APICAL_ISP_DS2_CS_CONV_DATA_MASK_BV_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_ds2_cs_conv_data_mask_bv_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x7d0L);
+	APICAL_WRITE_32(0x7d0L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_ds2_cs_conv_data_mask_bv_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x7d0L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Dither DS 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Enable dither
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enables dithering module
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DITHER_ENABLE_DITHER_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DITHER_ENABLE_DITHER_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dither_enable_dither_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7e0L);
+	APICAL_WRITE_32(0x7e0L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_dither_enable_dither_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7e0L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dither amount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= dither to 9 bits; 1=dither to 8 bits; 2=dither to 7 bits; 3=dither to 6 bits
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DITHER_DITHER_AMOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DITHER_DITHER_AMOUNT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds2_dither_dither_amount_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7e0L);
+	APICAL_WRITE_32(0x7e0L, (((uint32_t) (data & 0x3)) << 1) | (curr & 0xfffffff9));
+}
+static __inline uint8_t apical_isp_ds2_dither_dither_amount_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7e0L) & 0x6) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Shift mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= output is LSB aligned; 1=output is MSB aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DITHER_SHIFT_MODE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DITHER_SHIFT_MODE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dither_shift_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x7e0L);
+	APICAL_WRITE_32(0x7e0L, (((uint32_t) (data & 0x1)) << 4) | (curr & 0xffffffef));
+}
+static __inline uint8_t apical_isp_ds2_dither_shift_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x7e0L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Statistics
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Derives information for use by the AE and AWB modules
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Hist Thresh 0 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Histogram threshold for bin 0/1 boundary
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_THRESH_0_1_DEFAULT (0x10)
+#define APICAL_ISP_METERING_HIST_THRESH_0_1_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_hist_thresh_0_1_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x800L);
+	APICAL_WRITE_32(0x800L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_hist_thresh_0_1_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x800L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist Thresh 1 2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Histogram threshold for bin 1/2 boundary
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_THRESH_1_2_DEFAULT (0x20)
+#define APICAL_ISP_METERING_HIST_THRESH_1_2_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_hist_thresh_1_2_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x804L);
+	APICAL_WRITE_32(0x804L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_hist_thresh_1_2_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x804L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist Thresh 3 4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Histogram threshold for bin 2/3 boundary
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_THRESH_3_4_DEFAULT (0xD0)
+#define APICAL_ISP_METERING_HIST_THRESH_3_4_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_hist_thresh_3_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x808L);
+	APICAL_WRITE_32(0x808L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_hist_thresh_3_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x808L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist Thresh 4 5
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Histogram threshold for bin 3/4 boundary
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_THRESH_4_5_DEFAULT (0xE0)
+#define APICAL_ISP_METERING_HIST_THRESH_4_5_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_hist_thresh_4_5_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x80cL);
+	APICAL_WRITE_32(0x80cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_hist_thresh_4_5_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x80cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist 0
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Normalized histogram results for bin 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_0_DEFAULT (0x0)
+#define APICAL_ISP_METERING_HIST_0_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_hist_0_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x820L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist 1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Normalized histogram results for bin 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_1_DEFAULT (0x0)
+#define APICAL_ISP_METERING_HIST_1_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_hist_1_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x824L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist 3
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Normalized histogram results for bin 3
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_3_DEFAULT (0x0)
+#define APICAL_ISP_METERING_HIST_3_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_hist_3_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x828L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Hist 4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Normalized histogram results for bin 4
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_HIST_4_DEFAULT (0x0)
+#define APICAL_ISP_METERING_HIST_4_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_hist_4_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x82cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AEXP Nodes Used Horiz
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of active zones horizontally for AE stats collection
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AEXP_NODES_USED_HORIZ_DEFAULT (15)
+#define APICAL_ISP_METERING_AEXP_NODES_USED_HORIZ_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_aexp_nodes_used_horiz_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x830L);
+	APICAL_WRITE_32(0x830L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_aexp_nodes_used_horiz_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x830L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AEXP Nodes Used Vert
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of active zones vertically for AE stats collection
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AEXP_NODES_USED_VERT_DEFAULT (15)
+#define APICAL_ISP_METERING_AEXP_NODES_USED_VERT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_aexp_nodes_used_vert_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x830L);
+	APICAL_WRITE_32(0x830L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_metering_aexp_nodes_used_vert_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x830L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB stats mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Statistics mode: 0 - legacy(G/R,B/R), 1 - current (R/G, B/G)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AWB_STATS_MODE_DEFAULT (0)
+#define APICAL_ISP_METERING_AWB_STATS_MODE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_metering_awb_stats_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x868L);
+	APICAL_WRITE_32(0x868L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_metering_awb_stats_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x868L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: White Level AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Upper limit of valid data for AWB
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_WHITE_LEVEL_AWB_DEFAULT (0x3FF)
+#define APICAL_ISP_METERING_WHITE_LEVEL_AWB_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_metering_white_level_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x840L);
+	APICAL_WRITE_32(0x840L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_metering_white_level_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x840L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Black Level AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Lower limit of valid data for AWB
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_BLACK_LEVEL_AWB_DEFAULT (0x000)
+#define APICAL_ISP_METERING_BLACK_LEVEL_AWB_DATASIZE (10)
+
+// args: data (10-bit)
+static __inline void apical_isp_metering_black_level_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x844L);
+	APICAL_WRITE_32(0x844L, (((uint32_t) (data & 0x3ff)) << 0) | (curr & 0xfffffc00));
+}
+static __inline uint16_t apical_isp_metering_black_level_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x844L) & 0x3ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cr Ref Max AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum value of R/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CR_REF_MAX_AWB_DEFAULT (0x1FF)
+#define APICAL_ISP_METERING_CR_REF_MAX_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cr_ref_max_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x848L);
+	APICAL_WRITE_32(0x848L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cr_ref_max_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x848L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cr Ref Min AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum value of R/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CR_REF_MIN_AWB_DEFAULT (0x040)
+#define APICAL_ISP_METERING_CR_REF_MIN_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cr_ref_min_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x84cL);
+	APICAL_WRITE_32(0x84cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cr_ref_min_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x84cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cb Ref Max AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum value of B/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CB_REF_MAX_AWB_DEFAULT (0x1FF)
+#define APICAL_ISP_METERING_CB_REF_MAX_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cb_ref_max_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x850L);
+	APICAL_WRITE_32(0x850L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cb_ref_max_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x850L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cb Ref Min AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum value of B/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CB_REF_MIN_AWB_DEFAULT (0x040)
+#define APICAL_ISP_METERING_CB_REF_MIN_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cb_ref_min_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x854L);
+	APICAL_WRITE_32(0x854L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cb_ref_min_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x854L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB RG
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AWB statistics R/G color ratio output
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AWB_RG_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AWB_RG_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline uint16_t apical_isp_metering_awb_rg_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x858L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB BG
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AWB statistics B/G color ratio output
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AWB_BG_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AWB_BG_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline uint16_t apical_isp_metering_awb_bg_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x85cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB SUM
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AWB output population.  Number of pixels used for AWB statistics
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AWB_SUM_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AWB_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_metering_awb_sum_read(void) {
+	return APICAL_READ_32(0x860L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB Nodes Used Horiz
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of active zones horizontally for AWB stats
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AWB_NODES_USED_HORIZ_DEFAULT (15)
+#define APICAL_ISP_METERING_AWB_NODES_USED_HORIZ_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_awb_nodes_used_horiz_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x870L);
+	APICAL_WRITE_32(0x870L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_awb_nodes_used_horiz_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x870L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB Nodes Used Vert
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of active zones vertically for AWB stats
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AWB_NODES_USED_VERT_DEFAULT (15)
+#define APICAL_ISP_METERING_AWB_NODES_USED_VERT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_awb_nodes_used_vert_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x870L);
+	APICAL_WRITE_32(0x870L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_metering_awb_nodes_used_vert_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x870L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cr Ref High AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum value of R/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CR_REF_HIGH_AWB_DEFAULT (0xFFF)
+#define APICAL_ISP_METERING_CR_REF_HIGH_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cr_ref_high_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x8d0L);
+	APICAL_WRITE_32(0x8d0L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cr_ref_high_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x8d0L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cr Ref Low AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum value of R/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CR_REF_LOW_AWB_DEFAULT (0x000)
+#define APICAL_ISP_METERING_CR_REF_LOW_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cr_ref_low_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x8d4L);
+	APICAL_WRITE_32(0x8d4L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cr_ref_low_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x8d4L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cb Ref High AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Maximum value of B/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CB_REF_HIGH_AWB_DEFAULT (0xFFF)
+#define APICAL_ISP_METERING_CB_REF_HIGH_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cb_ref_high_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x8d8L);
+	APICAL_WRITE_32(0x8d8L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cb_ref_high_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x8d8L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Cb Ref Low AWB
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Minimum value of B/G for white region
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_CB_REF_LOW_AWB_DEFAULT (0x000)
+#define APICAL_ISP_METERING_CB_REF_LOW_AWB_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_metering_cb_ref_low_awb_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x8dcL);
+	APICAL_WRITE_32(0x8dcL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_metering_cb_ref_low_awb_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x8dcL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF metrics shift
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Metrics scaling factor, 0x03 is default.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_METRICS_SHIFT_DEFAULT (0x3)
+#define APICAL_ISP_METERING_AF_METRICS_SHIFT_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_metering_af_metrics_shift_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x88cL);
+	APICAL_WRITE_32(0x88cL, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_metering_af_metrics_shift_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x88cL) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF metrics
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The integrated and normalized measure of contrast
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_METRICS_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_METRICS_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_af_metrics_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x880L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF metrics alt
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The integrated and normalized measure of contrast - with alternative threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_METRICS_ALT_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_METRICS_ALT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_af_metrics_alt_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x880L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF threshold write
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The suggested value of AF threshold (or 0 to use internallly calculated value)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_THRESHOLD_WRITE_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_THRESHOLD_WRITE_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_metering_af_threshold_write_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x884L);
+	APICAL_WRITE_32(0x884L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_metering_af_threshold_write_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x884L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF threshold alt write
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The suggested value of alternative AF threshold (or 0 to use threshold from previous frame)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_THRESHOLD_ALT_WRITE_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_THRESHOLD_ALT_WRITE_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_metering_af_threshold_alt_write_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x884L);
+	APICAL_WRITE_32(0x884L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_metering_af_threshold_alt_write_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x884L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF threshold read
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The calculated value of AF threshold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_THRESHOLD_READ_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_THRESHOLD_READ_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_af_threshold_read_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x888L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF intensity read
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The calculated value of AF intensity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_INTENSITY_READ_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_INTENSITY_READ_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_af_intensity_read_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x888L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF intensity zone read
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// The calculated value of AF intensity
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_INTENSITY_ZONE_READ_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_INTENSITY_ZONE_READ_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_metering_af_intensity_zone_read_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x89cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF Nodes Used Horiz
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of active zones horizontally for AF stats
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_NODES_USED_HORIZ_DEFAULT (15)
+#define APICAL_ISP_METERING_AF_NODES_USED_HORIZ_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_af_nodes_used_horiz_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x890L);
+	APICAL_WRITE_32(0x890L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_af_nodes_used_horiz_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x890L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF Nodes Used Vert
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of active zones vertically for AF stats
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_NODES_USED_VERT_DEFAULT (15)
+#define APICAL_ISP_METERING_AF_NODES_USED_VERT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_af_nodes_used_vert_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x890L);
+	APICAL_WRITE_32(0x890L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_metering_af_nodes_used_vert_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x890L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF NP offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AF noise profile offset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_NP_OFFSET_DEFAULT (0x9f)
+#define APICAL_ISP_METERING_AF_NP_OFFSET_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_metering_af_np_offset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x894L);
+	APICAL_WRITE_32(0x894L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_metering_af_np_offset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x894L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AF intensity norm mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// AF intensity normalization mode
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_AF_INTENSITY_NORM_MODE_DEFAULT (0x0)
+#define APICAL_ISP_METERING_AF_INTENSITY_NORM_MODE_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_metering_af_intensity_norm_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x898L);
+	APICAL_WRITE_32(0x898L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_metering_af_intensity_norm_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x898L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: skip x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Histogram decimation in horizontal direction: 0=every 2nd pixel; 1=every 3rd pixel; 2=every 4th pixel; 3=every 5th pixel; 4=every 8th pixel ; 5+=every 9th pixel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_SKIP_X_DEFAULT (0)
+#define APICAL_ISP_METERING_SKIP_X_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_metering_skip_x_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8c0L);
+	APICAL_WRITE_32(0x8c0L, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_metering_skip_x_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8c0L) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: skip y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Histogram decimation in vertical direction: 0=every pixel; 1=every 2nd pixel; 2=every 3rd pixel; 3=every 4th pixel; 4=every 5th pixel; 5=every 8th pixel ; 6+=every 9th pixel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_SKIP_Y_DEFAULT (0)
+#define APICAL_ISP_METERING_SKIP_Y_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_metering_skip_y_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8c0L);
+	APICAL_WRITE_32(0x8c0L, (((uint32_t) (data & 0x7)) << 4) | (curr & 0xffffff8f));
+}
+static __inline uint8_t apical_isp_metering_skip_y_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8c0L) & 0x70) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: offset x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= start from the first column;  1=start from second column
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_OFFSET_X_DEFAULT (0)
+#define APICAL_ISP_METERING_OFFSET_X_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_metering_offset_x_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8c0L);
+	APICAL_WRITE_32(0x8c0L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_metering_offset_x_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8c0L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: offset y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0= start from the first row; 1= start from second row
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_OFFSET_Y_DEFAULT (0)
+#define APICAL_ISP_METERING_OFFSET_Y_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_metering_offset_y_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8c0L);
+	APICAL_WRITE_32(0x8c0L, (((uint32_t) (data & 0x1)) << 7) | (curr & 0xffffff7f));
+}
+static __inline uint8_t apical_isp_metering_offset_y_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8c0L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: scale bottom
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// scale of bottom half of the range: 0=1x ,1=2x, 2=4x, 4=8x, 4=16x
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_SCALE_BOTTOM_DEFAULT (0)
+#define APICAL_ISP_METERING_SCALE_BOTTOM_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_metering_scale_bottom_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8c4L);
+	APICAL_WRITE_32(0x8c4L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_metering_scale_bottom_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8c4L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: scale top
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// scale of top half of the range: 0=1x ,1=2x, 2=4x, 4=8x, 4=16x
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_SCALE_TOP_DEFAULT (0)
+#define APICAL_ISP_METERING_SCALE_TOP_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_metering_scale_top_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x8c4L);
+	APICAL_WRITE_32(0x8c4L, (((uint32_t) (data & 0xf)) << 4) | (curr & 0xffffff0f));
+}
+static __inline uint8_t apical_isp_metering_scale_top_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x8c4L) & 0xf0) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Total Pixels
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Total number of pixels processed (skip x and skip y are taken into account)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_TOTAL_PIXELS_DEFAULT (0)
+#define APICAL_ISP_METERING_TOTAL_PIXELS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_metering_total_pixels_read(void) {
+	return APICAL_READ_32(0x8c8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Counted Pixels
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of pixels accumulated (with nonzero weight)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_METERING_COUNTED_PIXELS_DEFAULT (0)
+#define APICAL_ISP_METERING_COUNTED_PIXELS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_metering_counted_pixels_read(void) {
+	return APICAL_READ_32(0x8ccL);
+}
+// ------------------------------------------------------------------------------ //
+// Group: MVE
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frame Active width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_MVE_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_mve_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x900L);
+	APICAL_WRITE_32(0x900L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_mve_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x900L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Frame Active height
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_MVE_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_mve_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x904L);
+	APICAL_WRITE_32(0x904L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_mve_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x904L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Zone cols
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of zone clumns. Should be Zero
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_ZONE_COLS_DEFAULT (0x4)
+#define APICAL_ISP_MVE_ZONE_COLS_DATASIZE (5)
+
+// args: data (5-bit)
+static __inline void apical_isp_mve_zone_cols_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x908L);
+	APICAL_WRITE_32(0x908L, (((uint32_t) (data & 0x1f)) << 0) | (curr & 0xffffffe0));
+}
+static __inline uint8_t apical_isp_mve_zone_cols_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x908L) & 0x1f) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Zone rows
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of zone rows
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_ZONE_ROWS_DEFAULT (0x08)
+#define APICAL_ISP_MVE_ZONE_ROWS_DATASIZE (5)
+
+// args: data (5-bit)
+static __inline void apical_isp_mve_zone_rows_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x908L);
+	APICAL_WRITE_32(0x908L, (((uint32_t) (data & 0x1f)) << 8) | (curr & 0xffffe0ff));
+}
+static __inline uint8_t apical_isp_mve_zone_rows_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x908L) & 0x1f00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Border x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of pixels for left border
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_BORDER_X_DEFAULT (0x010)
+#define APICAL_ISP_MVE_BORDER_X_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_mve_border_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x90cL);
+	APICAL_WRITE_32(0x90cL, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_mve_border_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x90cL) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Border y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of pixels for top border
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_BORDER_Y_DEFAULT (0x010)
+#define APICAL_ISP_MVE_BORDER_Y_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_mve_border_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x910L);
+	APICAL_WRITE_32(0x910L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_mve_border_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x910L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Zone size x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of pixels for zone width
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_ZONE_SIZE_X_DEFAULT (0x020)
+#define APICAL_ISP_MVE_ZONE_SIZE_X_DATASIZE (9)
+
+// args: data (9-bit)
+static __inline void apical_isp_mve_zone_size_x_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x914L);
+	APICAL_WRITE_32(0x914L, (((uint32_t) (data & 0x1ff)) << 0) | (curr & 0xfffffe00));
+}
+static __inline uint16_t apical_isp_mve_zone_size_x_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x914L) & 0x1ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Zone size y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Number of pixels for zone height
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_ZONE_SIZE_Y_DEFAULT (0x020)
+#define APICAL_ISP_MVE_ZONE_SIZE_Y_DATASIZE (9)
+
+// args: data (9-bit)
+static __inline void apical_isp_mve_zone_size_y_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x918L);
+	APICAL_WRITE_32(0x918L, (((uint32_t) (data & 0x1ff)) << 0) | (curr & 0xfffffe00));
+}
+static __inline uint16_t apical_isp_mve_zone_size_y_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x918L) & 0x1ff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Range x
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Search range for offset_x
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_RANGE_X_DEFAULT (0x10)
+#define APICAL_ISP_MVE_RANGE_X_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mve_range_x_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x91cL);
+	APICAL_WRITE_32(0x91cL, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_mve_range_x_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x91cL) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Range y
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Search range for offset_y
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_RANGE_Y_DEFAULT (0x10)
+#define APICAL_ISP_MVE_RANGE_Y_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mve_range_y_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x920L);
+	APICAL_WRITE_32(0x920L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_mve_range_y_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x920L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F1 length
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F1 filter length for high freq
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F1_LENGTH_DEFAULT (0x08)
+#define APICAL_ISP_MVE_F1_LENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mve_f1_length_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x924L);
+	APICAL_WRITE_32(0x924L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_mve_f1_length_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x924L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F2 length
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F2 filter length for high freq
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F2_LENGTH_DEFAULT (0x10)
+#define APICAL_ISP_MVE_F2_LENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mve_f2_length_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x924L);
+	APICAL_WRITE_32(0x924L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_mve_f2_length_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x924L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F3 length
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F3 filter length for high freq
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F3_LENGTH_DEFAULT (0x20)
+#define APICAL_ISP_MVE_F3_LENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mve_f3_length_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x928L);
+	APICAL_WRITE_32(0x928L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_mve_f3_length_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x928L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F4 length
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F4 filter length for high freq
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F4_LENGTH_DEFAULT (0x40)
+#define APICAL_ISP_MVE_F4_LENGTH_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_mve_f4_length_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x928L);
+	APICAL_WRITE_32(0x928L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_mve_f4_length_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x928L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F0blk scale
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F0 block mixer scale factor
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F0BLK_SCALE_DEFAULT (0x1)
+#define APICAL_ISP_MVE_F0BLK_SCALE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_mve_f0blk_scale_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x930L);
+	APICAL_WRITE_32(0x930L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_mve_f0blk_scale_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x930L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F1 scale
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F1 filter mixer scale factor
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F1_SCALE_DEFAULT (0x1)
+#define APICAL_ISP_MVE_F1_SCALE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_mve_f1_scale_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x930L);
+	APICAL_WRITE_32(0x930L, (((uint32_t) (data & 0xf)) << 8) | (curr & 0xfffff0ff));
+}
+static __inline uint8_t apical_isp_mve_f1_scale_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x930L) & 0xf00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F2 scale
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F2 filter mixer scale factor
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F2_SCALE_DEFAULT (0x2)
+#define APICAL_ISP_MVE_F2_SCALE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_mve_f2_scale_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x930L);
+	APICAL_WRITE_32(0x930L, (((uint32_t) (data & 0xf)) << 16) | (curr & 0xfff0ffff));
+}
+static __inline uint8_t apical_isp_mve_f2_scale_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x930L) & 0xf0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F3 scale
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F3 filter mixer scale factor
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F3_SCALE_DEFAULT (0x3)
+#define APICAL_ISP_MVE_F3_SCALE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_mve_f3_scale_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x930L);
+	APICAL_WRITE_32(0x930L, (((uint32_t) (data & 0xf)) << 24) | (curr & 0xf0ffffff));
+}
+static __inline uint8_t apical_isp_mve_f3_scale_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x930L) & 0xf000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F4 scale
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F3 filter mixer scale factor
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F4_SCALE_DEFAULT (0x4)
+#define APICAL_ISP_MVE_F4_SCALE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_mve_f4_scale_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x934L);
+	APICAL_WRITE_32(0x934L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_mve_f4_scale_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x934L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F0blk clip
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F0 filter mixer clip value
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F0BLK_CLIP_DEFAULT (0x3FF)
+#define APICAL_ISP_MVE_F0BLK_CLIP_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_mve_f0blk_clip_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x938L);
+	APICAL_WRITE_32(0x938L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_mve_f0blk_clip_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x938L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F1 clip
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F1 filter mixer clip value
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F1_CLIP_DEFAULT (0x3FF)
+#define APICAL_ISP_MVE_F1_CLIP_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_mve_f1_clip_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x93cL);
+	APICAL_WRITE_32(0x93cL, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_mve_f1_clip_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x93cL) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F2 clip
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F1 filter mixer clip value
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F2_CLIP_DEFAULT (0x7FF)
+#define APICAL_ISP_MVE_F2_CLIP_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_mve_f2_clip_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x940L);
+	APICAL_WRITE_32(0x940L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_mve_f2_clip_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x940L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F3 clip
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F3 filter mixer clip value
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F3_CLIP_DEFAULT (0xBFF)
+#define APICAL_ISP_MVE_F3_CLIP_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_mve_f3_clip_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x944L);
+	APICAL_WRITE_32(0x944L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_mve_f3_clip_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x944L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: F4 clip
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// F4 filter mixer clip value
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_F4_CLIP_DEFAULT (0xFFF)
+#define APICAL_ISP_MVE_F4_CLIP_DATASIZE (12)
+
+// args: data (12-bit)
+static __inline void apical_isp_mve_f4_clip_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0x948L);
+	APICAL_WRITE_32(0x948L, (((uint32_t) (data & 0xfff)) << 0) | (curr & 0xfffff000));
+}
+static __inline uint16_t apical_isp_mve_f4_clip_read(void) {
+	return (uint16_t)((APICAL_READ_32(0x948L) & 0xfff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Video out select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Video out select
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_VIDEO_OUT_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_MVE_VIDEO_OUT_SELECT_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_mve_video_out_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x94cL);
+	APICAL_WRITE_32(0x94cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_mve_video_out_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x94cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Clear of internal alarms
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_CLEAR_ALARMS_DEFAULT (0x0)
+#define APICAL_ISP_MVE_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_mve_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x950L);
+	APICAL_WRITE_32(0x950L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_mve_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x950L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dump restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Restart request for first frame of a sequence
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_DUMP_RESTART_DEFAULT (0x0)
+#define APICAL_ISP_MVE_DUMP_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_mve_dump_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x950L);
+	APICAL_WRITE_32(0x950L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_mve_dump_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x950L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dump on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Enabling dumping of stats
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_DUMP_ON_DEFAULT (0x0)
+#define APICAL_ISP_MVE_DUMP_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_mve_dump_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x950L);
+	APICAL_WRITE_32(0x950L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_mve_dump_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x950L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Dump overflow fail
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_MVE_DUMP_OVERFLOW_FAIL_DEFAULT (0x0)
+#define APICAL_ISP_MVE_DUMP_OVERFLOW_FAIL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_mve_dump_overflow_fail_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x950L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Frame Stats
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: stats reset
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_STATS_RESET_DEFAULT (0)
+#define APICAL_ISP_FRAME_STATS_STATS_RESET_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stats_stats_reset_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x970L);
+	APICAL_WRITE_32(0x970L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_frame_stats_stats_reset_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x970L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: stats hold
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_STATS_HOLD_DEFAULT (0)
+#define APICAL_ISP_FRAME_STATS_STATS_HOLD_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stats_stats_hold_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0x974L);
+	APICAL_WRITE_32(0x974L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_frame_stats_stats_hold_read(void) {
+	return (uint8_t)((APICAL_READ_32(0x974L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_MIN_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_width_min_read(void) {
+	return APICAL_READ_32(0x980L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_MAX_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_width_max_read(void) {
+	return APICAL_READ_32(0x984L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_SUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_width_sum_read(void) {
+	return APICAL_READ_32(0x988L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_NUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_WIDTH_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_width_num_read(void) {
+	return APICAL_READ_32(0x98cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_MIN_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_height_min_read(void) {
+	return APICAL_READ_32(0x990L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_MAX_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_height_max_read(void) {
+	return APICAL_READ_32(0x994L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_SUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_height_sum_read(void) {
+	return APICAL_READ_32(0x998L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_NUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_ACTIVE_HEIGHT_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_active_height_num_read(void) {
+	return APICAL_READ_32(0x99cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_HBLANK_MIN_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_HBLANK_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_hblank_min_read(void) {
+	return APICAL_READ_32(0x9a0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_HBLANK_MAX_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_HBLANK_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_hblank_max_read(void) {
+	return APICAL_READ_32(0x9a4L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_HBLANK_SUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_HBLANK_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_hblank_sum_read(void) {
+	return APICAL_READ_32(0x9a8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: hblank num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_HBLANK_NUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_HBLANK_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_hblank_num_read(void) {
+	return APICAL_READ_32(0x9acL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_VBLANK_MIN_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_VBLANK_MIN_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_vblank_min_read(void) {
+	return APICAL_READ_32(0x9b0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank max
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_VBLANK_MAX_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_VBLANK_MAX_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_vblank_max_read(void) {
+	return APICAL_READ_32(0x9b4L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank sum
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_VBLANK_SUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_VBLANK_SUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_vblank_sum_read(void) {
+	return APICAL_READ_32(0x9b8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vblank num
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STATS_VBLANK_NUM_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STATS_VBLANK_NUM_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stats_vblank_num_read(void) {
+	return APICAL_READ_32(0x9bcL);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Temper Frame Buffer
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_temper_frame_buffer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_temper_frame_buffer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_temper_frame_buffer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame write on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_WRITE_ON_DEFAULT (1)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_frame_buffer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame read on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_READ_ON_DEFAULT (1)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_READ_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_frame_buffer_frame_read_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_frame_read_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame write cancel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_frame_buffer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0x1)) << 24) | (curr & 0xfeffffff));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0x1000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame read cancel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_READ_CANCEL_DEFAULT (0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_FRAME_READ_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_frame_buffer_frame_read_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa00L);
+	APICAL_WRITE_32(0xa00L, (((uint32_t) (data & 0x1)) << 25) | (curr & 0xfdffffff));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_frame_read_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa00L) & 0x2000000) >> 25);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_temper_frame_buffer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xa08L, data);
+}
+static __inline uint32_t apical_isp_temper_frame_buffer_blk_config_read(void) {
+	return APICAL_READ_32(0xa08L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BLK_STATUS_DEFAULT (0x0000)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_temper_frame_buffer_blk_status_read(void) {
+	return APICAL_READ_32(0xa0cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_temper_frame_buffer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xa10L);
+	APICAL_WRITE_32(0xa10L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_temper_frame_buffer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xa10L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_temper_frame_buffer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xa14L);
+	APICAL_WRITE_32(0xa14L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_temper_frame_buffer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xa14L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_temper_frame_buffer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xa18L, data);
+}
+static __inline uint32_t apical_isp_temper_frame_buffer_bank0_base_read(void) {
+	return APICAL_READ_32(0xa18L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_temper_frame_buffer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xa1cL, data);
+}
+static __inline uint32_t apical_isp_temper_frame_buffer_bank1_base_read(void) {
+	return APICAL_READ_32(0xa1cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_temper_frame_buffer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xa24L, data);
+}
+static __inline uint32_t apical_isp_temper_frame_buffer_line_offset_read(void) {
+	return APICAL_READ_32(0xa24L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_AXI_PORT_ENABLE_DEFAULT (0x0)
+#define APICAL_ISP_TEMPER_FRAME_BUFFER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_temper_frame_buffer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa28L);
+	APICAL_WRITE_32(0xa28L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_temper_frame_buffer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa28L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Frame stitch Frame Buffer
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame write on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_WRITE_ON_DEFAULT (1)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0x1)) << 16) | (curr & 0xfffeffff));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame read on
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_READ_ON_DEFAULT (1)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_READ_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_frame_read_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0x1)) << 17) | (curr & 0xfffdffff));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_frame_read_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame write cancel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0x1)) << 24) | (curr & 0xfeffffff));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0x1000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Frame read cancel
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_READ_CANCEL_DEFAULT (0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_FRAME_READ_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_frame_read_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa40L);
+	APICAL_WRITE_32(0xa40L, (((uint32_t) (data & 0x1)) << 25) | (curr & 0xfdffffff));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_frame_read_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa40L) & 0x2000000) >> 25);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xa48L, data);
+}
+static __inline uint32_t apical_isp_frame_stitch_frame_buffer_blk_config_read(void) {
+	return APICAL_READ_32(0xa48L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BLK_STATUS_DEFAULT (0x0000)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_frame_stitch_frame_buffer_blk_status_read(void) {
+	return APICAL_READ_32(0xa4cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xa50L);
+	APICAL_WRITE_32(0xa50L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_frame_stitch_frame_buffer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xa50L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xa54L);
+	APICAL_WRITE_32(0xa54L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_frame_stitch_frame_buffer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xa54L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xa58L, data);
+}
+static __inline uint32_t apical_isp_frame_stitch_frame_buffer_bank0_base_read(void) {
+	return APICAL_READ_32(0xa58L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xa5cL, data);
+}
+static __inline uint32_t apical_isp_frame_stitch_frame_buffer_bank1_base_read(void) {
+	return APICAL_READ_32(0xa5cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xa64L, data);
+}
+static __inline uint32_t apical_isp_frame_stitch_frame_buffer_line_offset_read(void) {
+	return APICAL_READ_32(0xa64L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_AXI_PORT_ENABLE_DEFAULT (0x0)
+#define APICAL_ISP_FRAME_STITCH_FRAME_BUFFER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_frame_stitch_frame_buffer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xa68L);
+	APICAL_WRITE_32(0xa68L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_frame_stitch_frame_buffer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xa68L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Video DMA Writer FR
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Full resolution video DMA writer controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_dma_writer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_fr_dma_writer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_fr_dma_writer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: single frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_single_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_single_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		0 = no frames written(when switched from 1, current frame completes writing before stopping),
+//		1= write frame(s) (write single or continous frame(s) )
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: half irate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation , 1= write half(alternate) of input frames( only valid for continuous mode)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_HALF_IRATE_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_HALF_IRATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_half_irate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_half_irate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi xact comp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_axi_xact_comp_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb00L);
+	APICAL_WRITE_32(0xb00L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_axi_xact_comp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb00L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_FR_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_dma_writer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xb04L);
+	APICAL_WRITE_32(0xb04L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fr_dma_writer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xb04L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_FR_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fr_dma_writer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xb04L);
+	APICAL_WRITE_32(0xb04L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_fr_dma_writer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xb04L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb08L, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_bank0_base_read(void) {
+	return APICAL_READ_32(0xb08L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb0cL, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_bank1_base_read(void) {
+	return APICAL_READ_32(0xb0cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank2_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 2 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BANK2_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_bank2_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb10L, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_bank2_base_read(void) {
+	return APICAL_READ_32(0xb10L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank3_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 3 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BANK3_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_bank3_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb14L, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_bank3_base_read(void) {
+	return APICAL_READ_32(0xb14L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank4_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 4 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BANK4_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_bank4_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb18L, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_bank4_base_read(void) {
+	return APICAL_READ_32(0xb18L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max bank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_MAX_BANK_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_fr_dma_writer_max_bank_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb1cL);
+	APICAL_WRITE_32(0xb1cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_max_bank_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb1cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0 restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_bank0_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb1cL);
+	APICAL_WRITE_32(0xb1cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_bank0_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb1cL) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_FR_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xb20L, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_line_offset_read(void) {
+	return APICAL_READ_32(0xb20L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write cancel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= cancel current/future frame write(s), any unstarted AXI bursts cancelled and fifo flushed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb24L);
+	APICAL_WRITE_32(0xb24L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// enables axi, active high, 1=enables axi write transfers, 0= reset axi domain( via reset synchroniser)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_PORT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb24L);
+	APICAL_WRITE_32(0xb24L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank currently active. valid values =0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_CURR_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_wbank_curr_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank last active. valid values = 0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_LAST_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_LAST_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_wbank_last_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x3800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank active
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_wbank_active_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at start of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_START_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_START_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_wbank_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank stop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at end of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_STOP_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBANK_STOP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_wbank_stop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb24L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// currently active bank base addr - in bytes. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBASE_CURR_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBASE_CURR_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_fr_dma_writer_wbase_curr_read(void) {
+	return APICAL_READ_32(0xb28L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// last active bank base addr - in bytes. Updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WBASE_LAST_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_WBASE_LAST_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_fr_dma_writer_wbase_last_read(void) {
+	return APICAL_READ_32(0xb2cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame icount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_fr_dma_writer_frame_icount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xb30L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame wcount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_fr_dma_writer_frame_wcount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xb30L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0>1 transition(synchronous detection) causes local axi/video alarm clear
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_8
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 8, 0= Dont reduce
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_max_burst_length_is_8_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_max_burst_length_is_8_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 4, 0= Dont reduce( has priority overmax_burst_length_is_8!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_max_burst_length_is_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_max_burst_length_is_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: write timeout disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		At end of frame an optional timeout is applied to wait for AXI writes to completed/accepted befotre caneclling and flushing.
+//		0= Timeout Enabled, timeout count can decrement.
+//		1 = Disable timeout, timeout count can't decrement.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_FR_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fr_dma_writer_write_timeout_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_write_timeout_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: awmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// awvalid maxwait limit(cycles) to raise axi_fail_awmaxwait alarm . zero disables alarm raise.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AWMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_FR_DMA_WRITER_AWMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_dma_writer_awmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_awmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// wvalid maxwait limit(cycles) to raise axi_fail_wmaxwait alarm . zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_FR_DMA_WRITER_WMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_dma_writer_wmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_wmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wxact_ostand_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// number oustsanding write transactions(bursts)(responses..1 per burst) limit to raise axi_fail_wxact_ostand. zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_WXACT_OSTAND_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_FR_DMA_WRITER_WXACT_OSTAND_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fr_dma_writer_wxact_ostand_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb34L);
+	APICAL_WRITE_32(0xb34L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_isp_fr_dma_writer_wxact_ostand_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb34L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_bresp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate bad  bresp captured
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_axi_fail_bresp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_awmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when awmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_axi_fail_awmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_axi_fail_wmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wxact_ostand
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wxact_ostand_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_axi_fail_wxact_ostand_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_width detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_vi_fail_active_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_vi_fail_active_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interline_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interline blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_vi_fail_interline_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interframe_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interframe blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_vi_fail_interframe_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: video_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_video_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on axi port(s)( bresp or awmaxwait or wmaxwait or wxact_ostand failure )
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_AXI_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_AXI_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fr_dma_writer_axi_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb38L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block configuration (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_FR_DMA_WRITER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fr_dma_writer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xb3cL, data);
+}
+static __inline uint32_t apical_isp_fr_dma_writer_blk_config_read(void) {
+	return APICAL_READ_32(0xb3cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block status output (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FR_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_FR_DMA_WRITER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_fr_dma_writer_blk_status_read(void) {
+	return APICAL_READ_32(0xb40L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Video DMA Writer FR UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Full resolution video DMA writer controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fruv_dma_writer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_fruv_dma_writer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_fruv_dma_writer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: single frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_single_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_single_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		0 = no frames written(when switched from 1, current frame completes writing before stopping),
+//		1= write frame(s) (write single or continous frame(s) )
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: half irate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation , 1= write half(alternate) of input frames( only valid for continuous mode)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_HALF_IRATE_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_HALF_IRATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_half_irate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_half_irate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi xact comp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_axi_xact_comp_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb80L);
+	APICAL_WRITE_32(0xb80L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_xact_comp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb80L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_FRUV_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fruv_dma_writer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xb84L);
+	APICAL_WRITE_32(0xb84L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_fruv_dma_writer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xb84L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_FRUV_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_fruv_dma_writer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xb84L);
+	APICAL_WRITE_32(0xb84L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_fruv_dma_writer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xb84L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb88L, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_bank0_base_read(void) {
+	return APICAL_READ_32(0xb88L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb8cL, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_bank1_base_read(void) {
+	return APICAL_READ_32(0xb8cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank2_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 2 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK2_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_bank2_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb90L, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_bank2_base_read(void) {
+	return APICAL_READ_32(0xb90L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank3_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 3 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK3_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_bank3_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb94L, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_bank3_base_read(void) {
+	return APICAL_READ_32(0xb94L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank4_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 4 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK4_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_bank4_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xb98L, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_bank4_base_read(void) {
+	return APICAL_READ_32(0xb98L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max bank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_MAX_BANK_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_fruv_dma_writer_max_bank_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb9cL);
+	APICAL_WRITE_32(0xb9cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_max_bank_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb9cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0 restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_bank0_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xb9cL);
+	APICAL_WRITE_32(0xb9cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_bank0_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xb9cL) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_FRUV_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xba0L, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_line_offset_read(void) {
+	return APICAL_READ_32(0xba0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write cancel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= cancel current/future frame write(s), any unstarted AXI bursts cancelled and fifo flushed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xba4L);
+	APICAL_WRITE_32(0xba4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// enables axi, active high, 1=enables axi write transfers, 0= reset axi domain( via reset synchroniser)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_PORT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xba4L);
+	APICAL_WRITE_32(0xba4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank currently active. valid values =0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_CURR_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_wbank_curr_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank last active. valid values = 0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_LAST_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_LAST_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_wbank_last_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x3800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank active
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_wbank_active_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at start of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_START_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_START_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_wbank_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank stop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at end of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_STOP_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBANK_STOP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_wbank_stop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xba4L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// currently active bank base addr - in bytes. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBASE_CURR_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBASE_CURR_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_fruv_dma_writer_wbase_curr_read(void) {
+	return APICAL_READ_32(0xba8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// last active bank base addr - in bytes. Updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WBASE_LAST_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WBASE_LAST_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_fruv_dma_writer_wbase_last_read(void) {
+	return APICAL_READ_32(0xbacL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame icount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_fruv_dma_writer_frame_icount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xbb0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame wcount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_fruv_dma_writer_frame_wcount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xbb0L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0>1 transition(synchronous detection) causes local axi/video alarm clear
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_8
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 8, 0= Dont reduce
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_max_burst_length_is_8_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_max_burst_length_is_8_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 4, 0= Dont reduce( has priority overmax_burst_length_is_8!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_max_burst_length_is_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_max_burst_length_is_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: write timeout disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		At end of frame an optional timeout is applied to wait for AXI writes to completed/accepted befotre caneclling and flushing.
+//		0= Timeout Enabled, timeout count can decrement.
+//		1 = Disable timeout, timeout count can't decrement.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_FRUV_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_fruv_dma_writer_write_timeout_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_write_timeout_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: awmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// awvalid maxwait limit(cycles) to raise axi_fail_awmaxwait alarm . zero disables alarm raise.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AWMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_FRUV_DMA_WRITER_AWMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fruv_dma_writer_awmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_awmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// wvalid maxwait limit(cycles) to raise axi_fail_wmaxwait alarm . zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_FRUV_DMA_WRITER_WMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fruv_dma_writer_wmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_wmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wxact_ostand_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// number oustsanding write transactions(bursts)(responses..1 per burst) limit to raise axi_fail_wxact_ostand. zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_WXACT_OSTAND_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_FRUV_DMA_WRITER_WXACT_OSTAND_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_fruv_dma_writer_wxact_ostand_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xbb4L);
+	APICAL_WRITE_32(0xbb4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_isp_fruv_dma_writer_wxact_ostand_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_bresp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate bad  bresp captured
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_fail_bresp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_awmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when awmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_fail_awmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_fail_wmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wxact_ostand
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wxact_ostand_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_fail_wxact_ostand_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_width detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_vi_fail_active_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_vi_fail_active_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interline_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interline blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_vi_fail_interline_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interframe_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interframe blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_vi_fail_interframe_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: video_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_video_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on axi port(s)( bresp or awmaxwait or wmaxwait or wxact_ostand failure )
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_AXI_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_fruv_dma_writer_axi_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xbb8L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block configuration (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_FRUV_DMA_WRITER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_fruv_dma_writer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xbbcL, data);
+}
+static __inline uint32_t apical_isp_fruv_dma_writer_blk_config_read(void) {
+	return APICAL_READ_32(0xbbcL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block status output (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_FRUV_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_FRUV_DMA_WRITER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_fruv_dma_writer_blk_status_read(void) {
+	return APICAL_READ_32(0xbc0L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Video DMA Writer DS1
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Down scaled video DMA writer 1 controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_dma_writer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds1_dma_writer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds1_dma_writer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: single frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_single_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_single_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		0 = no frames written(when switched from 1, current frame completes writing before stopping),
+//		1= write frame(s) (write single or continous frame(s) )
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: half irate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation , 1= write half(alternate) of input frames( only valid for continuous mode)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_HALF_IRATE_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_HALF_IRATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_half_irate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_half_irate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi xact comp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_axi_xact_comp_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc00L);
+	APICAL_WRITE_32(0xc00L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_xact_comp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc00L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_DS1_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_dma_writer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xc04L);
+	APICAL_WRITE_32(0xc04L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1_dma_writer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xc04L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_DS1_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1_dma_writer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xc04L);
+	APICAL_WRITE_32(0xc04L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_ds1_dma_writer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xc04L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc08L, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_bank0_base_read(void) {
+	return APICAL_READ_32(0xc08L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc0cL, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_bank1_base_read(void) {
+	return APICAL_READ_32(0xc0cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank2_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 2 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BANK2_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_bank2_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc10L, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_bank2_base_read(void) {
+	return APICAL_READ_32(0xc10L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank3_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 3 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BANK3_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_bank3_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc14L, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_bank3_base_read(void) {
+	return APICAL_READ_32(0xc14L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank4_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 4 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BANK4_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_bank4_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc18L, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_bank4_base_read(void) {
+	return APICAL_READ_32(0xc18L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max bank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_MAX_BANK_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_ds1_dma_writer_max_bank_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc1cL);
+	APICAL_WRITE_32(0xc1cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_max_bank_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc1cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0 restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_bank0_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc1cL);
+	APICAL_WRITE_32(0xc1cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_bank0_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc1cL) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_DS1_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xc20L, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_line_offset_read(void) {
+	return APICAL_READ_32(0xc20L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write cancel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= cancel current/future frame write(s), any unstarted AXI bursts cancelled and fifo flushed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc24L);
+	APICAL_WRITE_32(0xc24L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// enables axi, active high, 1=enables axi write transfers, 0= reset axi domain( via reset synchroniser)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_PORT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc24L);
+	APICAL_WRITE_32(0xc24L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank currently active. valid values =0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_CURR_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_wbank_curr_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank last active. valid values = 0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_LAST_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_wbank_last_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x3800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank active
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_wbank_active_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at start of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_START_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_START_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_wbank_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank stop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at end of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_STOP_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBANK_STOP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_wbank_stop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc24L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// currently active bank base addr - in bytes. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBASE_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBASE_CURR_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds1_dma_writer_wbase_curr_read(void) {
+	return APICAL_READ_32(0xc28L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// last active bank base addr - in bytes. Updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WBASE_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_WBASE_LAST_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds1_dma_writer_wbase_last_read(void) {
+	return APICAL_READ_32(0xc2cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame icount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds1_dma_writer_frame_icount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xc30L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame wcount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds1_dma_writer_frame_wcount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xc30L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0>1 transition(synchronous detection) causes local axi/video alarm clear
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_8
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 8, 0= Dont reduce
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_max_burst_length_is_8_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_max_burst_length_is_8_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 4, 0= Dont reduce( has priority overmax_burst_length_is_8!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_max_burst_length_is_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_max_burst_length_is_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: write timeout disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		At end of frame an optional timeout is applied to wait for AXI writes to completed/accepted befotre caneclling and flushing.
+//		0= Timeout Enabled, timeout count can decrement.
+//		1 = Disable timeout, timeout count can't decrement.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_DS1_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1_dma_writer_write_timeout_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_write_timeout_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: awmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// awvalid maxwait limit(cycles) to raise axi_fail_awmaxwait alarm . zero disables alarm raise.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AWMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS1_DMA_WRITER_AWMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_dma_writer_awmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_awmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// wvalid maxwait limit(cycles) to raise axi_fail_wmaxwait alarm . zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS1_DMA_WRITER_WMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_dma_writer_wmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_wmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wxact_ostand_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// number oustsanding write transactions(bursts)(responses..1 per burst) limit to raise axi_fail_wxact_ostand. zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_WXACT_OSTAND_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS1_DMA_WRITER_WXACT_OSTAND_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1_dma_writer_wxact_ostand_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc34L);
+	APICAL_WRITE_32(0xc34L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_isp_ds1_dma_writer_wxact_ostand_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc34L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_bresp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate bad  bresp captured
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_fail_bresp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_awmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when awmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_fail_awmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_fail_wmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wxact_ostand
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wxact_ostand_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_fail_wxact_ostand_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_width detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_vi_fail_active_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_vi_fail_active_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interline_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interline blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_vi_fail_interline_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interframe_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interframe blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_vi_fail_interframe_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: video_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_video_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on axi port(s)( bresp or awmaxwait or wmaxwait or wxact_ostand failure )
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_AXI_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1_dma_writer_axi_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc38L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block configuration (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_DS1_DMA_WRITER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1_dma_writer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xc3cL, data);
+}
+static __inline uint32_t apical_isp_ds1_dma_writer_blk_config_read(void) {
+	return APICAL_READ_32(0xc3cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block status output (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_DS1_DMA_WRITER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds1_dma_writer_blk_status_read(void) {
+	return APICAL_READ_32(0xc40L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Video DMA Writer DS1 UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Down scaled video DMA writer 1 controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1uv_dma_writer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds1uv_dma_writer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds1uv_dma_writer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: single frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_single_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_single_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		0 = no frames written(when switched from 1, current frame completes writing before stopping),
+//		1= write frame(s) (write single or continous frame(s) )
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: half irate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation , 1= write half(alternate) of input frames( only valid for continuous mode)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_HALF_IRATE_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_HALF_IRATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_half_irate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_half_irate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi xact comp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_axi_xact_comp_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc80L);
+	APICAL_WRITE_32(0xc80L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_xact_comp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc80L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_DS1UV_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1uv_dma_writer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xc84L);
+	APICAL_WRITE_32(0xc84L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds1uv_dma_writer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xc84L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_DS1UV_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds1uv_dma_writer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xc84L);
+	APICAL_WRITE_32(0xc84L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_ds1uv_dma_writer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xc84L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc88L, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_bank0_base_read(void) {
+	return APICAL_READ_32(0xc88L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc8cL, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_bank1_base_read(void) {
+	return APICAL_READ_32(0xc8cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank2_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 2 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK2_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_bank2_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc90L, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_bank2_base_read(void) {
+	return APICAL_READ_32(0xc90L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank3_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 3 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK3_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_bank3_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc94L, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_bank3_base_read(void) {
+	return APICAL_READ_32(0xc94L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank4_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 4 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK4_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_bank4_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xc98L, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_bank4_base_read(void) {
+	return APICAL_READ_32(0xc98L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max bank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_MAX_BANK_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_ds1uv_dma_writer_max_bank_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc9cL);
+	APICAL_WRITE_32(0xc9cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_max_bank_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc9cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0 restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_bank0_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xc9cL);
+	APICAL_WRITE_32(0xc9cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_bank0_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xc9cL) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_DS1UV_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xca0L, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_line_offset_read(void) {
+	return APICAL_READ_32(0xca0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write cancel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= cancel current/future frame write(s), any unstarted AXI bursts cancelled and fifo flushed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xca4L);
+	APICAL_WRITE_32(0xca4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// enables axi, active high, 1=enables axi write transfers, 0= reset axi domain( via reset synchroniser)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_PORT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xca4L);
+	APICAL_WRITE_32(0xca4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank currently active. valid values =0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_CURR_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wbank_curr_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank last active. valid values = 0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_LAST_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wbank_last_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x3800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank active
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wbank_active_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at start of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_START_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_START_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wbank_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank stop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at end of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_STOP_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBANK_STOP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wbank_stop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xca4L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// currently active bank base addr - in bytes. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBASE_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBASE_CURR_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds1uv_dma_writer_wbase_curr_read(void) {
+	return APICAL_READ_32(0xca8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// last active bank base addr - in bytes. Updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBASE_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WBASE_LAST_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds1uv_dma_writer_wbase_last_read(void) {
+	return APICAL_READ_32(0xcacL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame icount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds1uv_dma_writer_frame_icount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xcb0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame wcount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds1uv_dma_writer_frame_wcount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xcb0L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0>1 transition(synchronous detection) causes local axi/video alarm clear
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_8
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 8, 0= Dont reduce
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_max_burst_length_is_8_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_max_burst_length_is_8_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 4, 0= Dont reduce( has priority overmax_burst_length_is_8!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_max_burst_length_is_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_max_burst_length_is_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: write timeout disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		At end of frame an optional timeout is applied to wait for AXI writes to completed/accepted befotre caneclling and flushing.
+//		0= Timeout Enabled, timeout count can decrement.
+//		1 = Disable timeout, timeout count can't decrement.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds1uv_dma_writer_write_timeout_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_write_timeout_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: awmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// awvalid maxwait limit(cycles) to raise axi_fail_awmaxwait alarm . zero disables alarm raise.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AWMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AWMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1uv_dma_writer_awmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_awmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// wvalid maxwait limit(cycles) to raise axi_fail_wmaxwait alarm . zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1uv_dma_writer_wmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wxact_ostand_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// number oustsanding write transactions(bursts)(responses..1 per burst) limit to raise axi_fail_wxact_ostand. zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_WXACT_OSTAND_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS1UV_DMA_WRITER_WXACT_OSTAND_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds1uv_dma_writer_wxact_ostand_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xcb4L);
+	APICAL_WRITE_32(0xcb4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_isp_ds1uv_dma_writer_wxact_ostand_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_bresp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate bad  bresp captured
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_fail_bresp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_awmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when awmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_fail_awmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_fail_wmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wxact_ostand
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wxact_ostand_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_fail_wxact_ostand_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_width detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_vi_fail_active_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_vi_fail_active_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interline_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interline blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_vi_fail_interline_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interframe_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interframe blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_vi_fail_interframe_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: video_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_video_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on axi port(s)( bresp or awmaxwait or wmaxwait or wxact_ostand failure )
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_AXI_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds1uv_dma_writer_axi_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xcb8L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block configuration (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds1uv_dma_writer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xcbcL, data);
+}
+static __inline uint32_t apical_isp_ds1uv_dma_writer_blk_config_read(void) {
+	return APICAL_READ_32(0xcbcL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block status output (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS1UV_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_DS1UV_DMA_WRITER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds1uv_dma_writer_blk_status_read(void) {
+	return APICAL_READ_32(0xcc0L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Video DMA Writer DS2
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Down scaled video DMA writer 2 controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_dma_writer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds2_dma_writer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds2_dma_writer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: single frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_single_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_single_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		0 = no frames written(when switched from 1, current frame completes writing before stopping),
+//		1= write frame(s) (write single or continous frame(s) )
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: half irate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation , 1= write half(alternate) of input frames( only valid for continuous mode)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_HALF_IRATE_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_HALF_IRATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_half_irate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_half_irate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi xact comp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_axi_xact_comp_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd00L);
+	APICAL_WRITE_32(0xd00L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_xact_comp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd00L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_DS2_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_dma_writer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xd04L);
+	APICAL_WRITE_32(0xd04L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2_dma_writer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xd04L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_DS2_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2_dma_writer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xd04L);
+	APICAL_WRITE_32(0xd04L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_ds2_dma_writer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xd04L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd08L, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_bank0_base_read(void) {
+	return APICAL_READ_32(0xd08L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd0cL, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_bank1_base_read(void) {
+	return APICAL_READ_32(0xd0cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank2_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 2 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BANK2_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_bank2_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd10L, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_bank2_base_read(void) {
+	return APICAL_READ_32(0xd10L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank3_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 3 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BANK3_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_bank3_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd14L, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_bank3_base_read(void) {
+	return APICAL_READ_32(0xd14L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank4_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 4 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BANK4_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_bank4_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd18L, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_bank4_base_read(void) {
+	return APICAL_READ_32(0xd18L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max bank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_MAX_BANK_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_ds2_dma_writer_max_bank_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd1cL);
+	APICAL_WRITE_32(0xd1cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_max_bank_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd1cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0 restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_bank0_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd1cL);
+	APICAL_WRITE_32(0xd1cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_bank0_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd1cL) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_DS2_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xd20L, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_line_offset_read(void) {
+	return APICAL_READ_32(0xd20L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write cancel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= cancel current/future frame write(s), any unstarted AXI bursts cancelled and fifo flushed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd24L);
+	APICAL_WRITE_32(0xd24L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// enables axi, active high, 1=enables axi write transfers, 0= reset axi domain( via reset synchroniser)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_PORT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd24L);
+	APICAL_WRITE_32(0xd24L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank currently active. valid values =0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_CURR_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_wbank_curr_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank last active. valid values = 0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_LAST_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_wbank_last_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x3800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank active
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_wbank_active_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at start of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_START_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_START_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_wbank_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank stop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at end of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_STOP_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBANK_STOP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_wbank_stop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd24L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// currently active bank base addr - in bytes. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBASE_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBASE_CURR_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds2_dma_writer_wbase_curr_read(void) {
+	return APICAL_READ_32(0xd28L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// last active bank base addr - in bytes. Updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WBASE_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_WBASE_LAST_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds2_dma_writer_wbase_last_read(void) {
+	return APICAL_READ_32(0xd2cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame icount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds2_dma_writer_frame_icount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xd30L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame wcount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds2_dma_writer_frame_wcount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xd30L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0>1 transition(synchronous detection) causes local axi/video alarm clear
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_8
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 8, 0= Dont reduce
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_max_burst_length_is_8_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_max_burst_length_is_8_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 4, 0= Dont reduce( has priority overmax_burst_length_is_8!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_max_burst_length_is_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_max_burst_length_is_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: write timeout disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		At end of frame an optional timeout is applied to wait for AXI writes to completed/accepted befotre caneclling and flushing.
+//		0= Timeout Enabled, timeout count can decrement.
+//		1 = Disable timeout, timeout count can't decrement.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_DS2_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2_dma_writer_write_timeout_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_write_timeout_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: awmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// awvalid maxwait limit(cycles) to raise axi_fail_awmaxwait alarm . zero disables alarm raise.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AWMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS2_DMA_WRITER_AWMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_dma_writer_awmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_awmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// wvalid maxwait limit(cycles) to raise axi_fail_wmaxwait alarm . zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS2_DMA_WRITER_WMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_dma_writer_wmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_wmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wxact_ostand_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// number oustsanding write transactions(bursts)(responses..1 per burst) limit to raise axi_fail_wxact_ostand. zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_WXACT_OSTAND_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS2_DMA_WRITER_WXACT_OSTAND_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2_dma_writer_wxact_ostand_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd34L);
+	APICAL_WRITE_32(0xd34L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_isp_ds2_dma_writer_wxact_ostand_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd34L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_bresp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate bad  bresp captured
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_fail_bresp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_awmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when awmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_fail_awmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_fail_wmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wxact_ostand
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wxact_ostand_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_fail_wxact_ostand_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_width detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_vi_fail_active_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_vi_fail_active_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interline_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interline blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_vi_fail_interline_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interframe_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interframe blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_vi_fail_interframe_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: video_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_video_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on axi port(s)( bresp or awmaxwait or wmaxwait or wxact_ostand failure )
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_AXI_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2_dma_writer_axi_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd38L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block configuration (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_DS2_DMA_WRITER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2_dma_writer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xd3cL, data);
+}
+static __inline uint32_t apical_isp_ds2_dma_writer_blk_config_read(void) {
+	return APICAL_READ_32(0xd3cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block status output (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_DS2_DMA_WRITER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds2_dma_writer_blk_status_read(void) {
+	return APICAL_READ_32(0xd40L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Video DMA Writer DS2 UV
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Down scaled video DMA writer 2 controls
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Format
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Format
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_FORMAT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_FORMAT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2uv_dma_writer_format_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0xff)) << 0) | (curr & 0xffffff00));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_format_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0xff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Base mode
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Base DMA packing mode for RGB/RAW/YUV etc (see ISP guide)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BASE_MODE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BASE_MODE_DATASIZE (4)
+
+// args: data (4-bit)
+static __inline void apical_isp_ds2uv_dma_writer_base_mode_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0xf)) << 0) | (curr & 0xfffffff0));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_base_mode_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0xf) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Plane select
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Plane select for planar base modes.  Only used if planar outputs required.  Not used.  Should be set to 0
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_PLANE_SELECT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_PLANE_SELECT_DATASIZE (2)
+
+// args: data (2-bit)
+static __inline void apical_isp_ds2uv_dma_writer_plane_select_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0x3)) << 6) | (curr & 0xffffff3f));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_plane_select_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0xc0) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: single frame
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = All frames are written(after frame_write_on= 1), 1= only 1st frame written ( after frame_write_on =1)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_SINGLE_FRAME_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_SINGLE_FRAME_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_single_frame_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0x1)) << 8) | (curr & 0xfffffeff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_single_frame_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write on
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		0 = no frames written(when switched from 1, current frame completes writing before stopping),
+//		1= write frame(s) (write single or continous frame(s) )
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_WRITE_ON_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_WRITE_ON_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_frame_write_on_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0x1)) << 9) | (curr & 0xfffffdff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_frame_write_on_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: half irate
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation , 1= write half(alternate) of input frames( only valid for continuous mode)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_HALF_IRATE_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_HALF_IRATE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_half_irate_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0x1)) << 10) | (curr & 0xfffffbff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_half_irate_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0x400) >> 10);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi xact comp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = dont wait for axi transaction completion at end of frame(just all transfers accepted). 1 = wait for all transactions completed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_XACT_COMP_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_XACT_COMP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_axi_xact_comp_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd80L);
+	APICAL_WRITE_32(0xd80L, (((uint32_t) (data & 0x1)) << 11) | (curr & 0xfffff7ff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_xact_comp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd80L) & 0x800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video width in pixels 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_ACTIVE_WIDTH_DEFAULT (0x780)
+#define APICAL_ISP_DS2UV_DMA_WRITER_ACTIVE_WIDTH_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2uv_dma_writer_active_width_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xd84L);
+	APICAL_WRITE_32(0xd84L, (((uint32_t) (data & 0xffff)) << 0) | (curr & 0xffff0000));
+}
+static __inline uint16_t apical_isp_ds2uv_dma_writer_active_width_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xd84L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: active height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Active video height in lines 128-8000
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_ACTIVE_HEIGHT_DEFAULT (0x438)
+#define APICAL_ISP_DS2UV_DMA_WRITER_ACTIVE_HEIGHT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline void apical_isp_ds2uv_dma_writer_active_height_write(uint16_t data) {
+	uint32_t curr = APICAL_READ_32(0xd84L);
+	APICAL_WRITE_32(0xd84L, (((uint32_t) (data & 0xffff)) << 16) | (curr & 0xffff));
+}
+static __inline uint16_t apical_isp_ds2uv_dma_writer_active_height_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xd84L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 0 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK0_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK0_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_bank0_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd88L, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_bank0_base_read(void) {
+	return APICAL_READ_32(0xd88L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank1_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 1 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK1_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK1_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_bank1_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd8cL, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_bank1_base_read(void) {
+	return APICAL_READ_32(0xd8cL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank2_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 2 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK2_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK2_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_bank2_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd90L, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_bank2_base_read(void) {
+	return APICAL_READ_32(0xd90L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank3_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 3 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK3_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK3_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_bank3_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd94L, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_bank3_base_read(void) {
+	return APICAL_READ_32(0xd94L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank4_base
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// bank 4 base address for frame buffer, should be word-aligned
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK4_BASE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK4_BASE_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_bank4_base_write(uint32_t data) {
+	APICAL_WRITE_32(0xd98L, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_bank4_base_read(void) {
+	return APICAL_READ_32(0xd98L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max bank
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// highest bank*_base to use for frame writes before recycling to bank0_base, only 0 to 4 are valid
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_MAX_BANK_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_MAX_BANK_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline void apical_isp_ds2uv_dma_writer_max_bank_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd9cL);
+	APICAL_WRITE_32(0xd9cL, (((uint32_t) (data & 0x7)) << 0) | (curr & 0xfffffff8));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_max_bank_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd9cL) & 0x7) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: bank0 restart
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= restart bank counter to bank0 for next frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK0_RESTART_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BANK0_RESTART_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_bank0_restart_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xd9cL);
+	APICAL_WRITE_32(0xd9cL, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_bank0_restart_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xd9cL) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: Line_offset
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		Indicates the offset in bytes from the start of one line to the next line.
+//		This value should be equal to or larger than one line of image data and should be word-aligned
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_LINE_OFFSET_DEFAULT (0x1000)
+#define APICAL_ISP_DS2UV_DMA_WRITER_LINE_OFFSET_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_line_offset_write(uint32_t data) {
+	APICAL_WRITE_32(0xda0L, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_line_offset_read(void) {
+	return APICAL_READ_32(0xda0L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame write cancel
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0 = normal operation, 1= cancel current/future frame write(s), any unstarted AXI bursts cancelled and fifo flushed
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_WRITE_CANCEL_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_WRITE_CANCEL_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_frame_write_cancel_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xda4L);
+	APICAL_WRITE_32(0xda4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_frame_write_cancel_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_port_enable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// enables axi, active high, 1=enables axi write transfers, 0= reset axi domain( via reset synchroniser)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_PORT_ENABLE_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_PORT_ENABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_axi_port_enable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xda4L);
+	APICAL_WRITE_32(0xda4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_port_enable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank currently active. valid values =0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_CURR_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wbank_curr_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x700) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// write bank last active. valid values = 0-4. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_LAST_DATASIZE (3)
+
+// args: data (3-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wbank_last_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x3800) >> 11);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank active
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = wbank_curr is being written to. Goes high at start of writes, low at last write transfer/completion on axi.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_ACTIVE_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_ACTIVE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wbank_active_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x10000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank start
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at start of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_START_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_START_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wbank_start_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x20000) >> 17);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbank stop
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1 = High pulse at end of frame write to bank.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_STOP_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBANK_STOP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wbank_stop_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xda4L) & 0x40000) >> 18);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase curr
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// currently active bank base addr - in bytes. updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBASE_CURR_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBASE_CURR_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds2uv_dma_writer_wbase_curr_read(void) {
+	return APICAL_READ_32(0xda8L);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wbase last
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// last active bank base addr - in bytes. Updated at start of frame write
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBASE_LAST_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WBASE_LAST_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds2uv_dma_writer_wbase_last_read(void) {
+	return APICAL_READ_32(0xdacL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame icount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of incomming frames (starts) to vdma_writer on video input, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_ICOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_ICOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds2uv_dma_writer_frame_icount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xdb0L) & 0xffff) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: frame wcount
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// count of outgoing frame writes (starts) from vdma_writer sent to AXI output, non resetable, rolls over, updates at pixel 1 of new frame on video in
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_WCOUNT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_FRAME_WCOUNT_DATASIZE (16)
+
+// args: data (16-bit)
+static __inline uint16_t apical_isp_ds2uv_dma_writer_frame_wcount_read(void) {
+	return (uint16_t)((APICAL_READ_32(0xdb0L) & 0xffff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: clear alarms
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 0>1 transition(synchronous detection) causes local axi/video alarm clear
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_CLEAR_ALARMS_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_CLEAR_ALARMS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_clear_alarms_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0x1)) << 0) | (curr & 0xfffffffe));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_clear_alarms_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_8
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 8, 0= Dont reduce
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_MAX_BURST_LENGTH_IS_8_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_max_burst_length_is_8_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0x1)) << 1) | (curr & 0xfffffffd));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_max_burst_length_is_8_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: max_burst_length_is_4
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// 1= Reduce default AXI max_burst_length from 16 to 4, 0= Dont reduce( has priority overmax_burst_length_is_8!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_MAX_BURST_LENGTH_IS_4_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_max_burst_length_is_4_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0x1)) << 2) | (curr & 0xfffffffb));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_max_burst_length_is_4_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: write timeout disable
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//
+//		At end of frame an optional timeout is applied to wait for AXI writes to completed/accepted befotre caneclling and flushing.
+//		0= Timeout Enabled, timeout count can decrement.
+//		1 = Disable timeout, timeout count can't decrement.
+//
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DEFAULT (0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WRITE_TIMEOUT_DISABLE_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline void apical_isp_ds2uv_dma_writer_write_timeout_disable_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0x1)) << 3) | (curr & 0xfffffff7));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_write_timeout_disable_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: awmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// awvalid maxwait limit(cycles) to raise axi_fail_awmaxwait alarm . zero disables alarm raise.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AWMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AWMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2uv_dma_writer_awmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0xff)) << 8) | (curr & 0xffff00ff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_awmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0xff00) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wmaxwait_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// wvalid maxwait limit(cycles) to raise axi_fail_wmaxwait alarm . zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WMAXWAIT_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WMAXWAIT_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2uv_dma_writer_wmaxwait_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0xff)) << 16) | (curr & 0xff00ffff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wmaxwait_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0xff0000) >> 16);
+}
+// ------------------------------------------------------------------------------ //
+// Register: wxact_ostand_limit
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// number oustsanding write transactions(bursts)(responses..1 per burst) limit to raise axi_fail_wxact_ostand. zero disables alarm raise
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_WXACT_OSTAND_LIMIT_DEFAULT (0x00)
+#define APICAL_ISP_DS2UV_DMA_WRITER_WXACT_OSTAND_LIMIT_DATASIZE (8)
+
+// args: data (8-bit)
+static __inline void apical_isp_ds2uv_dma_writer_wxact_ostand_limit_write(uint8_t data) {
+	uint32_t curr = APICAL_READ_32(0xdb4L);
+	APICAL_WRITE_32(0xdb4L, (((uint32_t) (data & 0xff)) << 24) | (curr & 0xffffff));
+}
+static __inline uint8_t apical_isp_ds2uv_dma_writer_wxact_ostand_limit_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb4L) & 0xff000000) >> 24);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_bresp
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate bad  bresp captured
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_BRESP_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_BRESP_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_fail_bresp_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x1) >> 0);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_awmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when awmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_AWMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_fail_awmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x2) >> 1);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wmaxwait
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wmaxwait_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_WMAXWAIT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_fail_wmaxwait_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x4) >> 2);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_fail_wxact_ostand
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high when wxact_ostand_limit reached
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_FAIL_WXACT_OSTAND_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_fail_wxact_ostand_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x8) >> 3);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_width
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_width detected
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_ACTIVE_WIDTH_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_vi_fail_active_width_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x10) >> 4);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_active_height
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate mismatched active_height detected ( also raised on missing field!)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_ACTIVE_HEIGHT_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_vi_fail_active_height_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x20) >> 5);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interline_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interline blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_INTERLINE_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_vi_fail_interline_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x40) >> 6);
+}
+// ------------------------------------------------------------------------------ //
+// Register: vi_fail_interframe_blanks
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  clearable alarm, high to indicate interframe blanking below min
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_VI_FAIL_INTERFRAME_BLANKS_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_vi_fail_interframe_blanks_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x80) >> 7);
+}
+// ------------------------------------------------------------------------------ //
+// Register: video_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on video port(s) ( active width/height or interline/frame blanks failure)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_VIDEO_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_VIDEO_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_video_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x100) >> 8);
+}
+// ------------------------------------------------------------------------------ //
+// Register: axi_alarm
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+//  active high, problem found on axi port(s)( bresp or awmaxwait or wmaxwait or wxact_ostand failure )
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_ALARM_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_AXI_ALARM_DATASIZE (1)
+
+// args: data (1-bit)
+static __inline uint8_t apical_isp_ds2uv_dma_writer_axi_alarm_read(void) {
+	return (uint8_t)((APICAL_READ_32(0xdb8L) & 0x200) >> 9);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_config
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block configuration (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BLK_CONFIG_DEFAULT (0x0000)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BLK_CONFIG_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline void apical_isp_ds2uv_dma_writer_blk_config_write(uint32_t data) {
+	APICAL_WRITE_32(0xdbcL, data);
+}
+static __inline uint32_t apical_isp_ds2uv_dma_writer_blk_config_read(void) {
+	return APICAL_READ_32(0xdbcL);
+}
+// ------------------------------------------------------------------------------ //
+// Register: blk_status
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// block status output (reserved)
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DS2UV_DMA_WRITER_BLK_STATUS_DEFAULT (0x0)
+#define APICAL_ISP_DS2UV_DMA_WRITER_BLK_STATUS_DATASIZE (32)
+
+// args: data (32-bit)
+static __inline uint32_t apical_isp_ds2uv_dma_writer_blk_status_read(void) {
+	return APICAL_READ_32(0xdc0L);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Iridix LUT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT: Asymmetry
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix target curve.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_LUT_ASYMMETRY_LUT_NODES (33)
+#define APICAL_ISP_IRIDIX_LUT_ASYMMETRY_LUT_ADDRBITS (6)
+#define APICAL_ISP_IRIDIX_LUT_ASYMMETRY_LUT_DATASIZE (16)
+
+// args: index (0-32), data (16-bit)
+static __inline void apical_isp_iridix_lut_asymmetry_lut_write(uint8_t index,uint16_t data) {
+	APICAL_WRITE_32(0x1c00L, index);
+	APICAL_WRITE_32(0x1c04L, data);
+}
+// ------------------------------------------------------------------------------ //
+// LUT: Rev Percept
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix look-up-table 1
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_LUT_REV_PERCEPT_LUT_NODES (65)
+#define APICAL_ISP_IRIDIX_LUT_REV_PERCEPT_LUT_ADDRBITS (7)
+#define APICAL_ISP_IRIDIX_LUT_REV_PERCEPT_LUT_DATASIZE (16)
+
+// args: index (0-64), data (16-bit)
+static __inline void apical_isp_iridix_lut_rev_percept_lut_write(uint8_t index,uint16_t data) {
+	APICAL_WRITE_32(0x1c20L, index);
+	APICAL_WRITE_32(0x1c24L, data);
+}
+// ------------------------------------------------------------------------------ //
+// LUT: Fwd Percept
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Iridix look-up-table 2
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_IRIDIX_LUT_FWD_PERCEPT_LUT_NODES (65)
+#define APICAL_ISP_IRIDIX_LUT_FWD_PERCEPT_LUT_ADDRBITS (7)
+#define APICAL_ISP_IRIDIX_LUT_FWD_PERCEPT_LUT_DATASIZE (12)
+
+// args: index (0-64), data (12-bit)
+static __inline void apical_isp_iridix_lut_fwd_percept_lut_write(uint8_t index,uint16_t data) {
+	APICAL_WRITE_32(0x1c30L, index);
+	APICAL_WRITE_32(0x1c34L, data);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Sinter Shading
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// LUT: rm_shading_lut
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Radial Sinter LUT.  See ISP guide for more details
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_SINTER_SHADING_RM_SHADING_LUT_NODES (33)
+#define APICAL_ISP_SINTER_SHADING_RM_SHADING_LUT_ADDRBITS (6)
+#define APICAL_ISP_SINTER_SHADING_RM_SHADING_LUT_DATASIZE (8)
+
+// args: index (0-32), data (8-bit)
+static __inline void apical_isp_sinter_shading_rm_shading_lut_write(uint8_t index,uint8_t data) {
+	uint32_t addr = 0x1c40L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	uint32_t curr = APICAL_READ_32(addr);
+	APICAL_WRITE_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
+}
+static __inline uint8_t apical_isp_sinter_shading_rm_shading_lut_read(uint8_t index) {
+	uint32_t addr = 0x1c40L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	return (uint8_t)(APICAL_READ_32(addr) >> offset);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Noise Profile RAW frontend LUT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile controls for RAW frontend
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Weight lut
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile LUT.  Calculated during calibration process.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_LUT_WEIGHT_LUT_DEFAULT (0x0)
+#define APICAL_ISP_NOISE_PROFILE_RAW_FRONTEND_LUT_WEIGHT_LUT_DATASIZE (8)
+
+// index (0-127), args: data (8-bit)
+static __inline void apical_isp_noise_profile_raw_frontend_lut_weight_lut_write(uint32_t index,uint8_t data) {
+	uint32_t addr = 0x1c80L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	uint32_t curr = APICAL_READ_32(addr);
+	APICAL_WRITE_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
+}
+static __inline uint8_t apical_isp_noise_profile_raw_frontend_lut_weight_lut_read(uint32_t index) {
+	uint32_t addr = 0x1c80L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	return (uint8_t)(APICAL_READ_32(addr) >> offset);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Noise Profile LUT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile controls for Sinter and Temper
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Weight lut
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile LUT.  Calculated during calibration process.
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_NOISE_PROFILE_LUT_WEIGHT_LUT_DEFAULT (0x0)
+#define APICAL_ISP_NOISE_PROFILE_LUT_WEIGHT_LUT_DATASIZE (8)
+
+// index (0-127), args: data (8-bit)
+static __inline void apical_isp_noise_profile_lut_weight_lut_write(uint32_t index,uint8_t data) {
+	uint32_t addr = 0x1d00L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	uint32_t curr = APICAL_READ_32(addr);
+	APICAL_WRITE_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
+}
+static __inline uint8_t apical_isp_noise_profile_lut_weight_lut_read(uint32_t index) {
+	uint32_t addr = 0x1d00L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	return (uint8_t)(APICAL_READ_32(addr) >> offset);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Demosaic LUT
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Bayer Demosaic lookup
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: Weight lut
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Noise profile LUT
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_DEMOSAIC_LUT_WEIGHT_LUT_DEFAULT (0x0)
+#define APICAL_ISP_DEMOSAIC_LUT_WEIGHT_LUT_DATASIZE (8)
+
+// index (0-127), args: data (8-bit)
+static __inline void apical_isp_demosaic_lut_weight_lut_write(uint32_t index,uint8_t data) {
+	uint32_t addr = 0x1d80L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	uint32_t curr = APICAL_READ_32(addr);
+	APICAL_WRITE_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
+}
+static __inline uint8_t apical_isp_demosaic_lut_weight_lut_read(uint32_t index) {
+	uint32_t addr = 0x1d80L + (index & 0xFFFFFFFC);
+	uint8_t offset = (index & 3) << 3;
+	return (uint8_t)(APICAL_READ_32(addr) >> offset);
+}
+// ------------------------------------------------------------------------------ //
+// Group: Zones
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Controls zone weighting for auto-exposure and auto-white-balance
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Register: AEXP Weight
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets zone weighting for auto exposure. Index is (row,col) where (0,0) is top-left zonea
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_ZONES_AEXP_WEIGHT_DEFAULT (0xF)
+#define APICAL_ISP_ZONES_AEXP_WEIGHT_DATASIZE (4)
+
+// index1 (0-14), index2 (0-14), args: data (4-bit)
+static __inline void apical_isp_zones_aexp_weight_write(uint32_t index1, uint32_t index2,uint8_t data) {
+	uint32_t addr;
+	uint8_t offset;
+	uint32_t curr;
+	addr = 0x1e00L + (index1 * 15 + index2);
+	offset = (addr & 3) << 3;
+	addr &= 0xFFFFFFFC;
+	curr = APICAL_READ_32(addr);
+	APICAL_WRITE_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
+}
+static __inline uint8_t apical_isp_zones_aexp_weight_read(uint32_t index1, uint32_t index2) {
+	uint32_t addr = 0x1e00L + ((index1 * 15 + index2));
+	uint8_t offset = (addr & 3) << 3;
+	addr &= 0xFFFFFFFC;
+	return (uint8_t)(APICAL_READ_32(addr) >> offset);
+}
+// ------------------------------------------------------------------------------ //
+// Register: AWB Weight
+// ------------------------------------------------------------------------------ //
+
+// ------------------------------------------------------------------------------ //
+// Sets zone weighting for auto white balance. Index is (row,col) where (0,0) is top-left zone
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_ISP_ZONES_AWB_WEIGHT_DEFAULT (0xF)
+#define APICAL_ISP_ZONES_AWB_WEIGHT_DATASIZE (4)
+
+// index1 (0-14), index2 (0-14), args: data (4-bit)
+static __inline void apical_isp_zones_awb_weight_write(uint32_t index1, uint32_t index2,uint8_t data) {
+	uint32_t addr;
+	uint8_t offset;
+	uint32_t curr;
+	addr = 0x1f00L + (index1 * 15 + index2);
+	offset = (addr & 3) << 3;
+	addr &= 0xFFFFFFFC;
+	curr = APICAL_READ_32(addr);
+	APICAL_WRITE_32(addr, ((uint32_t)data << offset) | (curr & ~(0xFF << offset)));
+}
+static __inline uint8_t apical_isp_zones_awb_weight_read(uint32_t index1, uint32_t index2) {
+	uint32_t addr = 0x1f00L + ((index1 * 15 + index2));
+	uint8_t offset = (addr & 3) << 3;
+	addr &= 0xFFFFFFFC;
+	return (uint8_t)(APICAL_READ_32(addr) >> offset);
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_ISP_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_core_nomem_settings.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_core_nomem_settings.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_core_nomem_settings.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_core_nomem_settings.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,81 @@
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+#if !defined(__APICAL_ISP_CORE_NOMEM_SETTINGS_H__)
+#define __APICAL_ISP_CORE_NOMEM_SETTINGS_H__
+#define ISP_CORE_ID    0x8c157f2d
+#define ISP_PIPE_RAW_BITS    12
+#define ISP_PIPE_RAW_WDR_BITS    16
+#define ISP_PIPE_RGB_BITS    10
+#define ISP_CONFIG_AW    15
+#define ISP_CONFIG_DW    32
+#define ISP_DEFECT_PIXEL_AW    12
+#define ISP_DEFECT_PIXEL_CXW    12
+#define ISP_DEFECT_PIXEL_CYW    12
+#define ISP_SHADING_MX    6
+#define ISP_SHADING_MY    6
+#define ISP_SHADING_MW    8
+#define ISP_SHADING_GEOM    13
+#define ISP_SHADING_LUT_AW    5
+#define ISP_FRONTEND_LUT0_AW    5
+#define ISP_FRONTEND_LUT1_AW    8
+#define ISP_GAMMA_RGB_AW    7
+#define ISP_METERING_ZONES_AWB_V    15
+#define ISP_METERING_ZONES_AWB_H    15
+#define ISP_METERING_ZONES_V    15
+#define ISP_METERING_ZONES_H    15
+#define ISP_METERING_OFFSET_AE    0
+#define ISP_METERING_OFFSET_AWB    1856
+#define ISP_METERING_OFFSET_AF    928
+#define ISP_METERING_OFFSET_MVE    1392
+#define ISP_METERING_MEM_END    2415
+#define ISP_INTERRUPT_EVENT_NONES_COUNT    16
+#define ISP_INTERRUPT_EVENT_ISP_START_FRAME_END    16
+#define ISP_INTERRUPT_EVENT_ISP_START_FRAME_START    24
+#define ISP_INTERRUPT_EVENT_ISP_DEFECT_PIXEL_FRAME_END    17
+#define ISP_INTERRUPT_EVENT_ISP_DEFECT_PIXEL_FRAME_START    25
+#define ISP_INTERRUPT_EVENT_ISP_SINTER_FRAME_END    18
+#define ISP_INTERRUPT_EVENT_ISP_SINTER_FRAME_START    26
+#define ISP_INTERRUPT_EVENT_ISP_TEMPER_FRAME_END    19
+#define ISP_INTERRUPT_EVENT_ISP_TEMPER_FRAME_START    27
+#define ISP_INTERRUPT_EVENT_ISP_IRIDIX_FRAME_END    20
+#define ISP_INTERRUPT_EVENT_ISP_IRIDIX_FRAME_START    28
+#define ISP_INTERRUPT_EVENT_ISP_DEMOSAIC_FRAME_END    21
+#define ISP_INTERRUPT_EVENT_ISP_DEMOSAIC_FRAME_START    29
+#define ISP_INTERRUPT_EVENT_ISP_FR_SHARPEN_FRAME_END    22
+#define ISP_INTERRUPT_EVENT_ISP_FR_SHARPEN_FRAME_START    30
+#define ISP_INTERRUPT_EVENT_ISP_FR_OUT_FRAME_END    23
+#define ISP_INTERRUPT_EVENT_ISP_FR_OUT_FRAME_START    31
+#define ISP_INTERRUPT_EVENT_ISP_DS1_SCALER_FRAME_END    48
+#define ISP_INTERRUPT_EVENT_ISP_DS1_SCALER_FRAME_START    56
+#define ISP_INTERRUPT_EVENT_ISP_DS1_SHARPEN_FRAME_END    49
+#define ISP_INTERRUPT_EVENT_ISP_DS1_SHARPEN_FRAME_START    57
+#define ISP_INTERRUPT_EVENT_ISP_DS1_OUT_FRAME_END    50
+#define ISP_INTERRUPT_EVENT_ISP_DS1_OUT_FRAME_START    58
+#define ISP_INTERRUPT_EVENT_ISP_DS2_SCALER_FRAME_END    51
+#define ISP_INTERRUPT_EVENT_ISP_DS2_SCALER_FRAME_START    59
+#define ISP_INTERRUPT_EVENT_ISP_DS2_SHARPEN_FRAME_END    52
+#define ISP_INTERRUPT_EVENT_ISP_DS2_SHARPEN_FRAME_START    60
+#define ISP_INTERRUPT_EVENT_ISP_DS2_OUT_FRAME_END    53
+#define ISP_INTERRUPT_EVENT_ISP_DS2_OUT_FRAME_START    61
+#define ISP_INTERRUPT_EVENT_METERING_AEXP    8
+#define ISP_INTERRUPT_EVENT_METERING_AWB    9
+#define ISP_INTERRUPT_EVENT_METERING_AF    10
+#define ISP_INTERRUPT_EVENT_METERING_HIST    11
+#define ISP_INTERRUPT_EVENT_MVE    12
+#define ISP_INTERRUPT_EVENT_TEMPER_FRAME_BUFFER    13
+#define ISP_INTERRUPT_EVENT_FR_DMA_WRITER    14
+#define ISP_INTERRUPT_EVENT_DS1_DMA_WRITER    15
+#define ISP_INTERRUPT_EVENT_DS2_DMA_WRITER    1
+#define ISP_INTERRUPT_EVENT_FLASH_TIMER_OUTPUT_STROBE6    6
+#define ISP_INTERRUPT_EVENT_FLASH_TIMER_OUTPUT_STROBE7    7
+#endif /* __APICAL_ISP_CORE_NOMEM_SETTINGS_H__*/
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_io.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_io.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_io.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_isp_io.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,40 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_ISP_IO_H__
+#define __APICAL_ISP_IO_H__
+
+
+#include <asm/io.h>
+#include "apical_types.h"
+#include "system_isp_io.h"
+#include "apical_firmware_config.h"
+
+
+#if ISP_ASIC_BUILD
+uint32_t APICAL_READ_32(uint32_t addr);
+uint16_t APICAL_READ_16(uint32_t addr);
+uint8_t APICAL_READ_8(uint32_t addr);
+void APICAL_WRITE_32(uint32_t addr, uint32_t data);
+void APICAL_WRITE_16(uint32_t addr, uint16_t data);
+void APICAL_WRITE_8(uint32_t addr, uint8_t data);
+#else
+#define APICAL_READ_32 system_isp_read_32
+#define APICAL_READ_16 system_isp_read_16
+#define APICAL_READ_8 system_isp_read_8
+#define APICAL_WRITE_32 system_isp_write_32
+#define APICAL_WRITE_16 system_isp_write_16
+#define APICAL_WRITE_8 system_isp_write_8
+#endif
+
+#include "apical_configuration.h"
+#endif /* __APICAL_ISP_IO_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt1_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt1_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt1_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt1_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_I_VFILT1_MEM_CONFIG_H__
+#define __APICAL_I_VFILT1_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'i_vfilt1_mem' of module 'scaler_vfilt_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_I_VFILT1_MEM_BASE_ADDR (0x16000L)
+#define APICAL_I_VFILT1_MEM_SIZE (0x1000)
+
+#define APICAL_I_VFILT1_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_I_VFILT1_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-255), data (32-bit)
+static __inline void apical_i_vfilt1_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x16000L + (index << 2), data);
+}
+static __inline uint32_t apical_i_vfilt1_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x16000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_I_VFILT1_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt2_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt2_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt2_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_i_vfilt2_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_I_VFILT2_MEM_CONFIG_H__
+#define __APICAL_I_VFILT2_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'i_vfilt2_mem' of module 'scaler_vfilt_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_I_VFILT2_MEM_BASE_ADDR (0x1a000L)
+#define APICAL_I_VFILT2_MEM_SIZE (0x1000)
+
+#define APICAL_I_VFILT2_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_I_VFILT2_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-255), data (32-bit)
+static __inline void apical_i_vfilt2_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x1a000L + (index << 2), data);
+}
+static __inline uint32_t apical_i_vfilt2_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x1a000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_I_VFILT2_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_jtag_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_jtag_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_jtag_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_jtag_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_JTAG_CONFIG_H__
+#define __APICAL_JTAG_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'jtag' of module 'jtag_frame_capture'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_JTAG_BASE_ADDR (0x21000L)
+#define APICAL_JTAG_SIZE (0x400)
+
+#define APICAL_JTAG_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_JTAG_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-255), data (32-bit)
+static __inline void apical_jtag_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x21000L + (index << 2), data);
+}
+static __inline uint32_t apical_jtag_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x21000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_JTAG_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_math.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_math.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_math.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_math.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,50 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_MATH_H__
+#define __APICAL_MATH_H__
+
+#include "apical.h"
+
+#define APICAL_ABS(a)        ((a)>=0?(a):-(a))
+
+#define U16_MAX 					0xFFFF
+#define APICAL_SIGN(a)  ((a)>=0?(1):(-1))
+#define APICAL_MIN(a,b) ((a)>=b?(b):(a))
+#define APICAL_MAX(a,b) ((a)>=b?(a):(b))
+#define APICAL_ABSDIFF(a,b) ((a)>(b)? (a-b) : (b-a))
+#define LIN_EQUATION_FRACTION_SIZE 5
+
+#define round_shift(a,sh)   (((a)>>(sh))+(((a)>>(sh-1))&1))
+#define PI   12868 //Q12 Format
+uint8_t leading_one_position(const uint32_t in);
+uint16_t sqrt32(uint32_t arg);
+uint32_t log2_int_to_fixed(const uint32_t val, const uint8_t out_precision, const uint8_t shift_out);
+uint32_t log2_fixed_to_fixed(const uint32_t val, const int in_fix_point, const uint8_t out_fix_point);
+uint32_t math_exp2(uint32_t val, const unsigned char shift_in, const unsigned char shift_out);
+uint8_t sqrt16(uint16_t arg);
+uint8_t log16(uint16_t arg);
+uint32_t math_log2(const uint32_t val, const uint8_t out_precision, const uint8_t shift_out);
+uint32_t multiplication_fixed_to_fixed(uint32_t a, uint32_t b, const int x1, const int x2);
+
+int32_t solving_lin_equation_a(int32_t y1, int32_t y2, int32_t x1, int32_t x2, int16_t a_fraction_size);
+int32_t solving_lin_equation_b(int32_t y1, int32_t a, int32_t x1, int16_t a_fraction_size);
+int32_t solving_nth_root_045(int32_t x, const int16_t fraction_size);
+uint32_t div_fixed(uint32_t a, uint32_t b, int16_t a_fraction_size);
+uint16_t sqrt32(uint32_t arg);
+
+uint16_t line_offset(uint16_t line_len, uint8_t bytes_per_pixel);
+int16_t apical_cosine(uint32_t theta);
+int16_t apical_sine(uint32_t theta);
+
+#define APICAL_MODULO(N,D)  ((N)-(((N)/(D))*(D)))
+#endif /* __APICAL_MATH_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_metering_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_metering_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_metering_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_metering_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_METERING_MEM_CONFIG_H__
+#define __APICAL_METERING_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'metering_mem' of module 'metering_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_METERING_MEM_BASE_ADDR (0x8000L)
+#define APICAL_METERING_MEM_SIZE (0x4000)
+
+#define APICAL_METERING_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_METERING_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-2415), data (32-bit)
+static __inline void apical_metering_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x8000L + (index << 2), data);
+}
+static __inline uint32_t apical_metering_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x8000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_METERING_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_radial_shading_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_radial_shading_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_radial_shading_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_radial_shading_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_RADIAL_SHADING_MEM_CONFIG_H__
+#define __APICAL_RADIAL_SHADING_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'radial_shading_mem' of module 'radial_shading_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_RADIAL_SHADING_MEM_BASE_ADDR (0x3800L)
+#define APICAL_RADIAL_SHADING_MEM_SIZE (0x400)
+
+#define APICAL_RADIAL_SHADING_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_RADIAL_SHADING_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-160), data (32-bit)
+static __inline void apical_radial_shading_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x3800L + (index << 2), data);
+}
+static __inline uint32_t apical_radial_shading_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x3800L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_RADIAL_SHADING_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_sensor_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_sensor_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_sensor_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_sensor_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,72 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL_SENSOR_CONFIG_H__
+#define __APICAL_SENSOR_CONFIG_H__
+
+
+#define SENSOR_BUS_ADDR_SHIFT 0
+#define ISP_SENSOR_DRIVER_DONGWOON 0
+#define SENSOR_IMAGE_WIDTH_PREVIEW 1920
+#define LOG2_SENSOR_DGAIN_MAXIMUM 0
+#define SENSOR_OUTPUT_BITS 12
+#define SENSOR_BOARD_MASTER_CLOCK 24000
+#define SENSOR_MID_MULT 1
+#define SENSOR_IMAGE_HEIGHT_PREVIEW 1080
+#define SENSOR_SEQUENCE_NAME default
+#define FULL_EXTRA_HEIGHT 0
+#define ISP_IMAGE_WIDTH SENSOR_IMAGE_WIDTH
+#define SENSOR_SEQUENCE_FULL_RES_MAX_FPS 0
+#define ISP_SENSOR_DRIVER_NULL 0
+#define SENSOR_EXP_NUMBER 1
+#define SENSOR_INTEGRATION_TIME_APPLY_DELAY 2
+#define RESOLUTION_CHANGE_ENABLED 1
+#define SENSOR_TOTAL_WIDTH 2200
+#define SENSOR_SEQUENCE_FULL_RES_HALF_FPS 2
+#define SPI_CLOCK_DIV 40
+#define SENSOR_MAX_INTEGRATION_TIME 1125
+#define SENSOR_MIN_INTEGRATION_TIME_NATIVE SENSOR_MIN_INTEGRATION_TIME
+#define SENSOR_DIGITAL_GAIN_APPLY_DELAY 2
+#define SENSOR_TOTAL_HEIGHT 1125
+#define SENSOR_TOTAL_WIDTH_PREVIEW 3264
+#define SENSOR_MAX_INTEGRATION_TIME_PREVIEW 2586-14
+#define ISP_SENSOR_DRIVER_LC898201 0
+#define ISP_SENSOR_DRIVER_ROHM 0
+#define SENSOR_IMAGE_HEIGHT 1080
+#define SENSOR_TOTAL_HEIGHT_PREVIEW 2586
+#define SENSOR_AF_MOVE_DELAY 20
+#define SENSOR_LONG_SHIFT 0
+#define SENSOR_MID_SHIFT 0
+#define ISP_SENSOR_DRIVER_AD5821 0
+#define SPI_CONTROL_MASK (RX_NEG_MSK|(CHAR_LEN_MSK&24)|AUTO_SS_MSK|LSB_MSK)
+#define SENSOR_DAY_LIGHT_INTEGRATION_TIME_LIMIT 300
+#define SENSOR_MAX_INTEGRATION_TIME_LIMIT 1125
+#define SENSOR_MIN_INTEGRATION_TIME 1
+#define SENSOR_SEQUENCE_PREVIEW_RES_MAX_FPS 1
+#define SENSOR_IMAGE_WIDTH_FULL 3264
+#define LOG2_SENSOR_AGAIN_MAXIMUM 0
+#define SENSOR_LONG_MULT 1
+#define PREVIEW_EXTRA_WIDTH 0
+#define SENSOR_IMAGE_WIDTH 1920
+#define FULL_EXTRA_WIDTH 0
+#define SENSOR_BUS spi
+#define SENSOR_BLACK_LEVEL_CORRECTION 0
+#define SENSOR_IMAGE_HEIGHT_FULL 2448
+#define ISP_IMAGE_HEIGHT SENSOR_IMAGE_HEIGHT
+#define SENSOR_ANALOG_GAIN_APPLY_DELAY 2
+#define SENSOR_SAMPLE_MASK 1
+#define SENSOR_MAX_INTEGRATION_TIME_NATIVE SENSOR_MAX_INTEGRATION_TIME
+#define SENSOR_ENDIAN_MASK 1
+#define PREVIEW_EXTRA_HEIGHT 0
+#define SENSOR_SEQUENCE_PREVIEW_RES_HALF_FPS 3
+#define SENSOR_BUS_ADDRESS 0
+#endif
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_shading_mem_config.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_shading_mem_config.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_shading_mem_config.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_shading_mem_config.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __APICAL_SHADING_MEM_CONFIG_H__
+#define __APICAL_SHADING_MEM_CONFIG_H__
+
+
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2014 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#include "apical_isp_io.h"
+
+// ------------------------------------------------------------------------------ //
+// Instance 'shading_mem' of module 'shading_mem'
+// ------------------------------------------------------------------------------ //
+
+#define APICAL_SHADING_MEM_BASE_ADDR (0x4000L)
+#define APICAL_SHADING_MEM_SIZE (0x4000)
+
+#define APICAL_SHADING_MEM_ARRAY_DATA_DEFAULT (0x0)
+#define APICAL_SHADING_MEM_ARRAY_DATA_DATASIZE (32)
+
+// args: index (0-3071), data (32-bit)
+static __inline void apical_shading_mem_array_data_write(uint32_t index, uint32_t data) {
+	APICAL_WRITE_32(0x4000L + (index << 2), data);
+}
+static __inline uint32_t apical_shading_mem_array_data_read(uint32_t index) {
+	return APICAL_READ_32(0x4000L + (index << 2));
+}
+// ------------------------------------------------------------------------------ //
+#endif //__APICAL_SHADING_MEM_CONFIG_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_types.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_types.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/apical_types.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/apical_types.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,102 @@
+/*-----------------------------------------------------------------------------
+  This confidential and proprietary software/information may be used only
+  as authorized by a licensing agreement from Apical Limited
+
+  (C) COPYRIGHT 2011 - 2015 Apical Limited
+  ALL RIGHTS RESERVED
+
+  The entire notice above must be reproduced on all authorized
+  copies and copies may only be made to the extent permitted
+  by a licensing agreement from Apical Limited.
+  -----------------------------------------------------------------------------*/
+
+#ifndef __APICAL__TYPES_H__
+#define __APICAL__TYPES_H__
+
+#include "apical_firmware_config.h"
+
+
+#if KERNEL_MODULE==1
+#include "linux/types.h"
+#include "linux/string.h"
+//#include "linux/math64.h"
+#else
+#include <stdint.h>
+#include <stdlib.h>
+#include <assert.h>
+#endif
+
+
+#define msleep(x) usleep((x)*1000)
+#if KERNEL_MODULE==1
+#include <asm/div64.h>
+#include <linux/math64.h>
+#define usleep(a) usleep_range((a),(a)+100)
+#else
+#define div64_u64(x,y) ((x)/(y))
+#define div64_s64(x,y) ((x)/(y))
+#endif
+
+#define UNIT_DISABLED 0
+#define UNIT_ENABLED 1
+
+#define array_size(a) \
+	(sizeof(a)/sizeof(a[0]))
+
+
+typedef struct _modulation_entry_t {
+	uint16_t x,y;
+} modulation_entry_t;
+
+typedef struct _modulation_entry_32_t {
+	uint32_t x,y;
+} modulation_entry_32_t;
+
+
+#define MIN(a,b) ((a) < (b) ? (a) : (b))
+
+typedef struct LookupTable {
+	void *ptr ;
+	uint16_t rows ;
+	uint16_t cols ;
+	uint16_t width ;
+} LookupTable ;
+#if ISP_HAS_CONNECTION_SOCKET
+enum apical_socket_domain {
+	APICAL_SOCKET_DOMAIN_UNIX,
+	APICAL_SOCKET_DOMAIN_INET
+};
+
+struct apical_socket_f {
+	int (* socket)(enum apical_socket_domain sock_domain, int sock_nonblock, int *fd);
+	int (* set_reuseaddr)(int fd, int reuseaddr);
+	int (* set_nonblock)(int fd, int nonblock);
+	int (* bind_port)(int server_fd, unsigned short port);
+	int (* bind_path)(int server_fd, const char *path);
+	int (* listen)(int fd);
+	int (* accept)(enum apical_socket_domain sock_domain, int server_fd, int *client_fd);
+	int (* read)(int fd, uint8_t *data, int size, int *have_read);
+	int (* write)(int fd, const uint8_t *data, int size, int *have_written);
+	int (* close)(int fd);
+};
+#endif // ISP_HAS_CONNECTION_SOCKET
+
+/*// got to an infinite loop when we try to access NULL memory pointer.
+#define CHECK_NULL_PTR( c ) { if ( c == NULL ) LOG(LOG_CRIT, "Trying to access NULL memory pointer") ; while ( 1 ) {} ; }
+
+#define GET_UCHAR_PTR( c ) ((uint8_t *)c->ptr)
+#define GET_USHORT_PTR( c ) (( uint16_t *)c->ptr)
+#define GET_USHORT_2D_PTR( c ) (( uint16_t (*)[c->cols] )c->ptr )
+#define GET_MOD_ENTRY_PTR( c ) ( (modulation_entry_t *)c->ptr )
+#define GET_UINT_PTR( c ) ((uint32_t *)c->ptr)
+#define GET_ROWS( c ) ( c->rows )
+#define GET_COLS( c ) ( c->cols )
+#define GET_WIDTH( c ) ( c->width )
+#define GET_LEN( c ) ( (c->rows) * (c->cols) )
+#define GET_SIZE( c ) ( (c->rows) * (c->cols) * (c->width) )
+ */
+
+
+
+
+#endif /* __APICAL__TYPES_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/system_interrupts.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/system_interrupts.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/system_interrupts.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/system_interrupts.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,17 @@
+#if !defined(__SYSTEM_INTERRUPTS_H__)
+#define __SYSTEM_INTERRUPTS_H__
+
+#include "apical_types.h"
+#define APICAL_IRQ_COUNT 16
+typedef uint32_t system_fw_interrupt_mask_t;
+typedef void (*system_interrupt_handler_t)(void* ptr);
+
+#define APICAL_IRQ_MASK(num) (1 << num)
+void system_init_interrupt(void);
+
+void system_set_interrupt_handler(uint8_t source, system_interrupt_handler_t handler, void* param);
+
+void system_hw_interrupts_enable(void);
+void system_hw_interrupts_disable(void);
+
+#endif /* __SYSTEM_INTERRUPTS_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/system_io.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/system_io.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/system_io.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/system_io.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,16 @@
+#if !defined(__SYSTEM_IO_H__)
+#define __SYSTEM_IO_H__
+
+#include "apical_types.h"
+
+void system_isp_set_base_address(void *address);
+//------------------------------------------------------
+uint32_t system_isp_read_32(uint32_t addr);
+uint16_t system_isp_read_16(uint32_t addr);
+uint8_t  system_isp_read_8(uint32_t addr);
+void system_isp_write_32(uint32_t addr, uint32_t data);
+void system_isp_write_16(uint32_t addr, uint16_t data);
+void system_isp_write_8( uint32_t addr, uint8_t  data);
+//------------------------------------------------------
+
+#endif /* __SYSTEM_IO_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/system_isp_io.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/system_isp_io.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/apical-isp/system_isp_io.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/apical-isp/system_isp_io.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,8 @@
+#if !defined(__SYSTEM_ISP_IO_H__)
+#define __SYSTEM_ISP_IO_H__
+
+#include "apical_types.h"
+#include "system_io.h"
+void system_reset_sensor(uint32_t mask);
+
+#endif /* __SYSTEM_ISP_IO_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/sensor-common.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/sensor-common.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/sensor-common.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/sensor-common.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,84 @@
+#ifndef __TX_SENSOR_COMMON_H__
+#define __TX_SENSOR_COMMON_H__
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>
+#include <linux/i2c.h>
+#include <soc/gpio.h>
+
+#include "tx-isp-common.h"
+
+#define SENSOR_R_BLACK_LEVEL	0
+#define SENSOR_GR_BLACK_LEVEL	1
+#define SENSOR_GB_BLACK_LEVEL	2
+#define SENSOR_B_BLACK_LEVEL	3
+
+/* External v4l2 format info. */
+#define V4L2_I2C_REG_MAX		(150)
+#define V4L2_I2C_ADDR_16BIT		(0x0002)
+#define V4L2_I2C_DATA_16BIT		(0x0004)
+#define V4L2_SBUS_MASK_SAMPLE_8BITS	0x01
+#define V4L2_SBUS_MASK_SAMPLE_16BITS	0x02
+#define V4L2_SBUS_MASK_SAMPLE_32BITS	0x04
+#define V4L2_SBUS_MASK_ADDR_8BITS	0x08
+#define V4L2_SBUS_MASK_ADDR_16BITS	0x10
+#define V4L2_SBUS_MASK_ADDR_32BITS	0x20
+#define V4L2_SBUS_MASK_ADDR_STEP_16BITS 0x40
+#define V4L2_SBUS_MASK_ADDR_STEP_32BITS 0x80
+#define V4L2_SBUS_MASK_SAMPLE_SWAP_BYTES 0x100
+#define V4L2_SBUS_MASK_SAMPLE_SWAP_WORDS 0x200
+#define V4L2_SBUS_MASK_ADDR_SWAP_BYTES	0x400
+#define V4L2_SBUS_MASK_ADDR_SWAP_WORDS	0x800
+#define V4L2_SBUS_MASK_ADDR_SKIP	0x1000
+#define V4L2_SBUS_MASK_SPI_READ_MSB_SET 0x2000
+#define V4L2_SBUS_MASK_SPI_INVERSE_DATA 0x4000
+#define V4L2_SBUS_MASK_SPI_HALF_ADDR	0x8000
+#define V4L2_SBUS_MASK_SPI_LSB		0x10000
+
+struct tx_isp_sensor_win_setting {
+	int	width;
+	int	height;
+	int fps;
+	enum v4l2_mbus_pixelcode mbus_code;
+	enum v4l2_colorspace colorspace;
+	void *regs;	/* Regs to tweak; the default fps is fast */
+};
+
+static inline int set_sensor_gpio_function(int func_set)
+{
+	int ret = 0;
+#if (defined(CONFIG_SOC_T10) || defined(CONFIG_SOC_T20) || defined(CONFIG_SOC_T30))
+	switch (func_set) {
+	case DVP_PA_LOW_8BIT:
+		ret = jzgpio_set_func(GPIO_PORT_A, GPIO_FUNC_1, 0x000340ff);
+		pr_info("set sensor gpio as PA-low-8bit\n");
+		break;
+	case DVP_PA_HIGH_8BIT:
+		ret = jzgpio_set_func(GPIO_PORT_A, GPIO_FUNC_1, 0x00034ff0);
+		pr_info("set sensor gpio as PA-high-8bit\n");
+		break;
+	case DVP_PA_LOW_10BIT:
+		ret = jzgpio_set_func(GPIO_PORT_A, GPIO_FUNC_1, 0x000343ff);
+		pr_info("set sensor gpio as PA-low-10bit\n");
+		break;
+	case DVP_PA_HIGH_10BIT:
+		ret = jzgpio_set_func(GPIO_PORT_A, GPIO_FUNC_1, 0x00034ffc);
+		pr_info("set sensor gpio as PA-high-10bit\n");
+		break;
+	case DVP_PA_12BIT:
+		ret = jzgpio_set_func(GPIO_PORT_A, GPIO_FUNC_1, 0x00034fff);
+		pr_info("set sensor gpio as PA-12bit\n");
+		break;
+	default:
+		pr_err("set sensor gpio error: unknow function %d\n", func_set);
+		ret = -1;
+		break;
+	}
+#else
+	ret = -1;
+#endif
+	return ret;
+}
+
+#endif// __TX_SENSOR_COMMON_H__
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/tx-isp-common.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/tx-isp-common.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/tx-isp-common.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/tx-isp-common.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,407 @@
+#ifndef __TX_ISP_COMMON_H__
+#define __TX_ISP_COMMON_H__
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/spi/spi.h>
+#include <linux/videodev2.h>
+#include <linux/v4l2-mediabus.h>
+#include <media/media-entity.h>
+#include <media/media-device.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <linux/clk.h>
+#include <mach/tx_isp.h>
+
+
+#if defined(CONFIG_SOC_T10)
+/* T10 */
+#define TX_ISP_EXIST_FR_CHANNEL 1
+#define TX_ISP_EXIST_DS2_CHANNEL 0
+
+#define TX_ISP_INPUT_PORT_MAX_WIDTH		1280
+#define TX_ISP_INPUT_PORT_MAX_HEIGHT	960
+#define TX_ISP_FR_CAHNNEL_MAX_WIDTH		1280
+#define TX_ISP_FR_CAHNNEL_MAX_HEIGHT	960
+#define TX_ISP_DS1_CAHNNEL_MAX_WIDTH	640
+#define TX_ISP_DS1_CAHNNEL_MAX_HEIGHT	640
+
+#elif defined(CONFIG_SOC_T20)
+/* T20 */
+#define TX_ISP_EXIST_CSI_DEVICE 1
+#define TX_ISP_EXIST_FR_CHANNEL 0
+#define TX_ISP_EXIST_DS2_CHANNEL 1
+
+#define TX_ISP_INPUT_PORT_MAX_WIDTH		2048
+#define TX_ISP_INPUT_PORT_MAX_HEIGHT	1536
+#define TX_ISP_DS1_CAHNNEL_MAX_WIDTH	2048
+#define TX_ISP_DS1_CAHNNEL_MAX_HEIGHT	1536
+#define TX_ISP_DS2_CAHNNEL_MAX_WIDTH	800
+#define TX_ISP_DS2_CAHNNEL_MAX_HEIGHT	800
+
+#elif defined(CONFIG_SOC_T30)
+/* T30 */
+#define TX_ISP_EXIST_FR_CHANNEL 1
+#define TX_ISP_EXIST_DS2_CHANNEL 0
+
+#define TX_ISP_INPUT_PORT_MAX_WIDTH		2688
+#define TX_ISP_INPUT_PORT_MAX_HEIGHT	2048
+#define TX_ISP_FR_CAHNNEL_MAX_WIDTH		2688
+#define TX_ISP_FR_CAHNNEL_MAX_HEIGHT	2048
+#define TX_ISP_DS1_CAHNNEL_MAX_WIDTH	1920
+#define TX_ISP_DS1_CAHNNEL_MAX_HEIGHT	1080
+
+#else /* other soc */
+
+#endif
+
+/***************************************************
+*  Provide extensions to v4l2 for ISP driver.
+****************************************************/
+#define V4L2_PIX_FMT_RGB310   v4l2_fourcc('R', 'G', 'B', 'A') /* 32  RGB-10-10-10  */
+#define V4L2_MBUS_FMT_RGB888_3X8_LE (V4L2_MBUS_FMT_Y8_1X8 - 0x10)
+
+/*
+*------ definition sensor associated structure -----
+*/
+
+/* define control bus */
+enum tx_sensor_control_bus_type{
+	TX_SENSOR_CONTROL_INTERFACE_I2C = 1,
+	TX_SENSOR_CONTROL_INTERFACE_SPI,
+};
+struct tx_isp_i2c_board_info {
+	char type[I2C_NAME_SIZE];
+	int addr;
+//	struct i2c_board_info board_info;
+	int i2c_adapter_id;
+};
+
+struct tx_isp_spi_board_info {
+	char modalias[SPI_NAME_SIZE];
+	int bus_num;
+//	struct spi_board_info board_info;
+};
+
+/* define data bus */
+enum tx_sensor_data_bus_type{
+	TX_SENSOR_DATA_INTERFACE_MIPI = 1,
+	TX_SENSOR_DATA_INTERFACE_DVP,
+	TX_SENSOR_DATA_INTERFACE_BT601,
+	TX_SENSOR_DATA_INTERFACE_BT656,
+	TX_SENSOR_DATA_INTERFACE_BT1120,
+};
+
+typedef enum {
+	DVP_PA_LOW_10BIT,
+	DVP_PA_HIGH_10BIT,
+	DVP_PA_12BIT,
+	DVP_PA_LOW_8BIT,
+	DVP_PA_HIGH_8BIT,
+} sensor_dvp_gpio_mode;
+
+typedef enum {
+	SENSOR_DVP_HREF_MODE,
+	SENSOR_DVP_HSYNC_MODE,
+	SENSOR_DVP_SONY_MODE,
+} sensor_dvp_timing_mode;
+
+typedef enum {
+	ISP_CLK_960P_MODE = 60000000,
+	ISP_CLK_1080P_MODE = 90000000,
+	ISP_CLK_3M_MODE = 100000000,
+} isp_clk_mode;
+
+typedef enum {
+	TX_SENSOR_MAX_FPS_30 = 30,
+	TX_SENSOR_MAX_FPS_25 = 25,
+	TX_SENSOR_MAX_FPS_15 = 15,
+	TX_SENSOR_MAX_FPS_12 = 12,
+	TX_SENSOR_MAX_FPS_10 = 10,
+	TX_SENSOR_MAX_FPS_5 = 5,
+} sensor_max_fps_mode;
+
+enum tx_isp_dvp_polarity {
+	DVP_POLARITY_DEFAULT,
+	DVP_POLARITY_HIGH,
+	DVP_POLARITY_LOW,
+};
+
+typedef struct {
+	unsigned short vblanking;
+	unsigned short hblanking;
+} sensor_dvp_blanking;
+
+typedef struct {
+	unsigned char hsync_polar;
+	unsigned char vsync_polar;
+	unsigned char pclk_polar;
+} sensor_dvp_polar;
+
+struct tx_isp_mipi_bus{
+	unsigned int clk;
+	unsigned char lans;
+};
+
+struct tx_isp_dvp_bus{
+	sensor_dvp_gpio_mode gpio;
+	sensor_dvp_timing_mode mode;
+	sensor_dvp_blanking blanking;
+	sensor_dvp_polar polar;
+};
+
+struct tx_isp_bt1120_bus{
+};
+struct tx_isp_bt656_bus{
+};
+struct tx_isp_bt601_bus{
+};
+
+/* define sensor attribute */
+
+#define TX_ISP_SENSOR_PREVIEW_RES_MAX_FPS 	1
+#define TX_ISP_SENSOR_FULL_RES_MAX_FPS 		2
+
+struct v4l2_tx_isp_sensor_register_info{
+	char name[32];
+	enum tx_sensor_control_bus_type cbus_type;
+	union {
+		struct tx_isp_i2c_board_info i2c;
+		struct tx_isp_spi_board_info spi;
+	};
+	unsigned short rst_gpio;
+	unsigned short pwdn_gpio;
+	unsigned short power_gpio;
+};
+
+typedef struct tx_isp_sensor_ctrl{
+	/* isp_gain mean that the value is output of ISP-FW,it is not a gain multiplier unit.
+	*  gain_mutiplier = (2^(isp_gain/(2^LOG_GAIN_SHIFT))).
+	*  the fuction will convert gain_mutiplier to sensor_Xgain.
+	*  the return value is isp_gain of sensor_Xgain's inverse conversion.
+	*/
+	unsigned int (*alloc_again)(unsigned int isp_gain, unsigned char shift, unsigned int *sensor_again);
+	unsigned int (*alloc_dgain)(unsigned int isp_gain, unsigned char shift, unsigned int *sensor_dgain);
+} TX_ISP_SENSOR_CTRL;
+
+#define TX_ISP_GAIN_FIXED_POINT 16
+struct tx_isp_sensor_attribute{
+	const char *name;
+	unsigned int chip_id;
+	enum tx_sensor_control_bus_type cbus_type;
+	unsigned int cbus_mask;
+	unsigned int cbus_device;
+	enum tx_sensor_data_bus_type dbus_type;
+	union {
+		struct tx_isp_mipi_bus 		mipi;
+		struct tx_isp_dvp_bus 		dvp;
+		struct tx_isp_bt1120_bus 	bt1120;
+		struct tx_isp_bt656_bus		bt656bus;
+		struct tx_isp_bt601_bus		bt601bus;
+		char string[64];
+	};
+	unsigned int max_again;	//the format is .16
+	unsigned int max_dgain;	//the format is .16
+	unsigned int again;
+	unsigned int dgain;
+	unsigned short min_integration_time;
+	unsigned short min_integration_time_native;
+	unsigned short max_integration_time_native;
+	unsigned short integration_time_limit;
+	unsigned int integration_time;
+	unsigned short total_width;
+	unsigned short total_height;
+	unsigned short max_integration_time;
+	unsigned short integration_time_apply_delay;
+	unsigned short again_apply_delay;
+	unsigned short dgain_apply_delay;
+	unsigned short one_line_expr_in_us;
+	TX_ISP_SENSOR_CTRL sensor_ctrl;
+	void *priv; /* point to struct tx_isp_sensor_board_info */
+};
+
+/* define common struct */
+enum tx_isp_priv_ioctl_direction {
+	TX_ISP_PRIVATE_IOCTL_SET,
+	TX_ISP_PRIVATE_IOCTL_GET,
+};
+enum tx_isp_priv_ioctl_command {
+	/* the commands of pipeline are defined as follows. */
+	TX_ISP_PRIVATE_IOCTL_MODULE_CLK,
+	TX_ISP_PRIVATE_IOCTL_SYNC_VIDEO_IN,
+	/* the commands of sensor are defined as follows. */
+	TX_ISP_PRIVATE_IOCTL_SENSOR_INT_TIME,
+	TX_ISP_PRIVATE_IOCTL_SENSOR_AGAIN,
+	TX_ISP_PRIVATE_IOCTL_SENSOR_DGAIN,
+	TX_ISP_PRIVATE_IOCTL_SENSOR_FPS,
+	TX_ISP_PRIVATE_IOCTL_SENSOR_BLACK_LEVEL,
+	TX_ISP_PRIVATE_IOCTL_SENSOR_WDR,
+	TX_ISP_PRIVATE_IOCTL_SENSOR_RESIZE,
+	TX_ISP_PRIVATE_IOCTL_SUBDEV_PREPARE_CHANGE,
+	TX_ISP_PRIVATE_IOCTL_SUBDEV_FINISH_CHANGE,
+	/* the commands of frame-channel are defined as follows. */
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_BYPASS_ISP,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_ENUM_FMT,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_TRY_FMT,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_FMT,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_CROP_CAP,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_CROP,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SCALER_CAP,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_SCALER,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_STREAM_ON,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_STREAM_OFF,
+	TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_QUEUE_BUFFER,
+};
+struct isp_private_ioctl {
+	enum tx_isp_priv_ioctl_direction dir;
+	enum tx_isp_priv_ioctl_command cmd;
+	int value;
+};
+
+struct frame_image_scalercap {
+	unsigned short max_width;
+	unsigned short max_height;
+	unsigned short min_width;
+	unsigned short min_height;
+};
+struct frame_image_scaler {
+	unsigned short out_width;
+	unsigned short out_height;
+};
+
+/* isp image tuning */
+struct isp_image_tuning_default_ctrl {
+	enum tx_isp_priv_ioctl_direction dir;
+	struct v4l2_control control;
+};
+
+#define VIDIOC_ISP_PRIVATE_IOCTL	 _IOW('V', BASE_VIDIOC_PRIVATE, struct isp_private_ioctl)
+#define VIDIOC_REGISTER_SENSOR		 _IOW('V', BASE_VIDIOC_PRIVATE + 1, struct v4l2_tx_isp_sensor_register_info)
+#define VIDIOC_RELEASE_SENSOR		 _IOW('V', BASE_VIDIOC_PRIVATE + 2, struct v4l2_tx_isp_sensor_register_info)
+//#define VIDIOC_DEFAULT_CMD_BYPASS_ISP	 _IOW('V', BASE_VIDIOC_PRIVATE + 3, int)
+#define VIDIOC_DEFAULT_CMD_SCALER_CAP	 _IOWR('V', BASE_VIDIOC_PRIVATE + 3, struct frame_image_scalercap)
+#define VIDIOC_DEFAULT_CMD_SET_SCALER	 _IOW('V', BASE_VIDIOC_PRIVATE + 4, struct frame_image_scaler)
+#define VIDIOC_DEFAULT_CMD_SET_BANKS	 _IOW('V', BASE_VIDIOC_PRIVATE + 5, int)
+
+#define VIDIOC_DEFAULT_CMD_ISP_TUNING	 _IOWR('V', BASE_VIDIOC_PRIVATE + 6, struct isp_image_tuning_default_ctrl)
+
+enum tx_isp_vidioc_default_command {
+	TX_ISP_VIDIOC_DEFAULT_CMD_BYPASS_ISP,
+	TX_ISP_VIDIOC_DEFAULT_CMD_SCALER_CAP,
+	TX_ISP_VIDIOC_DEFAULT_CMD_SET_SCALER,
+};
+
+enum tx_isp_frame_channel_bypass_isp{
+	TX_ISP_FRAME_CHANNEL_BYPASS_ISP_DISABLE,
+	TX_ISP_FRAME_CHANNEL_BYPASS_ISP_ENABLE,
+};
+
+enum {
+	TX_ISP_STATE_STOP,
+	TX_ISP_STATE_START,
+	TX_ISP_STATE_RUN,
+};
+
+enum {
+	TX_ISP_PAD_SOURCE,
+	TX_ISP_PAD_LINK,
+	TX_ISP_PADS_NUM,
+};
+
+struct tx_isp_video_in {
+	struct v4l2_mbus_framefmt mbus;
+	struct tx_isp_sensor_attribute *attr;
+	unsigned int vi_max_width;	//the max width of sensor output setting
+	unsigned int vi_max_height;	//the max height of sensor output setting
+	unsigned int fps;
+	int grp_id;
+};
+
+enum tx_isp_notify_statement {
+	TX_ISP_NOTIFY_LINK_SETUP = 0x10,
+	TX_ISP_NOTIFY_LINK_DESTROY,
+};
+
+enum tx_isp_notification {
+	TX_ISP_NOTIFY_GET_PIPELINE,
+	TX_ISP_NOTIFY_SYNC_VIDEO_IN,
+	TX_ISP_NOTIFY_ENABLE_IRQ,
+	TX_ISP_NOTIFY_DISABLE_IRQ,
+	TX_ISP_NOTIFY_MASK_IRQ,
+	TX_ISP_NOTIFY_UNMASK_IRQ,
+	TX_ISP_NOTIFY_PRIVATE_IOCTL,
+};
+
+struct tx_isp_notify_argument{
+	int value;
+	int ret;
+};
+
+/***************************************
+* some structs about pipeline of isp.
+***************************************/
+#if 1
+struct tx_isp_media_pipeline;
+
+/*
+ * Media pipeline operations to be called from within a video node,  i.e. the
+ * last entity within the pipeline. Implemented by related media device driver.
+ */
+struct tx_isp_media_pipeline_ops {
+	int (*prepare)(struct tx_isp_media_pipeline *p);// struct tx_isp_video_in *vin);
+	int (*unprepare)(struct tx_isp_media_pipeline *p);
+	int (*reset)(struct tx_isp_media_pipeline *p, int state);
+	int (*init)(struct tx_isp_media_pipeline *p, int state);
+	int (*set_stream)(struct tx_isp_media_pipeline *p, int state);
+};
+
+#define tx_isp_pipeline_call(ent, op, args...)				  \
+	(!(ent) ? -ENOENT : (((ent)->ops && (ent)->ops->op) ? \
+	(ent)->ops->op(((ent)), ##args) : -ENOIOCTLCMD))
+
+#endif
+
+#define tx_isp_sd_notify(ent, args...)				  \
+	(!(ent) ? -ENOENT : (((ent)->v4l2_dev && (ent)->v4l2_dev->notify) ? \
+	(ent)->v4l2_dev->notify(((ent)), ##args) : -ENOIOCTLCMD))
+/*
+ * This structure represents a chain of media entities, including a data
+ * source entity (e.g. an image sensor subdevice), a data capture entity
+ * - a video capture device node and any remaining entities.
+ */
+struct tx_isp_media_pipeline {
+	struct media_pipeline mp;
+	const struct tx_isp_media_pipeline_ops *ops;
+	struct v4l2_subdev *subdevs[TX_ISP_MAX_GRP_IDX];
+};
+
+#define to_tx_isp_pipeline(_ep) container_of(_ep, struct tx_isp_pipeline, ep)
+
+struct tx_isp_sensor{
+	struct v4l2_subdev sd;
+	int index;
+	unsigned int type;
+	struct list_head list;
+	struct v4l2_tx_isp_sensor_register_info info;
+	struct tx_isp_sensor_attribute attr;
+	struct tx_isp_video_in video;
+	struct clk *mclk;
+	void *priv;
+};
+
+#define tx_isp_readl(base, reg)		__raw_readl((base) + (reg))
+#define tx_isp_writel(base, reg, value)		__raw_writel((value), ((base) + (reg)))
+#define tx_isp_readw(base, reg)		__raw_readw((base) + (reg))
+#define tx_isp_writew(base, reg, value)		__raw_writew((value), ((base) + (reg)))
+#define tx_isp_readb(base, reg)		__raw_readb((base) + (reg))
+#define tx_isp_writeb(base, reg, value)		__raw_writeb((value), ((base) + (reg)))
+
+
+/* these structs are private */
+struct tx_isp_driver_fh {
+	enum v4l2_priority prio;
+};
+
+#endif /*__TX_ISP_COMMON_H__*/
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/include/tx-vic-regs.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/tx-vic-regs.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/include/tx-vic-regs.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/include/tx-vic-regs.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,199 @@
+#ifndef __VIC_REG_H__
+#define __VIC_REG_H__
+
+#ifdef CONFIG_SOC_T10
+#define VIC_SUPPORT_MIPI                0
+#define VIC_DB_CFG		         0x0
+#define DVP_DATA_POS			(1<<24)
+#define DVP_RGB_ORDER			(1<<21)
+#define DVP_RAW_ALIG			(1<<20)
+#define DVP_DATA_TYPE			(17)
+#define DVP_RAW8			(0<<DVP_DATA_TYPE)
+#define DVP_RAW10			(1<<DVP_DATA_TYPE)
+#define DVP_RAW12			(2<<DVP_DATA_TYPE)
+#define DVP_YUV422_16BIT		(3<<DVP_DATA_TYPE)
+#define DVP_RGB565_16BIT		(4<<DVP_DATA_TYPE)
+#define DVP_BRG565_16BIT		(5<<DVP_DATA_TYPE)
+#define DVP_YUV422_8BIT			(6<<DVP_DATA_TYPE)
+#define DVP_RGB565_8BIT			(7<<DVP_DATA_TYPE)
+#define DVP_HREF_MODE		(0 << 15)
+#define DVP_HSYNC_MODE		(1 << 15)
+#define DVP_SONY_MODE		(2 << 15)
+
+#define DVP_TIMEING_MODE		(1<<15)
+#define BT_INTF_WIDE			(1<<11)
+#define BT_LINE_MODE			(1<<10)
+#define BT_601_TIMING_MODE		(1<<9)
+#define YUV_DATA_ORDER			(4)
+#define UYVY				(0<<YUV_DATA_ORDER)
+#define VYUY				(1<<YUV_DATA_ORDER)
+#define YUYV				(2<<YUV_DATA_ORDER)
+#define YVYU				(3<<YUV_DATA_ORDER)
+#define FIRST_FIELD_TYPE		(1<<3)
+#define INTERLACE_EN			(1<<2)
+#define HSYN_POLAR			(1<<1)
+#define VSYN_POLAR			(1<<0)
+
+#define VIC_INPUT_HSYNC_BLANKING	0x04
+#define VIC_INPUT_VSYNC_BLANKING	0x08
+
+/* #define VIC_VCNT0                       0x0C */
+/* #define VIC_VCNY1                       0x10 */
+/* #define VIC_VCNY2                       0x14 */
+
+/* #define VIC_INTF_TYPE                   0x1C */
+/* #define INTF_TYPE_BT656			0x0 */
+/* #define INTF_TYPE_BT601			0x1 */
+/* #define INTF_TYPE_MIPI			0x2 */
+/* #define INTF_TYPE_DVP			0x3 */
+/* #define INTF_TYPE_BT1120		0x4 */
+
+#define VIC_RESOLUTION	 	        0x0C
+#define H_RESOLUTION			(1<<16)
+#define V_RESOLUTION			(1)
+
+#define VIC_H_BLANK_NUM		        (0x10)
+#define VIC_V_BLANK_NUM		        (0x14)
+
+#define VIC_AB_VALUE		        (0x18)
+#define A_VALUE				(1<<16)
+#define B_VALUE				(1)
+
+#define VIC_GLOBAL_CFG             	(0x1c)
+#define ISP_PRESET_MODE1		(0<<5)
+#define ISP_PRESET_MODE2		(1<<5)
+#define ISP_PRESET_MODE3		(2<<5)
+#define VCKE_EN				(1<<4)
+#define BLANK_EN			(2)
+#define AB_MODE_SELECT			(0)
+
+#define VIC_CONTROL			(0x20)
+#define VIC_RESET			(1<<4)
+#define GLB_SAFE_RST			(1<<3)
+#define GLB_RST				(1<<2)
+#define REG_ENABLE			(1<<1)
+#define VIC_SRART			(1<<0)
+
+#define ISP_VPLCK_GATE                  0x24
+#define VIC_PIXEL			0x28
+#define VIC_LINE			0x2c
+#define VIC_STATE			0x30
+#define VIC_OFIFO_COUNT			0x34
+#define VIC_FLASH_STROBE		0x38
+#define VIC_FIRST_CB			0x48
+#define VIC_SECOND_CB			0x4c
+#define VIC_THIRD_CB			0x50
+#define VIC_FOURTH_CB			0x54
+#define VIC_FIFTH_CB			0x58
+#define VIC_SIXTH_CB			0x5c
+#define VIC_SEVENTH_CB			0x60
+#define VIC_EIGHTH_CB			0x64
+#define CB_MODE0			0x68
+#define CB_MODE1			0x6c
+#define BK_NUM_CB1			0x70
+
+#elif (defined(CONFIG_SOC_T20) || defined(CONFIG_SOC_T30))
+#define VIC_SUPPORT_MIPI                1
+#define VIC_DB_CFG		        0x10
+#define DVP_DATA_POS			(1<<24)
+#define DVP_RGB_ORDER			(1<<21)
+#define DVP_RAW_ALIG			(1<<20)
+#define DVP_DATA_TYPE			(17)
+#define DVP_RAW8			(0<<DVP_DATA_TYPE)
+#define DVP_RAW10			(1<<DVP_DATA_TYPE)
+#define DVP_RAW12			(2<<DVP_DATA_TYPE)
+#define DVP_YUV422_16BIT		(3<<DVP_DATA_TYPE)
+#define DVP_RGB565_16BIT		(4<<DVP_DATA_TYPE)
+#define DVP_BRG565_16BIT		(5<<DVP_DATA_TYPE)
+#define DVP_YUV422_8BIT			(6<<DVP_DATA_TYPE)
+#define DVP_RGB565_8BIT			(7<<DVP_DATA_TYPE)
+
+#define DVP_TIMEING_MODE		(1<<15)
+#define DVP_SONY_MODE		        (2 << 15)
+#define BT_INTF_WIDE			(1<<11)
+#define BT_LINE_MODE			(1<<10)
+#define BT_601_TIMING_MODE		(1<<9)
+#define YUV_DATA_ORDER			(4)
+#define UYVY				(0<<YUV_DATA_ORDER)
+#define VYUY				(1<<YUV_DATA_ORDER)
+#define YUYV				(2<<YUV_DATA_ORDER)
+#define YVYU				(3<<YUV_DATA_ORDER)
+#define FIRST_FIELD_TYPE		(1<<3)
+#define INTERLACE_EN			(1<<2)
+#define HSYN_POLAR			(1<<1)
+#define VSYN_POLAR			(1<<0)
+
+#define VIC_HCNT0                       0x04
+#define VIC_HCNT1                       0x08
+
+/* #define VIC_VCNT0                       0x0C */
+/* #define VIC_VCNY1                       0x10 */
+/* #define VIC_VCNY2                       0x14 */
+
+#define VIC_INTF_TYPE                   0x0C
+#define INTF_TYPE_BT656			0x0
+#define INTF_TYPE_BT601			0x1
+#define INTF_TYPE_MIPI			0x2
+#define INTF_TYPE_DVP			0x3
+#define INTF_TYPE_BT1120		0x4
+
+#define VIC_RESOLUTION	 	        0x04
+#define H_RESOLUTION			(1<<16)
+#define V_RESOLUTION			(1)
+
+/* #define VIC_H_BLANK_NUM		        (0x10) */
+/* #define VIC_V_BLANK_NUM		        (0x14) */
+
+#define VIC_IDI_TYPE                    (0x14)/* VIC_INPUT_MIPI */
+#define MIPI_RAW8			0x0
+#define MIPI_RAW10			0x1
+#define MIPI_RAW12			0x2
+#define MIPI_RGB555			0x3
+#define MIPI_RGB565			0x4
+#define MIPI_RGB666			0x5
+#define MIPI_RGB888			0x6
+#define MIPI_YUV422			0x7
+#define MIPI_YUV422_10BIT		0x8
+
+#define VIC_AB_VALUE		        (0x18)
+#define A_VALUE				(1<<16)
+#define B_VALUE				(1)
+
+#define VIC_GLOBAL_CFG             	(0x50)
+#define ISP_PRESET_MODE1		(0<<5)
+#define ISP_PRESET_MODE2		(1<<5)
+#define ISP_PRESET_MODE3		(2<<5)
+#define VCKE_EN				(1<<4)
+#define BLANK_EN			(2)
+#define AB_MODE_SELECT			(0)
+
+#define VIC_CONTROL			(0x0)
+#define VIC_RESET			(1<<4)
+#define GLB_SAFE_RST			(1<<3)
+#define GLB_RST				(1<<2)
+#define REG_ENABLE			(1<<1)
+#define VIC_SRART			(1<<0)
+
+#define ISP_VPLCK_GATE                  0x24
+#define VIC_PIXEL			0x94
+#define VIC_LINE			0x98
+#define VIC_STATE			0x90
+#define VIC_OFIFO_COUNT			0x9c
+#define VIC_FLASH_STROBE		0x100
+#define VIC_FIRST_CB			0xc0
+#define VIC_SECOND_CB			0xc4
+#define VIC_THIRD_CB			0xc8
+#define VIC_FOURTH_CB			0xCC
+#define VIC_FIFTH_CB			0xD0
+#define VIC_SIXTH_CB			0xD4
+#define VIC_SEVENTH_CB			0xD8
+#define VIC_EIGHTH_CB			0xDC
+#define CB_MODE0			0xb0
+#define CB_MODE1			0xa0
+#define BK_NUM_CB1			0xb4
+
+#define VIC_INPUT_HSYNC_BLANKING 0x20
+#define VIC_INPUT_VSYNC_BLANKING 0x3c
+
+#endif/* CONFIG_SOC_T10 */
+#endif/* __VIC_REG_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/libapical_isp.a kernel-3.10.14_mod/drivers/media/platform/tx-isp/libapical_isp.a
--- kernel-3.10.14/drivers/media/platform/tx-isp/libapical_isp.a	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/libapical_isp.a	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,745 @@
+!<arch>
+/               1510573749  0     0     0       12330     `
+    3j  3j  3j  3j  3j  3j  3j  3j  3j  F  F  F  F  F  F  F  a  a  a  a  a  a  a  a  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ  pZ      v  v  v                                                ^  ^  ~  >  >  >  >  >  >  >  >  >  >  2  2  2  *  *  *  *  *  *                                                                                                                                                             > > > > > > > > > > > > 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+             N N N N N N N N N N N N N N N N N N N N N N NV NV NV NV NV NV NV NV NV NV NV NV NV NV NV NV NV NV q q q q q        * * * *         : : : : : : :                                    !d !d !d !d !d - - - - : : : : : : WT WT WT | | |                          | | | | | | | | | |           x x x x x @ @ @ @ @      'X 'X 'X 'X 'X . . . . . 7h 7h 7h 7h 7hapical_get_fw apical_init_calibrations init_stab stab apical_process apical_init apical_frame_buffer_configure_temper apical_frame_buffer_configure_all apical_change_resolution apical_get_current_isp_index load_isp_sequence apical_fw_interrupts_init apical_fw_init apical_fw_process apical_fw_raise_event apical_isp_raise_event calc_modulation_u16 calc_modulation_u32 calc_adjust_modulation_u16 calc_scaled_modulation_u16 calc_equidistant_modulation_u16 calc_equidistant_modulation_u32 calc_inv_equidistant_modulation_u16 calc_inv_equidistant_modulation_u32 leading_one_position log2_int_to_fixed log2_fixed_to_fixed math_exp2 _pow2_lut sqrt32 sqrt16 log16 multiplication_fixed_to_fixed math_log2 solving_lin_equation_a solving_lin_equation_b div_fixed solving_nth_root_045 line_offset apical_cosine cos_table apical_sine apical_event_queue_push apical_event_queue_pop apical_loop_buffer_init apical_loop_buffer_read_u8 apical_loop_buffer_write_u8 apical_pbuf_start_read apical_pbuf_end_read apical_pbuf_start_write apical_pbuf_end_write mem_read_u16 mem_read_u32 mem_write_u16 mem_write_u32 apical_sbus_read_u8 apical_sbus_read_u16 apical_sbus_read_u32 apical_sbus_read_data_u8 apical_sbus_read_data_u16 apical_sbus_read_data_u32 apical_sbus_write_u8 apical_sbus_write_u16 apical_sbus_write_u32 apical_sbus_write_data_u8 apical_sbus_write_data_u16 apical_sbus_write_data_u32 apical_sbus_write_data apical_sbus_copy apical_sbus_isp_init apical_sbus_i2c_init i2c_init_access apical_sbus_spi_init sensor_calibration_date sensor_no iridix_unlimit_strength_maximum_linear iridix_low_strength_maximum_linear iridix_medium_strength_maximum_linear iridix_high_strength_maximum_linear iridix_unlimit_ev_lim_no_str_linear iridix_low_ev_lim_no_str_linear iridix_medium_ev_lim_no_str_linear iridix_high_ev_lim_no_str_linear apical_connection_init apical_connection_destroy apical_connection_process sequence_read_u16 sequence_read_u32 sequence_write_u16 sequence_write_u32 sensor_load_binary_sequence sensor_load_array_sequence APICAL_READ_32 APICAL_READ_16 APICAL_READ_8 APICAL_WRITE_32 APICAL_WRITE_16 APICAL_WRITE_8 apical_wdr_fs_isp_setup apical_cmd_process get_apical_api_buffer selftest_sensor_id selftest_sensor_interface selftest_isp_interface system_freeze_firmware system_manual_exposure system_manual_exposure_ratio system_manual_integration_time system_manual_sensor_analog_gain system_manual_sensor_digital_gain system_manual_isp_digital_gain system_manual_directional_sharpening system_manual_un_directional_sharpening system_manual_iridix system_dis_x system_dis_y system_manual_sinter system_manual_temper system_manual_awb system_slow_frame_rate_enable system_manual_saturation system_manual_exposure_time system_exposure_dark_target system_exposure_bright_target system_exposure_ratio system_max_exposure_ratio system_integration_time system_max_integration_time system_sensor_analog_gain system_max_sensor_analog_gain system_sensor_digital_gain system_max_sensor_digital_gain system_isp_digital_gain system_max_isp_digital_gain system_directional_sharpening_target system_maximum_directional_sharpening system_minimum_directional_sharpening system_un_directional_sharpening_target system_maximum_un_directional_sharpening system_minimum_un_directional_sharpening system_iridix_strength_target system_maximum_iridix_strength system_minimum_iridix_strength system_sinter_threshold_target system_maximum_sinter_strength system_minimum_sinter_strength system_temper_threshold_target system_maximum_temper_strength system_minimum_temper_strength system_awb_red_gain system_awb_blue_gain system_saturation_target system_anti_flicker_frequency system_ae_compensation system_calibrate_bad_pixels selftest_lens_interface selftest_isp_revision selftest_fw_revision selftest_api_revision selftest_calibration_revision isp_system_state system_sensor_select test_pattern_enable test_pattern fr_pipe_status ds1_pipe_status ds2_pipe_status system_frame_buffer resolution_active_image fps_mode set_sensor_fps dvi_output image_resize_enable image_resize_width image_resize_height image_crop_xoffset image_crop_yoffset sd_capture_frames sd_capture_run wdr_mode histogram_lum apical_api_buffer_data_size af_mode af_range_low af_range_high af_roi af_status ae_mode ae_split_preset ae_gain ae_exposure ae_roi ae_compensation ae_freeze ae_integrator_set get_awb_idx awb_mode awb_red_gain awb_blue_gain awb_temperature awb_roi awb_range_low awb_range_high flash_mode flash_time awb_freeze antiflicker_mode iridix iridix_strength dis_mode sinter sinter_strength temper temper_strength defect_pixel register_address register_size register_source register_value scene_mode sharpening_mode sharpening_strength fr_output_mode ds1_output_mode ds2_output_mode brightness_strength contrast_strength saturation_strength antifog_mode antifog_set_preset orientation_hflip orientation_vflip color_mode exposure_log2 gain_log2 apical_api_read_buffer apical_sensor_calibration_update get_calibration_description buffer_data_type apical_api_calibration sensor_sync_get_output_resolution apply_dvi_sync_param apply_dvi_fpga_sync_param sensor_init_output sensor_hw_init sensor_update_black sensor_sw_init sensor_load_vars sensor_start_calibrate sensor_stop_calibrate sensor_fps_change sensor_get_lines_second _process_fps_cnt _init_fps_cnt cmos_get_fps cmos_alloc_integration_time cmos_alloc_sensor_analog_gain cmos_alloc_sensor_digital_gain cmos_alloc_isp_digital_gain cmos_get_manual_again_log2 cmos_get_manual_dgain_log2 cmos_get_manual_isp_dgain_log2 cmos_convert_integration_time_ms2lines cmos_update_exposure_partitioning_lut exposure_partitions_balanced exposure_partition_int_priority cmos_init cmos_get_lines_per_second cmos_get_frame_exposure_set cmos_update_exposure_history cmos_move_exposure_history cmos_fsm_process_interrupt cmos_inttime_update cmos_analog_gain_update cmos_digital_gain_update get_quantised_integration_time get_quantised_long_integration_time cmos_antiflicker_update cmos_long_exposure_update cmos_calc_target_gain cmos_update_wdr_mode cmos_set_exposure_target defect_pixel_table_read defect_pixel_table_write defect_pixel_initialize defect_pixel_update ae_initialize ae_read_full_histogram_data AE_fsm_process_interrupt ae_calculate_exposure_ratio ae_calculate_target set_integrator_ae ae_calculate_exposure ae_exposure_correction fifo_push get_point interpl init_interp_2d_point get_index init_interp_2d_point_LUT AWB_mesh_LUT mesh_AWB_getKnownSourceLight_weight_LUT awb_coeffs_write awb_init awb_set_identity awb_read_statistics AWB_fsm_process_interrupt awb_zones_calculate compute_weight awb_calc_avg_weighted_gr_gb_mesh awb_calc_avg_weighted_gr_gb awb_process_temp_and_shift awb_detect_light_source awb_process_light_source awb_update awb_normalise mesh_shading_modulate_strength saturation_modulate_strength color_matrix_fsm_process_interrupt matrix_matrix_multiply matrix_vector_multiply complement_to_direct direct_to_complement color_matrix_recalculate color_matrix_setup shading_mesh_reload shading_mesh_load is_yuv_format shading_mesh_init color_matrix_write color_matrix_update color_matrix_change_CCMs color_matrix_initialize alpha_delta iridix_fsm_process_interrupt iridix_init_pre_post_gamma iridix_initialize iridix_control_strength_calculate iridix_update dynamic_dpc_strength_calculate stitching_error_calculate sinter_strength_calculate temper_strength_calculate noise_reduction_hw_init noise_reduction_initialize noise_reduction_update au_read_histogram setup_parameters_to_default sharpening_initialize sharpening_update flash_initialize flash_processing _update_ds _update_ds2 _update_fr crop_fsm_process_interrupt crop_resolution_changed crop_initialize apical_switch_wdr_mode general_initialize general_frame_start general_frame_end general_fsm_process_interrupt calc_fe_lut_output calc_fe_lut_input dis_initialize dis_update_stats dis_update_settings dis_update_output dis_analyze_stats dis_fsm_process_interrupt exp_lut_16fx exp_lut_8fx exp_lut_4fx exp_lut_2fx dis_get_default_settings dis_reset dis_set_settings dis_get_settings dis_check_settings dis_open dis_close dis_clip_gmv_vector dis_analyze dis_update_bg_map get_common_estimations validate_smooth_test validate_complexity_test validate_borders validate_motion_vectors get_exp get_gmv_gauss_init get_gmv_gauss_method_fast_v1 get_gmv_gauss_method_fast_v2 get_gmv_gauss_method_fast_v3 iir_filter_reset iir_filter_v2 iir_filter_v4 iir_filter_v3 update_composite_matrix compute_transfrom_matrix matrix_yuv_recompute matrix_yuv_coefft_write_to_hardware matrix_yuv_update matrix_yuv_initialize GET_API2FRM_IDX apical_api_init_idx_array apical_command apical_isp_init apical_isp_process_interrupt apical_isp_process_events sensor_fsm_clear sensor_request_interrupt sensor_fsm_switch_state sensor_fsm_process_state sensor_fsm_process_event cmos_fsm_clear cmos_request_interrupt cmos_fsm_switch_state cmos_fsm_process_state cmos_fsm_process_event defect_pixel_fsm_clear defect_pixel_request_interrupt defect_pixel_fsm_switch_state defect_pixel_fsm_process_state defect_pixel_fsm_process_event AE_fsm_clear AE_request_interrupt AE_fsm_switch_state AE_fsm_process_state AE_fsm_process_event AWB_fsm_clear AWB_request_interrupt AWB_fsm_switch_state AWB_fsm_process_state AWB_fsm_process_event color_matrix_fsm_clear color_matrix_request_interrupt color_matrix_fsm_switch_state color_matrix_fsm_process_state color_matrix_fsm_process_event iridix_fsm_clear iridix_request_interrupt iridix_fsm_switch_state iridix_fsm_process_state iridix_fsm_process_event noise_reduction_fsm_clear noise_reduction_request_interrupt noise_reduction_fsm_switch_state noise_reduction_fsm_process_state noise_reduction_fsm_process_event sharpening_fsm_clear sharpening_request_interrupt sharpening_fsm_switch_state sharpening_fsm_process_state sharpening_fsm_process_event flash_fsm_clear flash_request_interrupt flash_fsm_switch_state flash_fsm_process_state flash_fsm_process_event crop_fsm_clear crop_request_interrupt crop_fsm_switch_state crop_fsm_process_state crop_fsm_process_event general_fsm_clear general_request_interrupt general_fsm_switch_state general_fsm_process_state general_fsm_process_event dis_fsm_clear dis_request_interrupt dis_fsm_switch_state dis_fsm_process_state dis_fsm_process_event matrix_yuv_fsm_clear matrix_yuv_request_interrupt matrix_yuv_fsm_switch_state matrix_yuv_fsm_process_state matrix_yuv_fsm_process_event //                                              704       `
+apical_modulation.c.o/
+apical_event_queue.c.o/
+apical_loop_buf.c.o/
+apical_sbus_isp.c.o/
+apical_sbus_i2c.c.o/
+apical_sbus_spi.c.o/
+apical_connection.c.o/
+apical_isp_io.c.o/
+apical_wdr_fs.c.o/
+apical_cmd_interface.c.o/
+apical_command_api_impl.c.o/
+defect_pixel_func.c.o/
+ae_balanced_func.c.o/
+awb_mesh_NBP_func.c.o/
+color_matrix_func.c.o/
+iridix_hist_func.c.o/
+noise_reduction_func.c.o/
+sharpening_func.c.o/
+general_func.c.o/
+dis_gauss_lut.c.o/
+dis_validation.c.o/
+dis_gauss_method.c.o/
+matrix_yuv_func.c.o/
+apical_command_api.c.o/
+defect_pixel_fsm.c.o/
+ae_balanced_fsm.c.o/
+awb_mesh_NBP_fsm.c.o/
+color_matrix_fsm.c.o/
+iridix_hist_fsm.c.o/
+noise_reduction_fsm.c.o/
+sharpening_fsm.c.o/
+matrix_yuv_fsm.c.o/
+apical.c.o/     1510573706  0     0     100644  4728      `
+ELF                      P   P4     (               '   <  1&$ 	    <$$(E   &	 $	  
+$<  4!   
+$$(E     '  <   B$'  <  B$  	@ !  @  < $  $ V!      $!       y$   '  <  @ $  B$ C2 $4 C $ Cu $ C  $! C$ @ @ @ @ @ @ @	 @
+ @ @ @ @ @ @ @ @  @" @% @ @( @+ @. @1 C2 C3 @5 C6 @8 @ : @  <  <  9'    $'  <   B$	@ !     <  B$	@  $  <  B$	@       <  <  B$	@   $  <  B$	@       <  B$	@       <  B$	@        <  9'   ''  !   <  &!(  	 
+$!( 
+$	   <  1&	  $D0  <  B$	@  $!(@ 	 $
+$	 $ E4	 $	 (
+$ E4	 (
+$	  
+$<c4  $C  <!   
+$%(E     ''   <  1& !  $, ( $ ! D    P 	  D0  <  B$	@  $ $	 !@ B0Rp  <  B$!p!  	@   <  &!(`	 X
+$!(`	 \
+$!(@	 d
+$	 h
+$ E4	 h
+$  <  B$VUT, ( $         <  <-$  9'  0 ''  < $4  $0 , ( $         B$	@   <  &0$	@!@ $$C   <  & E4	 0$  <  B$  <	@   & $   <  B$	@   <   <d $!(  	@ L d& 	@ L d& $<	@j $S %(^ 	  $ $	@l $S %(^ 	  $$	@j $S %(^ 	 $$	@j $S %(^ 	 $$$	@l $S %(^ 	 $$   <  < C!  R&  < $! @  b&	@ !(   C 1&!  d( 0  C  &4H!(  <4  B$	@ ! @  < $  B$	@ !    <  <  B$	@ $  &0$	  $$C   &0$	 E44 0 , ( $         <  9'  8 '    |                                                                                                                                                                                                                            0                       8          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   @                    	   @       X                %                                  +               /                 0     p                          =                                  9   	   @       0  H               B                                   P      0                          Y   o                                            i                                
+  p              	                f                                                                                                     
+       h     $       /                                             	              
+ )              8              H   h        V   t   X     o                                             <                                                                                	             &  $       K             W        y                 H                                                                     2             J              apical.c disable_all_frame_buffers __fw APICAL_READ_32 APICAL_WRITE_32 apical_get_fw apical_init_calibrations preview_set_supported init_isp_set init_stab stab apical_process apical_fw_process apical_init load_isp_sequence apical_fw_init apical_api_init_idx_array apical_custom_initialization apical_frame_buffer_configure_temper line_offset apical_frame_buffer_configure_all matrix_yuv_coefft_write_to_hardware apical_change_resolution log2_fixed_to_fixed system_hw_interrupts_disable cmos_get_frame_exposure_set cmos_set_exposure_target apical_fw_raise_event crop_resolution_changed system_hw_interrupts_enable                   ,     h     p     x     |                                                                                                                   4    8    X    \    l    p            0    4    T    X    h    l                                 ,     4    8    P    T    d  !  h  !  l    t                                H    P    L    X    \  "  h  "            #    #    $    $    %    %                  ,  &  0  &              @     `                              apical_fw.c.o/  1510573707  0     0     100644  7076      `
+ELF                         P4     (                ' B$      <!     B$   $	@  $   B$    B$      ' ' B$      <  B	 @!     <   $  B$	@  $    B$      ' ' B$      <  B	 @!     <   $  B$	@  $    B$      ' ' B$      <  B	 @!     <   $  B$	@  $    B$      ' ' B$      <  B	 @!     <   $  B$	@  $    B$      ' ' B$      <  B	 @!     <   $  B$	@  $    B$      ' ' B$      <  B	 @!     <  
+ $  B$	@  $    B$      ' , @      <  B$  ! D   '  <  B$   !  `   <	@  $$$C   ? %2	@  $<c4? 12$C  , i   $	@  $$$C   ? %2	@  $<c4? 12$C  , Z   $	@  $$$C   ? %2	@  $<c4? 12$C  , K   $	@  $$$C   ? %2	@  $<c4? 12$C  , <   $	@  $$$C   ? %2	@  $<c4? 12$C  , -   $	@  $$$C   ? %2	@  $<c4? 12$C  ,    $	@  $$$C   ? %2	@  $<c4? 12$C  ,    $	@  $$$C   ? %2	@  $<c4? 12$C  ,  $    & %(E     '     '  <  B$ 	@        B  ''  <  B$( ,  0	@  ' $   <  B$	@      @!(@   < '  B$	@ !0 , (  0 ''  <  B$    <!  R&	@     $	@ $  <  <  1&!0  $	   $!   	@ $  <!0 !   	 $ $	@ $  <!0  $	 l $ $	@	 $  <!0  $	  $ $	@ $  <!0  $	 D$ $	@ $  <!0  $	 $ $	@ $  <!0  $	 $    <!0 !   
+ $$    ''  </$!(    B$   	@ !   <  B$	@  &  <  B$	@ !   $  < &        B$	@   $  <  B$	@      <  1&	 x $  < E4  &	 x $	 x $  $!  x $$(E     '  <  B'   @!   $ b   <   $  B$	@  $  &  < 
+ $  9'   '  <  B @     '   @!   <  B$	@     <  B$	@ .&  @T   <  B$	@       &  <   9'    '      ' B$       <  B	 @!     <  !(    B$	@  $    <  B$!  	@  $  $ b  <   <@ $  B$	@    R.$$C @( %(E   <  B$	@ @ $$  "  " @B$ B0  < @  b  <   B$	@ $$$C  %2%(E   <  B$	@ $  B$       '  <  B! @     ' B   @!   <  B$	@     <  B$	@ .&  B @T   <  B$	@          < $  9'    '                 |                                             l                                              D                                                                                                                                                    0                                                                                                                                                              8  P  t            (  @  d  |           GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .sbss .comment .gnu.attributes                                                         @   
+                    	   @                       %             
+                     +             
+                     0     p       
+                   =              
+                    9   	   @                        B                                   T                @                  P   	   @       $        	         \            @                    b      0       @                   k   o        ^                                  n  {                                                 	                G                                                                                                            l     *   l   l     D      l     _   D  l          l          l          l          D    	    ,    $                        	                                                                       6             S             X             g             w  8  (                    `  d                                                D                 ,             I         X             _             n             ~                 d                                 D                                               0  	        apical_fw.c apical_interrupt_frame_start apical_interrupt_ae_stats apical_interrupt_awb_stats apical_interrupt_frame_buffer_fr apical_interrupt_frame_buffer_ds apical_interrupt_frame_buffer_ds2 apical_interrupt_fpga_frame_wdr apical_program_interrupt_event.part.0 apical_interrupt_frame_end frame_delay.10468 apical_isp_process_interrupt stab APICAL_READ_32 APICAL_WRITE_32 apical_get_current_isp_index apical_get_fw load_isp_sequence apical_sbus_isp_init apical_custom_sequence sensor_load_binary_sequence apical_fw_interrupts_init system_init_interrupt system_set_interrupt_handler apical_fw_init memset init_semaphore apical_isp_init system_hw_interrupts_enable apical_fw_process apical_isp_process_events wait_semaphore apical_fw_raise_event system_hw_interrupts_disable apical_event_queue_push raise_semaphore apical_isp_raise_event       (                                           `    d    t                        8    <    L    X                                     4        <    @    d    h                      !    !             "    "          (    8    H    X    h    x                                      $    $  0  %  4  %  @     D     T  &  h  &  |  '    '                            )    )  ,  *  8  *  D    H    l  ,  p  ,    -    -    '    '    .    .          	    	     	  +  $	  +  H	    P	    p	    t	    	    @	    	    	    	    	    	    	    	    	     
+    (
+  ,  ,
+  ,  <
+  -  @
+  -  \
+  '  `
+  '  x
+  .  
+  .              @     `                                   @     `  #    (    +        /                                                 $     (     ,     0     4     8     <     /0              1510573707  0     0     100644  3616      `
+ELF                      	   P4     (  
+               0+D  @T$   !   C+  `       $  B!   c+  `P B$8 B$ !8 !(            *F `  8 #   " #   `   $  #      Cp    B0  +D  @T$   !   C+  `       $  B!   c+  `P B$ B$ ! !(   g  	 T#    bB0*F `  B$ " #0     b  $0    #8   p          0'0+(d 0B  	%H	 !H   *+( ; P!  8 P!   )5  Q!  2 C $  *Ph !P   J+P  @Q c$P c$ !P !8   K   h J  !@@*Ph @P  c$#   " #@h    $ @  #h     Hq@  B #0 #@ 2 0p#(%        !b   B0!    '0  0'+ 0M ` % !   l+H F  Q!  C @Q!   i@  Q!  =  $  *Xh !X   k+X  `Q c$@ c$ !@ !8      # )   *Xh `X  @ #`   l #   " #X   2 (    ` $# X   J @#  `              lp (   D *   kp  p      '!   '     0 0   4 T $$@0 !(        $ < F    C0`P    ` B0'0  00bp#   "   @ @  c$@ ! !(   G  0  0   D  $#0   p '   C$  D(d   B0 T4    T $$0 !(    $ < F    @ $  @   0bp#   "   @   c$ ! !(   F       #8   p          0+d 0B `!  $@ !   C+ ; `4 $5 *F       !   c+  `P B$$ <   @ ! G$  h@ !(   
+ 0    p*F `@  $ B0#   " #  ` 0'(  8p0 p   $#(     p   C$  D(d    B0 !   '       +d   `!  $ !   C+  `4 $+  $  +f !   B+  @P c$$ < F   ! g$  H !(   0   fp     +f @T  $#   " #(    $(    #@  q  Fp  !               ?                                                                                                                                                                                                                                                                  GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                    !                                  '                                  ,     p                          9              (                    5   	   @         @               >              (	                     L      0       (	                   U   o        F	                                  V	  e                                        
+         	                                                                                                                                                                             	             )           =     ,    X     \    s   0                      $               apical_modulation.c calc_modulation_u16 calc_modulation_u32 calc_adjust_modulation_u16 calc_scaled_modulation_u16 calc_equidistant_modulation_u16 calc_equidistant_modulation_u32 calc_inv_equidistant_modulation_u16 calc_inv_equidistant_modulation_u32      
+        @     `                         apical_math.c.o/1510573708  0     0     100644  4744      `
+ELF                      p   P4     (                <+  @T!  $  $ , ` , B$"  B0 , ` , B$!  B0 , `T , B$   B0 ,      B$ B0     '!       0"  0  <  B$	@ !  C( `PD$ $#    !  
+  !8      @  c$  $ #  $*( T p" $#( !b 0  C%        ''  <  0  !0  !   B$	@ !(  #P      ' 0 $ 'c$$d    ,    0   < $#(    B$ !b  $#Q #0    b$@    %  B$@ !  !  8   D$$ #      <     B$	@ (   $#q !B#0       '!  !   4 $(h !( 8p c$+8 0f
+      0!  !   $ $(h !(E 8p c$*8  0f
+      0 1 !  !   $ $'(h *P  @ i0    	 B$H  !I  B0 c$g(h   '  '   (    <   B$	@ !0    ''!       0"  0  <  B$	@ !  C( `PD$ $#    !  
+  !8      @  c$  $ #  $*( T p" $#( !b 0  C%        '!   #  #  d   @        p  #C  4  4   '  <  B$  ! 	@ !(  ! @   <!0 !(`   B$	@ !8      ' , ,    $ ( ! !  #D  00 p $ B0d$  @ '(  0  (bp#  ",
+ @PD2,G $  @   <  B$    ,  @  @PfK,G $$  @ Z $  #C B0  <@     c$ @d,G $$  @   <  B$    @ !b   B#       `!  G $$  @ Z $  #C   <@   c$!C   B  'd$  @ '(  0  (bp#  ", @PD2,G $  @ Z $  #C B0  <@     c$ @PfK,G $$  @   <  B$    @ !b     B @Pd,G $$  @ Z $  #C B0  <@     c$ `!  G $$  @   <  B$    @ !b   B#      '                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             @???????`?6??>>\>>==4=<<#<;V;:w: :9987l76F655l433n211M0/.	.A-u,+*)#)F(f'&%$#"! {eN6
+vY;   @LfAaB@LDERGHwzJ)LM0zO!8QUkRZTuVXyZ}\Q^e&`	bdFgTie~kmvofptrtc`u\wznA}            GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rodata .comment .gnu.attributes                                                       @   0                    	   @                        %             p                     +             p                     0     p       p                   =                                  9   	   @                        B              	                     P             	  @                 X      0       
+                   a   o        
+                                  
+  q                                                 	                5                                                                                                                                              	              
+                      |     $   |        6   <  H     J              T          ^          	 h   h  8     o     <     v     \     |   8  0        h          (  ,        T                        d  `                        (                                	 )         apical_math.c leading_one_position log2_int_to_fixed log2_fixed_to_fixed __lshrdi3 math_exp2 _pow2_lut sqrt32 sqrt16 log16 multiplication_fixed_to_fixed math_log2 solving_lin_equation_a solving_lin_equation_b __ashldi3 div_fixed div64_u64 solving_nth_root_045 line_offset apical_cosine cos_table apical_sine              @    \                (    0    H    P            |                @    D                             `    l                                        @     `                                   @    `                    /23             1510573709  0     0     100644  1820      `
+ELF                         P4     (                 <  C' c$  C  !0    ! 	 `!@    *b  @  <  C   <!  !(    B$	@  0  CT    " B$   "    '   % b      < C' c$ C     ! 	 `!@    *b  @  <  C   <!    B$	@ !(     c$*(d # d 
+   #c$   # $      '            |                                                                      GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .sbss .comment .gnu.attributes                                                         @   `                    	   @                        %                                  +                                  0     p                          =                @                  9   	   @                        B                                   P                                V      0                          _   o                                          &  o                                                	                                                                                                                                  	           	              	                                          
+               &            >              Z           q               apical_event_queue.c _qlock1 _qlock2 apical_event_queue_push apical_loop_buffer_write_u8 apical_event_queue_pop apical_loop_buffer_read_u8                 T     D     `     x                                        (    4                /47             1510573709  0     0     100644  1312      `
+ELF                         P4     (  
+                    !(  * # 
+(C  !(E      !(  * # 
+(C  !E   F  $* # 
+(b  !     |                                                                                                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                     !                                   '                                   ,     p                           9                 `                  5   	   @                        >              8                     L      0       8                   U   o        V                                  f  e                                        
+         	                b                                                                                                                                                             	             +      (     F   <   @      apical_loop_buf.c apical_loop_buffer_init apical_loop_buffer_read_u8 apical_loop_buffer_write_u8       
+        @     apical_pbuf.c.o/1510573710  0     0     100644  1456      `
+ELF                      <   P4     (  
+                 C     !b    B !      C     !b   c!C   B$*(C #C 
+e          #b c$ `\ d( !b  d( $ d    !b   e!(E   $* # 
+(C            <                                                                                                                                               GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                     !                                  '                                  ,     p                          9              (                    5   	   @                         >                                   L      0                          U   o                                            e                                D        
+         	              $  i                                                                                                                                                             	        (     &   (   @     ;   h   0     S      4      apical_pbuf.c apical_pbuf_start_read apical_pbuf_end_read apical_pbuf_start_write apical_pbuf_end_write        
+        @     `     apical_sbus.c.o/1510573711  0     0     100644  8092      `
+ELF                         P4     (                0 @          %C     0 $ CP  $ C $ C                  %C     %C     0 @0  *       0 $ C $	 C $ C      ,      .       f0,  $'  b0  @  b0 @P c00  , 2 %F  2 * %(  c0B0 `0     ,   %( ` 
+      c0$ b    0  * %(E 0	  $  ' B0       ' C0  $    ! 5 `!   C0 `  C0 `P B00   " %d  "  %  B0c0 @2        % @!       %P B0$ C!  0   %P 2!  !( 	  $  # c0 `B0  $      %b  C0 `4  <  s&	`    !   &	`!@   # c0 `P    %R B0$       ( '  ' C0  $    ! D `!   C0 `  C0 `P B00   " %d  "  %  B0c0 @2        % @!       %P B0$ C!  0   %P 2!  !( 	  $  # d0  c0E0 "  * %   *  % 0 `B0   $     %D  `     %b  C0 `$  <  s&	`      #!@ @ c0 $ $
+(C !  	`!(   # c0 `P    %R $       ( ''( $      , ! ! ! ! !      <  &	@ ! @!p  b &*@!(, ( $       0 '  ' $@ c0  $
+C  0$      4 0 , ( ! ! ! !  @!      <!(   '	@ ! `!(@   &	@ ! !   1&  <  <@ *5@!  4   &	@ ! `@ !  b! 1&*5@!( 4 0 , ( $        8 '  ' C0$      4 0 , (  ! ! ! !  ` $@ B0 $ $
+b  2 @!      <!(   '	@ ! `!(@   &	@ ! !   R&  <  < *U@!  4   &	@ ! ` !  b! R&*U@!( 4 0 , ( $        8 '   C0( ` 0  C0 `  C0 `P B00  , : %g  : * %(  B0c0 @0     ,   %(  @  , 
+  %(E B0$ C    0  * %(E 0   $       ' C00  $    ! 7 `!  C0 `  C0  2 %0f 0  C0 ` 9 C0 `P B02   " %d  "  %  B0c0 @2        % @   
+  %P B0$ C$ 2   %P 2$    !  !(    $  ( ' C0 `  B0 0 @ f0!0` s0  <!    R&	@!( $ !   &  !0`!@     ( '$       ( '  ' C0  $    ! H `!  C0 ` C00  4 " %d  " 2 %0  D0c0 0       4  `  C0  4 %0f   C0 ` 9 C0 `P B02   " %d  "  %  B0c0 @2        % @   
+  %P B0$ C$ 2   %P 2$    !  !(    $  ( ' C0 `  B00 @f0!0`s0  <!    R&	@!(   # $@ c0 $
+(C $ !  !(   !0`!@     ( '$       ( ''( $      , ! ! ! ! !      <!p  F  &	@ ! @ &*@!(, ( $       0 '  ' $@ c0  $
+C  0( $     4 0 , ! ! ! !  @!      <  &	@  R&!0@ !(   &	@ ! `  !  <  <@  *U@!   4 !  F!(   &	@ ! `! R&*U@@ 4 0 , ( $       8 '  ' C0( $     4 0 ,  ! ! ! !  ` $@ B0 $ $
+b  2 @!      <  &	@  R&!0@ !(   &	@ ! `  !  <  <  *U@!   4 !  F!(   &	@ ! `! R&*U@ 4 0 , ( $       8 '  ' C0$      , ( ! ! ! !  ` $  2 B0 $ C $ C $8 C *    F  F  <! `!(   B$	@ &k   R&*   1&  <! `!(   B$	@ &a   R& 1& $   <, ( $  ! `!(      F  <   9'  0 '  B$	@ ! @!0@   <! `!(   B$	@ &C   $ R&!" * @ *  b B0 @P  b$$  <8 ! `!( !0@  B$	@ #-  !U * @!5  ,  @      b B0 @, $$  <C8 ! `!( !0@  B$	@ #  !U  !4  , , ( $ ! `!(    !0@!8     <  9'  0 ', ( $       0 ''  P (  B*$   < 8 4 0 , ! ! ! g @!     % C  0 0(  0 d08   $@ c0 $ $
+  C0 ` $@ B0 $ $
+b !    <  <!(   b$  	@ ! !0@ !(   '	@ ! `  &*!6!@ $%  p 0$ P!G $@ c0 $!0 
+0 @ B0! C ! 
+ !    <  <!(   $  	@ ! !0@ !(   &	@ ! ` & *!#!@ $r  !r #'  <  <!(   &	@ ! !0!0@ ! `!(  &	@  &!( U  <  $ B B* @ $ $M B<     < B $G B< 0    <!   B$	@ !(   <! `!( !0@ /    9'  <!   B$	@ !(   <! `!( !0@ $    9'  <  &! 	!(   <!0@   R&! `	@!( ! 	 &!0@ ! `	@ %&! 	 &!0@ ! ` %&
+  !@!   B$	@ !(   <! `!( !0@   9'< 8 4 0 , ( $       @ '8 4 0 , ( $      @ '                                                                                                                                                                                       (                       (               ?        0                       8                       8                                                     (                       (               ?        0                       8                       8               ?        0                       @          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @                       %                                   +                                   0     p                           =              8  @                 9   	   @                        B              x                     P      0       x                   Y   o                                            i                                @       
+         	                                                                                                                                                               	              
+        (        (   `     )      $     7      P     E           Y     `    n                       P         \         t          (         	               +         F        a    d    x    \     apical_sbus.c mem_read_u16 mem_read_u32 mem_write_u16 mem_write_u32 apical_sbus_read_u8 apical_sbus_read_u16 apical_sbus_read_u32 apical_sbus_read_data_u8 apical_sbus_read_data_u16 apical_sbus_read_data_u32 apical_sbus_write_u8 apical_sbus_write_u16 apical_sbus_write_u32 apical_sbus_write_data_u8 apical_sbus_write_data_u16 apical_sbus_write_data_u32 apical_sbus_write_data apical_sbus_copy            d    h                                                             T	    \	        $              
+  p  
+  l                    |    x                                          
+  $  
+  4    @                    L    P    $    0    (    L                        (         D                                                        `    l    |        
+        @     `                                   @    `                              /68             1510573712  0     0     100644  1932      `
+ELF                          P4     (               ' 0 $    !  !  0 @$0    $ T $ 0! @!  (    $ T!    $$   <! @  B$	@  2 	   $$  <! @  B$	@  2 4' $C (! @  %(E !(       <  9'    '      '' 0 $!     0 `$    < $  $ 0 `$    P  <
+ T     <    B$  B$	@          <  9'   '   '  <B$   <  B$                                                                                                                GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @                        %                                  +                                  0     p                          =              (  `                  9   	   @       t                 B                                   P      0                          Y   o                                            i                                P                	              `                                                                                                                   '                                                   	              
+ :              I              Y              h              v           apical_sbus_isp.c isp_io_write_sample isp_io_read_sample APICAL_READ_32 APICAL_WRITE_32 APICAL_READ_16 APICAL_READ_8 apical_sbus_isp_init  x                              \    t    l    4    x                                        @     /89             1510573713  0     0     100644  2276      `
+ELF                          P4     (                 ' C0, ( $ 4 0  0   `!   C0 ` $  B0 $ $
+b !   '!  B$  e+P `*        " @  <  B$	@     	  V  <  <! ` '  B$	@ !0@      ! ` '  B$	@ !0 @P  <       # `  <  c$	`    @P!0@  !  !        !D !   $$ 0 '4 0 , ( $  8 '  '  !   d0$    0 !   d0  $  c0 $ $
+ !   '!  c$  + b *  '!    !(    c$2  d0T!    !G   @  <  <  B$	@       < $ '  B$	@ !0@	  $   @    <  B$	@     $      ( '  <  B$   <PB$    <  9'                                                8         P            (                                                                      GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @                        %                                  +                                  0     p                          =                                  9   	   @                         B              h                     P      0       h                   Y   o                                            i                                0  0              	              `                                                                                                               P    &   P                                               	              
+ :              W              a              j                 \          x                      apical_sbus_i2c.c i2c_io_read_sample i2c_io_write_sample system_hw_interrupts_disable I2C_write I2C_read system_hw_interrupts_enable apical_sbus_i2c_init i2c_init_access I2C_init                                                                  4    8    \    `    h    l    x    |                @     `     /110            1510573713  0     0     100644  2948      `
+ELF                      @   P4     (               '0 ( $     4 ,   $v  0 $! ! !   -   C0 ` $ C0 ` $  B0!
+ 	   $  @ $  <  B$	@      $  E  < ! !0   B$	@ !8;  4  9 @0 4 , ( $       <  9'  8 ' D0B  8
+d  <$C 	 ` C0 C0 `   C0	 `    4  ` C0     `  %3 @B0'   b   @T E  <  B$	@      E  <! !0   B$	@ !8     4 0 , ( $      8 ''  , ( $    4 0  !  $  D0! t  8B 
+d   C0 ` 0 C0	 `T 6C0$ d 6   6 c8
+  $( C < C0 ` $ C0 ` $  B0!@
+ 	   $ " @ $  <  B$	@      $  e  <!0  !   B$	@ !8s  !@  "q @T4   <  B$	@     k  4 $C 8 ` C0'  @D0d  C0 ` B0	  R e " @T e  <  B$	@      e  <!0 !   B$	@ !8@<    @    K  $	  R e " @T e  <  B$	@      e  <!0 !   B$	@ !8@2    "0 @T $  <  B$	@     *   $. `P$ C0 ` D0      d  @B0'   b  " @T e  <  B$	@      e  <!0 !   B$	@ !8@!@ 	  $ " @$  <  B$	@     $ R$ $ B2   2 R:
+R 4 ! 0 , ( $     8 '  <B$   <  B$  <  9'                                      8             ?        8                                        GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @       <
+  0              %             0                     +             0                     0     p       0                   =              H  `                  9   	   @       l                 B                                   P      0                          Y   o                                            i                                p                 	              	                                                                                                                   '                                                  	              
+ :              W              `              |                   $                    apical_sbus_spi.c spi_io_write_sample spi_io_read_sample system_hw_interrupts_disable spi_rw48 system_hw_interrupts_enable spi_rw32 apical_sbus_spi_init spi_init_access                                 x    |                                    8    <    L    X                            (    ,    <    H    l    p                                        @     param.c.o/      1510573714  0     0     100644  1463      `
+ELF                          P4     (  
+                                               n o   ]          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .text .data .bss .reginfo .pdr .mdebug.abi32 .rodata .comment .gnu.attributes                                                       @                      !             @                      '             @                      ,     p       @                    5              X                      :              X                      H             `                      P      0                           Y   o                                              i                                   P              	              p  G                                                                                                                                                                          	 	            !           +           R           u                                                      &           param.c sensor_calibration_date sensor_no iridix_unlimit_strength_maximum_linear iridix_low_strength_maximum_linear iridix_medium_strength_maximum_linear iridix_high_strength_maximum_linear iridix_unlimit_ev_lim_no_str_linear iridix_low_ev_lim_no_str_linear iridix_medium_ev_lim_no_str_linear iridix_high_ev_lim_no_str_linear 
+/131            1510573715  0     0     100644  1212      `
+ELF                      l   P4     (  
+                                                                                                                                                      GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                      !             `                      '             `                      ,     p       `                    9              x   `                  5   	   @                        >                                    L      0                           U   o                                             e                                t        
+         	              D  `                                                                                                                                                             	             ,           F            apical_connection.c apical_connection_init apical_connection_destroy apical_connection_process     
+        @     sensor_init.c.o/1510573716  0     0     100644  3960      `
+ELF                      p	   P4     (               '$     4 0 , (   ! ! ! #   <M @! 2 @  "&  ! `	@ !( & R& ! !  #    < " 2 %0  "  #  %C  4 !(%0   '	@ ! ` & 1&*@T &  *  !!#UC ! !  #
+    <  " 2 !(%0   '	@ ! ` & 1&*@T &  * @ !!!  #U    <  F!(4  B&	@ ! ` 1&*5@!4 0 , ( $        8 '      %b     %b        %D  %b 0              '@0 !0 H D 8 0 T P L @ < 4      %C ! ! ! !      <!  F $-  W$ , ` $ $ P PT  $A T    C$  , ` $ $8 T    C  $2 T %   C C  %  W$ D   P%d  D    %%p   W$ C  !#  W$ W$   D D W$ B " %    <  B$	@ d $ ! D  %d  D E "   %  % d   W$ $ d $ d $dT! E 0 W$ &!0! @!(   &	@ !8 ! 0 & S W$ "* @P@  '  <!  !(  b$	@ @0 !8@ !p@ !  !  .  !H !(! @  B%$   	@ ( ( $ !0>   R
+ %PD   "  T
+ %  !( % D'0  $F   R
+ %PF    2  T
+ %0 %0F$  %D &  $  "       ' $*H @T  
+< & '!8 #@>!8G C@ !0^  $!H  %  #Pb!(F! @ $   (   b$	@  $     " %   $ $ '( $(E      %K $  %   $ $     (     )% $ $*(@T  <  )@ @@ ! '!8 !@ ##  #Hf  
+<!('  $     B%	@ ( $ !    $'( $E $  % D (     # *C @! @!(`  &	@ !8 @  !  <! @!(  B$	@  0 !P L H D @ < 8 4 0  X '0 '!(    0 , ( $   4 ! 4  <$  <    $   !   tp  &d $	@    !   '  b&	@  $!  @ &4 0 , ( $     8 '                                              8                                                                                                                                               X               ?        8          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @       h                 %                                  +                                  0     p                          =                                  9   	   @       @  8               B                                   P      0                          Y   o                                          	  i                                                	              0  5                                                                                                                                                         	              
+ !              6              L              b          t     ,                                                                                                                  sensor_init.c sensor_write_data apical_sbus_write_u8 apical_sbus_write_u32 apical_sbus_write_u16 sequence_read_u16 sequence_read_u32 sequence_write_u16 sequence_write_u32 sensor_load_binary_sequence usleep_range memcpy apical_sbus_read_u32 apical_sbus_read_u16 apical_sbus_read_u8 sensor_load_array_sequence    <     P                        P    \    t    x        $    0        `        \             t    x                <        X                @     `                    /154            1510573716  0     0     100644  2468      `
+ELF                          P4     (                <B4+  @!(   <  9'      < 4!  B, @  <     !0       %F   $ $!  !( $c$`!0       <B4+  @!   <  9'      < 4!(  , !    <  $!d <!C b!      !C B0      <c4+  `<  <  9'       c4!  d, !    <  B$!b   b      <B4+ !0  @!   <  9'      < 4!(  , !    <  $!0  $!8 !8  B$  E       <c4+ !  `0  <  9'      < 4! D  ,	 `  <  c$!  !C <  !b * E      <c4+  ` 0  <  9'      < c4!  C, `  <  c$!C   E                                                                                                                                                                                                                        GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   p                    	   @                        %                                  +                                  0     p                          =                                  9   	   @       t	  0               B                                   P      0                          Y   o                                            i                                P  p     
+         	                                                                                                                                                               	              
+                            3              H      p     W              j      P     x                 @  p                        h                        P                    apical_isp_io.c APICAL_READ_32 system_isp_read_32 apical_ext_sytem_mem APICAL_READ_16 system_isp_read_16 APICAL_READ_8 system_isp_read_8 APICAL_WRITE_32 system_isp_write_32 APICAL_WRITE_16 system_isp_write_16 APICAL_WRITE_8 system_isp_write_8           8     X                                 (    ,    X    \                            ,    0    P    T        
+        @     `               /173            1510573717  0     0     100644  1736      `
+ELF                         P4     (               '   <$      !   &	@ 0$  <$$(E   "&	@ 0$!   P&	 4$ B0@T  P&	 @
+$$$C   1& E4	 @
+$<	 @
+$C6$C  <%(E 	 @
+$	 @
+$R&$R  <%(E 	 @
+$	  $P
+$<	 !@ $S E2%(E 	 P
+$	  $T
+$	 !@ $S E2%(E 	 T
+$	 `$ $$R 2%(T 	 `$	 d$$R %(T 	 d$  <  B$	@ $h$	   T$S %(	 h$	 $$(R 	 $	 $ $$(E 	 $	 $$R  E4	 $	 0 $$$      $C !  0 $ E4  ( '<                                   (          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                        	   @       x  H               %             @                     +             @                     0     p       @                   =              X                     9   	   @                        B              x                     P      0       x                   Y   o                                            i                                @        
+         	                 V                                                                                                                                               	              
+             )              8              H               apical_wdr_fs.c apical_wdr_fs_isp_setup APICAL_READ_32 APICAL_WRITE_32 _GET_UINT_PTR        $     0     <     L     `     t     T    X        
+  /192            1510573718  0     0     100644  3856      `
+ELF                         P4     (               '   <  &H $$    	  H $	 !@ H $	 !@ L $!@ 	   <  $C%r B0 $ %B  %B      ( ''   <  R& ! H $ 	@ < c$$C   *   <  &%(E 	 H $	@H $ <c4$C  <$(#%(E 	 H $	@H $ <c4$C   . %(E 	 H $	@L $ $ %2   $C !  L $%(E     ''    <( $ 4 0 ,   &	@ H $ R0 B. @  <  <   c$!b   B @       <  @  B$ @ @  <!(   $&  B$	@  $  &	 H $ E4  H $  &	 H $   <    b  &	 H $   < bH $	      $$C  E4  <  B$	@ H $    <  &	 H $   <  b  <  B$	@   &  < b H $  &	L $  < L $	  b  s&  b  <  B$	@  R: R. b r  <  D  B$ E F G '   <j    B$  <  B$	@   <  <  $   <B, @  c$	` H $ $$C H $   E4 	` H $ $$C H $ E4  &	     h    <  &	 L $L $	 !@   B0 s2%S   < B B$ +b) @  <  <  B$	@   #&!c    b  &	 L $L $	 !@   < c  R2 B0 c$%R  +C  `  <  #&!C   D  < B$	@     	 H $ $$C H $   E4	 H $ $$C H $ E4$    R&  <  D  B$ E G '   < &&  B$	@   &!@   < B$	@  	 L $< c$$C  * L $%(   <  R&	@    	 H $ $$C H $ E4	@      <  B$	@  $& @  <  @4 0 , ( $    8 '                                               (                                              8                        h      (    (                     GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @   p                    	   @                       %                                  +                                0     p                          =                `                  9   	   @                        B              (                     T             0  @                  P   	   @         p      	         \      0       p                   e   o                                            u                                	  p              	                                                                                                                                  "           -           <                         	                                                         @              O              _   h      r              y                                                         apical_cmd_interface.c read_data write_data api_cmd_buffer api APICAL_READ_32 APICAL_WRITE_32 apical_cmd_process memset apical_api_read_buffer apical_command apical_api_calibration apical_api_buffer_data_size                            $         p          
+    
+                                           0    4    P    T    h    x                                                                                (    ,    @        |                                        <    H    L    4                                    4                        (        d    ,        4    <    @                @                                                    $     (     ,     0     4     /218            1510573719  0     0     100644  41972     `
+ELF                      i   P4     (               '<  H  12 +\ X T P L D @  @8   0 s2+p @T  $     $< C ` B' '  42 q0 @  <' '  2 P0  V&	0$ C0!@ 0$ 2	 r B0" 0   $ ` !  $  drB0 c`    <  5rB0 #`   $ $  r^0 `   C07   $  `(  `!( + @$8 + @T!  !($8 !  ,   B&	@ 0 , 0  0  ( '( $E ( %(E   !  !($8 !  ,   B&	@ 0 , 0 ( ( '( !  $(E   b&	@      &v0 +v @$  &  2+D 
+ ` r+C $   &+b !   ( !  \ X T P L H D @ < 8  ` ''<  H  12 +\ X T P L D @  @8   0 s2+p @T  $     $ C ` B' '  42 q0 @  <' '  2 P0  V&	p$ C0!@ p$ 2	 r B0" 0   $ ` !  $  drB0 c`    <  5rB0 #`   $ $  r^0 `   C07   $  `(  `!( + @$8 + @T!  !($8 !  ,   B&	@ 0 , 0  0  ( '( $E ( %(E   !  !($8 !  ,   B&	@ 0 , 0 ( ( '( !  $(E   b&	@      &v0 +v @$  &  2+D 
+ ` r+C $   &+b !   ( !  \ X T P L H D @ < 8  ` '  <  B$ 0 $    $' 4 $  	@ !      '!        0 8 $   
+  0 $  ,  $'   <  & $$     	   $!@ 	 <$R   <4E4  1&	  $	  $ $	 !@ $R 2%(E 	  $b24B8 $$       
+ ( '!`       0 $     <  B      $  <  E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     <	 B      $  <	 E!        0 $     <8 B      $  <8 E!        0 $     <: B      $  <: E!        0 $     <
+ B      $  <
+ E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     < B      $  < E!        0 $     <  B      $  <  E!        0 $     <! B      $  <! E!        0 $     <" B      $  <" E!        0 $     <# B      $  <# E!        0 $     <$ B      $  <$ E!        0 $     <% B      $  <% E!        0 $     <& B      $  <& E!        0 $     <' B      $  <' E!        0 $     <( B      $  <( E!        0 $     <) B      $  <) E!        0 $     <* B      $  <* E!        0 $     <+ B      $  <+ E!        0 $     <, B      $  <, E!        0 $     <- B      $  <- E!        0 $     <. B      $  <. E!        0 $     </ B      $  </ E!        0 $     <0 B      $  <0 E!        0 $     <1 B      $  <1 E!        0 $     <2 B      $  <2 E!        0 $     <3 B      $  <3 E!        0 $     <4 B      $  <4 E!        0 $     <5 B      $  <5 E!        0 $     <6 B      $  <6 E!           $ 0 $    $'  < $    B$	@ !      '!        0 $ T!  y<c4  !   $    0 8d $  $   
+  0 $  
+  $  <  C  <  B    %b   !        0 $     BH FP   !  L  $'   " ! A    C e    ;  !  8 ` $  <  "&	@ 0$ B0 @ $/ C!    1&	 0$$$C  E4  <  B$	@ 0$  $    C  D P!    $  <  1&	 0$ B0 C, ` T<C  A!  	 0$$$(E   <  B$	@ 0$    @!       !       '         $'  0    @    < $  B$  < 	$	@   & E4  	$	@   &$	$$(E 	       !   $ B $  <	$  B$	@ !  B0 R $    0  "!   !       '' 0       , @P $  <	$  B$	@ !  $$C %(Q   <  B$	@ 	$  !       $ $	  $  <	$  B$	@ !  B0  !        ''  0       $   < $$ T!      <  B$	@  $ E4   $  B$	@  $$ $$(E   <  B$	@       !   $ # $  < $  B$	@ !  B0+  Q $ $  !        ''  0       $   < $$ T!      <  B$	@  $ E4   $  B$	@  $$ $$(E   <  B$	@       !   $ # $  < $  B$	@ !  B0+  Q $ $  !        ''  0       $   < $$ T!      <  B$	@  $ E4   $  B$	@  $$ $$(E   <  B$	@       !   $ # $  < $  B$	@ !  B0+  Q $ $  !        '  $ 0    $8     .   ' $     !  $  $  ,   $   $!    <0$  B&	@  0$$(E   <  B$	@ 0$  B&	@ 0$ B0@T  B&  <!    B$	@  $  <  B$	@ !    !   @P $ F     $   !    $  $       ' 0    $ $  $'  <    B$	@ !     !    $   '     ' 0    $   !  $R T $)   $ , @P $  <  B$( !(E   4 $L && `  "
+   $   $   $   $  2 $< $	@         <  1   $   c$	`  $& * @P $(  !  !(  4 $L &&	@ !  $ C C, `2 $ $ C $CT     $ C< $ C $CT    	 $
+   $	       $      
+ $ $     $     ( '  $' 0      $t T $M  B$B$ C,G `P $  <  c$!b   B @ 0 $  $ $: T $    <  B$	@ $X  !   $  $ $+ T $      < $  $ $ T $      < $  $ $ T $      < $  $ $ T $      <%     C," `P    < , c$!b   B @     <$(   <$(   <$(   <$(   <$(  $ $
+d %E     !   $   ' 0     $=       B$B$ C, `P $  < @ c$!b   B @     *  (  &  $  "  "     C, `P    < T c$!b   B @     <$(   <$(   <$(   <$(   <$( %(    !    $  $ 0     $=       B$B$ C, `P $  < h c$!b   B @     *  (  &  $  "  "     C, `P    < | c$!b   B @     <$(   <$(   <$(   <$(   <$( %(    !    $  $ 0     $+       B0B0 $ C $ C $ CT $           $	 C $ C $ CT  <$(   <$(   <$( %(    !    $  $ 0     $+       B0B0 $ C $ C $ CT $           $	 C $ C $ CT  <$(   <$(   <$( %(    !    $  $  $  $ 0    $ P $ T $    '@ $'C  ( $ T  $B @P $ F       $   !      $ 0 $   $ ' B   !  @!   <  B$	@       <  @ $@  B @T     <  B$	@             '!           $    $    $ 0  8  B0 +b  @ $  B0 0+(E       $    $ !   $
+  !`     $ 0-   '& $   ! ' , @' $% $2 T $    <   <( $+ T $   $   @ $  <   b @ $    < C  <  B$	@ $  <  B$	@  &  !   $  $  < C ` @P( $  & $ @P% $' $   !     '     ' 0    ) $   <* $ T $  <H  B$	@  $  !   $ !  H     ' 0   $ ` $ , @T $ !      $ $  $' !  !   !    < $ $  B$	@ !   "     '!       ' 0$      .     <  C$!  e!@ @  $ c> `$   <  B$	@  $ R      rp <!Q   <!  !( @B4  B$	@ !8   <@Bd$+ $& P $?Bc$ #<c4+    s&   $  s&   b $  $  < $  B$	@ !   < @ c <@B$ d !0@    (    <  B$	@ !8         !  $       ( ' 0 !   <  9'  !0  $  $<b  !        0    , ` $  <  5 E $  $  <5 B  !       ' 0   + $ P , $' T $    $V $  & $ $V $% $  <  B$	@ !8      $  $  <!   $V $% $  B$	@  $
+ @% $   d& $ dT $  + $, $       ' 0 T $(  ,         !  $ , `!    < B$!          0=   '3 $    !  ! 4 , @; ,2 $9 T $   $5 @P $    < $  < C  <Z  B$	@ H$  Z  < @    B$	@  $!@   <  B$	@ !    <  c$ $ Z  d!B D  BB 1 bB 2 b  !   $  $  < B @T2 $   !        '      0    , ` $  <  c$ d       1 e $  $  <  B$ C `P`  1 BB   !        0    , ` $  <  c$ d       2 e $  $  <  B$ C `Pb  2 BB   !        0 $'    $d $ b @ !         ' 0 !   <9'  !0  $  $b  !        0%  ', $  < 8 4 0 (    ! !    <  b&	@  $!@   <  B$	@  $B$@ !    d $p <@B& @     p&	  $  B+T ) @ $	       C	 ` $	  $  B <@Bc$ b @   "  p&	  $  C
+ ` $	  $  B4 b @       "  s&	` $  Ce ` $	` $[    B	   <  & $	!@ B$@ !B  B+W @!  	  $ $	!@ B$@ !B  C ` $	  $ $	!@ B$@ !   <@Bc$ b @    $  r&	@"  & $	 !@ B$@ !   ` $	@ $ $	 !@ B$@ !B  B4 b @        $  s&	`"  & $	 !@ B$@ !B  C ` $	` $ $	 !@ B$@ !B  B4 b @       o  " R2  p&	  $@ !C   B+T @T R&R& R2 $	  S&@ !S  $@ 	   V!R  $	   W!R  $	   ^!S  $#	   V#!R r  B $#
+	  $ !R   V $  	 !!R  $	   ^!R   C $	  !S   B  $#b 	  !R   B # $	 r!S  $	   S!R   C2#cc  d $  r #B05  $4 v       # @ $4 b @       #  !   $  $d $ b @ !        < 8 4 0 , ( $     @ '      0%  ', $  < 8 4 0 (    ! !    <  b&	@  $!@   <  B$	@  $B$@ !    d $p <@B& @     p&	  $  B+T ) @ $	       C	 ` $	  $  B <@Bc$ b @   "  p&	  $  C
+ ` $	  $  B4 b @       "  s&	` $  Ce ` $	` $[    B	   <  & $	!@ B$@ !B  B+W @!  	  $ $	!@ B$@ !B  C ` $	  $ $	!@ B$@ !   <@Bc$ b @    $  r&	@"  & $	 !@ B$@ !   ` $	@ $ $	 !@ B$@ !B  B4 b @        $  s&	`"  & $	 !@ B$@ !B  C ` $	` $ $	 !@ B$@ !B  B4 b @       o  " R2  p&	  $@ !C   B+T @T R&R& R2 $	  S&@ !S  $@ 	   V!R  $	   W!R  $	   ^!S  $#	   V#!R r  B $#
+	  $ !R   V $  	 !!R  $	   ^!R   C $	  !S   B  $#b 	  !R   B # $	 r!S  $	   S!R   C2#cc  d $  r #B05  $4 v       # @ $4 b @       #  !   $  $d $ b @ !        < 8 4 0 , ( $     @ '      0   '  < |  B$	@ 	 $  !   $  $   !    '      0
+   '|  <  B$ 	@ 	 $  !   8 $ 
+    '' 0   + $ P , $' T $    $` $  3 $ $` $2 $  <  B$	@ !8      $  $  <!   $` $2 $  B$	@  $
+ @2 $   d3 $ dT $  + $, $       ' 0    , ` $  <  4 E $  $  <4 B  !       '   0 $   !  `  = $G ! > , @? $; $0 P  << , @  < $ T $    <v   <? ,T @  <@ $ T $  <  B$	@ $ $  <  c  <  R&  C	@[ $  <  c[ $	@  C  B  <  R&) B  <  B$	@ $ E4  <  B$	@ $0  	 @  s&	`$  < E4  R&	@$	`$ E4	@$ $  <  	 C  <  B$	@ $ $  <  c  <  C  s&	`[ $  <  c  C  <  <  R&$  B$	@ 	 @ E4  <  B$	@ $	`[ $  B) Bi  0  B$	@ $ $  <  c  <  C  R&	@[ $  <  c  <  C  <  &$  B$	@ 	   E4  <  B$	@ $	@[ $  B) ,  > $  B$	@ $ $  <  c  <  C  s&	`[ $  <   c  B$	@ $ $  <  c  <  C  R&	@[ $  <  c  <  C  <  &$  B$	@ 	   E4  <  B$	@ $	@[ $  B) < $  "  B$	@ $$$(E   <  B$	@ $  0 $ c $  <$  B$	@ !  B0 S $  <	 B @T; $"  B!  $       ( ' 0   '  <$    B$	@ !  D0  $  <  c$	 e   . @T( p   $	  !   $
+       <( B   !      '  $ 0    $ T    l- $ T $ $  l-  $l-p- !   $ ( $d        $'   <  @ $  &    $ ! ! 	  0 C07 ` $& ` $; $ #@ $ # $/ #$       	 $ E4  $	 $ E4  <  B$	@ $ $  <  
+ C	 $$$$(E   <  B$	@       <  
+ @ c$ 	 $ B0 @T  <   $
+ D@ $; $
+d   B!  $       ( ''    <  @ $  s&   $ ! ! 	` 0 C0 ` $ @ $	`$ B0+(   $  <  $
+  e$  ". @P    +    $ C$   <+ B  !  $       ( ''   <  @ $  &    $ ! ! 	  0 C0: ` $) `V $; $ B@ $ B $ B $      	 $ E4  $	 $ E4  <  B$	@ $ $  <   C	 $$$$(E   <  B$	@       <   @  "   $ c$ 	 $ B0 @T  <   $ D@ $; $
+d   "!  $       ( ''    <  @ $  s&   $ ! ! 	` 0 C0 ` $ @ $	`$ E0  $  <  $  e$  ". @P    .    $ C$   <. B  !  $       ( ' 0  $B $  $  <6 C!        0       $  $   !        0   $ C, `< c$C  C $
+   $    $ $  $  !        0      $  $  !       ! '! ] $ 0  ! 	   ^ $  $[ $ T $  4 d$  d$ d$  e8     g  @@  08 !( c $
+ f  $ f!0@  $ fT $ F0  <    B$F0  <  B$	@       !    <   B$     $  $b $ C  $ C $ CT    <  B$	@          <   B$  <   B$ $    ' 0   ',   << 8 4 0 ( $   r&!   ! !   $V $% $	@!8    <  &!@ $ ` ` ` b $` $2 $!8  	@  . $a $ $!8   	@  $b $d $!8  	@   $ y $ $	@!8  !  
+& $4 . @ $  < B$ !U    @      @!     $P   &  @ P d $  `   &     $a $ $!8    b&	@  !    $b $- $!8    s&	`
+BS @P!     $  & $        $ [ $ $  s&	`!8  x @T $w @< u   $ $a $# $!8    b&	@  !  
+B $b $# $   b&	@ !8  !  
+  $y $    $  & $ C C C C C  CP @   C $ 4P   &  $a $ $   b&	@ !8  !  
+B  $b $ $  s&	`!8  9 @T $8  < 6   $P   &  $  <  1& $	   B $	  B $	  B $	  B $	  B $	  B $	  B $	  B $	  B]  $  $   !   $< 8 4 0 , ( $   @ '         $ 0    , ` $ , `6 4(p(pB-  4 $  $6  !       ' 0    U $  $V , @V $T $- T $   $  $W $& T $   $  ..  <  B$	@ t-$  !   $  . $ d d, P $ bT $
+  U $ bW $ $	 bT $T $    !      V $   '' 0    U $  $V , @V $T $- T $   $  $W $& T $   $  6.6.  <  B$	@ t-$  !   $  6. $ d d, P $ bT $
+  U $ bW $ $	 bT $T $    !      V $   '' 0    U $  $V , @V $T $- T $   $  $W $& T $   $  P.P.  <  B$	@ t-$  !   $  P. $ d d, P $ bT $
+  U $ bW $ $	 bT $T $    !      V $   ' 0   . , T'  $  <  B$ 	@ t-$  !   $    .   !     ' 0   . , T'  $  <  B$ 	@ t-$  !   $    .   !     ' 0   . , T'  $  <  B$ 	@ t-$  !   $    .   !     ' 0    $)     !  &'- $   ! . $ T $  <  c$ $$	 b) d  &  <  B$	@ [ $  C  <  B$) C	 @&   !    	   $ FT- $. $   !    $    '' 0  , ( $        $c  $^  %0 $!  ! 1 $9 / $R  $&U @!    <  < $$  &  s&	 b	  <$$(E   &	$	$$$(E 	$  $&< @!    <  < $$  &  s&		 b$$C   < E4  &	$	$$$C @ E4	$$( b"  %& @!    <  < $$  &  s&		 b$$C   < E4  &	$	$$$C p E4	$ $     $!      , !@( $       0 ' 0    $A     8   ' $ $     !  $	 T $     $   C   @  +   $  $  < C$  1&	   B0$	  B E4  <  B$	@ $<  <!   '  B$	@    <!   'B$	@  
+  !   $ D $
+d    !    $$      ( ' 0    $        ' $ $      !  $	 T $     $   C   @  r   $  <  &	 $$	   $	  S0!@  &# " B' @  < $ b(r `$ $ b@(  $ bR $( (p  "&	@ $ $(Er$  "&	@ (p@( (p  "&	@ $(r  "&	@ $$  1&	 !(   $-  !(  $ b@( " `E& $ b $ $	 bR(  $(Er$$  "&	@ (r( $(r  "&	@ $ $(Er$$  "&	@ (r@( $(r  "&	@ $E&(r  1&	 $ $#( 	     
+  !   $ D $
+d    !    $$       ( ' 0(   '(   <$    !  ! !  $y $ $  s&, 	`!8  O ". @ $S ". @  <S $ "V $  $y $ $	`!8    <  B$j.Q	@ t-D&  !   $  $j.   !  , ( $    0 '      0    $ $       !        0    $ $
+     !b !C B$   !         < !     b  !(      B$  < $  e+(E !(      ' @ ,( , $      0  @      <  B$! ! 	@ !  bV $  <  &	! @ $! @  ! 	! @!    !    !(    c$s!(C      !   $   $, ( $       0 ', `!  '  <  B$    	@ ! !@   <  B$	@ !  !@   <  B$	@ !   1&%B %Q       '     '  <  B$    ! ! 	@  0 $ C    #. `P  @ !Q   D  <  B$	@         !     $ $       ''  <  B$ D @ < 8 4 0 , $ (  0! X 	@  0!@   <  B$	@       V!@  B.  ` @  $  bc   $ .` @ $@ !  $Z   < !  !(@  B$	@ !0R @!@ /$r!u  * ` D$ *1 `P *
+ ` * *+ `P@   * `&%  ; `T!   *  `T&   $ * ` $ * `  < $  * ` $& $+p %  V!     $  $ V!    <$    B$$D  <    B$  <$  B$	@       D   <  B$	@ $!(@   <  B$	@ !  $  
+ !  D ! @ < 8 4 0 , ( $  H '                                      `                     `                                                                                                          (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (                                                                                                                                                                                                                                                                                                                      @                       @                                                                                                                             (                                                                            (                       (                       (                       (                                                                                                                                                                      @                                                                                                                                                                                                                                                  ?        0                       (                       (                       0                                                                                                         ?        0                                                                       H                               8  h      (  8  H  X  h             H  X  h  x            $  \  l  |      B  xE  xE  D  xE  B  B  C  \C  C  C  D  <D  HD  D                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @   PV                    	   @                        %             V                     +             V                   0     p       V                   =              V                   9   	   @         h              B              Hh                     T             Ph                    P   	   @       \       	         \      0       0i                   e   o        Ni                                  ^i  u                                Tl                	              $y                                                                                                                  )         8           J          	              	                                                         U              d              t              ,  L        x                    X  <                        <         <         <     =  H  <     ^    <         <         <       8  <       t  <         <         <       (	  <     0  d	  <     E  	  <     W  	  <     u  
+  <       T
+  <       
+  <       
+  <         <       D  <         <     ,    <     H    <     b  4  <       p  <         <         <       $  <       `  <         <     9    <     _    <       P  <         <         <         <       @  <     5  |  <     T    <     s    <       0  <       l  <         <         <          <       \  <     1    <     O    <     f    <       L         X  P         ,                   @                                 4  d    ,         A         U  l       b         q                                                                 `                                       8         C        W             o                                     `!         h!         p!         !                    	           -	             I	  "       Q	  "       ^	  "       l	  "  d     s	  #       }	   #      	             	             	  4$  h     	  $       	             	  H%  X    	             	             
+  &  <     
+
+  &  H     
+  $'       $
+             3
+  '  0     E
+  ((  (     Q
+  P(  D    Z
+             o
+             
+  )  p     
+  *  p     
+  t*  <     
+  *  <     
+  *      
+             
+             
+  /      
+  4  `     
+  D5  L       5         d6  H        6      '             5             V             e                                                                              9             `  8:       p  :  t     y  L;  8      <         L=  D      >         T?  ,       ?  4       ?  d       @  4       L@  X                                           3             G             \             q  A      |  E         E  `       F                      G         G         H  h       XI  h       I  h       (J       (  J      ;  L  8    M  N  \    _  tP       j  XQ  0     x  Q  H       Q  H       R                                   R                                                S                    -  T  <    D             R             k                                        apical_command_api_impl.c ae_roi.part.1 awb_roi.part.2 apical_api_buffer CSWTCH.226 APICAL_READ_32 APICAL_WRITE_32 get_apical_api_buffer selftest_sensor_id selftest_sensor_interface selftest_isp_interface system_freeze_firmware stab system_manual_exposure system_manual_exposure_ratio system_manual_integration_time system_manual_sensor_analog_gain system_manual_sensor_digital_gain system_manual_isp_digital_gain system_manual_directional_sharpening system_manual_un_directional_sharpening system_manual_iridix system_dis_x system_dis_y system_manual_sinter system_manual_temper system_manual_awb system_slow_frame_rate_enable system_manual_saturation system_manual_exposure_time system_exposure_dark_target system_exposure_bright_target system_exposure_ratio system_max_exposure_ratio system_integration_time system_max_integration_time system_sensor_analog_gain system_max_sensor_analog_gain system_sensor_digital_gain system_max_sensor_digital_gain system_isp_digital_gain system_max_isp_digital_gain system_directional_sharpening_target system_maximum_directional_sharpening system_minimum_directional_sharpening system_un_directional_sharpening_target system_maximum_un_directional_sharpening system_minimum_un_directional_sharpening system_iridix_strength_target system_maximum_iridix_strength system_minimum_iridix_strength system_sinter_threshold_target system_maximum_sinter_strength system_minimum_sinter_strength system_temper_threshold_target system_maximum_temper_strength system_minimum_temper_strength system_awb_red_gain system_awb_blue_gain system_saturation_target system_anti_flicker_frequency system_ae_compensation system_calibrate_bad_pixels selftest_lens_interface selftest_isp_revision selftest_fw_revision selftest_api_revision selftest_calibration_revision sensor_calibration_date sensor_no isp_system_state system_sensor_select test_pattern_enable test_pattern fr_pipe_status ds1_pipe_status ds2_pipe_status system_frame_buffer resolution_active_image apical_isp_raise_event apical_init_calibrations fps_mode cmos_get_fps set_sensor_fps cmos_update_exposure_partitioning_lut dvi_output image_resize_enable crop_resolution_changed image_resize_width image_resize_height image_crop_xoffset image_crop_yoffset sd_capture_frames sd_capture_run wdr_mode histogram_lum system_hw_interrupts_disable apical_api_buffer_data_size system_hw_interrupts_enable af_mode af_range_low af_range_high af_roi af_status ae_mode AE_fsm_process_state cmos_fsm_process_state ae_split_preset ae_gain math_exp2 ae_exposure cmos_get_lines_per_second div64_u64 ae_roi ae_compensation ae_freeze apical_command ae_integrator_set get_awb_idx awb_mode _GET_MOD_ENTRY16_PTR AWB_fsm_process_state awb_red_gain awb_blue_gain awb_temperature awb_roi awb_range_low _GET_USHORT_PTR _GET_LEN awb_range_high flash_mode flash_time awb_freeze antiflicker_mode iridix _GET_UINT_PTR iridix_high_ev_lim_no_str_linear _GET_UCHAR_PTR iridix_medium_strength_maximum_linear iridix_high_strength_maximum_linear iridix_medium_ev_lim_no_str_linear iridix_low_ev_lim_no_str_linear iridix_low_strength_maximum_linear iridix_unlimit_ev_lim_no_str_linear iridix_unlimit_strength_maximum_linear iridix_strength dis_mode sinter sinter_strength temper temper_strength defect_pixel register_address register_size register_source register_value apical_sbus_write_u8 apical_sbus_write_u16 apical_sbus_write_u32 apical_sbus_read_u8 apical_sbus_read_u16 apical_sbus_read_u32 scene_mode sharpening_mode sharpening_strength fr_output_mode matrix_yuv_update ds1_output_mode ds2_output_mode brightness_strength contrast_strength saturation_strength antifog_mode antifog_set_preset orientation_hflip orientation_vflip color_mode exposure_log2 gain_log2 apical_api_read_buffer apical_sensor_calibration_update _GET_SIZE _GET_LUT_PTR get_calibration_description _GET_WIDTH _GET_ROWS _GET_COLS buffer_data_type GET_API2FRM_IDX apical_api_calibration apical_get_fw color_matrix_change_CCMs apical_switch_wdr_mode iridix_initialize defect_pixel_table_write                              0        d             (                    h    l                                                     4    8    X    \    p    t                                            $    (    H    L    `    d                                         	    	    	    8	    <	    P	    T	    t	    x	    	    	    	    	    	    	    	    	    
+    
+    (
+    ,
+    @
+    D
+    d
+    h
+    |
+    
+    
+    
+    
+    
+    
+    
+    
+    
+            0    4    T    X    l    p                                                 $    D    H    \    `                                                    4    8    L    P    p    t                                             $    (    <    @    `    d    x    |                                            ,    0    P    T    h    l                                                     @    D    X    \    |                                                0    4    H    L    l    p                                                  $    8    <    p          N    N    O    O                              T    X                         (                            P    T    l                    $    (    @    X    \    |                <        ,    0    P    X                          ,        @    D  Y  L  Y  X  Z  \  Z    \    \  \  
+  `  
+  P$  ^    ^    ^    
+    
+     a    a    a    a  d  a  $  a    
+    
+    
+    
+  ,  
+  4  
+    
+    
+  @  
+  H  
+  ,"  j  0"  j  <"  k  @"  k  \"  l  `"  l  `#    #    h#    #    #    #    #    #    #  s  #  s  #  t  #  t  #    #    `$  ^  h$  ^  %  w  %  w  l%    p%    %  y  %  y  %  z  %  z  &    &    ,&  y  4&  y  @&    H&    d&  z  h&  z  &    &    &    &    '    '    t'  ~  x'  ~  '  ~  '  ~  8(  
+  <(  
+  (    (    (    (    (    (    (    (    (     )    )    )    X)    \)    )    )    )    )    *     *    D*    H*    *    *    0+    4+    D+    H+    +    +    ,    D,    H,    ,    ,    P-    \-    -    ,0    00    @0    D0    0    0    1    @1    D1    1    1    L2    X2    2    4  Y  5  Y  X5  Y  \5  Y  5  ~  5  ~  6  ~  6  ~  |6    6    6    6    87    <7    H7    L7    P7    T7    d7    h7    |7    7    7    7    7    7    6    7    7    7    7    7    7    7    8    8    8    8    $8    (8    08    88    7    @8    P8    T8     7    x8    8    8    8    8    8    8    8    8    48    8    8    8    7    8     9    9    9    9    9    $9    (7    (9    49    89    <9    D9    P9    T9    X9    d9    8    l9    |9    9    `9    9    9    9    9    9     :    :    H:    X:    p:    t:    :    :    T;    `;    ;    ;    ;    ;    <    <     <    (<    D<    P<    <    <    <    <     =    $=    T=    `=    =    =    =    =    >    >     >    (>    P>    \>    >    >    >    >    (?    ,?    l?    p?    @     A    A    A     A    (A    `A    dA    xA    A    A    A    A  ~  A  ~  B    B    B  
+  B  
+  B    B    C  ~  @C  ~  \C    C  ~  C  ~  C  ~  D    LD    dD  ~  D  ~  D    D    D    |F    P    F    pG    tG    dH    hH    I    I    |I    I    I    I    lJ    pJ    J    J    J    J    lK    xK    hK    |K    K    K    K    K    K    K    K    K    DL    PL    @L    TL    hL    pL    `M    lM    M    M    M    M    M    M    N    N    O    (O    <O    LO    \O    O        O        O        O    N    P    P  ~  P  ~   Q    Q    Q  k  Q    Q    Q  k   R  k  PR    TR    pR    tR    S    S    ,S    0S    @S    DS    S    S    S    S    T    T    \T    `T    T    T    U    `U    U    U    U    U    U    U    U    U     V                @     `                                   @    `                             !  @  "  `  #    $    %    &    '     (     )  @  *  `  +    ,    -    .    /     0     1  @  2  `  3    4    5    6    7     8     9  @  :  `  ;    <    =    >    ?     @     A  @  B  `  C    D    E    F    G     H     I  @  J  `  K    L    M    P    Q     R     S  @  T  `  U    V    W    X    [   	  ]   	  _  @	  `  `	  b  	  c  	  d  	  e  	  f   
+  g   
+  h  @
+  i  `
+  m  
+  n  
+  o  
+  p  
+  q     r     u  @  v  `  x    {    |    }                @    `                              @    `                              @    `                              @    `                              @    `                              @    `                                                       $     (     ,     0     4     8     <     @     D     H     L     P     T     X     \     `     d     h     l     p     t     x     |                                                                                                    sensor_func.c.o/1510573720  0     0     100644  5008      `
+ELF                      p   P4     (                $ CT$ $      8$  '    < <  R&  !   &, ( $ 	@  <$T %(Q   <  1&	  6 u	@ 6B0 ,  6	 %(E  &	@  u$T %(U 	  6 t	@ 6B0 ,  6	 %(E  t	@ & $$U 2 6	 %(E  v 6	@ <62$T  ,  6	 %(E  v	@ &$U 2 6	 %(E  v	@ 62$T  ,  6	 %(E  p	@ <$U 2%(E 	  <
+ p	@ <2$T  , , ( $      !   <%(E   0 ''    < <  R&  !  D &, ( $ 	@  <$T %(Q   <  1&	 D 6 u	@D 6B0 , D 6	 %(E  &	@  u$T %(U 	  6 &	@ u$T %(U 	  6 t	@L & $$U 2L 6	 %(E  vL 6	@ <62$T  , L 6	 %(E  v	@P &$U 2P 6	 %(E  v	@P 62$T  , P 6	 %(E  v	@@ &$U 2@ 6	 %(E 
+ s	@@ 6s2$T  , , ( $     @ 6!   %(E   0 '$	 H 8$ 8C,  8$ `8$$*E $(b   '  <  B$    ! 	@ 0$$$C  E4  <  B$	@ 0$( &  <!    B$	@      & B4   <  B$	@ ! @   B   <  B$	@ ! @ 	@        <! @  B$	@   <  R&$	@L$ 	@     $	@L$@ &  !  	@ !0@ !  !0@	@ !(   	@ !  X   <"  0 !   B$ C\ "  0 !  C       ''  < 8 4 0 , ( $     $Q  <  &!( t $	 S!( y $	 !@ !(  $ 	   <!( ~ $!@ 	   &  <! @  &!@ 	 ! @s2!@ 	  <!0@   R&!( ! `	@  <  1&$ $	 !@ $W 2  <  &%( 	 $	! ! 	  !0@ 	@! ` 	 $ $W 0%( 	 $	! ! 	  !0@ 	@! `$	 !@ $W 3%( 	 $	  	!@ !0@ !(	@! `$	 !@ $W 3%( 	 $	! ! 	!@ !0@ !(	@! `!@ 	 $  <$D < 8 4 0 , ( $    e0!  $%(   @ ''   <  R&  F !  $$   	@ <$S %(Q   <  1&	  $ $	@H $S %(T 	  $$	@F $S %(T 	 $$	@F $S %(T 	 $$$	@H $S %(T 	 $$   <  B$	@ !   !(  !0  	@ ( &! @   <  B$	@     	@0$$$C 0$	  E4$      !    <   9'  ( '                    !(  @ $  ( $|                                                                 0                       0                                                                             @                       (                                                                                                                                                                GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @    	                    	   @         p              %             @	                     +             @	                     0     p       @	                   =              X	                   9   	   @       0  `               B              
+                     P      0       
+                   Y   o        
+                                    i                                  0     
+         	                                                                                                                                                              	              
+        ,     1   ,       F              U              e              @          l                                                                                          D  D                 +             @             J             ^    D    m                                                           sensor_func.c sensor_sync_get_output_resolution apply_dvi_sync_param APICAL_READ_32 APICAL_WRITE_32 apply_dvi_fpga_sync_param sensor_init_output sensor_hw_init sensor_init init_sensor_interface reset_sensor_interface load_sensor_interface usleep_range stab sensor_update_black _GET_HDR_TABLE_INDEX _GET_MOD_ENTRY16_PTR _GET_ROWS calc_modulation_u16 sensor_sw_init apical_wdr_fs_isp_setup sensor_load_vars sensor_start_calibrate sensor_stop_calibrate sensor_fps_change sensor_get_lines_second    8     @     x     |             0    4                         (    D    H    `    d                            x    |                                    (    ,                    L    P    t    x                
+        @     `                                    @  !  `  "  cmos_func.c.o/  1510573721  0     0     100644  11672     `
+ELF                      P   P4     (               !   C'   !  V eX cQ CB !"!#   <     !(    B$	@  $ !Q        ''  <  B$   ! 	@ ! 
+      `  # d  # !b            ''  <  B$    	@ !  $ C `    <  9'           ''  <  B$  	@ ! !(@   $  < # !8    B$	@ - B0    ''  <  b$      $ !   !   El  Rx  !`    B  < $  B$	@ !0  + S  !`+2
+C+Q 
+#!@   & D T C$        ( '
+   < c   * e 
+  Y! `   V E$ !         < C   *8e '! `  F
+   	 V E$  C(    !     '
+       <! B * b d *    !    <  B$ C `  < E  9'  *  $  <  B$ C `  < E  9'  *  $  <  B$ C `  <  E  9'  *  $'      L &	@ ! P  Ep * (p$  @    '   ',   !   H * $< 8 4 0 ( $        <    1&  <  1&h Bd V  <!  &! $  <#    < . @P 1&  %   '  x D	@ ! l E+ E   
+(D  !!  !(    b&	@  $  '!t   #D   E(   !    1& &  <( B$V  4< 8 4 0 , ( $      @ ''  <  B$  	@ !  $   <!    B$	@  $ &  <   9'   ''  <  B$  	@ !  D, $d    P c Cp '  !(   ,   $$
+(C ( $p!d  d B$'    , ( $  !    @  <   B B @!      <!  	    <  &	@ !  !(@   B&	@ !   1&~ b*Q @!(      B$	@     !    R&	@  &   B B @  <  <  B$	@       B& C `T C  < $  "&	@ !0   <  <!@   &	@  d&B0 ,   <%(   &	@  d6  B& C `T  C $ $  1&	 !   < $&  &	!@ <  $ e0$D %(   &	 $6	 $6s2 <c4 $C  , %( 	 $6  B& C `  R&  C B @,    B, ( $       0 '' B$ C,
+ $   , (    ~ E  <  b&	@ ! ! @ !@   <  %&  B$	@ ( $$B $ C $I CT ~ E  s&!  	`$!@ "@ $ ST  < >  $   B$	@ | $ B0    @  <"!(  Dp B! $  D  c$!  #   $	`  $  `P  $ Dp C `       B   $  B D!( !  #    c$ $	`  $$  `P  $ DDp C `        @ B, @,   @ $$ @ $  , ( $     0 '' 0D @ d ` \ X T P L H !     $Rd   <  B$	@   <   $$B~ %  <  < C!   $! C  b&  v&	  &$ R!   $	   B| $	   < B0 @ &	    <$C   E2	    B0 ,  6  &	%(E   $ 	@  < R &  &	 B0 , %(E   &	 6@ $$    %  s&	`!   T %!  	`  U!   $	`  BL &   < '  B$	@  $  <  b!`  $ C4 2&  $c$ b  &4 2&V 3& "! @	@ !(` " ! @	@ L && "!(!0`	@ ! @ 7&  "  <!   B$	@  4 "! @!(	@ !0` "! @	@ !(`  &4 b c  
+  Cd ` \ X T P L H D     <@  $  9'  h '$"X B$ B,  < @ $ $  B&	@  $  <!@   b&	@ $ $$C 2  <%(E   &	@ $ $H5&$$  $BB$ B, @r!u pD   $!u pD $  B&	@  $$0r D,0 'B0
+&!      $$BB$+b ' @T  v&  r&	@$B0$	@( B0$	@* B0$	@, B0 <. $!   4 $0 '!( '!    B$#       d@   q" F  d  v&0 	 $ $$U E2%(E   &	@ $2 	$$U 2%(E 	@$4 	$$U 2%(E 	@$6 	$$U 2%(E 	@$   $$B C $ C  <\   s&	`L$ $$C E2%(E L$  &	 <\ 	` D&B0 ,  D6	%(E   <!    B$	@ !(   Ep "d ` \ X T P L H D +(E &  <@  8  9'  h '` \ X T P L H D @  h ''  <  C$  < 8 4 0 , ( $    c!  `!   !@  $	 b    < $  B$	@  $  #B  <  B$	@     #B  B(
+b   <  B$	@ !  #B  B(
+b   <  B$	@ !  #B  B(
+b   B*  < !  !  * $  <  	<
+$$  %$H -  %&h  $%
+  (JphKp!    !  ,    T!d !hd *hM#(C  !!d * r  P"B$FTH -"a @<  "^ @  s& b\ @8   <  B$	@ !    #P s#Sp@  C `   M `<      <!(    B$	@  $* `P  "*BP!@   "$E  <  B$	@  $! @   <  B$	@   <4 `!   $!0    &!@ 	   S `  &  $ ! 	!0    $# !0  	!@ + `+ #P+r 
+ @     `    +        !
+ <  S `  +t  8  #< 8 4 0 , ( $   !  !(     <  9'  @ ''  <  B$    ! 	@  A!@  Q&  "*   <!    R&	@!(   < c ` 
+ E$*# `$*q   V 	@!         ''  <  B$   	@ ! 	 A!@ #(   <  B$	@ !  !@   <  B$	@ !  
+ A !  #(   <  B$	@ #(       ''    @!   @   <  B$	@ !   P cCp@  C `    @ $ "@   1bp !      '  ! l e+E  `  <+(F 
+ !(@   9'      '  <  B$  	@ ! +C  `T    ''   $   $ $ C!  $" CT @ $@ d,D t bp < +b 4(b   <!0   B$	@ !    +"
+C  &	@ V $  b @    
+  $    @ $V $$  ( '$     ( ''   !   $   <  $  c$	`  $	    C( !(    c$	`  $#"  C( #C  a #      '       C- `    '    ! $E  <!   B$ $	@ ! ! @   <  B$	@       B#(q ' &( #  +  	 T*# `B   !"#" R. @ $      '     ?                                                                                                                                 (                                                                                                                                                                                                                             @                                                                                           ?        0                       0                       h                       @                                                                                                                                                    (                                                                                                               
+  < d            GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rodata .comment .gnu.attributes                                                       @                       	   @       &                %                                  +               0                  0     p                          =                                 9   	   @       ,                 B              x                     P               0                  X      0                          a   o                                            q                                                	              h"  u                                                                                                                 +       (                                              	              
+               3              G      l     X              o      P     }                               H  X                                                            `  4         X     %    4     A     ,     \  L  ,     w  x  ,         X         P             	            	    L  T     *             A    H     [    4     w    0                                                          L                     
+      )             =             T    0    h             }                                 8           0         @       4       1          G         \          cmos_func.c cmos_store_frame_exposure_set exp_lut log2_fixed_to_fixed _process_fps_cnt system_timer_timestamp _init_fps_cnt system_timer_frequency system_timer_init cmos_get_fps div64_u64 cmos_alloc_integration_time stab math_exp2 cmos_alloc_sensor_analog_gain cmos_alloc_sensor_digital_gain cmos_alloc_isp_digital_gain cmos_get_manual_again_log2 cmos_get_manual_dgain_log2 cmos_get_manual_isp_dgain_log2 cmos_convert_integration_time_ms2lines cmos_update_exposure_partitioning_lut exposure_partitions_balanced exposure_partition_int_priority cmos_init cmos_request_interrupt cmos_get_lines_per_second cmos_get_frame_exposure_set cmos_update_exposure_history system_hw_interrupts_disable system_hw_interrupts_enable APICAL_READ_32 APICAL_WRITE_32 cmos_move_exposure_history memcpy cmos_fsm_process_interrupt sensor_update_black apical_isp_raise_event cmos_inttime_update _GET_HDR_TABLE_INDEX _GET_UINT_PTR cmos_analog_gain_update cmos_digital_gain_update get_quantised_integration_time get_quantised_long_integration_time cmos_antiflicker_update cmos_long_exposure_update cmos_calc_target_gain cmos_update_wdr_mode cmos_set_exposure_target    L     d                         (    ,    L    P    t                        $    d    h                         $    0    8    L    P    \    d    x    |            D     L     P  !  T  !  `    l                        P    T    p  #  x  #                  x  %  |  %      h  '    '  L          (    (              (  )  0  )  D  *  L  *  X          )    *             %    %    ,    ,    %    )  	    8	    	    T
+  +  X
+  +  
+  %  `
+  %  
+  %  
+  )  
+  *     )  8  *    %  T  %    ,    ,                 .  (  .  X      /    /        )    )    *    *      \      )    )    )  @  )  `  *  t
+  )    )  x
+  *    *  8  %  @  %                       (    <    @    X    \    t    x              !    !                @    P    T              1    1    2    2                          0    8    D    H                                    `    d      5    5    5     5    6    6  @    L    x    l      1    1     2    2              @     `                                   @    `          "    $    %     &     +  @  -  `  0    3    4    5    6     7     8  @  9  `  :    ;  /247            1510573722  0     0     100644  2664      `
+ELF                      p   P4     (                    ',  $( $   ,   !  !   4    <  &	@ ! t!S  b &   !   $, ( $       0 '1     ',  $     $ !  !    <   4!D  E  b&	@ !   &    <  1&	 $ $$C 2  <%(E   &	 $	  $ E4	  $	  $$$(E 	  $  !   $$        ( ''   <  1& ! $$   	    <  & E4	 $	 $ E4	 $@ $ B	  $ E4	  $ S	 $ $$C e2$	 %(E $      @  ( ''   <     R&6 Q $_ "  ! `!     <!(   $  B$	@ !0   $  . B $. B $   <  B$	@ $ $    $C   <$ E4  9'    ' 	 D,5 P  q  < $  R& 	@ $  <  1& E4	  $	@ $ E4	  $	@ $$$(E 	  $	@ $ E4	  $    @  R&	@$  $"r$ 	@  $$C %2%(E   <  B$	@ $ $  B$        '        | ?                          ?        0                       (                       (                                  GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                        	   @       p	                 %             @                     +             @                     0     p       @                   =              X                    9   	   @       H
+                  B                                   P      0                          Y   o                                            i                                        
+         	                                                                                                                                                               	              
+             -              <           U              e          }   @                                   defect_pixel_func.c defect_pixel_table_read APICAL_READ_32 defect_pixel_table_write APICAL_WRITE_32 defect_pixel_initialize defect_pixel_update stab cmos_set_exposure_target  D     H                            $                    H    X    |                                $    (                    
+        @     `     /270            1510573723  0     0     100644  5520      `
+ELF                         P4     (               '0 , $      4 (  !  $$  < $ $    <$  '	@ ! @ 2  s '  $ (t %(E ! @  &	@  &$$  $  &4 0 , ( $       "!    <  $  9'  8 ''  <  B$0 , ( $    4   	@ ! !@ !  !   <  < $   &	@ ! v#  0 C0 c4$ ! 1&0 c5!C8 @08 !   $! 0 !  c$b    <  C4 0 , ( $       8 ' 0 $     '  <  B$  	@ !       < $  9'   '     '    $E  <!   B$	@  $! @   <  B$	@       <  $!H@   !P         0 & $  8  0    2 %0f   , !0 c!8 + `P$@( $ $ e    $$ ,   cp @ $@ e, + C 
+d  $     ,  d  0  #f !b  D  ,       D%       ''  < ( $     8 4 0 , $E  <!   b&	@  $  <! @   "&	@     0!@   <5 T  $BB$ B,# @ L $ $!  !   !(  !P  g  #Xl8bp B @8 X  P  !X @8 !8.  % G@  H  xp!8 !H+P !@ !   G$!(H+@ !@!   !  $ $!  !   !(  !h  #p+@ !8@P   %+@J @q B @@     !@ !@0  J% K @  H  hcq!XBX  !H    hiq! !+@D ! ! @ !( $ ,@ B%  <  B$	@ !8  ! @   <  B$	@     B :  U0@8 !8.  J%  @  H  hp!8 !H!@ +h !   G$!(+@ !@! ! +@K !8`@P   %!0 B H% H +
+H  @  Xbp J%!Hi!XBX   $    hiq! !+@D ! ! @ !( ,@   <@0   B$	@ !8  !@  D  <  R&!(  	@ $! !(   $!@ 	@&#  !T   < $  B$	@  $!@   ) $  s&	`$E! @   <  B$	@   2& $	@!@   B+U  @T $;    q	@  <  & $	!@ B$ !B  B+' @ $	 $!b)  Q	 $ !^   B+ @P R&	 $C&  !D !c $  q	  V!^   B!r V  C#q #up#V    !Q    12  &	@  $+B@  7&!  1& ! < 8 4 0 , ( $      @ '   $ '    <(    4 0 , $    &   C!  3&
+ `  < D $  &	 $  Q( _  !@ $%  <  B$	@  $! @   <  B$	@   &  R <  <$  B$d >h 7	@ 1$ !(  	 $  $ %(    !  !       $ !!!Q  B H  @  r !i  7 !  +( ! ! *(C 	 !H@  bT + @T       	  A!  !       ! D / !( + !(E   <!0@  B$	@ !8  Q( ! @ !@   < $  B$	@  $  &   <   B$	@ !  ( 4 0 , ( $     ! `!(     <!0@   9'  8 ''     ! $E  <!   B$	@  $! @   <  B$	@       E  %r !(  + !C        '                                      8                       8                                                                      @                                                     8                                  GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   
+                    	   @         8              %             0                     +             0                     0     p       0                   =              H                    9   	   @       P  @               B              H                     P      0       H                   Y   o        f                                  v  i                                  0     
+         	              @                                                                                                                                                	              
+             "              1              A              V           r                                 T                      0  L                                              |      ,             6             =             Q             [             j             s            ,  D                                p
+  |      ae_balanced_func.c ae_initialize APICAL_READ_32 APICAL_WRITE_32 AE_request_interrupt ae_read_full_histogram_data get_apical_api_buffer apical_api_buffer_data_size AE_fsm_process_interrupt apical_isp_raise_event ae_calculate_exposure_ratio _GET_HDR_TABLE_INDEX _GET_UINT_PTR stab ae_calculate_target div64_u64 sqrt32 log2_fixed_to_fixed math_exp2 _GET_UCHAR_PTR _GET_LEN set_integrator_ae ae_calculate_exposure div64_s64 cmos_set_exposure_target ae_exposure_correction    8     P     H     |                         0    <                            D    L    \    `    l    p    `                            @    D    T    X    <    D    X    \                                             4    \    t                                    	     	     	     
+    
+    
+    
+    \
+  !  d
+  !  
+    
+    
+    
+        
+        @     `                       "  /292            1510573724  0     0     100644  15052     `
+ELF                      -   P4     (               '!    +@E   Q+0     b P#E $  @  G     @ !b   b  ''  <  B$   $ 0$	@ 0  B  < @  <        d     PpQp     b  @ !   # d    @ !$(  #% q$     ( ''  <  B$  ! 	@ $  C  < `  <   B  `     C ` (          B    !       ' ! ' #  #f dp#(  e   '   !      '  <  B$( $      , !  $! ! ! @ 	@ D +P  `T!   '  '   !   $!  +Q  `T!  '    !(   $ !e  $ T@    P$  !    $@  !     $!   `P  c $ eT@   Q$!    c$@ !c  c   c$!c  c("r, ! @ !  $  B( !@      D C  0 ''  <  B$   !  $	@ !    $! $  *  P c$  b$+ b @  B$      ''H   <\   &X T P L D @ < ! 8 ! !( ! p 	! !(@!  	!@   <!@ !0@   &  0 '!(!8	 &!0  ( '!(!8	 &    '!(!0	!8   '!(!0!8	  <  S&	` $  B+" @ $	` $  Q $  U&	  <  t& $	!@ B$@ !  +" @T  T&	 $ $	!@ B$@ !"  1  T&	 $  B+ @P  R&	 $  P  R&	@ $  s& $	`!@ B$@ !  + @, 	@ $ $	`!@ B$@ !  , 0 ( 4   <  R&!  	@ !@     $ !  	@ 2 " \ X T P L H < !  !0`8 D !@@ p   ` ''  <  B$0 , ( $       4 ! !    $!  H L P T 	@ X  +&  !   `rP$   '! t  #+"c&  !   `(rQ$   &! ("r4 ! \ @ !  B0  B, !@( $        D C  8 'h'  <t      | x p      $  B$h !      	@    h   #@S  @    E$+  @   !`!@  # t        B$+(D 
+   !!    <  &      $ @ '!( !0@ !8`h T 	` ` T B @ D  	%!(       $ 8 '!0@ !8`d \ X 	H T ` 8 <  B$      $ 0 '!( !0@ !8`L P 	T H T 2 0 4 !(       $ ( '!0@ !8`` T 	H P X \ L   <  & ! @!(!0	 !8( , H T  ! @!8`!(!0`	 !@ h d `       | x !0 ! t p  ! ` !(@!8    ' !@     | x t p   ''  <  B$H D @ < 8 ! 4 0 , L !  $` 0&	@ 0!@ *3V& & R&	 @!  * @    * @    *P c8 `!  &< $ @   < $  B$         	@   $  <   <      ! !( !0   B$	@ < L H D @ < 8 4 0 ,  P '     ' $   <, $      1&! (   	 p$ <	 p$ D&` d h 	 l  D6	 !@  
+ P@   s2
+ $pSp C `    @   <  1&	  $  Bn @,  $	   <  s& $	`!@ B$@ !B  Ba @, 	  $  B\ @, 	  $  BW @, 	  $ $	`!@ B$@ !B  BL @, 	  $ $	`!@ B$@ !B  BA @, 	  $ $	`!@ B$@ !B  B <@BR& B@  $  	   B $ B@ 4  	   B $ B@   	   B $ B@   	  $	`!@ B$@ !   $ B@   	  $	`!@ B$@ !"  " B@   , ( $      0 '!   $!(  B$CF  $V N  F '8 , (     < 4 0 $ !  !   4  < $(  4&    '	!   D0p   c0
+B0Dp C`  B0
+ 3& !& 1&12    B@   d  !    	 c  b!b   +"@@ < 8 4 0 , ( $      @ ' 0 $     '  <  B$  	@ !       < $  9'   '          '$  	$     m!   $$ $$  #P%   Q B$Z k `Q B$ #@@q!`   )`!!`    Q  g &@#@ 
+@`  r!@%+Xh `U  !@    @hq   B$ c$ $H0+@ UX h    ''  <  1&  !  p$	 p$	 !@  B0  R2Rp  <  1& 	  $  < $	   B&	@  $ !@  b,@!     $ '!  
+'  	'!    $'!   '! "  '! B  ! b   B$D0+  T     $$E  <  B$	@ s T0  <  &	! !@   B+b @  <	 $8    B  <  %	! B$ !  B+b0 @ $	 $  <!   c$	` !@ B$ !b  s+  !  B+b @P '' !  E $  &	 !T ! $  t	  V!^   B   <! `!0  B$	@ !8B0
+  3  B&	@ ! +@  '-7 @c 
+$  	<  3%	` $ $	`  ^ $	`  W $	`  T  V& $	!8B0  <!0 !(  &	  $	`  E $	` $	`  ^ $	`  W $	!@ B0  !0	!8   $  <  %	` $  B  #+C  @      	` $  B  <  S$	` $  B >+^  @  <	` $  ^  <  t$	 $  S& $	`!@ B$@ !  7  +W  @  <	 $ $	`!@ B$@ !    <  $	 $  S& $	`B$@ !b  4  b+T  @	 $ $	`!@ B$@ !   $@@     < cr!   C B* h @d * ^ D * d *"HC  s&s2  &	@  $+b@!     !  S U* j !  * B8 E0* @!   * u 8	 !    ' & ! BB, B8 ' B0!P @
+B  <  V$	 $	 $	 $  < ! `b$	@ !(!@ !@      	< q!(`!   G B!     "%	@ !0 D(
+  &*   P %  !@  $	K %1  <  %	@  $+@  *!H  
+H< ") @ '!t j  
+@  < '   $!  $	  I  E $	  F $	 $	  V  H& $	   	<B0 ! `!8  6%	 	 $  E $	  F $	  G $	 $	 !@ B0! ` 	 2 $0$qDp0p 'Cp! F  !( d $0p     Gp D      d $0pDp '!t DB!H" B%!@B0 &t0 +.@ & `Q2 $ k `   q0 k `     r02 $  <  B$	@ $  B2 $
+b 
+b $
+@b +2  @ #2 B( @    <#Q B(u @+2P "-2 @!  6  !S
+' @  v&  <  $  t%!	   $	!@   B@ !  +   $	  $	!@   B@ !  +V    '!  Dp    C '!b   @ s&s2 +b@ '0 !  ;- @d $  '-  !    	<  3%	` $ $	`!@   B $@ !	`   $	`!@   B &@ !  'C  $   < ! B( 
+'  B$	@  ' !  ! B   !     d p  d B$ c$D0+  
+'  !   @P  <  '  !  !     !   '!      d p  d B$ c$D0+  
+'  !    b$	@  $  T +! !    !  R e B$!eB0D c$ @P  < b@     <  U$	 $  B+C  @;b,s. `    	 $ $	!@   B$@ !b  s$ $  <  $	` $ $	`!@   B $@ !   B$C r U J&3 B(   @~0	`    	` $  B@ !(     	`    	` $  B@ !(   r U   h0 $'!( !    !0  +P+	 @U  +H  U  Z +H	  U    H 
+' '!Pb !H  )  J'PIq!Hb   ) B$PIq   $Iq $!0f I0+H' UX  P & '  !  $  <  '!      d' p!(   $' p!(    B$ p c$dD0+  
+':    @P  <  '/  !    $	` $ $	`!@   B $@ !	`   $	`!@   B &@ !  'C   $  < ! B( 
+'  B$	@  '   !     !   '!      d p  d B$ c$D0+  
+' !     !  !(    $!e 0+( 	'  +  ) +2*  e -* `!  -* ` '  !  	'
+'!0#!8C    @@ 8p`'!HHP  c$Pp $  *'!@(R 8p  0pf0+0  $!   Q  !   `!  - `!  >  !   '!      
+$$'!@c	'
+'!0#  	!@  `'@(q@H !XP 1`q   c$#0F0`p $  l'!HiR @q8p  '0pf0+0  $ !   $'!( 
+'  !(   `'(p@0 !8P 0@p c$  '!0 R (p  e0+(  $ !    '!(    $!e 0+( T( ? `T!   !    !  P  c$!%c0b $ `  < #`     R$	@ $ $	@!@   B@ !b  b+Q 3  R $	@ $ $	@!@   B $@ !"	@  1 $	@!@   B@ !b!    r(  '`''!( !8!0&      @p8p!!    $!  !  0+( @0  C`    #` <     8  $   <  S$	` $ B @    	` $  B $	`Qp B $ "@ 	`   B $	`Rp B B@          @8   < 
+ @R!(  4        @  (  !(  !     <  B$	@       <  B$	@ '  < B0 C @4  @    d  !  b  !    <  S$	` $ $	`!@  $	`!@ 4 r @   <!0!8B$    q     (  	@ G @ <@Bc$ b @    C( `P'$#b * C  P   * b  P0   *  !`  4 &     @4 "@     @4  @ (    <  R$	@ $ $	@!@  $	@!@    <!  !0B$	@ !8`@ <@Bc$ b @     xV'$ z V4 !(  v@4o       '  <  9'            $}xbC( `B( @P $ $}     '    "2 !B"! !B  <   B$	@ 	$  B  *B= c, ` B8~ c$ c0~+d 2 `T}D#E#}D#F#G# @!  }$  F#|}" dT~ D$
+ T~ @F# `T~  } `T}~ c$ c0~+d  `T}D#E#}D#F#G# @!  }F#H"I"}   |    '     '@ $   <! p(  $  & $D < 8 4 0 	 , r $ $!@ 	  t $ $!@ 	  v $ $  <!@  	   R&!@   B @P 1 D $	  $2 D!U  $ $	  !V  1 B@  2 B@     $	  $ !U  $ $	  !V   B 1 B B 2 B  !(  * b d *
+C *tb   $ B $#    &	 <#t#!   $ '!   F!(!0  c$d`D @ < 8 4 0 , ( $  H '                                                                   (                                                                    ?        0                                             `                       8                                              P                                                     0                                                     @                                                                                                                                                                                                                                                                          H          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .sbss .comment .gnu.attributes                                                         @   )                    	   @       4  (              %             P)                     +             P)                     0     p       P)                   =              h)                    9   	   @       :                 B              h,                     P            h,                    V      0       h,                   _   o        ,                                  ,  o                                `/                 	              `2                                                                                                              \                 	 '          	 .                      	                                          
+               >   \        H              W          a     <     i     `    ~                 ,  p                               0         
+  4       D          L      	                 ,     )     (    =  (  T     W             n  |                  d  $                                                                       %       
+  %       %  %  0     =  %  \    V  ,'       a  4'      o              awb_mesh_NBP_func.c luts_fetch rg_avg gb_avg AWB_mesh.isra.1 fifo_push _GET_UCHAR_PTR get_point interpl init_interp_2d_point _GET_LEN get_index _GET_USHORT_PTR init_interp_2d_point_LUT AWB_mesh_LUT mesh_AWB_getKnownSourceLight_weight_LUT awb_coeffs_write awb_init APICAL_READ_32 awb_set_identity awb_read_statistics AWB_fsm_process_interrupt apical_isp_raise_event awb_zones_calculate compute_weight awb_calc_avg_weighted_gr_gb_mesh _GET_COLS _GET_HDR_TABLE_INDEX _GET_UINT_PTR _GET_ROWS stab awb_calc_avg_weighted_gr_gb awb_process_temp_and_shift awb_detect_light_source awb_process_light_source awb_update awb_normalise log2_fixed_to_fixed  `     d        
+     
+     
+     
+     
+     
+     
+     
+             
+  <  
+     
+  @  
+  0  
+  h  
+  8  
+  l  
+          0    4                                            h        d        L    $        4    @                 $    4    l             <	    @	    
+    
+    
+    
+    
+        X    l                    <    T    <    @    `     h     l    t      $    $          |  %    %    &    &                   L  &                          0    @                     ,    0    <                  '  \  '          4    H    h          '    '      $        d    |                                  "    "                   d    h    D    X      "    "  !    !    "    "    H#    L#    X#    \#    h#  (  t#  (  #    #    #    #    $    $    $    $    %  #  %  #  %    &    @'  /  T'  /  '  (  '  (  (  /              @     `                                   @    `                  !     "     #  @  )  `  *    +    ,    -    .  /315            1510573725  0     0     100644  8820      `
+ELF                         P4     (                 'C QB!#!"  <    B$	@  $!@   <  B$	@  $ !0@ 12  <!(   B$	@ !  !@   <  B$	@ $<$C   %(P   < $  9'    '  'C Q   $E!#C  <V $  B$	@ !#!@ ! @   <  B$	@  !@   <  B$	@ !  !0@   <$2  B$	@ !(@   <   3 b   '       @p @`   !H  @ !   !   c$8s !PX*m  !Xl@ !   j B$*H  `#xH @x !x !X  !P   !   )%!0 !  *'@!        !    @X	 !` !P     J c$PqR
+   !@
+!  *Pi @@P @ !   h B$!  *G `!@        $ $  #  0B0  B40 $ $  #         '  <  C$D @ T P L H  c!  `!@   <  B$	@     , '  <  <  1&! @  $ $  s&	`3 4 '  <! `  $	` $@   	$!@ J &#H$!   $!8B  !8b   @q8'q % $B : !0"!8 B$E   $    <!  8 && &  B$	@  $!    < $!  &	@ & D 1&3& BT P L H D @  X ''   <  1&0 ! 0<  8 4 0 , ( $   	 0  	 ! @ P !  	  T ! 	  X ! 	  \ ! 	  ` ! 	 
+ d ! 	   	 ! `< 8 4 0 , ( $       @ ''  <0 $!(  t p l h d ` \ X T ! P  '  B$	@   <  &	 @ $ B0@ $  <	 + $  &$(E 	 @ $	 $$$(E 	 $	 $$$C  E4	 $	 $$$C   E4	 $	 $<c4$C  <%(E 	 $	 $<c4$C  <%(E 	 $	 $$$C  E4	 $	 $$$C  E4	 $  <  1&!(@	  $  <  &	 ! @ !(@ $	  	 ! @ !(@ $	  	 ! @ !(@ $	  	 ! @ !(@ $	  	 ! @ !(@ $	   	 ! @ !(@ $	 $ 	 ! @ !(@ $	 ( 	 ! @ !(@ $	 , 	 ! @ !(@ $	 0 	 ! @ !(@ $	 4 	 ! @  $!(@	 8 	 ! @ <  '!  ! $  $ $-   $#!#   #!!b   e # * !b   c @$  !(   #  &!b   c &!( $ #!b   BD   !( H L 	@ D H L @   R& GR &!HT !    1& !    &	 $ E4	$	 $t p l h ` \ X T P $!d $$(E   x '   < $   Y$!     Y$      0, @P$, @$   $ $+ D        $ !       '   $       <!   &g @  <	 $$$C   R& E4	@$	 $$$C  E4	@$	 $<c4$C  <%(E 	@$	 $ $$(E $	@<	 $ e&$(E 	@$	 $ <4$(E 	@$$	  4$S %(T 	@$$	  4$S %(T 	@$$	  4$S %(T 	@$$	  4$S %(T 	@$$	  4$S %(T 	@$$	  4$S %(T 	@$$	  4$S %(T 	@$$	  4$S $	@%(T <   1& $	 <$S   R&%(T 	@$$	 ( 4$S %(T 	@$$	 * 4$S %(T 	@$$	 , 4$S %(T 	@$$	 . 4$S %(T 	@$$	 0 4$S %(T 	@$$	 2 4$S %(T 	@$$	 4 4$S $	@%(T 6 1	 $$S $     %(Q !@  $  ( '' 4 0 , ( $   a 
+ !    b  <*C J `  <1    T&_  $	 Ct $ $ C $ B8b $  
+  $^  $	 Dt & $ D &b & B8  
+   &` !  #P  	$$ , !8b !@     !X#@@
+q  `  !88 g B$I       	$$$(E   3&	`$	$$$(E 	`$	$<4$(E 	`$  &   $ *b $ `P  *C   `P   T&	$$$C  E4  3&	`$	$$$C  E4	`$	$<c4$C  <%(E 	`$ $    $l   *b  `P   T&	$$$C  E4  3&	`$	$$$C  E4	`$	$<c4$C  <%(E 	`$      $*b  `P  *C  `P   U&	$$$(E   4&	$	$$$(E 	$	$<4$	$(E  #   *b + `P  R& *C ' @P  R&  U&	$$$C  E4  4&	$	$$$C  E4	$	$<c4$C  <$	%(E   	  $c#b ep#  b @       R&$	@  $$C %(S   1&	 $$	@ < c$$C  * %(E 	 $$	@  <c4$C  , %(E 	 $  <  B$	@ !    <  B$	@ !    <  B$	@ !  a  @B$a 4 0 , ( $     8 ''  , < 8 4 0 $C  <c$ c,!   B$ ` $ $	@   < C  E F G  C 
+ C  C  C   B$   "&	@ b &   $$C  <c$ c, `  B$ $	@      C  E F G  C 
+ C  C  C   B$   "&	@ t &   $$C  <c$ c, `  B$ $	@  & C  E F G  C 
+ C  3&  C! @  C &   B	`$  $ $      !   $!0  	`!8  a  @P^ < 8 4 0 !    <,   9'  @ ' $ C $ Cb & B8  
+b   t &!@!   $! "  !  B$C8 < 8 4 0 ,  @ ''  <  B$    	@ !   <$   3 b    <B$D  <  B$	@   R& $  $   	@$$$C   <  1& E4	 $	@$$$C  E4	 $	@$<c4$C  <%(E 	 $	@$ $$(E 	 $	@$< $$(E 	 $	@$ <4$(E 	 $$ <$ $ $$ $ ;$  $ #$       '                                                                                                                                                                                                                                            X                       @                       x                                                                                                                 (               ?        8                       @                                                          L   L   L   
+          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rodata .comment .gnu.attributes                                                       @   `                    	   @         (              %                                  +                                  0     p                          =                                  9   	   @       !                 B                                   P               0                  X      0                          a   o        .                                  >  q                                                	                ;                                                                                                                  	                                          
+                           4              I              S              g              v                                                        P          X            l       `  $     #    (     8    L    Q             X         k                                      $         D       	         	                  H                     x    /  &       	  color_matrix_func.c mesh_shading_modulate_strength _GET_MOD_ENTRY16_PTR _GET_ROWS calc_modulation_u16 APICAL_READ_32 APICAL_WRITE_32 saturation_modulate_strength _GET_HDR_TABLE_INDEX stab color_matrix_fsm_process_interrupt matrix_matrix_multiply matrix_vector_multiply complement_to_direct direct_to_complement color_matrix_recalculate memcpy color_matrix_setup shading_mesh_reload memset _GET_UCHAR_PTR shading_mesh_load is_yuv_format shading_mesh_init color_matrix_write color_matrix_update color_matrix_change_CCMs _GET_USHORT_PTR color_matrix_initialize alpha_delta        ,     <     @     X     `     p     t                                               $    4    D                                            $                                 4    <    @    T    d    D    H    X    \        L                <	    D	    L	    `	    
+    X    ,                 8                (    ,    D    D        P        8    <    H  "  L  "  X    \      %    %           8  %  H  %        %    %      h  #  p  #    $    $          ,    0         8    `    d                @     `                                   @    `       !    "    #    $     &  /338            1510573725  0     0     100644  5508      `
+ELF                         P4     (                0e     '$   <4 0 , (    !   B&	@ $  3 B0+(  s&$  <  & 	 ! `! `!(	   T  D  <#   $  B$	@  $ @!@  C( $  
+C  $  B&	@ $ $$D 2  <%(   b&	@ $ $' 4   <$  B$	@  0  B C, `  R& $ #  @ !d (  #e  b @  #   0	@$ $* 4 0 , $    $C   y&( $%(   8 '0 , ( $    8 '     '0   <D 4 , ( $     &@ < 8 ! 	@$  <$$(E   0&	 $	@$$$(E 	 $  <  B$	@  $ $  < C!    <    <	@  $ !C   V 2  2&	@ $$$	@!(   &  <  b&	@  $+@  &!      <	@  $ !C   V 2  2&	@0$4$	@!( &  b&	@  $+@  &  &	$ E4  1&	 $	$D @ < 8 4 0 , (   ! $ $ E4  H ' $$BB$ B0 B, @  &	  2&@8 !G   D  &  	  $  2!(`   $	@  $$	@!(@ 	 $  !G   D	  "   !@ 	  2&@0 !F   B 2!(`    $	@  $$	@!(@ 	 $ !F   ^  0$	@!(` 4$	@!( &  b&	@  $+@T     &' $,     ( $      <  B$	@ !   <  B$	@  $ $  <  <9 C!    <  B$	@ $ E4  &	@ $    <	@  $ !C   V %2  &	 $ 1&$	!(12  B&	@  $+"@T  & b  <  1&( "  b  <$C `  <  [ $	@  $@ !C   V %2  &	 $ 1&$	!(  12  <  B&	@  $+"@T  &  b!    B$ $ dT $\ $    B$ dT $\ $    B$ d  B$\ $	@   R&  B$	@) "$$(E   &	 $	@$$$  $(E [ $	@   R&  B$	@) " E4  &	 $	@$ E4$	      e, ( $      ! `  <   9'  0 ''     <  ( $  < 8 4 0 , !   B& $	@ 80  Cd $pp!   b @ !  !  %&     $ ! 0 c0bp!!  +  `P B$ R  <
+    B&D        B$	@  $    P	@  $  B   @    `      b$C $ bT  b  B&	@  $  P   b $$B C      <  B$	@ $!@   <  B$	@ $!@   <  B$	@ L$D0  <!(   B$	@ !0 o     @  T& &  *C  	 $  B*P  @  B&	 $  P  B&	@  $&d $r  B $B$
+ @ $ $  <     '  $  b$E  <  B$	@   &	`! @  $0	`  ^  B  +  @d $#+ @!   $	`   P  $	`#p r  B#
+ @   #  R&	@ $  B* @* $  &	1  B+"    *	@ $    P *  <    c$ * b) c#b   tpd $ `      ! < 8 4 0 , ( $     B0 @ ''  <   P$	    !  `!@   <  B$	@        ( (     F&* !(@    d0+D  @T!(` ) !   0 d0+   T!`     "    '                                   ?        8                       H                       0                       @                                  GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @       D                %             P                     +             P                     0     p       P                   =              h                    9   	   @       \  (               B                                   P      0                          Y   o        &                                  6  i                                       
+         	                                                                                                                                                              	              
+            1              @              \              f              v                                                                                                x  d                                	        +             @             J             ^             s  \
+        iridix_hist_func.c iridix_fsm_process_interrupt APICAL_READ_32 cmos_get_frame_exposure_set math_exp2 APICAL_WRITE_32 _GET_UCHAR_PTR iridix_init_pre_post_gamma _GET_WIDTH _GET_LEN _GET_USHORT_PTR sqrt32 _GET_UINT_PTR iridix_initialize stab iridix_request_interrupt iridix_control_strength_calculate _GET_MOD_ENTRY16_PTR _GET_ROWS calc_modulation_u16 _GET_HDR_TABLE_INDEX iridix_update         4     T     X     |                                       h                            X    |                x                d    l    <    |        X    t                                    (    8        L    T    X                                p             <    d    h                                                ,    0    @    D    T    \    t    4                	    	        	        	        	    	    	    `
+    h
+    
+    
+    
+        
+        @     `          /360            1510573726  0     0     100644  5928      `
+ELF                          P4     (               '  $   << 4 0 , (     q&! 8 $  VU	 W$	 !@   $e $ T  <)  !  &	 $!@    $$E	!  <!    &	!@ !    <  1&	   !  	!W !  !@ 	 R2    <!@   1&	 ! @! @!(!0	 !@   s&$!@ 	` $$Q 2  <%(   &	 $	`$$Q E2< 8 4 0 , ( $    !  $%(   @ '  'C RB!C!B  <   !   B$	@  $!@   <  B$	@  $ !0@ R2  <!(   B$	@ ! @!@   " $$B C $ C   <  B$	@ T$<$C    %(P   < T$  9'    '      '  '( ! D  <0 L H D @ < 8 4 ,   B$	@   <  R&!@@ 
+ B @T+ Q    <$E  &  	. $!@   3 $$E	  <!@   8 $$E	  &!@   = $	$E   tb- E!b, W!  	!!   <  &!@ 	 2    <!8 !0  B$	@ ! !@  $ B,b ! `	+ Q! `	!@   <  w$!0@ !(@! 	  <  s&$	`!@  $$D  E2  <  R&%( 	@$	!  	!  ! 	!0@ !@ 	`$ 3 <7 4 $^ %(  	@$	`$ $^ %( 	@$	  	!@ !0@ ! 	!(!@ 	`$ 2$^   %(	@$	`$$^ $	@%(       $D $ ! #@(` %   B  L H D @ < 8 4 0 ,  (  P ''(       <! D0 , $ D @ < 8   B$	@ 4   <B$  1&S0 "  ! @    $b~0 7!b!  <  B$	@ / 6!@   <  B$	@  $  3  <! !(!0  B$	@ !8 D, $. "  
+d . "+!@   !   # S B   bp  B @ 0$ b @     D @ < 8 4 0 , ( $    H ''   <  1&$ 	    <$$(E   &	 $	  
+$<  4!   
+$$(E     '' $   " #  $    < $  1&   	  $ B  <  & $	 0 !@   <  B$	@  $B$ !" "/   <  B$	@ 
+$  P  <  B$	@ H$ $$C   %(  < H$  9'    '  'C Q< ( $    8 4 0 , $E!#C  <!   B$Q $	@ !#! @   <  B$	@  !@   <  B$	@ Q $!0@   <$2  B$	@ !(@  <!@   &	@ H$ $$C  %2  <%(   b&	@ H$   $$B C $ CT"   <  B$	@ !  "  $ "V#   <+ B   <  B$	@ !    Bi @P  &$Bf QT  &  &	 H$B0C  C `   <  &U&   0	$  B! !(  <  &	0 	 D$B0C*   ` $  	^0  B! !(	0!@   <  B$	@ 
+$  UC  `   c$  &$!  r&	   <$C 2%(E 	@$	 $ $$W  E4	@$	 $ ?$!    $W $#    c$ e0	@%( 	 |$ <c4$C  . %( 	@|$  !V !    	@$E4  q&	 $	@$ $$U   E4	 $	@$$U $	  E4  $ Q( B0
+$  &!@ 	 $$R %(Q   q&	 $ $ C( B0	C $R $	 %(V #  $& b<   <  B$	@ !    <  B$	@ !    &$ 	 $$Q %(R   s&	`$$	 $Q < 8 4 0 , (    %(P !` $ $  @ '8 4 0 , ( $      @ '                                  @                                               P                       H                                                                       @          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   P                    	   @         @              %                                  +                                  0     p                          =                                  9   	   @         8               B                                   P      0                          Y   o                                            i                                P       
+         	                                                                                                                                                               	              
+            7              F              [              p              z                                         |                                                   T  h        h     *  $       E             U    X    l             z              noise_reduction_func.c dynamic_dpc_strength_calculate APICAL_READ_32 _GET_HDR_TABLE_INDEX _GET_MOD_ENTRY16_PTR _GET_ROWS calc_modulation_u16 APICAL_WRITE_32 stitching_error_calculate sinter_strength_calculate log16 stab calc_adjust_modulation_u16 temper_strength_calculate noise_reduction_hw_init noise_reduction_initialize _GET_USHORT_PTR noise_reduction_update _GET_UINT_PTR calc_fe_lut_output         ,     l     x                                       4    <                            (    ,    P    \                                     l    p                                    d                                                        L    T    l    p                                    <    D    X    \    l    p                                    	    	    	    	    ,	    8	    <	    \	    `	    	    	    	    	    
+    
+    4    L              
+    
+              
+        @     `                    /386            1510573727  0     0     100644  5048      `
+ELF                      0   P4     (               '    <    Q&! $ 	  $ @P  Q&	  $B$B, @P  Q&	  $B$ $ b @     0 @      b0	  $B$C, `!  	  $  B0r2$      ( '   <8b4  @ 8b$c$(  ph !  !8b 4 h Hp B$!8'l F $      $b d     <  9'   $'   $     $B $
+ C!  @P $ $	 C $ C!     $   $    < $  <  B$	@       !@ - $L $d   < $  B$	@ b  B$@ !"  $  < $!(    B$	@ !0  f  $    $$B& CP  < @P  < $Y C ${ C$ 9    <  1&	 B $ B  <  &B $  <# 	   R&B $	@!@ B$ !b bG $	 $  BG $	 & !@ U  G $  1&	 C $ B  <  &C $  <# 	   R&C $	@!@ B$ !b bH $	 $  BH $	 & !@ 9  H $  1&	 E $ B  <  &E $  <# 	   R&E $	@!@ B$ !b bJ $	 $  BJ $	 & !@   J $  <  1&	 D $ B  <  &D $  <# 	   R&D $	@!@ B$ !b bI $	 $  BI $	 & !@ I $	@    B$ !" "' $       ( ''4 ( L H D @ < 8 0 , L - $!  C  <. $ CT      <  <  B$	@           B$	@       $E  b&	@  $! @   <  B$	@     dX P !@ d $ Dp(pM    \ N 0  EpR  (p  @ T 0  (p#Pf    V 0   p   @ !0  ! !  (  #Xe  $h  +(  !(  $0 $!0  !( !    $h  +H,  Q!(  $0 $!   !( !   	$h +` Q!(   c$c0i $!  !(   	$h K+Xj `Q+ $0 B$!(  + @P!0  #0 0+  @T+0   !  !  +0   $ *       B0!@ +C  @T!`   <  &	2!@ 	! 
+ @!  @ R&@ !#!2  d  C! B f  $$ d0 @0 !&	    " B$@ !0&!"    "! B  c0F0@( *(  P@   B0 B$B0 D#C  " <   $   ep b @ (    0!   $# b d     <CU!C$B! $	 C  $ C  &	 B $!@   G $  &	 C $!@   H $	 D $!@ I $	   <  &!@  b @  <  " q# e$ qB $  &	@ $  $   <!0 2  B$	@ !8@  Qp "2 B, @P $12  &" Q  & b @P& e  % ~' rG $  &	@ $  $   <!82  B$	@ !0@  ^p 3 B, @P $3  &%   <  &	<$ $$R %(Q   <  1&	 <$	@$$R %(^ 	 @$    s&$E	`e $  &	! @   &!@ 	e $2!(  <!0@   '	! $ 	$$ $R  0%( 	 $  j $	`$E	! @ j $	$ $ !0@ 	! $ 	$$$ $R  0%( 	 $$  o $	`$E	! @ o $	!@ !0@ !( 	! $$	!@ $R  2L H D @ < 8 4 0 ( ! , $$%(   P '                                      (                                                                                   (                       P          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   
+                    	   @       X  8              %             
+                     +             
+                     0     p       
+                   =              
+                    9   	   @         (               B                                   P      0                          Y   o                                            i                                `                	                E                                                                                                                                                          	              
+ 1              :      `     L   (        h              |   H                                                                               L  P                                             !             1              sharpening_func.c histogramspace_to_gamma_space _GET_LEN au_read_histogram setup_parameters_to_default sensor_update_black sharpening_initialize _GET_USHORT_PTR math_log2 _GET_MOD_ENTRY16_PTR stab _GET_ROWS sharpening_update _GET_HDR_TABLE_INDEX calc_scaled_modulation_u16 APICAL_READ_32 APICAL_WRITE_32 calc_modulation_u16              ,     D     8    <                                P    T    d    h    p    |                        4    D    H    P    \                                                                ,        4                D    X    d                        	    	    	    (	    ,	        T	        d	    ,    p	    	    	                @     `          flash_func.c.o/ 1510573729  0     0     100644  2624      `
+ELF                         P4     (               '  <  B$  ! 	@ $ $<$C  %(P   < $ $  9'   ''X $   <$   1&       $	 <  <  &$(R 	   $  $	 S&$(S 	   $	 $ $$(R 	 $ $	 $ $$(S 	 $ $	 ( $$(R 	 ( $	 ( $$(S 	 ( $	 , $$(R 	 , $	 , $$(S 	 , $	 0 $$(R 	 0 $	 0 $$(S 	 0 $	 4 $$(R 	 4 $	 4 $$(S 	 4 $	 8 $$(R 	 8 $	 8 $$(S 	 8 $	 < $$(R 	 < $	 < $$(S $     !  < $  ( ''  < 8 4 0 , ( $   Y $ C  Z $ CP   !    $< 8 4 0 , ( $      <  9'  @ ' @!  $ #   < b $""  <  B$	@  $T     $9 C C,# #b ' & #D  #   & d #  $ C ` (  *  ` <  c,< `T" <  c$ C `   <  <  R&$  & $1 U2 T  C(	C $	  W  B##T rSp  !!t $1 U2 T    `T   < @# $ " $"    <  B$	@ 
+ $  <  B$	@ !     " B$ c$  "<  8 4 0 , ( $     @ '            <                                                          (                       @          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   0                    	   @       h	                 %             p                     +             p                     0     p       p                   =                `                  9   	   @       (
+                 B                                   P      0                          Y   o                                            i                                                 	                                                                                                                             H                                              	              
+ )              8              H   H       Y     H    j              o              ~               flash_func.c write_to_flash_output_port APICAL_READ_32 APICAL_WRITE_32 flash_initialize flash_processing stab _GET_UCHAR_PTR apical_isp_raise_event              0     <     T     \     |          P    T    x    |                $         ,                                        @     crop_func.c.o/  1510573729  0     0     100644  8292      `
+ELF                         P4     (               '  0 $     < 8 4 , ( R RT Q !   << @  <$ +R  @T& B&$ & +Q  @T$ "&& $   !*B @P& #U  & " !C *# `  &#"" $	<$R   q&%(U 	 $$	& $R %(U 	 $$	  $R %(U 	 $$	" $R $	 %(U   "    &	@  $$$C  2%(E   b&	@  $(  @< * +B @T* , +" @T,   &	H$ $$W E2  t&%(E 	H$	L$$W %2%(E 	L$* 	P$ $$C 3%(E 	P$, 	T$$W 3T$	%(E *  R* ,  @P*  B. @T  	X$ <$C   w  <c4         W X$  	  <$C   <c4$( %(E 	X$ #. `,   b @   &    	`$ <$C  <c4  $(   b @   &    	`$ <$C   <c4$( %(E   b&	@ `$*  $r  <*C\$ `  B$	@     $$C \$   E4	@ @  T$$C \$   c$ e0%(E   b&	@     ,  $Cr  <*#d$ `  B$	@   s&$$C d$   E4	@ @  2@$$C d$   c$ e0%(E   s&	`    * , < . 0 8 4 0 , ( $      @ ''  ( $     < 8 4 0 , R RT Q2 !   << @  <8 +R  @T: B&8 : +Q  @T8 "&: 8 4 !*B @P: #V4 : 6 !C *# `  &#"6 $	<$R   q&%(V 	 $$	: $R %(V 	 $$	4 $R %(V 	 $$	6 $R $	 %(V 4 6 2   &	@  $$$C  2%(E   b&	@  $<  @P< > +B @T> @ +" @T@   &	H$ $$W E2  u&%(E 	H$	L$$W %2%(E 	L$> 	P$ $$C 3%(E 	P$@ 	T$$W 3T$	%(E >  R> @  @P>  B. @T  	X$ <$C   w  <c4         W X$  	  <$C   <c4$( %(E 	X$ #. `@   b @   &    	@ `$ <$C  <c4  $(   b @   &    	@ `$ <$C   <c4$( %(E   b&	@ `$>  $r  <*C\$ `  B$	@     $$C \$   E4	@ @  U$$C \$   c$ e0%(E   b&	@     @  $Cr  <*#d$ `  B$	@     $$C d$   E4	@ @  2@$$C d$   c$ e0%(E   b&	@     > @ <   &	D $ .$$C (   s&D $	`%(E < B D 8 4 0 , ( $      @ ''  ( $    ,    R RT Q !   << @  < +R  @T B&  +Q  @T "&   !*B @P #T   !C *# `  &#" $	`<$R   &%(T 	 $$	` $R %(T 	 $$	` $R %(T 	 $$	` $R $	 %(T      &	$$$C  e2  &$	%(E ,   ( $        0 '  $ b 0 $     '  <!(      B$	@ !   <!    B$	@ !(    <!    B$	@ !(        < $  9'   '     '  <!(      B$	@ !   <!    B$	@ !(    <!    B$	@ !(       <  $  9'   ''  $   <, ( $      T&   ! 	@ $<4  <  3&$(E 	`@ $	h$ E4	`h$	h$$h$$(E  <	`  < $!   @&    &!  E  "&	@ !   s&tV   <  <!   $ `&   &!  E  "&	@ !   s&tV   <!   $   @&  B&	@ !   s&t   <!   $   `&  B&	@ !   s&tV    T&	h$  3& E4	`h$	h$$$(U 	`h$	D $$$(E 	`D $	h$$U  E4	`h$	h$$(U h$ <	`  < $!   6    &!  E  "&	@ !   s&tV   <  <!   $ 6   &!  E  "&	@ !   s&tV   <!   $   6  B&	@ !   s&t   <!   $   6  B&	@ !   s&t    R&	@h$ E4  1&	 h$	@h$$h$	 $(E $    "        D8$ T$$*   , * , T C9c, `T(   $( 2  $T B4 6  $> B,$ @@  $  < <   , ( $      !    <   9'  0 '        <                                   @                       @                       0                                                                     0                  ''  )$  ,!  .  0  3  5  7  9  :  ;  <
+  >   >   ?    @      @      @    ?   >   >  
+<  ;  :  9  7  5  3  0  .  !,  $)  %& '$ (# )! )   *  +  + , - - - / 	/ / / / / / /	 / - - - , +  +  *   ) !) #( $' 
+
+ 	 	        ! ! ! " " " " " "  "  " " " " " " ! ! !        	 	     
+ 
+ 
+ 
+ 
+ 	 	 	 	 	 	 		 		 		 	 	 	 	 	 	 
+ 
+ 
+ 
+ 
+      @      @    @   ?   ?   >	   <   ;   8  7  5  2  1  .  ,!  )$  &&  $)  !,  .  1  2  5  7  8   ;   <   	>   ?   ?   @    @   &% $' #( !)  )  *   + + , - - - / /	 / / / / / 	/ / - - - , + +   *  )  )! (# '$ 
+
+ 	 	        ! ! ! " " " " " "  "  " " " " " " ! ! !        	 	     
+ 
+ 
+ 
+ 
+ 	 	 	 	 	 	 		 		 		 	 	 	 	 	 	 
+ 
+ 
+ 
+ 
+     GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rodata .comment .gnu.attributes                                                       @   0                    	   @                       %             p                     +             p                     0     p       p                   =                                  9   	   @       4   0               B              H                     P             P                    X      0       P                   a   o        n                                  ~  q                                H  p              	                                                                                                                                 	           	              	                                          
+                      h    *              9              I   h      U    	      `   
+       {                   h                             crop_func.c h_filter v_filter _update_ds APICAL_READ_32 APICAL_WRITE_32 _update_ds2 _update_fr crop_fsm_process_interrupt apical_isp_raise_event crop_resolution_changed crop_initialize crop_request_interrupt              <    X                    ,    T                        4                    ,    d                4                	    	    @     4
+    L
+    
+    
+    
+    
+    
+    
+    
+            ,    8    @    L    T    h    t                             ,    H    \    h    D                            T    h    H     t                            $        8	         @	    0                        @     `               /407            1510573730  0     0     100644  6940      `
+ELF                         P4     (               '( $       , ! ! $ $!    < $! @  &	@ !(   C 1&!c  d( 5  C  <!   B$	@ !(`4H  <  B$	@ ! @, ( $      !    <  $  9'  0 ''8 0   < 0T !( P L D < 4   S& $H 	`@   <! @   &	@   < $!( 	`!@ ! @   &	@  <!   '  <    ' !   $ , 	(  < c4  %	!   %	! ( ,   s& 1&bV  %  R $ $  $  Q&	 !( !(  $	 !@ !@   &	 ! ! `	 !@   <$ !@   b$	@ $  < E4  "&	@ $  <!   $	@   $ C!   <  B$	@ !  	      !D   e ($  #&	`    &    <  b$	@ ! ` $8 CT  &    <  &	@ !  
+      !C   e     #&	`  ($  &V@    <  B$	@ ! `!@   !  !  E  "&	@  0$ s&vV    <  S$	`$$$(E   1&	 $	`$ E4	 $	`$ E4	 $   $	! `!@   !  !    E  "&	@  0$ s&vV@    < $  B&	@ !(   <! @   "&	@ !   $  < $    < $0t!s   G$!  ,   &	@ (  d2  ( ( '( , $E ( %(E   '	@ !   s&  F&,  $	 !( ! @   &	@     +b@,  $	 !(   1&	 ! @ !@ !  $  < $/    <  K$H4 &%  &!      , 	   #2 8w  , '8 (k $G !    '%(E $ , 	 (      J)% !   	   ( $    $G (j , !  	 %(E  1& $  B&	@ !( ! @   &	@     +"@!Pq  T  <  <  B$	@  $&$$(E   <  B$	@  $6T P L H D @ < 8 4 !    <0   9'  X ''  $    !     <  B$	@ < <  $! CPp B @Px B $K C $` CT  4    <  <  <  1&  R&. $	@ " B. $	@- "!@   <  B$	@ . $B$ !B B $  , "  <  <  1&  R&/ $	@ " B/ $	@- "!@   <  B$	@ / $B$ !B B!   , "  <  B$	@     +      R&	@1 $ B  <1 $  1&	@- "!@   <  B$	@ 1 $B$ !B   Bp B  <  1& "  <0 $  B$	@   <  R&0 $	@!@  B0 $s&- "	@ !S  B, "    <  B$	@ $  $        <$  9'  ( ''  <  B$  ! 	@ $ $ $$  $ O $ @ $ [ $   <B$	@ !    !    <   9'   '@ G @'  !(  !  f$( $!@  $!H <  T!(  ( $!@ 0  $!H $Ep8e E  0  A ,+ @TA A  B$ B0A  B,$ @ <A '` d  /v$ $!@ 0  $!H $Ep8e E  0  A , @PA A  B$ B0A  B,	 @<A  d'`4  <  9'   '  '? <  E    '     <  "! L &&	@ 4 $&? [ "  <B$	@ !      <  B$	@ $A       '      0   < $   <    9'  9'           '   , ( $     0$E+ !@  <!   &	  $  <  &	! @ !@   " $$E	   <  s&	`! @ ! @  <F0  R&	@!(!@   " $	 $E	! @ !@   " $	 $E	`! @ F0! 	@!(, ( $       0 ''   $     $B $7 C0 $ C $G CT!   <  R&  $	@  <  1&  $	 !@ !    <!(`  &	 F0 $	@!@ !@    $  <  R&" $	@  <  1&" $	 !@ !    <!(`  &	 F0 $	@!@ !@  $	     F0! `	 !(@  $   <  R&! $	@  <  1&! $	 !@ !    <!(`  &	 F0 $	@!@ !@   $$       ( '                                          0                       X                     (                                                                                                                         ?        0                       (          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                        	   @         H              %             @                     +             @                     0     p       @                   =              X                    9   	   @         H               B              x                     P      0       x                   Y   o                                            i                                @                	                                                                                                                                                                                    	              
+ 5              Q              h                                  D                                                                                                                  #             5             J             O             Y             k             }               (  x                                   ,      	                      P
+  4     2  
+       E             e    t    w              general_func.c adjust_exposure general_set_wdr_mode cmos_get_frame_exposure_set ae_exposure_correction cmos_set_exposure_target apical_fw_raise_event apical_switch_wdr_mode _GET_HDR_TABLE_INDEX _GET_USHORT_PTR _GET_LEN APICAL_WRITE_32 APICAL_READ_32 _GET_WIDTH _GET_UINT_PTR _GET_UCHAR_PTR shading_mesh_load _GET_MOD_ENTRY16_PTR stab _GET_ROWS load_isp_sequence iridix_initialize sharpening_initialize general_initialize apical_sbus_isp_init general_request_interrupt general_frame_start general_frame_end color_matrix_change_CCMs general_fsm_process_interrupt calc_fe_lut_output calc_equidistant_modulation_u16 calc_fe_lut_input calc_inv_equidistant_modulation_u16  8     D     l     t                                           $    <    d                                  ,        4    L    P    p                                    0    4    H    P                                L    \    t                        |                                 4    8    x        t                        |                ,    0        D    T    \    l    p                                            ,  !  0  !  p    t      "    "  	    	    
+    
+    $
+  %  (
+  %  d
+  #  l
+  #  X
+  $  p
+  $  
+    
+    
+    
+    
+    
+      (    (                    *    *          (    ,    @  *  H  *                    *    *              @     `         #     $     &     '     )  dis_func.c.o/   1510573731  0     0     100644  3340      `
+ELF                         P4     (               '  <  B$L T ! P 	@ ( ' $$  &!     '!0   !   f B$ C,`4 '  <( ,   B$	@ 0  @T  <  <  B$	@ p$&<c4$C  <%(E   <  B$	@ p$6` $   <!    B$	@ ` $@ T P L  X ''   <4      2&! 0 	$, ( $ 	@  	$	@!@   > (  B0 s2 br $*b    `P! 4 0 , ( $             <  $  9'  8 '@ , &!   4   $    &	!  qD&  !@ 	!          #  B0 4 # " # > R& 1&*V@TpD& 4 $ 4  B$0 , ( $      $   8 ';     @ $7 b     4 @    '8   <@ 4   3&! 	$D 	`< 	$	` R0  B0 C   CD     < '  B$	@    1&	 	$ B0	$	   B0     <  B$	@  'D @ < 8 4 !   H ' !   ,048  <  <  B$8 E: F   !  <  $@'  $ + C!  1 `$   " `T$     <  B$   	@    < , & '  B$	@  ' @   ,04 8 <  <  B$8 D: C     $  B$	  $ D @$   <  B$	@  D $   ( '      0 $     '  <  B$  ! 	@ ($  !    <   9'   '                                            X                       8                       H                                                     (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                        	   @                        %             @                     +             @                     0     p       @                   =              X                    9   	   @         0               B                                   P      0                          Y   o        6                                  F  i                                       
+         	              
+  )                                                                                                                                              	              
+                           4              =              L              \              r                           p                                      h  @                                                            X      dis_func.c dis_initialize dis_get_default_settings dis_open APICAL_READ_32 APICAL_WRITE_32 dis_request_interrupt dis_update_stats apical_isp_raise_event dis_update_settings dis_get_settings dis_set_settings dis_update_output stab dis_analyze_stats dis_analyze dis_reset dis_fsm_process_interrupt              \     h                                                                            0    4                             H    L    |                            
+        @     `               /425            1510573732  0     0     100644  1258      `
+ELF                          P4     (  	                _} Q @; }_ )K 0 9I E I   x lq xj D@d    Q }_ 0 E  x xj Y-^ lS aXI @ 9 h2 r|, EB'    }_ E x Y-^ aXI 9 r|, U" q  ]  	  B    E Y-^ 9 U"    U 
+   r  b  ;  ?$                           GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .text .data .bss .reginfo .pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                      !             @                     '             @                     ,     p       @                   5              X                     :              X                     H      0       X                   Q   o        v                                    a                                        
+         	                B                                                                                                                                                                     @        @   @     *      @     6      @      dis_gauss_lut.c exp_lut_16fx exp_lut_8fx exp_lut_4fx exp_lut_2fx dis.c.o/        1510573732  0     0     100644  3700      `
+ELF                         P4     (                 $ $   $  $  $      !   $ T' $  <  B$ 	@      @T$   '     	  $'  <   B$	@   $  !   $   ' ! 
+ !  ' E$  <   B$	@   $  !   $   '      !  '  $     , 0 4 L 9 D  $!  B!   !    <  &  <!(  ,$  B$	@ !    <  0 &  B$	@ !    <!  , '  B$	@   $  <  B    <  B  $ ( $   <  B$ $ $      &!(`    <  9'  ( '  !  $$        ( '$   $   # *0  T    *C  `T    # *   T  * d  !        'D @ < 8 4 0 ,   $    +  $    <! ! !0!8`  B$! 	@ ! @  ' $ !  !(!0	@ !8`@  <  $ !    B$	@  '!@   <!    B$	@  '   B  B    "$  "D !`@ < 8 4 0 ,  H ''   ( r $*
+C   <$   ! , ! ! $ $  B$	@   $E @ $  F C & F #   :  ! #0 &(C !  #   ( $ 0   ( :  $#     j(J  d$!    K(R  C$k Z B ! !     $!8    *(  
+  *0& B9 *(  TB $* d P c$B9 B $8 !8'  m '  $   B$ c$*(p  lp  , ! , ( $     0 '            ??                                                                                                                                                                      (                                                                           ?        H                       0         ff>= GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rodata.cst4 .comment .gnu.attributes                                                      @   p                    	   @       4                 %                                  +               0                 0     p                          =                @                 9   	   @       $  P               B                                   P                                ]      0                          f   o        .                                  >  v                                
+                	                5                                                                                                            ,                 	              	             	                                          
+               #       H     <   H   8     F              W      D     h              o      H                  $  8                                                 \          h  d                                         #         dis.c dis_global_static $LC0 $LC1 dis_get_default_settings dis_reset iir_filter_reset dis_set_settings memcpy dis_get_settings dis_check_settings dis_open memset get_gmv_gauss_method_fast_v2 get_gmv_gauss_init dis_close dis_clip_gmv_vector dis_analyze validate_motion_vectors iir_filter_v2 dis_update_bg_map    X     \                         p    t    x                                  	    	               $        $    \    l    |                             @     `                                   /444            1510573733  0     0     100644  1912      `
+ELF                         P4     (                !  !  
+  !@   )%!j  *XJ K%U  $ %!H  @q' h          b  !   $  '  #b  *   d $#C dp B$ b @ ' '    *  *  @* #0 *  
+ !  *  @#   $*(e     !       '     %     '$  $0 , (     4   ! ! p! !    <   $ #b  B( @!     & 1&4V !u R& V!` !   $  !    &	@ K $@T    4 0 , ( $        8 '                                                                                                                                                                8          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @       @                 %             P                     +             P                     0     p       P                   =              h                    9   	   @       P  (               B                                   P      0                          Y   o        &                                  6  i                                        
+         	                                                                                                                                                               	              
+        x     )   x        >      4     W      L     h           dis_validation.c get_common_estimations validate_smooth_test validate_complexity_test validate_borders validate_motion_vectors `            
+        @     `          /464            1510573734  0     0     100644  3068      `
+ELF                      0   P4     (                +  `!      ! D        #      $   < , @ $ $         <
+   < $         <    B$    B$  B$   $   !    B$      $'0 L H D @ < 8 4 , ( C ` 0p!  $! !  $!  *    <  	 @ 
+$   & @P 1&  " ##"#C cpBp!(   $      	@ ! d       ! 1&   '!!  !  W "+ & &V $	 bR  @ $br!v   b  B b   B @  !  $L H D @ < 8 4 0 , (  P '  'bp $f(
+F   !P  !X  	$!  9   $!0      !8    !0   hp !p     #h  #p    qh  +p Q $ h !h  !0  $*h     +8F T!P  ! !P !H@        p0  +8   B$ 0 !0   !Xf*0C 8Lp $XbqBX +PK @ $       "q!He   "   " !    '' 4 !  0 (p $(, 
+(C < 8 ! P !0  $!  F   
+$ !  i  h )#   q     c$  ` B B c$ ! c!   C  c0`  !   % hp!`     #` #h  qh  `qc +h Q $ ` !`
+ `  Bi B %h !h !`l h  1 $*`     	 `P B$+   T!0`   B$!0` !8@  B$*E ` Jp $p  <!8r     " 
+  "     !  !(@  s&	`!0  
+  < !  !(@  b&	@ !0  B(@T  < 8 4 0 , !   @ '                                                                                                          P                                                    @          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @       l  h               %                                  +                                  0     p                          =                                  9   	   @         (               B                                   P      0                          Y   o                                            i                                `	  @     
+         	              
+                                                                                                                                                 	              
+        (        (        /              ;              G              S              `      p    }   0  l                            dis_gauss_method.c get_exp get_gmv_gauss_init exp_lut_4fx exp_lut_2fx exp_lut_8fx exp_lut_16fx get_gmv_gauss_method_fast_v1 get_gmv_gauss_method_fast_v2 get_gmv_gauss_method_fast_v3 dis_update_bg_map    X     |     8          `          t            
+  P  
+  @        \        
+        @     `          dis_filter.c.o/ 1510573735  0     0     100644  3240      `
+ELF                         P4     (                !(  '  <  !  $  B$	@ ( $ $ ( $   !   $    '  <  H  	<!@   H  B$ D'!   #$       D $Cp, 0 ! !  e$  f(
+(f ( !(  % )% #  <Cp  s& C$  F(f 0 !0  &  	< *<
+ !j C # !C %% # 	 !I C # !"  f(  e$  #@  E( C$e  #     	` 	$$R 2  <%(E   &	  	$	`	$$R %2%(E 	 	$$      !   ( '  < C', !(e  E B$ C0 !0   <  d$       F $@Dp  <!  $  ( C   p  c$ d  s&@Dp<! D$  Q(   <0 C  q $  <`hp( K( I$#!@ %  )@@ 0 0 $  *hlp#*! l$  m( !@h !C#( #0     	$( H	` #$R 2  <%(E   &	  	$	`	$$R %2%(E 	 	$$      !   ( '  <8 C', !(e 8 E8 B$ C  <H 0 !0  $$      `hp F  <@ K@ I$# !@ %  )@CA H H $  *hlp# ! l$  m(C !@h !C#( #0   <     s& 	$@ H #	`<$R 2  <%(E   &	  	$	`	$$R %2%(E 	 	$$      !   ( '        ?                                                         (                       (                       (          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .sbss .comment .gnu.attributes                                                         @                       	   @       
+                %                                  +                                  0     p                          =                                  9   	   @                         B              X                     P            X  P                  V      0       X                   _   o        v                                    o                                P                	              
+                                                                                                                   	           	           	 (          	 0           	 9   0       	 B   (       	 K   8       	 S   H       	 \   @       	              	                                          
+               e       \     v              }   \   p                                     |       H  0     dis_filter.c sp.9007 fsp.9008 csp.9009 sp.9015 fsp.9016 fmv.9018 csp.9017 sp.9024 fmv.9026 fsp.9025 iir_filter_reset memset iir_filter_v2 APICAL_READ_32 APICAL_WRITE_32 iir_filter_v4 iir_filter_v3              \     `     l     p               d                                      |                                4    8        @    \    `    p    x    |                         H    L    \    `    h    l                                    (    0                @     `     /486            1510573736  0     0     100644  7320      `
+ELF                      t   P4     (               ' !   <  <  1&  $ $! $	  '  < ' $	 6 $ '  <! `  $	  $!@  $!  !0b   !(B B$D  L&B0[ C, ` & &Z c, `P&$  #  Z c, `PZ .#   & & 	   $ `D$ & &   $!  !   @  !  q D [ C, `D Z $  #b &Z c, `PZ .B$      $ `P&$  #b Z .  Z B$     $!  !  @ ! B!(@Cp '    ' G F8p0p; 3 !0   G B$C8 !0  4 4 C1   D $$  (''!@!    ! $ $   $Kp!xB  !x   B$xsz L!8 !p& $   !  !8   !p  c$ mP!  !0  !Pd  !H $!8  !0  B$C  !   	$!    
+$!X   l!X  k B$XqZ J!0 !8 c$ b  ip!0  !8D  !  !   $!  f(  $!  4 4  ( P$!0  B$G !   $! ! !8  h  B$!8F g!     '' '  <( !   <8 , D @ < 4 0 !  0! `  $  B$	@  $!@  $!  !0b   !( B$D    <  r&p $&	@!( X $&	@!(  $&	@!( ( $&	@!( @ $&	@!(  $   <  B$	@ $!@ !    < $!  D  &	@     !2 R&T b $&  s&	`!( !    < $!  BC(	 `$! @    B( @P $ $ $   &	@  1&3  B &	 $ $  ( `$    f(       $ b c$     c$   B$ B0E &D @ < 8 4 0 , (  H '' '  <<   <@ 8 4  D ! p $ $! `   B&	@  $!@ !8@!   $!0b   !(" B$D  b&B0 C, `P   <  c$!b   B @      K0 @X     !X   ` B$J K0 c$ bepf    !   $ 	$ 
+$ep0 ! Q  h0!0& !  !@ 	!@  B$E  	 c$ f!  P    !   $ $!   ! # K0 @X     !X   ` B$J K0 c$ bTep  $!   $ 	$ 
+$ep0 ! Q  h0!0& !    .   u $p  $r  $  $t p $z   $v x | ~     K0 @X     !X   ` B$J K0 c$ bep    !   $ 	$ 
+$ep0 ! Q  h0!0& !           `@ &$(Dp <c4!   $$(Dp< c$!  $ C ` !       (  $!(  c$d   $R T V  @ H P  $#b @  ( & !   $!0 B$E  : < >   '  <( 0 8 $! `   $	  $R&!@  &@ !   $!0b   !("0p B$2 D     B$  X & B$    B$    <  B$	@   <   1&!  	  & !  	  & D @ < !   &! 4 8   H ''   <, ( $      T&   ! @$	<$U %(Q   <  3&	`@$D$	 $U %(V 	`D$H$	 $U %(V 	`H$L$	 $U %(V 	`L$P$	 $U %(V 	`P$T$	 $U %(V 	`T$X$	 $U %(V 	`X$\$	 $U %(V 	`\$`$	 $U %(V 	``$ 	d$ $$U 2%(E 	`d$ 	h$$U 2%(E 	`h$ 	l$$U 2%(E 	`l$	p$ E4	`p$  $ C $ C          	p$ E4	`p$	p$ E4  p$	p$ E4	`p$	p$ E4	`p$	p$ E4  p$	p$$$(E 	`p$	p$$p$$(E 	`    	p$$p$$(E 	`  T&$<	 $U %(S   3&	`$$	 $U %(V 	`$$	 $U %(V 	`$$	 $U %(V 	`$$	 $U %(V 	`$$	 $U %(V 	`$$	 $U %(V 	`$$	 $U %(V 	`$$	 $U %(V 	`$ 	$ $$U 2%(E 	`$ 	$$U 2%(E 	`$ 	$$U 2%(E 	`$	$ E4	`$  $ C $ C          	$ E4	`$	$ E4  $	$ E4	`$	$ E4	`$	$ E4  $	$$$(E 	`$	$$$$(E 	`    	$$$$(E 	`  R&$<	@ $S   1&%(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $$	@ $S %(T 	 $ 	@$ $$S 2%(E 	 $ 	@$$S 2%(E 	 $ 	@$$S 2%(E 	 $	@$ E4	 $  $ C $ C          	@$ E4	 $	@$ E4  $	@$ E4	 $	@$ E4	 $	@$ E4  $	@$$$(E 	 $	@$$$$(E 	     	@$$$$(E , ( $      !    0 ''  <  B$  	@ !  !    <   9'   '' '  <  < $@ < 8 4 ( D ! 0 ! ` ,   B$	@  $!@ $    $ @ $   O $ !  !`   < $!  R  &	 ! @ 	 ! @@ 	 ! @( 	 ! @X 	 ! @ 	 ! @ 	 ! @ s& t &D @ < 8 4 0 , (  H '                                          (              @                                H                       H                       0                                              H                  @???????a?6??>>\>>==4=<<$<;W;:x::9987m76F655m433o211M0/.
+.A-u,+*)#)G(g'&%$#"!   |fN6
+wY<    #,
+%oL0# %oEL#O%o	L8                        kh l       P      8                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @   P                    	   @                       %                                  +                                  0     p                          =                                  9   	   @       8  8               B                                   T               @                 P   	   @       p  (      	         \      0                          e   o                                            u                                                	              t  #                                                                                                                              	                                                         1              8          P         i              y                               x  0       	  H                                     8       (        matrix_yuv_func.c matrix_compute_hue_saturation memcpy update_composite_matrix compute_transfrom_matrix _GET_USHORT_PTR direct_to_complement complement_to_direct matrix_yuv_recompute matrix_yuv_coefft_write_to_hardware APICAL_READ_32 APICAL_WRITE_32 matrix_yuv_update matrix_yuv_initialize                       8     @     P     X                          H    L    `    p                                                         H	    L	    T	    \	    	    	    	    	    (    D    x                        0    8    4    d                        @     `                         $    (    ,    0    /507            1510573737  0     0     100644  16364     `
+ELF                      t   P4     (                 <   B$'  <   <   &$  B$	@ $ $   $  & C $ C $ C $ C $
+ C $ C $ C $ C $ C $ C $ C $ C $ C $ C $ C $  C $" C $$ C $& C $( C $* C $, C $. C $0 C $2 C $4 C $6 C $8 C $: C $< C $> C $@ Ct $B C $D C~ $F Cy $H C $J C $L C $N C $P C $R C $T C $V C $X C $Z C $\ C $^ C $` C $b C $d C $f C $h C $j C $l C $n C $p C $r C $t C $v C $x C $z C $| C $~ C $ C $ C $ C $ C $ C $ C $ C $ C  $ Cu $ C $ C $ Cz $ C $ C $ C $ C $ C $ C$ C $ C $ C $ C $ C $ C$ C
+$ C$ C$ C$ C $ C$ C$ C$ C$ C[ $ C\ $ C $ C $ C $ C $ C$ $ C% $ C) $ C* $ C $ C. $ C/ $ C3 $ C4 $ C8 $ C9 $ C= $ C> $ CB $ CC $ CG $ CH $ Ce $ Cf $ Cj $ Ck $ Co $ Cp $ CQ $ CR $ C $CV $CW $C $C$
+C$C	$C $C $C $C$ C  ''  <  !  0( $   ,   B$ 0 0	@ @   C/$(p !   b.@ $  <  B$ !S   b @      B.@,   < B$ !R   B!(  @ !8 , ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 'R& R27 B.@,   << B$ !R   B!(  @ !8 , ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 'R& R2 B.@,   <B$ !R   B!(  @ !8 , ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 'R& R2  B.@,   <`B$ !R   B!(  @ !8 , ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 'R& R2 B. @,   <B$ !R   B!(  @ !8 , ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 ', ( $      <  9'  0 '} $ B~ B. @~ $| $M B,   (  B $G B,    ( $ !( !8      <  9'  0 ', ( $ !( !8      <  9'  0 ', ( $ !( !8      <  9'  0 '$ !( !8      <  9'  0 ' $ B $ B,   ( , ( $ !( !8      <  9'  0 '$ !( !8      <  9'  0 ', ( $     $ 0 '                                                                                                0                    l  \        l  L  p           $  H          0  T  x          ,  P  t        	  (	  L	  p	  	  	  	   
+  $
+  H
+  l
+  
+  
+  
+  
+     D  h            @  d            <  `            8             D  h            @  d          L  p           $  H  l             D  h            @  d            <  `         $  H  l             D  h       GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @                        	   @       2                %             @                     +             @                    0     p       @                   =              X  `                  9   	   @       ;                 B                                   T                                P   	   @       ;       	         \      0                          e   o                                            u                                  0	              	              $(  
+                                                                                                                             	                                                         "            2          L              S     P    b              p                                                                                                               +             <             M             a             n                                                                                           :             _                                                                                                                     )             E             a                                                                                                        6             U             m                                                                 "             K             t                                                                              -             L             k                                                                                                        5             D             S             c             s             |                                                                                                                                  #             5             D             L             Y             g             n             x                                                                                                                                                	             	             	             *	             8	             H	             P	             [	             l	             s	             	             	             	             	             	             	             	             	             	             	             	             
+              
+             4
+             F
+             Z
+             e
+             p
+             
+             
+             
+             
+             
+              apical_command_api.c API2FRM_IDX GET_API2FRM_IDX apical_api_init_idx_array memset apical_command apical_get_fw selftest_sensor_id selftest_sensor_interface selftest_isp_interface selftest_lens_interface selftest_isp_revision selftest_fw_revision selftest_api_revision selftest_calibration_revision buffer_data_type isp_system_state test_pattern_enable test_pattern system_freeze_firmware system_manual_exposure system_manual_exposure_ratio system_manual_integration_time system_manual_sensor_analog_gain system_manual_sensor_digital_gain system_manual_isp_digital_gain system_manual_directional_sharpening system_manual_un_directional_sharpening system_manual_iridix system_dis_x system_dis_y system_manual_sinter system_manual_temper system_manual_awb system_slow_frame_rate_enable system_manual_saturation system_manual_exposure_time system_exposure_dark_target system_exposure_bright_target system_exposure_ratio system_max_exposure_ratio system_integration_time system_max_integration_time system_sensor_analog_gain system_max_sensor_analog_gain system_sensor_digital_gain system_max_sensor_digital_gain system_isp_digital_gain system_max_isp_digital_gain system_directional_sharpening_target system_maximum_directional_sharpening system_minimum_directional_sharpening system_un_directional_sharpening_target system_maximum_un_directional_sharpening system_minimum_un_directional_sharpening system_iridix_strength_target system_maximum_iridix_strength system_minimum_iridix_strength system_sinter_threshold_target system_maximum_sinter_strength system_minimum_sinter_strength system_temper_threshold_target system_maximum_temper_strength system_minimum_temper_strength system_awb_red_gain system_awb_blue_gain system_saturation_target system_anti_flicker_frequency system_ae_compensation system_calibrate_bad_pixels resolution_active_image set_sensor_fps fr_pipe_status ds1_pipe_status ds2_pipe_status fps_mode wdr_mode dvi_output orientation_hflip orientation_vflip image_resize_enable image_resize_width image_resize_height image_crop_xoffset image_crop_yoffset histogram_lum sd_capture_frames sd_capture_run af_mode af_range_low af_range_high af_roi af_status ae_mode ae_split_preset ae_gain ae_exposure ae_roi ae_compensation ae_freeze ae_integrator_set antifog_mode antifog_set_preset awb_mode awb_range_low awb_range_high awb_red_gain awb_blue_gain awb_temperature awb_roi awb_freeze antiflicker_mode iridix iridix_strength dis_mode sinter sinter_strength temper temper_strength defect_pixel scene_mode color_mode fr_output_mode ds1_output_mode ds2_output_mode sharpening_strength brightness_strength contrast_strength saturation_strength flash_mode flash_time register_address register_size register_source register_value exposure_log2 gain_log2                              (     8     @                     ,    0    `    d                                            8    <    \    `                                          $    D    H    h    l                        !    !    "    "    #     #  @  $  D  $  d  %  h  %    &    &    '    '    (    (    )    )  	  *  	  *  <	  +  @	  +  `	  ,  d	  ,  	  -  	  -  	  .  	  .  	  /  	  /  	  0  	  0  
+  1  
+  1  8
+  2  <
+  2  \
+  3  `
+  3  
+  4  
+  4  
+  5  
+  5  
+  6  
+  6  
+  7  
+  7    8    8  4  9  8  9  X  :  \  :  |  ;    ;    <    <    =    =    >    >    ?    ?  0  @  4  @  T  A  X  A  x  B  |  B    C    C    D    D    E    E    F    F  ,  G  0  G  P  H  T  H  t  I  x  I    J    J    K    K    L    L    M    M  (  N  ,  N  L  O  P  O  p    t      P    P    Q    Q    R    R    S    S  4  T  8  T  X  U  \  U  |  V    V    W    W    X    X    Y    Y    Z    Z  0  [  4  [  T  \  X  \  x  ]  |  ]    ^    ^    _    _    `    `    a    a  ,    0    `  b  d  b    c    c    d    d    e    e    f    f    g    g  8  h  <  h  \  i  `  i    j    j    k    k    l    l    m    m    n    n  4  o  8  o  X  p  \  p  |  q    q    r    r    s    s    t    t    u    u  0  v  4  v  T  w  X  w  x  x  |  x    y    y    z    z    {    {    |    |  ,  }  0  }  P  ~  T  ~  t    x                                    8    <    \    `                                            4    8    X    \    |                        8    <    \    `                                @                                                    $     (     ,     0     4     8     <     @     D     H     L     P     T     X     \     `     d     h     l     p     t     x     |                                                                                                                                                                                                           $    (    ,    0    4    8    <    @    D    H    L    P    T    X    \    `    d    h    l    p    t    x    |                                                                                                                                                 apical_isp.c.o/ 1510573737  0     0     100644  7412      `
+ELF                      
+   P4     (               '  <( ! L .& $H D @ < 8 4 0 ,   B$	@ .$ $ 	&   <!     B$	@  	 $ &  <!     B$	@   $&  <!    B$	@   $&  <!    B$	@   $H&L  <! ` H  B$	@   &  <! @   $	 $ &  <!   $	 & $  <  $	 ! & $  <!   $	 |&  <!   $	 |&  <!   $	 & $  <  $	 ! `0  <,&! @  $	 ,x-t-  <t-&  $	 !     
+<!    J%	@ $   
+<!    J%	@ $   
+<!    J%	@!(     
+<!    J%	@!(      
+<! `   J%	@!(  $   
+<! @   J%	@!(    
+<!   J%	@!(    
+<!   J%	@ $  
+<!   J%	@!(    
+<!   J%	@!(    
+<!   J%	@ $  
+<! `  J%	@!(    
+<! @  J%	@!(    
+<  J%!  	@!(     <  $	 !     <  $	 !     <  $	 !     <  $	 !    ! `   <  c$	`     $ ! @   <  B$	@       <  B$	@ !   <  B$	@ !   <  B$	@ !   <  B$	@ !   <  B$	@ !   <  B$	@ ! `  <  B$	@ ! @L H D @ < 8 4 0 , !    <(   9'  P ''   $ 02$B   `! ' %d $b   < &  B$	@ !( $B `PP' %d $b   <&  B$	@ !( P$B `PT' %d $b P  <H&  B$	@ !( $B `P' %d $b   <&  B$	@ !( $B `P' %d $b   <&  B$	@ !( $B `P' %d $b   <&  B$	@ !( $B `P4' %d $b   <&  B$	@ !( 4$B @ 8' %C$B 4,&!(     <  9'    '      ''8 4 0 , ( $    <  ! ! !    <  <  <  <  <  B @  &  &	@       &	@ .&!@   B @  &	@        &  &	@ !( !@  &!(   '	@   &%C  C0  <!(   B$	@   &%b  C0  <!(   B$	@   H&%b  C0  <!(   B$	@   &%b  C0  <!(   B$	@   &%b  C0  <!(   B$	@   &%b  C0  <!(   B$	@   &%b  C0  <!(   B$	@   |&%b  C0  <!(   B$	@   &%b  C0  <!(   B$	@   &%b  C0  <!(   B$	@   ,&%b  C0  <!(   B$	@   t-&%b  C0  <   B$	@ !(  %b  C0u`P r` R&*Sp@T < 8 4 0 , ( $      @ '                                      P                                               @          GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   0	                    	   @         H              %             p	                     +             p	                     0     p       p	                   =              	  `                  9   	   @                        B              	                     P      0       	                   Y   o        
+                                  
+  i                                       
+         	                                                                                                                                                              	              
+        d                  6              G              V              m              z                                                                                                                                          3             K             a                                                                                                        2             H             a             v                                                                                           +             D             f                                                                                d                   7             P             j                                                                   h                   4             K             g                                                                                                         ;             X             p                                                     apical_isp.c apical_isp_init apical_loop_buffer_init sensor_fsm_clear cmos_fsm_clear defect_pixel_fsm_clear AE_fsm_clear AWB_fsm_clear color_matrix_fsm_clear iridix_fsm_clear noise_reduction_fsm_clear sharpening_fsm_clear flash_fsm_clear crop_fsm_clear general_fsm_clear dis_fsm_clear matrix_yuv_fsm_clear sensor_fsm_switch_state cmos_fsm_switch_state defect_pixel_fsm_switch_state AE_fsm_switch_state AWB_fsm_switch_state color_matrix_fsm_switch_state iridix_fsm_switch_state noise_reduction_fsm_switch_state sharpening_fsm_switch_state flash_fsm_switch_state crop_fsm_switch_state general_fsm_switch_state dis_fsm_switch_state matrix_yuv_fsm_switch_state sensor_fsm_process_state cmos_fsm_process_state defect_pixel_fsm_process_state AE_fsm_process_state AWB_fsm_process_state color_matrix_fsm_process_state iridix_fsm_process_state noise_reduction_fsm_process_state sharpening_fsm_process_state flash_fsm_process_state crop_fsm_process_state general_fsm_process_state dis_fsm_process_state matrix_yuv_fsm_process_state apical_isp_process_interrupt cmos_fsm_process_interrupt AE_fsm_process_interrupt AWB_fsm_process_interrupt color_matrix_fsm_process_interrupt iridix_fsm_process_interrupt crop_fsm_process_interrupt general_fsm_process_interrupt dis_fsm_process_interrupt apical_isp_process_events system_hw_interrupts_disable apical_event_queue_pop system_hw_interrupts_enable sensor_fsm_process_event cmos_fsm_process_event defect_pixel_fsm_process_event AE_fsm_process_event AWB_fsm_process_event color_matrix_fsm_process_event iridix_fsm_process_event noise_reduction_fsm_process_event sharpening_fsm_process_event flash_fsm_process_event crop_fsm_process_event general_fsm_process_event dis_fsm_process_event matrix_yuv_fsm_process_event      <     T     `     x                                                      ,    @    L    `    l    |                                                $    ,    <    D    T    \    l    t                        !    !    "    "    #    #    $    $    %    %    &    &  $  '  (  '  <  (  @  (  P  )  T  )  d  *  h  *  x  +  |  +    ,    ,    -    -    .    .    /    /    0    0    1    1    2    2    3    3    4    4  P  5  X  5    7    7    8    8    9     9  P  :  X  :    ;    ;    <    <    =     =  D  >  H  >    A    @    @    A    A    B    B    C     C    D    D  4  E  <  E  X  F  `  F  |  G    G    H    H    I    I    J    J    K    K  0  L  8  L  T  M  \  M  x  N    N    O    O    P    P      
+      6  @   ?  sensor_fsm.c.o/ 1510573738  0     0     100644  3352      `
+ELF                         P4     (                <B4 8$        ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      ' a  C,'    ! !  
+ ` , @V $    <  B$	@  $*   $ $B C  <  B$	@     =          B$	@  $ $; "   <  B$	@ !    @B$    <  B$	@  $      $( b     <  B$	@  $      " $
+ $  < !      9' " $  <  B$	@ !       "   <!    9'        '@V  <  $      '     '     <   $ !   s&  <& . @$  !p   @      "@!  
+   $   " " @$    $   $  !   $!    B&	@ !(  &      ( '' $   !  , @ $ $? T!  #    P  $8 T!       $ bT $  <  B$	@     !      $) d!   B$     $" !     $ $ !     $ $ !    <  B$	@ 0$$$(E   <  B$	@ 0$!   $  <  B$	@         <  <  B$	@ !   $    '    <                                                                                                                 (                                                             GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @   @                    	   @         (              %                                  +                                  0     p                          =                                  9   	   @         (               B              8                     T             @                     P   	   @         0      	         \      0       `                   e   o        ~                                    u                                                	              4
+  a                                                                                                                  	                                                                (        (        8              U              q                                                                                                 @           8    1             B             Q              sensor_fsm.c sensor_fsm_clear sensor_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable sensor_fsm_switch_state apical_isp_raise_event sensor_stop_calibrate sensor_update_black sensor_start_calibrate sensor_hw_init sensor_sw_init sensor_fsm_process_state sensor_fsm_process_event sensor_load_vars APICAL_READ_32 APICAL_WRITE_32    P     T                                     (    @    D    `    d                                    L    d    h        h    l                                                     @     `                                         cmos_fsm.c.o/   1510573739  0     0     100644  3720      `
+ELF                         P4     (               ' $    $  < ) $H $ 2$@ $  <!   $$  B$	@  $  <!C    '  ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      ''    U   $! !  B   <  B$	@       B&B& B, @B&$ B, @B&  <    B$	@  $B& B,
+ @ $"& B, @"&  <  B$	@ !   $ ""&  <!  $    9' B, @ $R& R. @ $  <  B$	@ !   $ " $  <!      9' "   <!      9' " $  <!      9' "   <!    9'        '       ''    <     $ !   s&  <  <& . @$  !p   @       !    &	@ !     $   $   $ $!    B&	@ !(  &$        ( '$ ,@ @(   < B$!(E   '   @ !  0 `!  !     $  $) !  !   $  <  B$	@         <  $ !    <  B$!  	@  $   C c$   C  $ !  !   !(    $bP!    !    <  B$	@ !   $    ' !              |                                                                                                          (                                          @  $     @        @  @    @  @  0  @  @  @  @  @  @               GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @                       	   @       x  8              %                                  +                                  0     p                          =                                  9   	   @         (               B              x                     T               `                  P   	   @               	         \      0                          e   o                                            u                                	                	              
+                                                                                                                    	                                                                                   /           F              c                                                                                                                        ,             @             X         o               `       cmos_fsm.c cmos_fsm_clear log2_fixed_to_fixed cmos_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable cmos_fsm_switch_state cmos_update_wdr_mode apical_isp_raise_event cmos_long_exposure_update cmos_init cmos_calc_target_gain cmos_analog_gain_update cmos_digital_gain_update cmos_inttime_update cmos_antiflicker_update cmos_fsm_process_state cmos_update_exposure_history cmos_fsm_process_event  H     p                         L    P                                         (    4    @    L    X    d    l                         ,    p    t                    H        L                @     `                                                         $     (     ,     0     4     8     <     @     D     H     L     P     T     /531            1510573740  0     0     100644  2188      `
+ELF                         P4     (                      ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '          <    9' $   <  9'           '      $ !  $  <  R $	 $    $!    B&	@ !(            ( '' $  	 !  $ P  $ T!       $ !     $ $ !    <  B$	@  $    < $	 !   $     <  B$	@ !   $    '    <                                                                                                                       (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @         x               %             0                     +             0                     0     p       0                   =              H                    9   	   @       d  (               B                                   P      0                          Y   o                                            i                                  0     
+         	                                                                                                                                                              	              
+             +           J              g                    @                                       p        <        defect_pixel_fsm.c defect_pixel_fsm_clear defect_pixel_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable defect_pixel_fsm_switch_state defect_pixel_initialize defect_pixel_update defect_pixel_fsm_process_state defect_pixel_fsm_process_event  0     4     h     l                                                          
+        @     `          /553            1510573740  0     0     100644  2484      `
+ELF                      p   P4     (               !     @ $( , @@<!  B4   $ 4 8  ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      ' 7 B$' B,   ! ! 
+ @ $ B, @ $  <    B$	@  $   $  <!      9'
+ " $  !    <  $  9'    ' " $  <!      9'	 "   <!    9'       '    '     '      $ !  $  <  $ R $
+  $    $ $!    B&	@ !(            ( '' $  	 !  $ P  $ T!       $ !  
+   $ $ !     $ $ !   $  <  B$	@         <  B$	@ !   $    '        <                                                                                                                 (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @                        %                                   +                                   0     p                           =              8                    9   	   @       	  (               B                                   P      0                          Y   o                                            i                                  P     
+         	                                                                                                                                                               	              
+        @         @        5              R              n                                                                        |        ,        ae_balanced_fsm.c AE_fsm_clear AE_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable AE_fsm_switch_state apical_isp_raise_event ae_initialize ae_calculate_target ae_calculate_exposure AE_fsm_process_state AE_fsm_process_event  h     l                            ,    D    P    d    p    |                                     
+        @     `          /574            1510573742  0     0     100644  3524      `
+ELF                      4   P4     (               ' $     2 $ $  $   < $!   R&8 <  0 4 	@ $  B $	@p B $	@r B $	@t B v$x $|'$4$4 $# $  ~     '  ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      ' N     '  ! 	    <  B$	@       <!      9' $  $  <  9'     ' T $  <   9' T $  <   9' T $  <   9' T $  <   9' 	 $  <  B$	@  $      <!(    9'   ' T
+ $  <   9' T $  <   9'     < $  9'   '  '     '     <   $ !   s&  < . @$  !p   @        $  	 $
+   $   $  
+ $   $   $ $!    B&	@ !(   .$       ( '' $   !  , P $ $* T!       $$ !      c$
+ c, `!   $     $ !  !     $ $bP!    !   !    <  B$	@         <  <  B$	@ !   $    '|                                                                                                          (                                        <  `  `  D        $  `  ,  4       GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .rel.rodata .comment .gnu.attributes                                                       @   `                    	   @         8              %                                  +                                  0     p                          =                                  9   	   @       D  (               B              X                     T             `  0                  P   	   @       l  X      	         \      0                          e   o                                            u                                                	              
+                                                                                                                    	                                                                     "              2           H              e                 x  H                                                                                                                  +             C             \         r  |        awb_mesh_NBP_fsm.c AWB_fsm_clear _GET_USHORT_PTR AWB_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable AWB_fsm_switch_state awb_init awb_coeffs_write awb_calc_avg_weighted_gr_gb awb_zones_calculate awb_process_temp_and_shift awb_update awb_normalise apical_isp_raise_event awb_detect_light_source awb_process_light_source AWB_fsm_process_state AWB_fsm_process_event ,     8              T    X                                                    $    ,    8    <    T    \    p    x                                L    $    (    <    8    @                @     `                                                         $     (     /596            1510573743  0     0     100644  2268      `
+ELF                         P4     (                $\ ] ^ _  $` a     ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '          <    9' $  $  <  9'   $   <  9'           '      $ !  $  <  R $	 $    $!    B&	@ !(            ( '' $  	 !  $ P  $ T!       $ !   $    $ !     $ $ !   $  <  B$	@         <  <  B$	@ !   $    '        <                                                                                                                       (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   0                    	   @       ,                 %             p                     +             p                     0     p       p                   =                                  9   	   @         (               B              (                     P      0       (                   Y   o        F                                  V  i                                  0     
+         	                                                                                                                                                               	              
+        (     +   (        J              g                    X                                      p        t        color_matrix_fsm.c color_matrix_fsm_clear color_matrix_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable color_matrix_fsm_switch_state color_matrix_initialize color_matrix_update color_matrix_fsm_process_state color_matrix_fsm_process_event  P     T                                             (    H                             
+        @     `          /618            1510573743  0     0     100644  2256      `
+ELF                         P4     (               ' $     <!   B$	@ $  B        '  ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '          <    9' $   <  9'           '      $ !  $  <  R $	 $    $!    B&	@ !(            ( '' $   !  $ P  $ !    $     $  $ !   $
+    $ !    <  B$	@  $    <  <  B$	@ !   $    '        <                                                                                                                (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   0                    	   @                         %             p                     +             p                     0     p       p                   =                                  9   	   @         (               B              (                     P      0       (                   Y   o        F                                  V  i                                  @     
+         	              0                                                                                                                                                 	              
+        H     $              3   H        L              i                    @                                      p        |        iridix_hist_fsm.c iridix_fsm_clear _GET_UCHAR_PTR iridix_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable iridix_fsm_switch_state iridix_initialize iridix_update iridix_fsm_process_state iridix_fsm_process_event            p     t                                   0    P                             
+        @     `          /639            1510573744  0     0     100644  2204      `
+ELF                      @   P4     (                      ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '   $    <    9' $   <  9'             $ b  <  9'  !(       ' $  	 !  $ P  $ T!       $ !       $ !    <  B$	@       !   `!    <  B$	@  $    <  <  B$	@ !   $    '        <                                                                                                                                                               GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @                        %                                  +                                  0     p                          =                                  9   	   @       t  (               B                                   P      0                          Y   o                                            i                                p  @     
+         	                ;                                                                                                                                              	              
+             1           S              p                    @                                       $               $              noise_reduction_fsm.c noise_reduction_fsm_clear noise_reduction_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable noise_reduction_fsm_switch_state noise_reduction_initialize noise_reduction_hw_init noise_reduction_fsm_process_state noise_reduction_fsm_process_event noise_reduction_update  0     4     h     l                                   L    P    l    p                    
+        @     `          /664            1510573745  0     0     100644  2444      `
+ELF                      `   P4     (                $  $" 
+ $M $N  $P 
+ $R T V  $X \  $d  $L ` b  f   ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      ' !     '   ! !  @   <    B$	@  $   $  <!      9'	 "   <!    9'       '    '     '     !   <  R $& .	      $!    B&	@ !(            '' $   !  , @ $ $( T!      P  $! T!       $ !     $ $ !  
+   $ $ !     $ $ !   $  <  B$	@         <  B$	@ !   $    '            <                                                                                                                                                   GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @                        %                                  +                                  0     p                          =              (                    9   	   @       d	  (               B                                   P      0                          Y   o                                            i                                  @     
+         	                                                                                                                                                              	              
+        d     '   d        D              a              }                                                        |  l                sharpening_fsm.c sharpening_fsm_clear sharpening_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable sharpening_fsm_switch_state apical_isp_raise_event sharpening_initialize sharpening_update sharpening_fsm_process_state sharpening_fsm_process_event                               0    <    H    P                                
+        @     `          flash_fsm.c.o/  1510573746  0     0     100644  2136      `
+ELF                         P4     (                   ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '          <    9' $   <  9'           '      $ !  $  <  R $	 $    $!    B&	@ !(            ( ''	 $  	 ! 
+ $ P  $ T!       $ !     $ $ !   $
+    $ !    <  B$	@  $    <  <  B$	@ !   $    '    <                                                                                                                       (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @         x               %             0                     +             0                     0     p       0                   =              H                    9   	   @       0  (               B                                   P      0                          Y   o                                            i                                  0     
+         	                                                                                                                                                               	              
+                        5              R              n      @                                       p        <        flash_fsm.c flash_fsm_clear flash_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable flash_fsm_switch_state flash_initialize flash_processing flash_fsm_process_state flash_fsm_process_event  0     4     h     l                                                          
+        @     `          crop_fsm.c.o/   1510573746  0     0     100644  2120      `
+ELF                      p   P4     (                      ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '   $    <  9'             $ b  <  9'   $     ' $   !  , @ $ $2 T!  %    P  $+ T!      c,& `!   $     $ !     $ $ !    <  B$	@       <  B$	@ !    $
+ bP  <    $	 !   $     <  B$	@ !   $    '<                                                                                                                                                               GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @         x               %                                   +                                   0     p                           =              8                    9   	   @          (               B                                   P      0                          Y   o                                            i                                  0     
+         	                                                                                                                                                               	              
+                        2              O              k      ,                         $                              crop_fsm.c crop_fsm_clear crop_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable crop_fsm_switch_state crop_initialize crop_fsm_process_state crop_fsm_process_event crop_resolution_changed  0     4     h     l                         l    p    |                        
+        @     `          general_fsm.c.o/1510573747  0     0     100644  1836      `
+ELF                         P4     (                $     " < = > ? @  A   ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '          <  9'             @  <  9'   $      !      <                                                                                                                                                                      GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @         @               %             P                     +             P                     0     p       P                   =              h                    9   	   @         (               B                                   P      0                          Y   o        &                                  6  i                                        
+         	                                                                                                                                                               	              
+        4     !   4        ;              X              t      ,                                          general_fsm.c general_fsm_clear general_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable general_fsm_switch_state general_initialize general_fsm_process_state general_fsm_process_event \     `                                       
+        @     `          dis_fsm.c.o/    1510573748  0     0     100644  2156      `
+ELF                         P4     (                $      $  (   ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '          <    9' $   <  9'           '      $ !  $  <  R $	 $    $!    B&	@ !(            ( '' $  	 !  $ P  $ T!       $ !     $ $ !   $
+    $ !    <  B$	@  $    <  <  B$	@ !   $    '        <                                                                                                                       (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @                       	   @         x               %             P                     +             P                     0     p       P                   =              h                    9   	   @       D  (               B                                   P      0                          Y   o        &                                  6  i                                  0     
+         	                                                                                                                                                                	              
+        $        $        /              L              h      @     }                                  p        X        dis_fsm.c dis_fsm_clear dis_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable dis_fsm_switch_state dis_initialize dis_analyze_stats dis_fsm_process_state dis_fsm_process_event   L     P                                       ,                            
+        @     `          /684            1510573749  0     0     100644  2268      `
+ELF                         P4     (               $    $       ' B  B  !  @!   <  B$	@         B%(  B @      <  9'    '      '        '  <  B$  	@ !  !    <   9'   ' $       <  9'   $     '      $ !  $  <  R $	 $    $!    B&	@ !(            ( '' $  	 !  $ P  $ T!       $ !     $ $ !   $
+    $ !    <  B$	@  $    <  <  B$	@ !   $    '    <                                                                                                                (                                 GCC: (Ingenic 2015.02) 4.7.2 A   gnu     .symtab .strtab .shstrtab .rel.text .data .bss .reginfo .rel.pdr .mdebug.abi32 .comment .gnu.attributes                                                       @   @                    	   @       ,                 %                                  +                                  0     p                          =                                  9   	   @         (               B              8                     P      0       8                   Y   o        V                                  f  i                                   0     
+         	              0                                                                                                                                                 	              
+        (     '   (        D              a              }      p                                      p                matrix_yuv_fsm.c matrix_yuv_fsm_clear matrix_yuv_request_interrupt system_hw_interrupts_disable system_hw_interrupts_enable matrix_yuv_fsm_switch_state matrix_yuv_initialize matrix_yuv_update matrix_yuv_fsm_process_state matrix_yuv_fsm_process_event  P     T                                           @    `                             
+        @     `          
\ No newline at end of file
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/Makefile kernel-3.10.14_mod/drivers/media/platform/tx-isp/Makefile
--- kernel-3.10.14/drivers/media/platform/tx-isp/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/Makefile	2018-11-09 03:11:48.624838726 +0100
@@ -0,0 +1,28 @@
+MODULE_NAME := tx-isp
+
+all: modules
+
+.PHONY: modules clean
+
+EXTRA_CFLAGS := -I$(src)/include
+
+$(MODULE_NAME)-objs := tx-isp-vic.o tx-isp-videobuf.o tx-isp-video-in.o tx-isp-frame-channel.o tx-isp-csi.o tx-isp-interrupt.o tx-isp-debug.o tx-isp-device.o \
+			apical-isp/tx-isp-core-tuning.o apical-isp/tx-isp-core.o \
+			apical-isp/apical_dynamic_calibrations.o apical-isp/apical_static_calibrations.o \
+			apical-isp/apical_calibrations.o apical-isp/apical_calibrations_init.o apical-isp/tx-isp-load-parameters.o \
+			apical-isp/apical_custom_initialization.o apical-isp/ApicalDefault.o \
+			apical-isp/system_isp_io.o apical-isp/log.o apical-isp/system_io.o \
+			apical-isp/system_i2c.o apical-isp/system_spi.o apical-isp/system_timer.o apical-isp/system_uart.o \
+			apical-isp/system_semaphore.o apical-isp/sensor_drv.o apical-isp/system_chardev.o
+
+$(MODULE_NAME)-objs += libapical_isp.a
+
+obj-m := $(MODULE_NAME).o
+
+modules:
+	@$(MAKE) -C $(KDIR) M=$(shell pwd) $@
+
+clean:
+	@find . -name '*.o' -o -name '*~' -o -name '.depend' -o -name '.*.cmd' \
+		-o -name '*.mod.c' -o -name '.tmp_versions' -o -name '*.ko' \
+		-o -name '*.symvers' -o -name 'modules.order' | xargs rm -rf
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-csi.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-csi.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-csi.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-csi.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,574 @@
+#include <linux/delay.h>
+#include <media/v4l2-common.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/mm.h>
+
+#include "tx-isp-csi.h"
+#include "tx-isp-debug.h"
+
+//#ifdef CONFIG_PRODUCT_FPGA
+#if TX_ISP_EXIST_CSI_DEVICE
+static int isp_csi_init_clk(struct tx_isp_csi_driver *csd)
+{
+	struct clk **clks = NULL;
+	struct v4l2_device *v4l2_dev = csd->sd.v4l2_dev;
+	struct tx_isp_subdev_platform_data *pdata = csd->pdata;
+	struct tx_isp_subdev_clk_info *info = pdata->clks;
+	unsigned int num = pdata->clk_num;
+	int ret = 0;
+	int i;
+
+	csd->clk_num = pdata->clk_num;
+	if(!csd->clk_num){
+		csd->clks = NULL;
+		return ISP_SUCCESS;
+	}
+
+	clks = (struct clk **)kzalloc(sizeof(clks) * num, GFP_KERNEL);
+	if(!clks){
+		v4l2_err(v4l2_dev, "%s[%d] Failed to allocate core's clks\n",__func__,__LINE__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	for (i = 0; i < num; i++) {
+		clks[i] = clk_get(csd->dev, info[i].name);
+		if (IS_ERR(clks[i])) {
+			v4l2_err(v4l2_dev, "Failed to get %s clock %ld\n", info[i].name, PTR_ERR(clks[i]));
+			ret = PTR_ERR(clks[i]);
+			goto failed_to_get_clk;
+		}
+		if(info[i].rate != DUMMY_CLOCK_RATE) {
+			ret = clk_set_rate(clks[i], info[i].rate);
+			if(ret){
+				v4l2_err(v4l2_dev, "Failed to set %s clock rate(%ld)\n", info[i].name, info[i].rate);
+				goto failed_to_get_clk;
+			}
+		}
+	}
+	csd->clks = clks;
+	return ISP_SUCCESS;
+failed_to_get_clk:
+	while(--i >= 0){
+		clk_put(clks[i]);
+	}
+	kfree(clks);
+exit:
+	return ret;
+}
+
+static long isp_csi_set_clk(struct tx_isp_csi_driver *csd, int state)
+{
+	struct clk **clks = csd->clks;
+	int i;
+
+	if(state){
+		for(i = 0; i < csd->clk_num; i++)
+			clk_enable(clks[i]);
+	}else{
+		for(i = csd->clk_num - 1; i >=0; i--)
+			clk_disable(clks[i]);
+	}
+	return ISP_SUCCESS;
+}
+
+
+static int isp_csi_release_clk(struct tx_isp_csi_driver *csd)
+{
+	struct clk **clks = csd->clks;
+	int i = 0;
+
+	if(clks == NULL)
+		return 0;
+	for (i = 0; i < csd->clk_num; i++)
+		clk_put(clks[i]);
+
+	kfree(clks);
+	return 0;
+}
+#else
+static int isp_csi_init_clk(struct tx_isp_csi_driver *csd)
+{
+	return 0;
+}
+static long isp_csi_set_clk(struct tx_isp_csi_driver *csd, int state)
+{
+	return 0;
+}
+static int isp_csi_release_clk(struct tx_isp_csi_driver *csd)
+{
+	return 0;
+}
+#endif
+
+void dump_csi_reg(struct tx_isp_csi_driver *csd)
+{
+	ISP_PRINT(ISP_INFO_LEVEL,"****>>>>> dump csi reg <<<<<******\n");
+	ISP_PRINT(ISP_INFO_LEVEL,"**********VERSION =%08x\n", csi_core_read(csd, VERSION));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********N_LANES =%08x\n", csi_core_read(csd, N_LANES));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********PHY_SHUTDOWNZ = %08x\n", csi_core_read(csd, PHY_SHUTDOWNZ));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********DPHY_RSTZ = %08x\n", csi_core_read(csd, DPHY_RSTZ));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********CSI2_RESETN =%08x\n", csi_core_read(csd, CSI2_RESETN));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********PHY_STATE = %08x\n", csi_core_read(csd, PHY_STATE));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********DATA_IDS_1 = %08x\n", csi_core_read(csd, DATA_IDS_1));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********DATA_IDS_2 = %08x\n", csi_core_read(csd, DATA_IDS_2));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********ERR1 = %08x\n", csi_core_read(csd, ERR1));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********ERR2 = %08x\n", csi_core_read(csd, ERR2));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********MASK1 =%08x\n", csi_core_read(csd, MASK1));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********MASK2 =%08x\n", csi_core_read(csd, MASK2));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********PHY_TST_CTRL0 = %08x\n", csi_core_read(csd, PHY_TST_CTRL0));
+	ISP_PRINT(ISP_INFO_LEVEL,"**********PHY_TST_CTRL1 = %08x\n", csi_core_read(csd, PHY_TST_CTRL1));
+}
+static struct tx_isp_csi_driver *dump_csd = NULL;
+void check_csi_error(void) {
+
+	unsigned int temp1, temp2;
+	while(1){
+		dump_csi_reg(dump_csd);
+		temp1 = csi_core_read(dump_csd,ERR1);
+		temp2 = csi_core_read(dump_csd,ERR2);
+		if(temp1 != 0)
+			ISP_PRINT(ISP_INFO_LEVEL,"error-------- 1:0x%08x\n", temp1);
+		if(temp2 != 0)
+			ISP_PRINT(ISP_INFO_LEVEL,"error-------- 2:0x%08x\n", temp2);
+	}
+}
+
+static unsigned char csi_core_write_part(struct tx_isp_csi_driver *csd,unsigned int address,
+						unsigned int data, unsigned char shift, unsigned char width)
+{
+        unsigned int mask = (1 << width) - 1;
+        unsigned int temp = csi_core_read(csd,address);
+        temp &= ~(mask << shift);
+        temp |= (data & mask) << shift;
+        csi_core_write(csd,address, temp);
+
+	return 0;
+}
+
+static unsigned char  csi_event_disable(struct tx_isp_csi_driver *csd,unsigned int  mask, unsigned char err_reg_no)
+{
+	switch (err_reg_no)
+	{
+		case 1:
+			csi_core_write(csd,MASK1, mask | csi_core_read(csd, MASK1));
+			break;
+		case 2:
+			csi_core_write(csd,MASK2, mask | csi_core_read(csd, MASK2));
+			break;
+		default:
+			return ERR_OUT_OF_BOUND;
+	}
+
+	return 0;
+}
+
+unsigned char csi_set_on_lanes(struct tx_isp_csi_driver *csd,unsigned char lanes)
+{
+	ISP_PRINT(ISP_INFO_LEVEL,"%s:----------> lane num: %d\n", __func__, lanes);
+	return csi_core_write_part(csd,N_LANES, (lanes - 1), 0, 2);
+}
+
+static void mipi_csih_dphy_test_data_in(struct tx_isp_csi_driver *csd,unsigned char test_data)
+{
+        csi_core_write(csd,PHY_TST_CTRL1, test_data);
+}
+
+static void mipi_csih_dphy_test_en(struct tx_isp_csi_driver *csd,unsigned char on_falling_edge)
+{
+        csi_core_write_part(csd,PHY_TST_CTRL1, on_falling_edge, 16, 1);
+}
+
+static void mipi_csih_dphy_test_clock(struct tx_isp_csi_driver *csd,int value)
+{
+        csi_core_write_part(csd,PHY_TST_CTRL0, value, 1, 1);
+}
+
+static void mipi_csih_dphy_test_data_out(void)
+{
+	//ISP_PRINT(ISP_INFO_LEVEL,"%s --------:%08x\n", __func__, csi_core_read(PHY_TST_CTRL1));
+}
+
+static void mipi_csih_dphy_write(struct tx_isp_csi_driver *csd,unsigned char address, unsigned char * data, unsigned char data_length)
+{
+        unsigned i = 0;
+        if (data != 0)
+        {
+                /* set the TESTCLK input high in preparation to latch in the desired test mode */
+                mipi_csih_dphy_test_clock(csd,1);
+                /* set the desired test code in the input 8-bit bus TESTDIN[7:0] */
+                mipi_csih_dphy_test_data_in(csd,address);
+                /* set TESTEN input high  */
+                mipi_csih_dphy_test_en(csd,1);
+		//mdelay(1);
+                /* drive the TESTCLK input low; the falling edge captures the chosen test code into the transceiver */
+                mipi_csih_dphy_test_clock(csd,0);
+		//mdelay(1);
+                /* set TESTEN input low to disable further test mode code latching  */
+                mipi_csih_dphy_test_en(csd,0);
+                /* start writing MSB first */
+                for (i = data_length; i > 0; i--)
+                {       /* set TESTDIN[7:0] to the desired test data appropriate to the chosen test mode */
+                        mipi_csih_dphy_test_data_in(csd,data[i - 1]);
+		//	mdelay(1);
+                        /* pulse TESTCLK high to capture this test data into the macrocell; repeat these two steps as necessary */
+                        mipi_csih_dphy_test_clock(csd,1);
+		//	mdelay(1);
+                        mipi_csih_dphy_test_clock(csd,0);
+                }
+        }
+	mipi_csih_dphy_test_data_out();
+}
+#if 0
+static void csi_phy_configure(struct tx_isp_csi_driver *csd)
+{
+	unsigned char data[4];
+
+	csi_core_write_part(csd,PHY_TST_CTRL0, 0, 0, 1);
+//	udelay(5);
+        csi_core_write(csd,PHY_TST_CTRL1, 0);
+	csi_core_write_part(csd,PHY_TST_CTRL0, 0, 16, 1);
+
+//	mipi_csih_dphy_test_data_in(0);
+//	mipi_csih_dphy_test_en(0);
+//	mipi_csih_dphy_test_clock(0);
+        csi_core_write_part(csd,PHY_TST_CTRL0, 0, 1, 1);
+	data[0]=0x00;
+	//data[0]=0x06; /*448Mbps*/
+//data[0]=0x13;
+	mipi_csih_dphy_write(csd,0x44,data, 1);
+
+	data[0]=0x1e;
+	mipi_csih_dphy_write(csd,0xb0,data, 1);
+
+	data[0]=0x1;
+	mipi_csih_dphy_write(csd,0xb1,data, 1);
+
+}
+#endif
+static int csi_phy_ready(struct tx_isp_csi_driver *csd)
+{
+	int ready;
+	int ret;
+	// TODO: phy0: lane0 is ready. need to be update for other lane
+	ready = csi_core_read(csd,PHY_STATE);
+
+#if 1
+	ISP_PRINT(ISP_INFO_LEVEL,"%s:phy state ready:0x%08x\n", __func__, ready);
+#endif
+	ret = ready & (1 << 10 );
+	switch(csd->vin.attr->mipi.lans){
+	case 2:
+		ret = ret && (ready & (1<<5));
+	case 1:
+		ret = ret && (ready & (1<<4));
+		break;
+	default:
+		printk("Do not support lane num more than 2!\n");
+	}
+
+	return !!ret;
+}
+
+#if 0
+static int csi_phy_init(void)
+{
+	//ISP_PRINT(ISP_INFO_LEVEL,"csi_phy_init being called ....\n");
+	return 0;
+}
+#endif
+static int csi_phy_release(struct tx_isp_csi_driver *csd)
+{
+	csi_core_write_part(csd,CSI2_RESETN, 0, 0, 1);
+	csi_core_write_part(csd,CSI2_RESETN, 1, 0, 1);
+	return 0;
+}
+
+static long csi_phy_start(struct tx_isp_csi_driver *csd)
+{
+	long ret = ISP_SUCCESS;
+#if 1
+	unsigned int i;
+	int retries = 30;
+	unsigned char data[4];
+	csi_set_on_lanes(csd, csd->vin.attr->mipi.lans);
+	/*reset phy*/
+	csi_core_write_part(csd,PHY_SHUTDOWNZ, 0, 0, 1);
+	csi_core_write_part(csd,DPHY_RSTZ, 0, 0, 1);
+	csi_core_write_part(csd,CSI2_RESETN, 0, 0, 1);
+/*csi_phy_configure*/
+	udelay(5);
+	csi_core_write_part(csd,PHY_TST_CTRL0, 0, 0, 1);
+        csi_core_write(csd,PHY_TST_CTRL1, 0);
+	csi_core_write_part(csd,PHY_TST_CTRL1, 0, 16, 1);
+        csi_core_write_part(csd,PHY_TST_CTRL0, 0, 1, 1);
+	data[0]=0x00;
+	//data[0]=0x06; /*448Mbps*/
+//data[0]=0x13;
+	mipi_csih_dphy_write(csd,0x44,data, 1);
+
+	data[0]=0x1e;
+	mipi_csih_dphy_write(csd,0xb0,data, 1);
+
+	data[0]=0x1;
+	mipi_csih_dphy_write(csd,0xb1,data, 1);
+	mdelay(10);
+	csi_core_write_part(csd,PHY_SHUTDOWNZ, 1, 0, 1);
+	//udelay(10);
+	mdelay(10);
+	csi_core_write_part(csd,DPHY_RSTZ, 1, 0, 1);
+	mdelay(10);
+	//udelay(10);
+	csi_core_write_part(csd,CSI2_RESETN, 1, 0, 1);
+
+	csi_event_disable(csd,0xffffffff, 1);
+	csi_event_disable(csd,0xffffffff, 2);
+
+	/* wait for phy ready */
+	for (i = 0; i < retries; i++) {
+		if (csi_phy_ready(csd))
+			break;
+		udelay(2);
+	}
+//	while(1){
+//	dump_csi_reg(csd);
+//	}
+	if(i >= retries){
+		ret = -ISP_ERROR;
+		printk("csi init failure!");
+	}
+#endif
+	return ret;
+}
+int csi_phy_stop(struct tx_isp_csi_driver *csd)
+{
+
+	ISP_PRINT(ISP_INFO_LEVEL,"csi_phy_stop being called \n");
+	/*reset phy*/
+	csi_core_write_part(csd,PHY_SHUTDOWNZ, 0, 0, 1);
+	csi_core_write_part(csd,DPHY_RSTZ, 0, 0, 1);
+	csi_core_write_part(csd,CSI2_RESETN, 0, 0, 1);
+
+	return 0;
+}
+
+static long isp_csi_ops_private_ioctl(struct tx_isp_csi_driver *csd, struct isp_private_ioctl *ctl)
+{
+	long ret = ISP_SUCCESS;
+	switch(ctl->cmd){
+		case TX_ISP_PRIVATE_IOCTL_MODULE_CLK:
+			ret = isp_csi_set_clk(csd, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SUBDEV_PREPARE_CHANGE:
+			if(csd->vin.attr->dbus_type == TX_SENSOR_DATA_INTERFACE_MIPI){
+	//			memcpy(&csd->vin, (void *)(ctl->value), sizeof(struct tx_isp_video_in));
+				ret = csi_phy_stop(csd);
+			}
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SUBDEV_FINISH_CHANGE:
+			if(csd->vin.attr->dbus_type == TX_SENSOR_DATA_INTERFACE_MIPI){
+				ret = csi_phy_start(csd);
+			}
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SYNC_VIDEO_IN:
+			if(ctl->value)
+				memcpy(&csd->vin, (void *)(ctl->value), sizeof(struct tx_isp_video_in));
+			else
+				memset(&csd->vin, 0, sizeof(struct tx_isp_video_in));
+			break;
+		case TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_ENUM_FMT:
+			//ret = isp_core_enum_fmt(core, ctl->value);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+static long isp_csi_ops_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct tx_isp_csi_driver *csd = sd_to_tx_isp_csi_driver(sd);
+	long ret = ISP_SUCCESS;
+	switch(cmd){
+		case VIDIOC_ISP_PRIVATE_IOCTL:
+			ret = isp_csi_ops_private_ioctl(csd, arg);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+static int csi_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	printk("functiong:%s, line:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int csi_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+/* enable clk*/
+//	struct tx_isp_video_in *vic_attr = (struct tx_isp_video_in *)ctrl.value;
+	printk("functiong:%s, line:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static int csi_init(struct v4l2_subdev *sd, u32 val)
+{
+	return 0;
+}
+static int csi_s_power(struct v4l2_subdev *sd, int on)
+{
+	/*printk("functiong:%s,line:%d\n", __func__, __LINE__);*/
+	return 0;
+}
+
+static int csi_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct tx_isp_csi_driver *csd = sd_to_tx_isp_csi_driver(sd);
+	int ret = ISP_SUCCESS;
+	if(csd->vin.attr->dbus_type == TX_SENSOR_DATA_INTERFACE_MIPI){
+		if (enable) {
+			ret = csi_phy_start(csd);//sd--lanes ???????
+			/*printk("csi------------start\n");*/
+		}
+		else {
+			ret = csi_phy_stop(csd);
+			/*printk("csi--------------stop\n");*/
+		}
+	}else{
+		/*printk("the sensor is not mipi bus\n");*/
+	}
+	return ret;
+}
+
+static const struct v4l2_subdev_internal_ops csi_internal_ops = {
+};
+
+static const struct v4l2_subdev_core_ops csi_core_ops = {
+//	.g_chip_ident = csi_g_chip_ident,
+	.g_ctrl = csi_g_ctrl,
+	.s_ctrl = csi_s_ctrl,
+//	.queryctrl = csi_queryctrl,
+//	.reset = csi_reset,
+	.init = csi_init,
+	.s_power = csi_s_power,
+	.ioctl = isp_csi_ops_ioctl,
+/* #ifdef CONFIG_VIDEO_ADV_DEBUG */
+/* 	.g_register = csi_g_register, */
+/* 	.s_register = csi_s_register, */
+/* #endif */
+};
+
+static const struct v4l2_subdev_video_ops csi_video_ops = {
+	.s_stream = csi_s_stream,
+};
+
+static const struct v4l2_subdev_ops csi_subdev_ops = {
+	.core = &csi_core_ops,
+	.video = &csi_video_ops,
+};
+
+/* media operations */
+static const struct media_entity_operations csi_media_ops = {
+//	.link_setup = csi_link_setup,
+};
+
+int register_tx_isp_csi_device(struct platform_device *pdev, struct v4l2_device *v4l2_dev)
+{
+	struct tx_isp_subdev_platform_data *pdata = pdev->dev.platform_data;
+	struct tx_isp_csi_driver *csd = NULL;
+	struct resource *res = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct media_pad *pads = NULL;
+	struct media_entity *me = NULL;
+	int ret = ISP_SUCCESS;
+
+	if(!pdata){
+		v4l2_err(v4l2_dev, "The platform_data of csi is NULL!\n");
+		ret = -ISP_ERROR;
+		goto exit;
+	};
+	csd = (struct tx_isp_csi_driver *)kzalloc(sizeof(*csd), GFP_KERNEL);
+	if(!csd){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor device\n");
+		ret = -ISP_ERROR;
+		goto exit;
+	}
+	csd->pdata = pdata;
+	csd->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	res = request_mem_region(res->start,
+			res->end - res->start + 1, dev_name(&pdev->dev));
+	if (!res) {
+		v4l2_err(v4l2_dev, "Not enough memory for resources\n");
+		ret = -EBUSY;
+		goto mem_region_failed;
+	}
+	csd->base = ioremap(res->start, res->end - res->start + 1);
+	if (!csd->base) {
+		v4l2_err(v4l2_dev, "Unable to ioremap registers!\n");
+		ret = -ENXIO;
+		goto ioremap_failed;
+	}
+	csd->res = res;
+	sd = &csd->sd;
+	pads = csd->pads;
+	me = &sd->entity;
+
+	v4l2_subdev_init(sd, &csi_subdev_ops);
+	sd->internal_ops = &csi_internal_ops;
+	strlcpy(sd->name, "TX-ISP-CSI-SUBDEV ", sizeof(sd->name));
+
+	sd->grp_id = pdata->grp_id ;	/* group ID for isp subdevs */
+	v4l2_set_subdevdata(sd, csd);
+
+	pads[TX_ISP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	pads[TX_ISP_PAD_LINK].flags = MEDIA_PAD_FL_SINK;
+
+	me->ops = &csi_media_ops;
+//	me->parent = v4l2_dev->mdev;
+	ret = media_entity_init(me, TX_ISP_PADS_NUM, pads, 0);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to init media entity!\n");
+		ret = -ISP_ERROR;
+		goto entity_init_failed;
+	}
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to register csi-subdev!\n");
+		ret = -ISP_ERROR;
+		goto register_failed;
+	}
+
+	ret = isp_csi_init_clk(csd);
+	if(ret < 0){
+		v4l2_err(v4l2_dev, "Failed to init isp's clks!\n");
+		ret = -ISP_ERROR;
+	}
+	dump_csd = csd;
+	return ISP_SUCCESS;
+register_failed:
+	media_entity_cleanup(me);
+entity_init_failed:
+	iounmap(csd->base);
+ioremap_failed:
+	release_mem_region(res->start, res->end - res->start + 1);
+mem_region_failed:
+	kfree(csd);
+exit:
+	return ret;
+}
+
+void release_tx_isp_csi_device(struct v4l2_subdev *sd)
+{
+	struct tx_isp_csi_driver *csd = v4l2_get_subdevdata(sd);
+	struct resource *res = csd->res;
+	csi_phy_release(csd);
+	isp_csi_release_clk(csd);
+	media_entity_cleanup(&sd->entity);
+
+	v4l2_device_unregister_subdev(sd);
+
+	iounmap(csd->base);
+	release_mem_region(res->start,res->end - res->start + 1);
+	kfree(csd);
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-csi.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-csi.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-csi.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-csi.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,57 @@
+#ifndef __TX_ISP_CSI_H__
+#define __TX_ISP_CSI_H__
+
+#include <tx-isp-common.h>
+
+/* csi host regs, base addr should be defined in board cfg */
+#define VERSION				0x00
+#define N_LANES				0x04
+#define PHY_SHUTDOWNZ			0x08
+#define DPHY_RSTZ			0x0C
+#define CSI2_RESETN			0x10
+#define PHY_STATE			0x14
+#define DATA_IDS_1			0x18
+#define DATA_IDS_2			0x1C
+#define ERR1				0x20
+#define ERR2				0x24
+#define MASK1				0x28
+#define MASK2				0x2C
+#define PHY_TST_CTRL0       0x30
+#define PHY_TST_CTRL1       0x34
+
+typedef enum
+{
+	ERR_NOT_INIT = 0xFE,
+	ERR_ALREADY_INIT = 0xFD,
+	ERR_NOT_COMPATIBLE = 0xFC,
+	ERR_UNDEFINED = 0xFB,
+	ERR_OUT_OF_BOUND = 0xFA,
+	SUCCESS = 0
+} csi_error_t;
+
+struct tx_isp_csi_driver {
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pads[TX_ISP_PADS_NUM];
+	struct resource *res;
+	void __iomem *base;
+	struct tx_isp_video_in vin;
+	struct clk **clks;
+	unsigned int clk_num;
+	void * pdata;
+	unsigned int lans;
+};
+
+#define csi_readl(port,reg)					\
+	__raw_readl((unsigned int *)(port->base + reg))
+#define csi_writel(port,reg, value)					\
+	__raw_writel((value), (unsigned int *)(port->base + reg))
+
+#define csi_core_write(port,addr, value) csi_writel(port,addr, value)
+#define csi_core_read(port,addr) csi_readl(port,addr)
+
+#define sd_to_tx_isp_csi_driver(sd) (container_of(sd, struct tx_isp_csi_driver, sd))
+int register_tx_isp_csi_device(struct platform_device *pdev, struct v4l2_device *v4l2_dev);
+void release_tx_isp_csi_device(struct v4l2_subdev *sd);
+void check_csi_error(void);
+#endif /* __TX_ISP_CSI_H__  */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-debug.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-debug.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-debug.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-debug.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,52 @@
+#include <linux/debugfs.h>
+#include "tx-isp-debug.h"
+
+/* -------------------debugfs interface------------------- */
+static struct dentry *isp_debug_dir;
+static struct dentry *isp_debug_print;
+unsigned int isp_print_level = PRINT_LEVEL;
+
+int isp_printf(unsigned int level, unsigned char *fmt, ...)
+{
+	struct va_format vaf;
+	va_list args;
+	int r = 0;
+
+	if(level >= isp_print_level){
+		va_start(args, fmt);
+
+		vaf.fmt = fmt;
+		vaf.va = &args;
+
+		r = printk("%pV",&vaf);
+		va_end(args);
+		if(level >= ISP_ERROR_LEVEL)
+			dump_stack();
+	}
+	return r;
+}
+int isp_debug_init(void)
+{
+	int ret = 0;
+	isp_debug_dir = debugfs_create_dir("isp_debug" , NULL);
+	if (!isp_debug_dir) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+	isp_debug_print = debugfs_create_u32("isp_print", S_IWUSR | S_IRUSR, isp_debug_dir, &isp_print_level);
+	if (!isp_debug_print) {
+		ret = -ENOMEM;
+		goto fail_u8;
+	}
+	return ret;
+fail_u8:
+	debugfs_remove(isp_debug_dir);
+fail:
+	return ret;
+}
+int isp_debug_deinit(void)
+{
+	debugfs_remove(isp_debug_print);
+	debugfs_remove(isp_debug_dir);
+	return 0;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-debug.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-debug.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-debug.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-debug.h	2018-11-09 02:40:35.293908828 +0100
@@ -0,0 +1,27 @@
+#ifndef _TX_ISP_DEBUG_H_
+#define _TX_ISP_DEBUG_H_
+
+/* =================== switchs ================== */
+
+/**
+ * default debug level, if just switch ISP_WARNING
+ * or ISP_INFO, this not effect DEBUG_REWRITE and
+ * DEBUG_TIME_WRITE/READ
+ **/
+//#define OVISP_CSI_TEST
+#define PRINT_LEVEL		ISP_ERROR_LEVEL
+//#define PRINT_LEVEL		ISP_INFO_LEVEL
+/* =================== print tools ================== */
+
+#define ISP_INFO_LEVEL		0x0
+#define ISP_WARNING_LEVEL	0x1
+#define ISP_ERROR_LEVEL		0x2
+#define ISP_PRINT(level, format, ...)		\
+	isp_printf(level, format, ##__VA_ARGS__)
+#define ISP_DEBUG(...) ISP_PRINT(ISP_INFO, __VA_ARGS__)
+
+//extern unsigned int isp_print_level;
+int isp_debug_init(void);
+int isp_debug_deinit(void);
+int isp_printf(unsigned int level, unsigned char *fmt, ...);
+#endif /* _ISP_DEBUG_H_ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-device.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-device.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-device.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-device.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,514 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/bug.h>
+#include <linux/io.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+
+#include "tx-isp-device.h"
+#include "tx-isp-interrupt.h"
+#include "tx-isp-debug.h"
+#include "tx-isp-vic.h"
+#include "tx-isp-csi.h"
+#include "tx-isp-video-in.h"
+#include "apical-isp/tx-isp-core.h"
+static int tx_isp_media_pipeline_set_clk(struct tx_isp_media_pipeline *p, int state)
+{
+	struct isp_private_ioctl ioctl;
+	struct v4l2_subdev *sd = NULL;
+	int ret = 0,index = 0;
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_MODULE_CLK;
+	ioctl.value = state;
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+		if(ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+	if(ret < 0 && ret != -ENOIOCTLCMD){
+		ioctl.value = !state;
+		while(--index >= 0){
+			sd = p->subdevs[index];
+			ret = v4l2_subdev_call(sd, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+		}
+	}
+	return ret;
+}
+static int tx_isp_media_pipeline_set_power(struct tx_isp_media_pipeline *p, int state)
+{
+	struct v4l2_subdev *sd = NULL;
+	int ret = 0,index = 0;
+
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, core, s_power, state);
+		if(ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+	if(ret < 0 && ret != -ENOIOCTLCMD){
+		while(--index >= 0){
+			sd = p->subdevs[index];
+			v4l2_subdev_call(sd, core, s_power, !state);
+		}
+	}
+	return ret;
+}
+static int tx_isp_media_pipeline_prepare(struct tx_isp_media_pipeline *p) // struct tx_isp_video_in *vin)
+{
+	int ret = ISP_SUCCESS;
+	if(!p)
+		return -ISP_ERROR;
+	ret = tx_isp_media_pipeline_set_clk(p, true);
+	if(ret < 0)
+		return -ISP_ERROR;
+	ret = tx_isp_media_pipeline_set_power(p, true);
+	if(ret != ISP_SUCCESS){
+		tx_isp_media_pipeline_set_clk(p, false);
+	}
+
+	return ret;
+}
+
+static int tx_isp_media_pipeline_unprepare(struct tx_isp_media_pipeline *p)
+{
+	int ret = ISP_SUCCESS;
+	if(!p)
+		return ISP_SUCCESS;
+
+	ret = tx_isp_media_pipeline_set_power(p, false);
+	if(ret < 0)
+		return -ISP_ERROR;
+	tx_isp_media_pipeline_set_clk(p, false);
+
+	return ISP_SUCCESS;
+}
+
+static int tx_isp_media_pipeline_reset(struct tx_isp_media_pipeline *p, int state)
+{
+	int ret = 0,index = 0;
+	struct v4l2_subdev *sd = NULL;
+
+	if(!p){
+		return -ISP_ERROR;
+	}
+
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, core, reset, state);
+		if(ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+
+	return ret;
+}
+
+static int tx_isp_media_pipeline_init(struct tx_isp_media_pipeline *p, int state)
+{
+	int ret = 0,index = 0;
+	struct v4l2_subdev *sd = NULL;
+
+	if(!p){
+		return -ISP_ERROR;
+	}
+
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, core, init, state);
+		if(ret < 0 && ret != -ENOIOCTLCMD){
+			printk("^^^ %s[%d] name = %s ^^^\n", __func__,__LINE__, sd->name);
+			break;
+		}
+		index++;
+	}
+	if(ret < 0){
+		while(index >= 0){
+			sd = p->subdevs[index];
+			v4l2_subdev_call(sd, core, init, !state);
+			index--;
+		}
+	}
+	return ret;
+}
+
+static int tx_isp_media_pipeline_set_stream(struct tx_isp_media_pipeline *p, int state)
+{
+	struct v4l2_subdev *sd = NULL;
+	int ret = 0,index = 0;
+
+	if(!p){
+		return -ISP_ERROR;
+	}
+
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, video, s_stream, state);
+		if(ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+	if(ret < 0){
+		while(index >= 0){
+			sd = p->subdevs[index];
+			v4l2_subdev_call(sd, video, s_stream, !state);
+			index--;
+		}
+	}
+	return ret;
+}
+
+struct tx_isp_media_pipeline_ops tx_isp_pipeline_ops = {
+	.prepare = tx_isp_media_pipeline_prepare,
+	.unprepare = tx_isp_media_pipeline_unprepare,
+	.reset = tx_isp_media_pipeline_reset,
+	.init = tx_isp_media_pipeline_init,
+	.set_stream = tx_isp_media_pipeline_set_stream,
+};
+
+static int tx_isp_notify_sync_video_in(tx_isp_device_t* ispdev, int vin)
+{
+//	struct v4l2_device *v4l2_dev = &ispdev->v4l2_dev;
+	struct tx_isp_media_pipeline *p = &ispdev->pipeline;
+	struct v4l2_subdev *sd = NULL;
+	struct isp_private_ioctl ioctl;
+	int ret = 0,index = 0;
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SYNC_VIDEO_IN;
+	ioctl.value = vin;
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+		if(ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+
+	return ret;
+}
+
+static int tx_isp_notify_call_ioctrl(tx_isp_device_t* ispdev, void *arg)
+{
+//	struct v4l2_device *v4l2_dev = &ispdev->v4l2_dev;
+	struct tx_isp_media_pipeline *p = &ispdev->pipeline;
+	struct v4l2_subdev *sd = NULL;
+	int ret = 0,index = 0;
+
+	while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+		sd = p->subdevs[index];
+		ret = v4l2_subdev_call(sd, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, arg);
+		if(ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+
+	return ret;
+}
+
+
+static int tx_isp_create_media_link_and_pipeline(tx_isp_device_t* ispdev)
+{
+	struct v4l2_device *v4l2_dev = &ispdev->v4l2_dev;
+	struct tx_isp_media_pipeline *p = &ispdev->pipeline;
+	struct v4l2_subdev *sd;
+	struct media_entity *source, *link;
+	unsigned int flags = 0;
+	int index;
+	int ret = ISP_SUCCESS;
+	list_for_each_entry(sd, &v4l2_dev->subdevs, list) {
+		if(sd->grp_id < TX_ISP_MAX_GRP_IDX)
+			p->subdevs[sd->grp_id] = sd;
+	}
+	p->ops = &tx_isp_pipeline_ops;
+	for(index = 0; index < TX_ISP_MAX_GRP_IDX - 1; index++){
+		/*printk("&&&&%s[%d] index = %d  &&&&\n",__func__,__LINE__,index);*/
+		source = &(p->subdevs[index]->entity);
+		link = &(p->subdevs[index + 1]->entity);
+		ret = media_entity_create_link(source, TX_ISP_PAD_SOURCE , link, TX_ISP_PAD_LINK, flags);
+		if(ret < 0){
+			v4l2_err(v4l2_dev, "Failed to create the link(%s => %s)!\n",
+						source->name, link->name);
+			ret = -ISP_ERROR;
+			break;
+		}
+	}
+	return ret;
+}
+
+#define sd_to_tx_ispdev(sd) (container_of((sd)->v4l2_dev, tx_isp_device_t, v4l2_dev))
+static void tx_isp_v4l2_dev_notify(struct v4l2_subdev *sd, unsigned int notification, void *arg)
+{
+	tx_isp_device_t* ispdev = sd_to_tx_ispdev(sd);
+	struct tx_isp_notify_argument *notify = (struct tx_isp_notify_argument *)arg;
+//	printk("%s[%d] sd->name = %s\n",__func__, __LINE__, sd->name);
+	switch(notification){
+		case TX_ISP_NOTIFY_GET_PIPELINE:
+			notify->value = (int)(&ispdev->pipeline);
+			notify->ret = ISP_SUCCESS;
+			break;
+		case TX_ISP_NOTIFY_SYNC_VIDEO_IN:
+			notify->ret = tx_isp_notify_sync_video_in(ispdev, notify->value);
+			break;
+		case TX_ISP_NOTIFY_ENABLE_IRQ:
+			ispdev->irq_dev->enable_irq(ispdev->irq_dev, notify->value);
+			notify->ret = ISP_SUCCESS;
+			break;
+		case TX_ISP_NOTIFY_DISABLE_IRQ:
+			ispdev->irq_dev->disable_irq(ispdev->irq_dev, notify->value);
+			notify->ret = ISP_SUCCESS;
+			break;
+		case TX_ISP_NOTIFY_MASK_IRQ:
+			ispdev->irq_dev->mask_irq(ispdev->irq_dev, notify->value);
+			notify->ret = ISP_SUCCESS;
+			break;
+		case TX_ISP_NOTIFY_UNMASK_IRQ:
+			ispdev->irq_dev->unmask_irq(ispdev->irq_dev, notify->value);
+			notify->ret = ISP_SUCCESS;
+			break;
+		case TX_ISP_NOTIFY_PRIVATE_IOCTL:
+			notify->ret = tx_isp_notify_call_ioctrl(ispdev, (void *)notify->value);
+			break;
+		default:
+			break;
+	}
+}
+static int tx_isp_subdev_match(struct device *dev, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	tx_isp_device_t* ispdev = (tx_isp_device_t*)data;
+	int ret = ISP_SUCCESS;
+
+	if(!get_device(dev))
+		return -ENODEV;
+	if(!strncmp(pdev->name, "tx-isp", 6)){
+		if(!strcmp(pdev->name, TX_ISP_CORE_NAME))
+			ret = register_tx_isp_core_device(pdev, &ispdev->v4l2_dev);
+		else if(!strcmp(pdev->name, TX_ISP_VIC_NAME))
+			ret = register_tx_isp_vic_device(pdev, &ispdev->v4l2_dev);
+		else if(!strcmp(pdev->name, TX_ISP_CSI_NAME))
+			ret = register_tx_isp_csi_device(pdev, &ispdev->v4l2_dev);
+		else
+			printk("register all isp device successfully!\n");
+			/*printk("the device[%s] isn't belong to ISP platform device.\n", pdev->name);*/
+	}
+	put_device(dev);
+	return ret;
+}
+
+static int tx_isp_md_link_notify(struct media_pad *source, struct media_pad *sink, u32 flags)
+{
+	printk("%s[%d] source is %s, sink is %s",__func__,__LINE__,
+					source->entity->name, sink->entity->name);
+	return ISP_SUCCESS;
+}
+
+static void tx_isp_release_subdevs(tx_isp_device_t* ispdev)
+{
+	struct v4l2_device *v4l2_dev = &ispdev->v4l2_dev;
+	struct v4l2_subdev *sd;
+	struct list_head *pos;
+	int index = 0;
+
+	list_for_each(pos, &v4l2_dev->subdevs) {
+		sd = list_entry(pos, struct v4l2_subdev, list);
+		switch(sd->grp_id){
+			case  TX_ISP_CORE_GRP_IDX:
+				release_tx_isp_core_device(sd);
+				index++;
+				break;
+			case  TX_ISP_VIC_GRP_IDX:
+				release_tx_isp_vic_device(sd);
+				index++;
+				break;
+			case  TX_ISP_CSI_GRP_IDX:
+				release_tx_isp_csi_device(sd);
+				index++;
+				break;
+			case  TX_ISP_VIDEO_IN_GRP_IDX:
+				release_tx_isp_video_in_device(sd);
+				index++;
+				break;
+			default:
+				break;
+
+		}
+		pos = &v4l2_dev->subdevs;
+		if(index > TX_ISP_MAX_GRP_IDX){
+			v4l2_info(v4l2_dev, "%s[%d] Failed to release isp's subdevs\n",__func__,__LINE__);
+			break;
+		}
+	}
+	v4l2_info(v4l2_dev, "Release all isp's subdevs\n");
+}
+
+static int tx_isp_probe(struct platform_device *pdev)
+{
+	tx_isp_device_t* ispdev;
+	struct v4l2_device *v4l2_dev;
+	int ret = ISP_SUCCESS;
+	/*printk("@@@@@@@@@@@@@@@@@@@@ tx-isp-probe @@@@@@@@@@@@@@@@@@@@@@@@@@\n");*/
+	ispdev = (tx_isp_device_t*)kzalloc(sizeof(*ispdev), GFP_KERNEL);
+	if (!ispdev) {
+		printk("Failed to allocate camera device\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+	spin_lock_init(&ispdev->slock);
+	ispdev->dev = &pdev->dev;
+
+	strlcpy(ispdev->media_dev.model, "INGENIC tx_isp",
+		sizeof(ispdev->media_dev.model));
+	ispdev->media_dev.link_notify = tx_isp_md_link_notify;
+	ispdev->media_dev.dev = ispdev->dev;
+
+	v4l2_dev = &ispdev->v4l2_dev;
+	v4l2_dev->mdev = &ispdev->media_dev;
+	v4l2_dev->notify = tx_isp_v4l2_dev_notify;
+	strlcpy(v4l2_dev->name, "tx_isp", sizeof(v4l2_dev->name));
+
+	ret = v4l2_device_register(ispdev->dev, &ispdev->v4l2_dev);
+	if (ret < 0) {
+		printk("Failed to register v4l2_device: %d\n", ret);
+		goto err_v4l2_dev;
+	}
+
+	ret = media_device_register(&ispdev->media_dev);
+	if (ret < 0) {
+		v4l2_err(v4l2_dev, "Failed to register media device: %d\n", ret);
+		goto err_media_dev;
+	}
+
+	ret = tx_isp_request_irq(pdev, ispdev);
+	if(ret != ISP_SUCCESS){
+		v4l2_err(v4l2_dev, "Failed to request isp's irq\n");
+		goto err_req_irq;
+	}
+
+	mutex_lock(&ispdev->media_dev.graph_mutex);
+	ret = bus_for_each_dev(&platform_bus_type, NULL, ispdev, tx_isp_subdev_match);
+	if (ret) {
+		mutex_unlock(&ispdev->media_dev.graph_mutex);
+		v4l2_err(v4l2_dev, "Failed to register isp's subdev\n");
+		goto err_match;
+	}
+	mutex_unlock(&ispdev->media_dev.graph_mutex);
+
+	ret = register_tx_isp_video_in_device(ispdev->dev->platform_data, &ispdev->v4l2_dev);
+	if (ret) {
+		v4l2_err(v4l2_dev, "Failed to register isp's sensor\n");
+		goto err_vin;
+	}
+	ret = tx_isp_create_media_link_and_pipeline(ispdev);
+	if(ret < 0){
+		v4l2_err(v4l2_dev, "Failed to create links of media\n");
+		goto err_link;
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&ispdev->v4l2_dev);
+	if (ret) {
+		v4l2_err(v4l2_dev, "Failed to register subdev nodes!\n");
+		goto err_nodes;
+	}
+
+	platform_set_drvdata(pdev, ispdev);
+
+	/* init v4l2_priority */
+	v4l2_prio_init(&ispdev->prio);
+	isp_debug_init();
+	ispdev->revision = 20150320;
+	printk("@@@@ tx-isp-probe ok @@@@@\n");
+	return 0;
+err_req_irq:
+err_nodes:
+err_link:
+err_vin:
+	tx_isp_release_subdevs(ispdev);
+err_match:
+	media_device_unregister(&ispdev->media_dev);
+err_media_dev:
+	v4l2_device_unregister(&ispdev->v4l2_dev);
+err_v4l2_dev:
+	kfree(ispdev);
+exit:
+	return ret;
+
+}
+
+static int __exit tx_isp_remove(struct platform_device *pdev)
+{
+	tx_isp_device_t* ispdev = platform_get_drvdata(pdev);
+
+	tx_isp_free_irq(ispdev);
+	tx_isp_release_subdevs(ispdev);
+	platform_set_drvdata(pdev, NULL);
+	isp_debug_deinit();
+
+	media_device_unregister(&ispdev->media_dev);
+	v4l2_device_unregister(&ispdev->v4l2_dev);
+	kfree(ispdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tx_isp_suspend(struct device *dev)
+{
+//	tx_isp_device_t* ispdev = dev_get_drvdata(dev);
+
+//	isp_dev_call(ispdev->isp, suspend, NULL);
+
+	return 0;
+}
+
+static int tx_isp_resume(struct device *dev)
+{
+//	tx_isp_device_t* ispdev = dev_get_drvdata(dev);
+
+//	isp_dev_call(ispdev->isp, resume, NULL);
+
+	return 0;
+}
+
+static struct dev_pm_ops tx_isp_pm_ops = {
+	.suspend = tx_isp_suspend,
+	.resume = tx_isp_resume,
+};
+#endif
+
+static struct platform_driver tx_isp_driver = {
+	.probe = tx_isp_probe,
+	.remove = __exit_p(tx_isp_remove),
+	.driver = {
+		.name = "tx-isp",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &tx_isp_pm_ops,
+#endif
+	},
+};
+
+static int __init tx_isp_init(void)
+{
+	return platform_driver_register(&tx_isp_driver);
+}
+
+static void __exit tx_isp_exit(void)
+{
+	platform_driver_unregister(&tx_isp_driver);
+}
+
+module_init(tx_isp_init);
+module_exit(tx_isp_exit);
+
+MODULE_AUTHOR("Ingenic xhshen");
+MODULE_DESCRIPTION("tx isp driver");
+MODULE_LICENSE("GPL");
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-device.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-device.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-device.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-device.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,28 @@
+#ifndef __TX_ISP_DEVICE_H__
+#define __TX_ISP_DEVICE_H__
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include <tx-isp-common.h>
+
+typedef struct __tx_isp_device {
+	struct v4l2_device v4l2_dev;
+	struct media_device media_dev;
+	struct device *dev;
+	unsigned int revision;
+	struct v4l2_prio_state prio;
+
+//	struct v4l2_subdev *subdevs[TX_ISP_MAX_IDX];
+	struct tx_isp_irq_device *irq_dev;
+//	struct mutex mlock;
+//	atomic_t state;
+	spinlock_t slock;
+	struct tx_isp_media_pipeline pipeline;
+} tx_isp_device_t;
+
+#endif/*__TX_ISP_DEVICE_H__*/
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-frame-channel.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-frame-channel.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-frame-channel.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-frame-channel.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,1005 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/bug.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+//#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/syscalls.h>
+#include <linux/fs.h>
+
+#include "tx-isp-frame-channel.h"
+#include "tx-isp-videobuf.h"
+#include "tx-isp-debug.h"
+//#include "tx-isp-csi.h"
+//#include "tx-isp-vic.h"
+
+static int frame_channel_video_irq_notify(frame_chan_vdev_t  *vdev, u32 phyaddr, bool *handled)
+{
+	unsigned long flags;
+	struct frame_channel_video_buffer *buf = NULL;
+	struct frame_channel_video_buffer *pos = NULL;
+
+/*	if(atomic_read(&vdev->state) != TX_ISP_STATE_RUN){
+		printk("vdev->state is stop \n");
+		return 0;
+	}
+*/
+	spin_lock_irqsave(&vdev->slock, flags);
+	list_for_each_entry(pos, &vdev->active_list, entry){
+		if(pos->buf.addr == phyaddr){
+			buf = pos;
+			list_del(&buf->entry);
+			break;
+		}
+	}
+#if 0
+	if (!list_empty(&vdev->active_list)){
+		buf = list_entry(vdev->active_list.next,
+				struct frame_channel_video_buffer, entry);
+		list_del(&buf->entry);
+	}
+#endif
+	spin_unlock_irqrestore(&vdev->slock, flags);
+	if(buf && buf->vb.state == VB2_BUF_STATE_ACTIVE){
+		struct timespec ts;
+		getrawmonotonic(&ts);
+
+		buf->vb.v4l2_buf.timestamp.tv_sec = ts.tv_sec;
+		buf->vb.v4l2_buf.timestamp.tv_usec = ts.tv_nsec / 1000;
+
+		buf->vb.v4l2_buf.sequence = vdev->out_frames++;
+		vb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);
+		complete(&vdev->comp);
+	//	printk("bufdone chan%d buf.index = %d\n", vdev->index, buf->vb.v4l2_buf.index);
+	}else{
+		vdev->lose_frames++;
+	//	printk("lose frame  chan%d \n", vdev->index);
+	}
+
+	return 0;
+}
+
+static int frame_channel_vb2_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
+			unsigned int *nbuffers, unsigned int *nplanes, unsigned int sizes[],
+			void *alloc_ctxs[])
+{
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vq);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &attr->output;
+	unsigned int size;
+	int ret = ISP_SUCCESS;
+
+	/*
+	* nbuffers 
+	* nplanes  size[]alloc_ctxs[] 
+	* plane
+	*/
+	size = output->fmt.pix.sizeimage;
+
+	*nplanes = 1;
+	sizes[0] = size;
+	alloc_ctxs[0] = vdev->vbm;
+
+//	printk("~~~~~~~~ %s[%d] size = %d ~~~~~~~~~~\n",__func__,__LINE__,size);
+	INIT_LIST_HEAD(&vdev->active_list);
+	return ret;
+}
+
+static int frame_channel_vb2_buffer_init(struct vb2_buffer *vb)
+{
+	/*
+	* MMAP
+	* USERPTRdriver
+	*/
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vb->vb2_queue);
+	struct frame_channel_video_buffer *buf =
+		container_of(vb, struct frame_channel_video_buffer, vb);
+	buf->buf.priv = vdev;
+
+	return 0;
+}
+
+static void frame_channel_vb2_buffer_cleanup(struct vb2_buffer *vb)
+{
+	/*
+	* MMAP
+	* USERPTRdriver
+	*/
+}
+
+#define TX_ISP_VIDEO_BUFFER_CACHE (1<<31)
+static int frame_channel_vb2_buffer_prepare(struct vb2_buffer *vb)
+{
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vb->vb2_queue);
+	struct frame_channel_video_buffer *buf =
+		container_of(vb, struct frame_channel_video_buffer, vb);
+	struct v4l2_buffer *v4l2_buf = &vb->v4l2_buf;
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &attr->output;
+	unsigned long size = output->fmt.pix.sizeimage;
+	void * addr = NULL;
+	int ret = ISP_SUCCESS;
+
+	/* plane */
+	if (vb2_plane_size(vb, 0) < size) {
+		ISP_PRINT(ISP_ERROR_LEVEL,"Data will not fit into plane (%lu < %lu)\n",
+				vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+	if(v4l2_buf->memory == V4L2_MEMORY_USERPTR){
+		addr = vb2_plane_vaddr(vb, 0);
+	}else if(v4l2_buf->memory == V4L2_MEMORY_MMAP){
+		addr = vb2_plane_cookie(vb, 0);
+	}else{
+		ISP_PRINT(ISP_ERROR_LEVEL,"%s[%d] memory is invalid!\n", __func__, __LINE__);
+		ret = -EINVAL;
+	}
+
+//	if(v4l2_buf->flags & TX_ISP_VIDEO_BUFFER_CACHE)
+	{
+		if(v4l2_buf->memory == V4L2_MEMORY_USERPTR){
+			dma_sync_single_for_device(NULL, (dma_addr_t)addr, size, DMA_FROM_DEVICE);
+//			dma_cache_sync(NULL, (void *)addr, size, DMA_FROM_DEVICE);
+		}else if(v4l2_buf->memory == V4L2_MEMORY_MMAP){
+			dma_sync_single_for_device(NULL, (dma_addr_t)addr, size, DMA_FROM_DEVICE);
+		}else{
+			ISP_PRINT(ISP_ERROR_LEVEL,"%s[%d] memory is invalid!\n", __func__, __LINE__);
+			ret = -EINVAL;
+		}
+	}
+//	printk("~~~~ %s[%d] index = %d addr = 0x%08x ~~~~\n",__func__,__LINE__, v4l2_buf->index, (unsigned int)addr);
+	buf->buf.addr = (unsigned int)addr;
+	return ret;
+}
+
+static int frame_channel_vb2_buffer_finish(struct vb2_buffer *vb)
+{
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vb->vb2_queue);
+	struct frame_channel_video_buffer *buf =
+		container_of(vb, struct frame_channel_video_buffer, vb);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_format *output = &attr->output;
+	unsigned long size = output->fmt.pix.sizeimage;
+
+	vb2_set_plane_payload(&buf->vb, 0, size);
+
+	return 0;
+}
+
+static void frame_channel_vb2_buffer_queue(struct vb2_buffer *vb)
+{
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vb->vb2_queue);
+	struct frame_channel_video_buffer *buf =
+		container_of(vb, struct frame_channel_video_buffer, vb);
+	struct v4l2_subdev *parent = vdev->parent;
+	unsigned long flags;
+	struct isp_private_ioctl ioctl;
+	int ret = ISP_SUCCESS;
+
+//	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	spin_lock_irqsave(&vdev->slock, flags);
+	list_add_tail(&buf->entry, &vdev->active_list);
+	spin_unlock_irqrestore(&vdev->slock, flags);
+
+//	ISP_PRINT(ISP_INFO_LEVEL,"%s[%d] %p\n", __func__, __LINE__, &buf->buf);
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_QUEUE_BUFFER;
+	ioctl.value = (int)buf;
+	ret = v4l2_subdev_call(parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+}
+
+static int frame_channel_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vq);
+	struct v4l2_subdev *parent = vdev->parent;
+	struct isp_private_ioctl ioctl;
+	int ret = ISP_SUCCESS;
+	unsigned long flags;
+
+	if(atomic_read(&vdev->state) != TX_ISP_STATE_START){
+		return -EBUSY;
+	}
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_STREAM_ON;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	if(ret == ISP_SUCCESS){
+		spin_lock_irqsave(&vdev->slock, flags);
+		atomic_set(&vdev->state, TX_ISP_STATE_RUN);
+		spin_unlock_irqrestore(&vdev->slock, flags);
+	}
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	return ret;
+}
+
+static int frame_channel_vb2_stop_streaming(struct vb2_queue *vq)
+{
+	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vq);
+	struct v4l2_subdev *parent = vdev->parent;
+	struct isp_private_ioctl ioctl;
+	int ret = ISP_SUCCESS;
+	unsigned long flags;
+
+	if(atomic_read(&vdev->state) == TX_ISP_STATE_RUN){
+		ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+		ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_STREAM_OFF;
+		ioctl.value = (int)vdev;
+		ret = v4l2_subdev_call(parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+		if(ret == ISP_SUCCESS){
+			spin_lock_irqsave(&vdev->slock, flags);
+			atomic_set(&vdev->state, TX_ISP_STATE_START);
+			spin_unlock_irqrestore(&vdev->slock, flags);
+		}
+		ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	}else if(atomic_read(&vdev->state) == TX_ISP_STATE_START){
+		ret = ISP_SUCCESS;
+	}else{
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static void frame_channel_vb2_lock(struct vb2_queue *vq)
+{
+//	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vq);
+//	mutex_lock(&vdev->mlock);
+}
+
+static void frame_channel_vb2_unlock(struct vb2_queue *vq)
+{
+//	frame_chan_vdev_t *vdev = vb2_get_drv_priv(vq);
+//	mutex_unlock(&vdev->mlock);
+}
+
+static struct vb2_ops frame_channel_vb2_qops = {
+	.queue_setup		= frame_channel_vb2_queue_setup,
+	.buf_init		= frame_channel_vb2_buffer_init,
+	.buf_cleanup		= frame_channel_vb2_buffer_cleanup,
+	.buf_prepare		= frame_channel_vb2_buffer_prepare,
+	.buf_finish		= frame_channel_vb2_buffer_finish,
+	.buf_queue		= frame_channel_vb2_buffer_queue,
+	.wait_prepare		= frame_channel_vb2_unlock,
+	.wait_finish		= frame_channel_vb2_lock,
+	.start_streaming	= frame_channel_vb2_start_streaming,
+	.stop_streaming		= frame_channel_vb2_stop_streaming,
+};
+
+static int frame_channel_vidioc_querycap(struct file *file, void  *priv,
+		struct v4l2_capability *cap)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+
+	strcpy(cap->driver, "frame_channel");
+	strcpy(cap->card, "frame_channel");
+	strlcpy(cap->bus_info, vdev->parent->v4l2_dev->name, sizeof(cap->bus_info));
+	cap->version = 0x00000001;
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+	return 0;
+}
+/**
+* frame_channel_vidioc_g_priority() - get priority handler
+* @file: file ptr
+* @priv: file handle
+* @prio: ptr to v4l2_priority structure
+*/
+static int frame_channel_vidioc_g_priority(struct file *file, void *priv,
+                          enum v4l2_priority *prio)
+{
+//	frame_chan_vdev_t *vdev = video_drvdata(file);
+//	*prio = v4l2_prio_max(&vdev->prio);
+	return 0;
+}
+/**
+* frame_channel_vidioc_s_priority() - set priority handler
+* @file: file ptr
+* @priv: file handle
+* @prio: ptr to v4l2_priority structure
+*/
+static int frame_channel_vidioc_s_priority(struct file *file, void *priv, enum v4l2_priority p)
+{
+//	frame_chan_vdev_t *vdev = video_drvdata(file);
+//	struct frame_channel_fh *fh = priv;
+//	return v4l2_prio_change(&vdev->prio, &fh->prio, p);
+	return 0;
+}
+
+static int frame_channel_vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
+		struct v4l2_fmtdesc *f)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct v4l2_subdev *parent = vdev->parent;
+	struct isp_private_ioctl ioctl;
+	int ret = ISP_SUCCESS;
+
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	vdev->fmtdesc = f;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_ENUM_FMT;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	if(ret == ISP_SUCCESS)
+		f->type = vdev->vbq.type;
+	return ret;
+}
+
+static int frame_channel_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
+		struct v4l2_format *f)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct v4l2_format	*out = &vdev->attr.output;
+#if 0
+	f->fmt.pix.pixelformat = output->fmt.pix.pixelformat;
+#else
+	memcpy(f, &vdev->attr.output, sizeof(*f));
+#endif
+	printk("%s[%d] pixformat = 0x%08x width = %d height = %d lineoffset = %d sizeimage = %d\n", __func__, __LINE__,
+	out->fmt.pix.pixelformat, out->fmt.pix.width, out->fmt.pix.height, out->fmt.pix.bytesperline, out->fmt.pix.sizeimage);
+	printk("%s[%d] pixformat = 0x%08x width = %d height = %d lineoffset = %d sizeimage = %d\n", __func__, __LINE__,
+	f->fmt.pix.pixelformat, f->fmt.pix.width, f->fmt.pix.height, f->fmt.pix.bytesperline, f->fmt.pix.sizeimage);
+	printk("%s[%d] g_fmt is ok!\n", __func__, __LINE__);
+	return ISP_SUCCESS;
+}
+
+static int frame_channel_vidioc_try_fmt_vid_cap(struct file *file, void *priv,
+		struct v4l2_format *f)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct isp_private_ioctl ioctl;
+	int ret = ISP_SUCCESS;
+
+	ISP_PRINT(ISP_INFO_LEVEL,"%s[%d] f->fmt.pix.width = %d, f->fmt.pix.height = %d\n",
+			__func__, __LINE__, f->fmt.pix.width, f->fmt.pix.height);
+
+	if (f->fmt.pix.field == V4L2_FIELD_ANY)
+		f->fmt.pix.field = V4L2_FIELD_INTERLACED;
+	else if (V4L2_FIELD_INTERLACED != f->fmt.pix.field)
+		return -EINVAL;
+	v4l_bound_align_image(&f->fmt.pix.width,
+			attr->min_width, attr->max_width, 3,
+			&f->fmt.pix.height,
+			attr->min_width, attr->max_height, 1, 0);
+	if (f->fmt.pix.width  < attr->min_width || f->fmt.pix.width  > attr->max_width ||
+			f->fmt.pix.height < attr->min_height || f->fmt.pix.height > attr->max_height) {
+		ISP_PRINT(ISP_ERROR_LEVEL,"Invalid format (%dx%d)\n",
+				f->fmt.pix.width, f->fmt.pix.height);
+		return -EINVAL;
+	}
+	vdev->fmt = f;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_TRY_FMT;
+	ioctl.value = (int)vdev;
+	ISP_PRINT(ISP_INFO_LEVEL,"%s[%d] f->fmt.pix.width = %d, f->fmt.pix.height = %d\n",
+			__func__, __LINE__, f->fmt.pix.width, f->fmt.pix.height);
+	ret = v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	if(ret != ISP_SUCCESS) {
+		ISP_PRINT(ISP_ERROR_LEVEL,"Format(0x%x) size(%dx%d) is unsupported\n",
+				f->fmt.pix.pixelformat,
+				f->fmt.pix.width,
+				f->fmt.pix.height);
+	}
+
+	return ret;
+}
+
+static int frame_channel_vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+		struct v4l2_format *f)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct isp_private_ioctl ioctl;
+//	struct frame_channel_fih *fh = priv;
+	struct vb2_queue *q = &vdev->vbq;
+	int ret = ISP_SUCCESS;
+
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	/* check priority */
+//	ret = v4l2_prio_check(&camdev->prio, fh->prio);
+//	if(0 != ret)
+//		return ret;
+	if (vb2_is_streaming(q))
+		return -EBUSY;
+
+	vdev->fmt = f;
+	ret = frame_channel_vidioc_try_fmt_vid_cap(file, priv, f);
+	if (ret != ISP_SUCCESS)
+		return ret;
+	/*set isp format */
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_FMT;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	if(ret != ISP_SUCCESS) {
+		ISP_PRINT(ISP_ERROR_LEVEL,"Format(0x%x) size(%dx%d) is unsupported\n",
+				f->fmt.pix.pixelformat,
+				f->fmt.pix.width,
+				f->fmt.pix.height);
+	}
+	return ret;
+}
+
+static int frame_channel_vidioc_cropcap(struct file *file, void *priv,
+		struct v4l2_cropcap *a)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct isp_private_ioctl ioctl;
+	int ret = ISP_SUCCESS;
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_CROP_CAP;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	if(ret != ISP_SUCCESS) {
+		ISP_PRINT(ISP_INFO_LEVEL,"Don't support to Crop\n");
+	}else{
+		a->bounds = attr->bounds;
+		a->defrect = attr->bounds;
+		a->type				= vdev->vbq.type;
+		a->pixelaspect.numerator	= 1;
+		a->pixelaspect.denominator	= 1;
+		ISP_PRINT(ISP_INFO_LEVEL,"CropCap: default rect is %dx%d\n",
+				attr->bounds.width, attr->bounds.height);
+	}
+	return ret;
+}
+
+static int frame_channel_vidioc_g_crop(struct file *file, void *priv,
+		struct v4l2_crop *a)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_attribute *attr = &vdev->attr;
+
+	a->c = attr->crop;
+	a->type	= vdev->vbq.type;
+
+	return ISP_SUCCESS;
+}
+
+static int frame_channel_vidioc_s_crop(struct file *file, void *fh,
+		const struct v4l2_crop *a)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct v4l2_rect *bounds = &(attr->bounds);
+	struct isp_private_ioctl ioctl;
+	struct vb2_queue *q = &vdev->vbq;
+	int ret = ISP_SUCCESS;
+
+	if (vb2_is_streaming(q))
+		return -EBUSY;
+
+	if(a->type != vdev->vbq.type)
+		return -EINVAL;
+
+	if(a->c.top < 0 || a->c.left < 0 || a->c.width < 0 || a->c.height < 0
+		|| a->c.left + a->c.width > bounds->width ||
+		a->c.top + a->c.height > bounds->height){
+		printk("%s[%d] the parameter is invalid!\n", __func__,__LINE__);
+		return -EINVAL;
+	}
+
+//	memcpy(&attr->crop, a->c,  sizeof(struct v4l2_rect));
+	if(a->c.width && a->c.height)
+		attr->crop_enable = 1;
+	else
+		attr->crop_enable = 0;
+	attr->crop = a->c;
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_CROP;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	return ret;
+}
+
+static int frame_channel_vidioc_reqbufs(struct file *file, void *priv,
+		struct v4l2_requestbuffers *p)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct vb2_queue *q = &vdev->vbq;
+	int ret = 0;
+	ISP_PRINT(ISP_INFO_LEVEL,"%s[%d]\n", __func__, __LINE__);
+	if(p->type != q->type){
+		ISP_PRINT(ISP_ERROR_LEVEL,"%s[%d] req->type = %d, queue->type = %d\n", __func__, __LINE__,
+					p->type, q->type);
+		return -EINVAL;
+	}
+
+	ret = vb2_reqbufs(&vdev->vbq, p);
+	if(!ret){
+		vdev->reqbufs = p->count;
+	}
+	return ret;
+}
+
+static int frame_channel_vidioc_querybuf(struct file *file, void *priv,
+		struct v4l2_buffer *p)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	return vb2_querybuf(&vdev->vbq, p);
+}
+
+static int frame_channel_vidioc_qbuf(struct file *file, void *priv,
+		struct v4l2_buffer *p)
+{
+	int ret;
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	ret = vb2_qbuf(&vdev->vbq, p);
+//	printk("+++ Qbuf: chan%d buf.index = %d\n", vdev->index, p->index);
+	return ret;
+}
+
+static int frame_channel_vidioc_dqbuf(struct file *file, void *priv,
+		struct v4l2_buffer *p)
+{
+	int ret;
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	ret = vb2_dqbuf(&vdev->vbq, p, file->f_flags & O_NONBLOCK);
+//	printk("--- DQbuf: chan%d buf.index = %d\n", vdev->index, p->index);
+	return ret;
+}
+/* static unsigned int irq_read(unsigned int offset) */
+/* { */
+/* 	return *(volatile unsigned int *)(0xb3320000 + 0xc); */
+/* } */
+static int frame_channel_vidioc_streamon(struct file *file, void *priv,
+		enum v4l2_buf_type i)
+{
+	int ret = 0;
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+
+	if(atomic_read(&vdev->state) != TX_ISP_STATE_START){
+		return -EBUSY;
+	}
+	vdev->out_frames = 0;
+	vdev->lose_frames = 0;
+	INIT_COMPLETION(vdev->comp);
+	ret = vb2_streamon(&vdev->vbq, i);
+//	check_csi_error();
+//	check_vic_error();
+/* 			for(i = 0;i<10;i++){ */
+/* 				while(((irq_read(0xc)&0x10000)!=0x10000)){ */
+/* 				printk("1111111111111111111111111111\n"); */
+/* 				} */
+/* 				printk("2222222222222  0x%08x  2222222222222222\n", */
+/* 				       (irq_read(0xc))); */
+/* 				*(volatile unsigned int *)(0xb3320000 + 4) = 0x10001; */
+
+/* } */
+
+/* //	irq_write(IRQ_CLR_1, 0x10001); */
+/* 		printk("vic------------start\n"); */
+
+
+	return ret;
+}
+
+static int frame_channel_vidioc_streamoff(struct file *file, void *priv,
+		enum v4l2_buf_type i)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	int ret = 0;
+	ISP_PRINT(ISP_INFO_LEVEL,"%s==========%d\n", __func__, __LINE__);
+	attr->crop_enable = 0;
+	attr->scaler_enable = 0;
+	attr->frame_rate = 0;
+	ret = vb2_streamoff(&vdev->vbq, i);
+	/* reset some public parameters */
+	memset(&attr->crop, 0, sizeof(attr->crop));
+	memset(&attr->scaler, 0, sizeof(attr->scaler));
+//	memset(&attr->output, 0, sizeof(attr->output));
+	return ret;
+}
+
+static int frame_channel_vidioc_s_ctrl(struct file *file, void *priv,
+		struct v4l2_control *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int frame_channel_vidioc_g_ctrl(struct file *file, void *priv,
+		struct v4l2_control *ctrl)
+{
+	int ret = 0;
+	return ret;
+}
+static int frame_channel_vidioc_s_parm(struct file *file, void *priv,
+		struct v4l2_streamparm *parm)
+{
+	int ret = 0;
+	return ret;
+
+}
+
+static int frame_channel_vidioc_g_parm(struct file *file, void *priv,
+		struct v4l2_streamparm *parm)
+{
+	int ret = 0;
+	return ret;
+}
+
+static inline long frame_channel_scaler_capture(frame_chan_vdev_t *vdev, void *arg)
+{
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct frame_image_scalercap *scalercap = &attr->scalercap;
+	struct isp_private_ioctl ioctl;
+	long ret = ISP_SUCCESS;
+
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SCALER_CAP;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	if(ret == ISP_SUCCESS) {
+	//	printk("&&&&&&& %s[%d] arg = %p *arg = 0x%08x  &&&&&&\n", __func__,__LINE__,arg, *(unsigned int*)arg);
+		memcpy(arg, scalercap, sizeof(*scalercap));
+	}
+	return ret;
+}
+
+static inline long frame_channel_set_scaler_info(frame_chan_vdev_t *vdev, void *arg)
+{
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct frame_image_scaler *scaler = &attr->scaler;
+	struct frame_image_scalercap *scalercap = &attr->scalercap;
+	struct isp_private_ioctl ioctl;
+	struct vb2_queue *q = &vdev->vbq;
+	long ret = ISP_SUCCESS;
+
+	if (vb2_is_streaming(q))
+		return -EBUSY;
+
+	memcpy(scaler, arg, sizeof(*scaler));
+
+//	attr->scaler = scaler;
+	if(scaler->out_width && scaler->out_height)
+		attr->scaler_enable = 1;
+	else
+		attr->scaler_enable = 0;
+
+	if (attr->scaler_enable) {
+		if(scaler->out_width > scalercap->max_width || scaler->out_width < scalercap->min_width
+				|| scaler->out_height > scalercap->max_height || scaler->out_height < scalercap->min_height){
+			printk("%s[%d] the parameter is invalid!\n", __func__, __LINE__);
+			return -EINVAL;
+		}
+	}
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_SCALER;
+	ioctl.value = (int)vdev;
+	ret = v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+	return ret;
+}
+
+static inline long frame_channel_set_channel_banks(frame_chan_vdev_t *vdev, void *arg)
+{
+	int count = *(int*)arg;
+	if(count <= 0)
+		return -EINVAL;
+
+	vdev->reqbufs = count;
+	return ISP_SUCCESS;
+}
+
+static inline long frame_channel_listen_buffer(frame_chan_vdev_t *vdev, void *arg)
+{
+//	unsigned int timeout = 0;
+	long ret = ISP_SUCCESS;
+#if 1
+	if(atomic_read(&vdev->state) != TX_ISP_STATE_RUN){
+		*(int *)arg = -1;
+		return -EPERM;
+	}
+#endif
+	/* -ERESTARTSYS value return to sdk */
+	ret = wait_for_completion_interruptible(&vdev->comp);
+	if (ret < 0)
+		*(int *)arg = ret;
+	else
+		*(int *)arg = vdev->comp.done + 1;
+	return ret;
+}
+
+static long frame_channel_vidioc_default(struct file *file, void *fh, bool valid_prio, unsigned int cmd, void *arg)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	long ret = ISP_SUCCESS;
+
+	switch(cmd){
+		case VIDIOC_DEFAULT_CMD_SCALER_CAP:
+			ret = frame_channel_scaler_capture(vdev, arg);
+			break;
+		case VIDIOC_DEFAULT_CMD_SET_SCALER:
+			ret = frame_channel_set_scaler_info(vdev, arg);
+			break;
+		case VIDIOC_DEFAULT_CMD_SET_BANKS:
+			ret = frame_channel_set_channel_banks(vdev, arg);
+			break;
+		case VIDIOC_DEFAULT_CMD_LISTEN_BUF:
+			ret = frame_channel_listen_buffer(vdev, arg);
+			break;
+		default:
+			ret = -ISP_ERROR;
+			break;
+	}
+	return ret;
+}
+
+static const struct v4l2_ioctl_ops frame_channel_v4l2_ioctl_ops = {
+
+	/* VIDIOC_QUERYCAP handler */
+	.vidioc_querycap		= frame_channel_vidioc_querycap,
+	/* Priority handling */
+	.vidioc_s_priority		= frame_channel_vidioc_s_priority,
+	.vidioc_g_priority		= frame_channel_vidioc_g_priority,
+
+	.vidioc_enum_fmt_vid_cap	= frame_channel_vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap		= frame_channel_vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap		= frame_channel_vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap		= frame_channel_vidioc_s_fmt_vid_cap,
+
+	/*frame management*/
+	.vidioc_reqbufs			= frame_channel_vidioc_reqbufs,
+	.vidioc_querybuf		= frame_channel_vidioc_querybuf,
+	.vidioc_qbuf			= frame_channel_vidioc_qbuf,
+	.vidioc_dqbuf			= frame_channel_vidioc_dqbuf,
+
+	/*isp function, modified according to spec*/
+	.vidioc_g_ctrl			= frame_channel_vidioc_g_ctrl,
+	.vidioc_s_ctrl			= frame_channel_vidioc_s_ctrl,
+	.vidioc_cropcap			= frame_channel_vidioc_cropcap,
+	.vidioc_g_crop			= frame_channel_vidioc_g_crop,
+	.vidioc_s_crop			= frame_channel_vidioc_s_crop,
+	.vidioc_s_parm			= frame_channel_vidioc_s_parm,
+	.vidioc_g_parm			= frame_channel_vidioc_g_parm,
+
+	.vidioc_streamon		= frame_channel_vidioc_streamon,
+	.vidioc_streamoff		= frame_channel_vidioc_streamoff,
+
+	/* For other private ioctls */
+	.vidioc_default			= frame_channel_vidioc_default,
+};
+
+static int frame_channel_v4l2_open(struct file *file)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_attribute *attr = &vdev->attr;
+	struct frame_channel_fh *fh;
+	struct isp_private_ioctl ioctl;
+	unsigned long flags;
+
+	if(atomic_read(&vdev->state) != TX_ISP_STATE_STOP){
+		return -EBUSY;
+	}
+
+	fh = (struct frame_channel_fh *)kzalloc(sizeof(*fh), GFP_KERNEL);
+	if(NULL == fh)
+		goto fh_alloc_fail;
+	file->private_data = fh;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_DEFAULT;
+//	v4l2_prio_open(&camdev->prio, &fh->prio);
+
+	/* reset some public parameters */
+	memset(&attr->crop, 0, sizeof(attr->crop));
+	memset(&attr->scaler, 0, sizeof(attr->scaler));
+//	memset(&attr->output, 0, sizeof(attr->output));
+	attr->crop_enable = 0;
+	attr->scaler_enable = 0;
+	attr->frame_rate = 0;
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_SCALER;
+	ioctl.value = (int)vdev;
+	v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+
+	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
+	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_FRAME_CHAN_SET_CROP;
+	ioctl.value = (int)vdev;
+	v4l2_subdev_call(vdev->parent, core, ioctl, VIDIOC_ISP_PRIVATE_IOCTL, &ioctl);
+
+	spin_lock_irqsave(&vdev->slock, flags);
+	atomic_set(&vdev->state, TX_ISP_STATE_START);
+	spin_unlock_irqrestore(&vdev->slock, flags);
+	return ISP_SUCCESS;
+fh_alloc_fail:
+	return -ENOMEM;
+}
+
+static int frame_channel_v4l2_close(struct file *file)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	struct frame_channel_fh *fh = file->private_data;
+	unsigned long flags;
+	if(atomic_read(&vdev->state) == TX_ISP_STATE_RUN){
+		frame_channel_vidioc_streamoff(file, NULL, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	}
+
+	if(atomic_read(&vdev->state) == TX_ISP_STATE_START){
+		spin_lock_irqsave(&vdev->slock, flags);
+		atomic_set(&vdev->state, TX_ISP_STATE_STOP);
+		spin_unlock_irqrestore(&vdev->slock, flags);
+	}
+	/* Close the priority */
+//	v4l2_prio_close(&camdev->prio, fh->prio);
+	if(fh){
+		kfree(fh);
+		file->private_data = NULL;
+	}
+	return ISP_SUCCESS;
+}
+
+static unsigned int frame_channel_v4l2_poll(struct file *file,
+		struct poll_table_struct *wait)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	return vb2_poll(&vdev->vbq, file, wait);
+}
+
+static int frame_channel_v4l2_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	frame_chan_vdev_t *vdev = video_drvdata(file);
+	return vb2_mmap(&vdev->vbq, vma);
+}
+
+
+static struct v4l2_file_operations frame_channel_v4l2_fops = {
+	.owner 		= THIS_MODULE,
+	.open 		= frame_channel_v4l2_open,
+	.release 	= frame_channel_v4l2_close,
+	.poll		= frame_channel_v4l2_poll,
+	.unlocked_ioctl	= video_ioctl2,
+	.mmap 		= frame_channel_v4l2_mmap,
+};
+
+static struct video_device frame_channel_video = {
+	.name = "isp-frame-channel",
+	.minor = -1,
+	.release = video_device_release,
+	.fops = &frame_channel_v4l2_fops,
+	.ioctl_ops = &frame_channel_v4l2_ioctl_ops,
+};
+
+static unsigned int bitmap = 0;
+static void inline set_bitmap(int index)
+{
+	bitmap |= (1 << index);
+}
+static void inline clear_bitmap(int index)
+{
+	bitmap &= ~(1 << index);
+}
+static bool inline check_bitmap(int index)
+{
+	return bitmap & (1 << index) ? true : false;
+}
+
+int tx_isp_frame_channel_device_register(frame_chan_vdev_t *vdev)
+{
+	struct v4l2_device *v4l2_dev;
+	struct video_device *vfd;
+	struct vb2_queue *q;
+	int ret = ISP_SUCCESS;
+
+	if(!vdev)
+		return -EINVAL;
+
+	if(!vdev->parent || !vdev->vbm || check_bitmap(vdev->index)){
+		return -EINVAL;
+	}
+
+	spin_lock_init(&vdev->slock);
+	mutex_init(&vdev->mlock);
+	init_completion(&vdev->comp);
+	INIT_LIST_HEAD(&vdev->active_list);
+	v4l2_dev = vdev->parent->v4l2_dev;
+//	printk("&&&&&&&&&&& %s frame channel%d :slock = %p, mlock = %p &&&&&&&&&&\n",__func__,vdev->index,
+//					&vdev->slock, &vdev->mlock);
+	/* Initialize queue. */
+	q = &vdev->vbq;
+	memset(q, 0, sizeof(*q));
+	q->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR;
+	q->drv_priv = vdev;
+	q->buf_struct_size = sizeof(struct frame_channel_video_buffer);
+	q->ops = &frame_channel_vb2_qops;
+	q->mem_ops = &frame_channel_vb2_memops;
+	q->timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+
+	ret = vb2_queue_init(q);
+	if(ret){
+		v4l2_err(v4l2_dev, "Failed to init vb2 queue\n");
+		goto exit;
+	}
+
+	/* Initialize video */
+	vfd = video_device_alloc();
+	if (!vfd) {
+		v4l2_err(v4l2_dev, "Failed to allocate frame channel video\n");
+		ret = -ENOMEM;
+		goto err_alloc_video;
+	}
+
+	sprintf(frame_channel_video.name, "isp-frame-channel%d",vdev->index);
+	memcpy(vfd, &frame_channel_video, sizeof(frame_channel_video));
+	vfd->lock = &vdev->mlock;
+	vfd->v4l2_dev = v4l2_dev;
+//	vfd->debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;
+	vfd->debug =0;
+
+	set_bit(V4L2_FL_USE_FH_PRIO, &(vfd->flags)); // add lately
+
+	vdev->video = vfd;
+
+	v4l2_disable_ioctl_locking(vfd, VIDIOC_DQBUF);
+	v4l2_disable_ioctl_locking(vfd, VIDIOC_QBUF);
+	v4l2_disable_ioctl_locking(vfd, VIDIOC_DEFAULT_CMD_LISTEN_BUF);
+
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, -1);
+	if (ret < 0) {
+		ISP_PRINT(ISP_ERROR,"Failed to register video device\n");
+		goto free_video_device;
+	}
+
+	vdev->interrupt_service_routine = frame_channel_video_irq_notify;
+
+	video_set_drvdata(vfd, vdev);
+
+	set_bitmap(vdev->index);
+
+	atomic_set(&vdev->state, TX_ISP_STATE_STOP);
+#if 0
+	/* init v4l2_priority */
+	v4l2_prio_init(&camdev->prio);
+#endif
+	return 0;
+free_video_device:
+	video_device_release(vfd);
+err_alloc_video:
+	vb2_queue_release(q);
+exit:
+	return ret;
+}
+
+void tx_isp_frame_channel_device_unregister(frame_chan_vdev_t *vdev)
+{
+	video_unregister_device(vdev->video);
+	vb2_queue_release(&vdev->vbq);
+	clear_bitmap(vdev->index);
+}
+
+#if 0
+static int frame_channel_camera_suspend(struct device *dev)
+{
+	struct frame_channel_camera_dev *camdev = dev_get_drvdata(dev);
+
+	isp_dev_call(camdev->isp, suspend, NULL);
+
+	return 0;
+}
+
+static int frame_channel_camera_resume(struct device *dev)
+{
+	struct frame_channel_camera_dev *camdev = dev_get_drvdata(dev);
+
+	isp_dev_call(camdev->isp, resume, NULL);
+
+	return 0;
+}
+#endif
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-frame-channel.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-frame-channel.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-frame-channel.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-frame-channel.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,87 @@
+#ifndef __TX_ISP_FRAME_CHANNEL_H__
+#define __TX_ISP_FRAME_CHANNEL_H__
+
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/videobuf2-core.h>
+
+#include <tx-isp-common.h>
+
+struct frame_channel_format {
+	unsigned char name[32];
+	unsigned int fourcc;
+	unsigned int depth;
+	unsigned int priv;
+};
+
+struct tx_isp_frame_channel_video_device;
+
+typedef struct tx_isp_frame_channel_video_device frame_chan_vdev_t;
+
+
+struct frame_channel_attribute {
+/* Private: internal use only */
+	unsigned short max_width;
+	unsigned short max_height;
+	unsigned short min_width;
+	unsigned short min_height;
+	unsigned short step_width;
+	unsigned short step_height;
+	struct v4l2_rect        bounds;
+	struct frame_image_scalercap scalercap;
+
+/* Public: user could set it through special ioctl */
+	struct v4l2_rect        crop;
+	struct frame_image_scaler scaler;
+	struct v4l2_format	output;
+	unsigned int  crop_enable :1;
+	unsigned int  scaler_enable :1;
+	unsigned int lineoffset;
+	int frame_rate;
+};
+
+struct frame_channel_buffer {
+	struct list_head entry;
+	unsigned int addr;
+	void *priv;
+};
+
+struct frame_channel_video_buffer{
+	struct vb2_buffer vb;
+	struct frame_channel_buffer buf;
+	struct list_head entry;
+};
+
+struct frame_channel_fh {
+	enum v4l2_priority prio;
+};
+struct tx_isp_frame_channel_video_device {
+	/* the paramters have been inited before it is registered */
+	struct v4l2_subdev *parent;
+	struct frame_vb2_manager *vbm;
+	struct frame_channel_attribute attr;
+	int index;
+	int bypass;
+
+	/* the parameters will be inited when it is registered */
+	struct video_device *video;
+	struct vb2_queue vbq;
+	struct list_head active_list;
+	spinlock_t slock;
+	struct mutex mlock;
+	atomic_t state;
+	struct completion comp;
+	int (*interrupt_service_routine)(frame_chan_vdev_t  *chan,
+						u32 status, bool *handled);
+	unsigned int out_frames;
+	unsigned int lose_frames;
+	struct v4l2_fmtdesc *fmtdesc;
+	struct v4l2_format *fmt;
+	int reqbufs;
+};
+
+int tx_isp_frame_channel_device_register(frame_chan_vdev_t *chan);
+void tx_isp_frame_channel_device_unregister(frame_chan_vdev_t *chan);
+
+#endif/*__TX_ISP_FRAME_CHANNEL_H__*/
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-interrupt.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-interrupt.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-interrupt.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-interrupt.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,179 @@
+#include <tx-isp-common.h>
+#include "tx-isp-interrupt.h"
+
+static unsigned int refcnt = 0;
+static void tx_isp_enable_irq(struct tx_isp_irq_device *irq_dev, int enable)
+{
+	volatile unsigned int reg = tx_isp_readl(irq_dev->base, TX_ISP_TOP_IRQ_ENABLE);
+	unsigned long flags;
+	reg |= enable;
+	tx_isp_writel(irq_dev->base, TX_ISP_TOP_IRQ_ENABLE, reg);
+	spin_lock_irqsave(&irq_dev->slock, flags);
+	if(irq_dev->state == 0){
+		irq_dev->state = 1;
+		refcnt++;
+		enable_irq(irq_dev->irq);
+//		printk("mask=0x%08x enable=0x%08x\n", tx_isp_readl(irq_dev->base, TX_ISP_TOP_IRQ_MASK), reg);
+//		printk("++ refcnt = %d ++\n",refcnt);
+	}
+	spin_unlock_irqrestore(&irq_dev->slock, flags);
+}
+static void tx_isp_disable_irq(struct tx_isp_irq_device *irq_dev, int enable)
+{
+	volatile unsigned int reg = tx_isp_readl(irq_dev->base, TX_ISP_TOP_IRQ_ENABLE);
+	unsigned long flags;
+	spin_lock_irqsave(&irq_dev->slock, flags);
+	reg &= ~enable;
+	tx_isp_writel(irq_dev->base, TX_ISP_TOP_IRQ_ENABLE, reg);
+	if(reg == 0 && irq_dev->state){
+		irq_dev->state = 0;
+		refcnt--;
+		disable_irq(irq_dev->irq);
+//		printk("-- refcnt = %d --\n",refcnt);
+	}
+	spin_unlock_irqrestore(&irq_dev->slock, flags);
+}
+static void tx_isp_mask_irq(struct tx_isp_irq_device *irq_dev, int mask)
+{
+	volatile unsigned int reg = tx_isp_readl(irq_dev->base, TX_ISP_TOP_IRQ_MASK);
+	reg |= mask;
+	tx_isp_writel(irq_dev->base, TX_ISP_TOP_IRQ_MASK, reg);
+}
+static void tx_isp_unmask_irq(struct tx_isp_irq_device *irq_dev, int mask)
+{
+	volatile unsigned int reg = tx_isp_readl(irq_dev->base, TX_ISP_TOP_IRQ_MASK);
+	reg &= ~mask;
+	tx_isp_writel(irq_dev->base, TX_ISP_TOP_IRQ_MASK, reg);
+}
+
+static inline void tx_isp_clear_irq(struct tx_isp_irq_device *irq_dev, unsigned int clear)
+{
+	tx_isp_writel(irq_dev->base, TX_ISP_TOP_IRQ_CLR_1, clear);
+}
+
+static irqreturn_t isp_irq_handle(int this_irq, void *dev)
+{
+	tx_isp_device_t *ispdev = (tx_isp_device_t *)dev;
+	struct tx_isp_media_pipeline *p = &ispdev->pipeline;
+	struct tx_isp_irq_device *irqdev = ispdev->irq_dev;
+	struct v4l2_subdev *sd = NULL;
+	volatile unsigned int state, pending, mask;
+	int index = 0;
+	int ret = IRQ_HANDLED;
+	irqreturn_t retval = IRQ_HANDLED;
+//	if(irqdev == NULL)
+//		return IRQ_HANDLED;
+
+	mask = tx_isp_readl(irqdev->base, TX_ISP_TOP_IRQ_MASK);
+	state = tx_isp_readl(irqdev->base, TX_ISP_TOP_IRQ_STA);
+	pending = state & (~mask);
+	if(pending){
+		tx_isp_clear_irq(irqdev, pending);
+		while(index < TX_ISP_MAX_GRP_IDX && p->subdevs[index]){
+			sd = p->subdevs[index];
+			ret = v4l2_subdev_call(sd, core, interrupt_service_routine, pending, NULL);
+			if(ret == IRQ_WAKE_THREAD)
+				retval = IRQ_WAKE_THREAD;
+			index++;
+		}
+	}
+	return retval;
+}
+
+extern irqreturn_t isp_irq_thread_handle(int this_irq, void *dev);
+int tx_isp_request_irq(struct platform_device *pdev, tx_isp_device_t *ispdev)
+{
+	struct v4l2_device *v4l2_dev;
+	struct resource *res;
+	struct tx_isp_irq_device *irqdev;
+	int irq;
+	int ret = ISP_SUCCESS;
+
+	if(!pdev || !ispdev){
+		printk("%s[%d] the parameters are invalid!\n",__func__,__LINE__);
+		ret = -EINVAL;
+		goto exit;
+
+	}
+	v4l2_dev = &ispdev->v4l2_dev;
+	irqdev = kzalloc(sizeof(*irqdev), GFP_KERNEL);
+	if (!irqdev) {
+		v4l2_err(v4l2_dev, "%s[%d] Failed to allocate irq device\n",__func__,__LINE__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if (!res || !irq) {
+		v4l2_err(v4l2_dev, "%s[%d] Not enough platform resources",__func__,__LINE__);
+		ret = -ENODEV;
+		goto err_resource;
+	}
+
+	res = request_mem_region(res->start,
+			res->end - res->start + 1, dev_name(&pdev->dev));
+	if (!res) {
+		v4l2_err(v4l2_dev, "%s[%d] Not enough memory for resources\n", __func__,__LINE__);
+		ret = -EBUSY;
+		goto err_req_mem;
+	}
+
+	irqdev->base = ioremap(res->start, res->end - res->start + 1);
+	if (!irqdev->base) {
+		v4l2_err(v4l2_dev, "%s[%d] Unable to ioremap registers\n", __func__,__LINE__);
+		ret = -ENXIO;
+		goto err_ioremap;
+	}
+
+	spin_lock_init(&irqdev->slock);
+//	tx_isp_mask_irq(irqdev, TX_ISP_TOP_IRQ_ALL);
+//	ispdev->irq_dev = irqdev;
+
+	ret = request_threaded_irq(irq, isp_irq_handle, isp_irq_thread_handle, IRQF_ONESHOT, "isp", ispdev);
+	if(ret){
+		v4l2_err(v4l2_dev, "%s[%d] Failed to request irq(%d).\n", __func__,__LINE__, irq);
+		ret = -EINTR;
+		goto err_req_irq;
+	}
+
+	irqdev->irq = irq;
+	irqdev->res = res;
+	irqdev->enable_irq = tx_isp_enable_irq;
+	irqdev->disable_irq = tx_isp_disable_irq;
+	irqdev->mask_irq = tx_isp_mask_irq;
+	irqdev->unmask_irq = tx_isp_unmask_irq;
+	irqdev->state = 1;
+	ispdev->irq_dev = irqdev;
+	tx_isp_disable_irq(irqdev, TX_ISP_TOP_IRQ_ALL);
+	tx_isp_unmask_irq(irqdev, TX_ISP_TOP_IRQ_ISP);
+//	printk("^^ %s[%d] irq = %d ^^\n", __func__,__LINE__,irq);
+
+	return ISP_SUCCESS;
+err_req_irq:
+	iounmap(irqdev->base);
+err_ioremap:
+	release_mem_region(res->start, res->end - res->start + 1);
+err_req_mem:
+err_resource:
+	kfree(irqdev);
+exit:
+	return ret;
+}
+
+void tx_isp_free_irq(tx_isp_device_t *ispdev)
+{
+	struct tx_isp_irq_device *irqdev;
+	struct resource *res;
+	if(!ispdev || !ispdev->irq_dev){
+		return;
+	}
+	irqdev = ispdev->irq_dev;
+	res = irqdev->res;
+	free_irq(irqdev->irq, ispdev);
+	iounmap(irqdev->base);
+	release_mem_region(res->start, res->end - res->start + 1);
+	kfree(irqdev);
+	ispdev->irq_dev = NULL;
+}
+
+
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-interrupt.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-interrupt.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-interrupt.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-interrupt.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,39 @@
+#ifndef __TX_ISP_INTERRUPT_H__
+#define __TX_ISP_INTERRUPT_H__
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "tx-isp-device.h"
+#define TX_ISP_TOP_IRQ_CNT		0x0
+#define TX_ISP_TOP_IRQ_CNT1		0x20
+#define TX_ISP_TOP_IRQ_CNT2		0x24
+#define TX_ISP_TOP_IRQ_CLR_1		0x4
+#define TX_ISP_TOP_IRQ_CLR_ALL		0x8
+#define TX_ISP_TOP_IRQ_STA		0xC
+#define TX_ISP_TOP_IRQ_OVF		0x10
+#define TX_ISP_TOP_IRQ_ENABLE		0x14
+#define TX_ISP_TOP_IRQ_MASK		0x1c
+#define TX_ISP_TOP_IRQ_ISP		0xffff
+#define TX_ISP_TOP_IRQ_VIC		0x7f0000
+#define TX_ISP_TOP_IRQ_ALL		0x7fffff
+
+struct tx_isp_irq_device {
+	struct resource *res;
+	void __iomem *base;
+	volatile int state;
+	spinlock_t slock;
+	int irq;
+	void (*enable_irq)(struct tx_isp_irq_device *irq_dev, int enable);
+	void (*disable_irq)(struct tx_isp_irq_device *irq_dev, int enable);
+	void (*mask_irq)(struct tx_isp_irq_device *irq_dev, int mask);
+	void (*unmask_irq)(struct tx_isp_irq_device *irq_dev, int mask);
+};
+
+int tx_isp_request_irq(struct platform_device *pdev, tx_isp_device_t *ispdev);
+void tx_isp_free_irq(tx_isp_device_t *ispdev);
+#endif /* __TX_ISP_INTERRUPT_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-vic.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-vic.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-vic.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-vic.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,584 @@
+#include <linux/delay.h>
+#include <media/v4l2-common.h>
+#include <linux/v4l2-mediabus.h>
+#include <linux/mm.h>
+#include <linux/clk.h>
+#include "tx-isp-vic.h"
+
+//#ifdef CONFIG_PRODUCT_FPGA
+#if 0
+static int isp_vic_init_clk(struct tx_isp_vic_driver *vsd)
+{
+	return 0;
+}
+static long isp_vic_set_clk(struct tx_isp_vic_driver *vsd, int state)
+{
+	return 0;
+}
+static int isp_vic_release_clk(struct tx_isp_vic_driver *vsd)
+{
+	return 0;
+}
+#else
+static int isp_vic_init_clk(struct tx_isp_vic_driver *vsd)
+{
+	struct clk **clks = NULL;
+	struct v4l2_device *v4l2_dev = vsd->sd.v4l2_dev;
+	struct tx_isp_subdev_platform_data *pdata = vsd->pdata;
+	struct tx_isp_subdev_clk_info *info = pdata->clks;
+	unsigned int num = pdata->clk_num;
+	int ret = 0;
+	int i;
+
+	vsd->clk_num = pdata->clk_num;
+	if(!vsd->clk_num){
+		vsd->clks = NULL;
+		return ISP_SUCCESS;
+	}
+
+	clks = (struct clk **)kzalloc(sizeof(clks) * num, GFP_KERNEL);
+	if(!clks){
+		v4l2_err(v4l2_dev, "%s[%d] Failed to allocate core's clks\n",__func__,__LINE__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	for (i = 0; i < num; i++) {
+		clks[i] = clk_get(vsd->dev, info[i].name);
+		if (IS_ERR(clks[i])) {
+			v4l2_err(v4l2_dev, "Failed to get %s clock %ld\n", info[i].name, PTR_ERR(clks[i]));
+			ret = PTR_ERR(clks[i]);
+			goto failed_to_get_clk;
+		}
+		if(info[i].rate != DUMMY_CLOCK_RATE) {
+			ret = clk_set_rate(clks[i], info[i].rate);
+			if(ret){
+				v4l2_err(v4l2_dev, "Failed to set %s clock rate(%ld)\n", info[i].name, info[i].rate);
+				goto failed_to_get_clk;
+			}
+		}
+	}
+	vsd->clks = clks;
+	return ISP_SUCCESS;
+failed_to_get_clk:
+	while(--i >= 0){
+		clk_put(clks[i]);
+	}
+	kfree(clks);
+exit:
+	return ret;
+}
+
+static long isp_vic_set_clk(struct tx_isp_vic_driver *vsd, int state)
+{
+	struct clk **clks = vsd->clks;
+	int i;
+
+	if(state){
+		for(i = 0; i < vsd->clk_num; i++)
+			clk_enable(clks[i]);
+	}else{
+		for(i = vsd->clk_num - 1; i >=0; i--)
+			clk_disable(clks[i]);
+	}
+	return ISP_SUCCESS;
+}
+
+
+static int isp_vic_release_clk(struct tx_isp_vic_driver *vsd)
+{
+	struct clk **clks = vsd->clks;
+	int i = 0;
+
+	if(clks == NULL)
+		return 0;
+	for (i = 0; i < vsd->clk_num; i++)
+		clk_put(clks[i]);
+
+	kfree(clks);
+	return 0;
+}
+#endif
+void dump_vic_reg(struct tx_isp_vic_driver *vsd)
+{
+	printk("BT_DVP_CFG : %08x\n", tx_isp_vic_readl(vsd,VIC_DB_CFG));
+#if VIC_SUPPORT_MIPI
+	printk("INTERFACE_TYPE : %08x\n", tx_isp_vic_readl(vsd,VIC_INTF_TYPE));
+	printk("IDI_TYPE_TYPE : %08x\n", tx_isp_vic_readl(vsd,VIC_IDI_TYPE));
+#endif
+	printk("RESOLUTION : %08x\n", tx_isp_vic_readl(vsd,VIC_RESOLUTION));
+	printk("AB_VALUE : %08x\n", tx_isp_vic_readl(vsd,VIC_AB_VALUE));
+	printk("GLOBAL_CONFIGURE : %08x\n", tx_isp_vic_readl(vsd,VIC_GLOBAL_CFG));
+	printk("CONTROL : %08x\n", tx_isp_vic_readl(vsd,VIC_CONTROL));
+	printk("PIXEL : 0x%08x\n", tx_isp_vic_readl(vsd,VIC_PIXEL));
+	printk("LINE : 0x%08x\n", tx_isp_vic_readl(vsd,VIC_LINE));
+	printk("VIC_STATE : 0x%08x\n", tx_isp_vic_readl(vsd,VIC_STATE));
+	printk("OFIFO_COUNT : 0x%08x\n", tx_isp_vic_readl(vsd,VIC_OFIFO_COUNT));
+	printk("0x3c :0x%08x\n",tx_isp_vic_readl(vsd,0x3c));
+	printk("0x40 :0x%08x\n",tx_isp_vic_readl(vsd,0x40));
+	printk("0x44 :0x%08x\n",tx_isp_vic_readl(vsd,0x44));
+	printk("0x54 :0x%08x\n",tx_isp_vic_readl(vsd,0x54));
+	printk("0x58 :0x%08x\n",tx_isp_vic_readl(vsd,0x58));
+	printk("0x58 :0x%08x\n",tx_isp_vic_readl(vsd,0x5c));
+	printk("0x60 :0x%08x\n",tx_isp_vic_readl(vsd,0x60));
+	printk("0x64 :0x%08x\n",tx_isp_vic_readl(vsd,0x64));
+	printk("0x68 :0x%08x\n",tx_isp_vic_readl(vsd,0x68));
+	printk("0x6c :0x%08x\n",tx_isp_vic_readl(vsd,0x6c));
+	printk("0x70 :0x%08x\n",tx_isp_vic_readl(vsd,0x70));
+	printk("0x74 :0x%08x\n",tx_isp_vic_readl(vsd,0x74));
+	printk("0x04 :0x%08x\n",tx_isp_vic_readl(vsd,0x04));
+	printk("0x08 :0x%08x\n",tx_isp_vic_readl(vsd,0x08));
+	printk("VIC_EIGHTH_CB :0x%08x\n",tx_isp_vic_readl(vsd,VIC_EIGHTH_CB));
+	printk("CB_MODE0 :0x%08x\n",tx_isp_vic_readl(vsd,CB_MODE0));
+}
+static struct tx_isp_vic_driver *dump_vsd = NULL;
+void check_vic_error(void){
+	while(1){
+		dump_vic_reg(dump_vsd);
+	}
+}
+
+static int tx_isp_vic_start(struct tx_isp_vic_driver *vsd)
+{
+	struct tx_isp_video_in *vin = &vsd->vin;
+	int ret = ISP_SUCCESS;
+	unsigned int input_cfg = 0;
+
+	if(vin->attr->dbus_type == TX_SENSOR_DATA_INTERFACE_MIPI){
+#if VIC_SUPPORT_MIPI
+		tx_isp_vic_writel(vsd,VIC_INTF_TYPE, INTF_TYPE_MIPI);//MIPI
+		switch(vin->mbus.code){
+			case V4L2_MBUS_FMT_SBGGR8_1X8:
+			case V4L2_MBUS_FMT_SGBRG8_1X8:
+			case V4L2_MBUS_FMT_SGRBG8_1X8:
+			case V4L2_MBUS_FMT_SRGGB8_1X8:
+				tx_isp_vic_writel(vsd,VIC_IDI_TYPE,MIPI_RAW8);//RAW8
+				break;
+			case 	V4L2_MBUS_FMT_SBGGR10_1X10:
+			case	V4L2_MBUS_FMT_SGBRG10_1X10:
+			case	V4L2_MBUS_FMT_SGRBG10_1X10:
+			case	V4L2_MBUS_FMT_SRGGB10_1X10:
+				tx_isp_vic_writel(vsd,VIC_IDI_TYPE,MIPI_RAW10);//RAW10
+				break;
+			case	V4L2_MBUS_FMT_SBGGR12_1X12:
+			case	V4L2_MBUS_FMT_SGBRG12_1X12:
+			case	V4L2_MBUS_FMT_SGRBG12_1X12:
+			case	V4L2_MBUS_FMT_SRGGB12_1X12:
+				tx_isp_vic_writel(vsd,VIC_IDI_TYPE,MIPI_RAW12);//RAW12
+				break;
+			case V4L2_MBUS_FMT_RGB555_2X8_PADHI_LE:
+				tx_isp_vic_writel(vsd,VIC_IDI_TYPE,MIPI_RGB555);//RGB555
+				break;
+			case V4L2_MBUS_FMT_RGB565_2X8_LE:
+				tx_isp_vic_writel(vsd,VIC_IDI_TYPE,MIPI_RGB565);//RGB565
+				break;
+			case 	V4L2_MBUS_FMT_UYVY8_1_5X8 :
+			case	V4L2_MBUS_FMT_VYUY8_1_5X8 :
+			case	V4L2_MBUS_FMT_YUYV8_1_5X8 :
+			case	V4L2_MBUS_FMT_YVYU8_1_5X8 :
+			case	V4L2_MBUS_FMT_YUYV8_1X16 :
+				tx_isp_vic_writel(vsd,VIC_IDI_TYPE,MIPI_YUV422);//YUV422
+				break;
+
+		}
+		ret = (vin->mbus.width<< 16) | (vin->mbus.height);
+		tx_isp_vic_writel(vsd,VIC_RESOLUTION, ret);
+		tx_isp_vic_writel(vsd,VIC_GLOBAL_CFG, ISP_PRESET_MODE1);//ISP_PRESET_MODE1);
+		tx_isp_vic_writel(vsd,VIC_CONTROL, REG_ENABLE);
+		while(tx_isp_vic_readl(vsd,VIC_CONTROL));
+		tx_isp_vic_writel(vsd, VIC_CONTROL, VIC_SRART);
+		//dump_vic_reg(dump_vsd);
+#endif
+	}else if(vin->attr->dbus_type == TX_SENSOR_DATA_INTERFACE_DVP){
+#if VIC_SUPPORT_MIPI
+		tx_isp_vic_writel(vsd,VIC_INTF_TYPE, INTF_TYPE_DVP);//DVP
+#endif
+
+#if defined(CONFIG_SOC_T30)
+		volatile unsigned int value = *(volatile unsigned int *)(0xb0000020);
+		value &= ~(1<<25);
+		*(volatile unsigned int *)(0xb0000020) = value;
+		*(volatile unsigned int*)(0xb004000c) = 0x0;
+		//msleep(1000);
+		*(volatile unsigned int*)(0xb004000c) = 0x1;
+		*(volatile unsigned int*)(0xb0022000) = 0x7d;
+		*(volatile unsigned int*)(0xb0022080) = 0x3e;//0x3f
+		*(volatile unsigned int*)(0xb0022300) = 0x1e;//disable
+		*(volatile unsigned int*)(0xb00222cc) = 0x1;
+#endif
+		switch(vin->mbus.code){
+			case V4L2_MBUS_FMT_SBGGR8_1X8:
+			case V4L2_MBUS_FMT_SGBRG8_1X8:
+			case V4L2_MBUS_FMT_SGRBG8_1X8:
+			case V4L2_MBUS_FMT_SRGGB8_1X8:
+				if (vin->attr->dvp.gpio == DVP_PA_LOW_8BIT) {
+					input_cfg = DVP_RAW8; //RAW8 low_align
+				} else if (vin->attr->dvp.gpio == DVP_PA_HIGH_8BIT) {
+					input_cfg = DVP_RAW8|DVP_RAW_ALIG;//RAW8 high_align
+				}else{
+					printk("%s[%d] VIC failed to config DVP mode!(8bits-sensor)\n",__func__,__LINE__);
+					ret = -1;
+				}
+				break;
+			case V4L2_MBUS_FMT_SBGGR10_1X10:
+			case V4L2_MBUS_FMT_SGBRG10_1X10:
+			case V4L2_MBUS_FMT_SGRBG10_1X10:
+			case V4L2_MBUS_FMT_SRGGB10_1X10:
+				if(vin->attr->dvp.mode == SENSOR_DVP_SONY_MODE){
+					input_cfg = DVP_RAW12|DVP_SONY_MODE;
+					tx_isp_vic_writel(vsd,0x60, 0xffc);
+					tx_isp_vic_writel(vsd,0x68, 0xffc);
+				}else{
+					if (vin->attr->dvp.gpio == DVP_PA_LOW_10BIT) {
+						input_cfg = DVP_RAW10; //RAW10 low_align
+					} else if (vin->attr->dvp.gpio == DVP_PA_HIGH_10BIT) {
+						input_cfg = DVP_RAW10|DVP_RAW_ALIG;//RAW10 high_align
+					}else{
+						printk("%s[%d] VIC failed to config DVP mode!(10bits-sensor)\n",__func__,__LINE__);
+						ret = -1;
+					}
+				}
+				break;
+			case V4L2_MBUS_FMT_SBGGR12_1X12:
+			case V4L2_MBUS_FMT_SGBRG12_1X12:
+			case V4L2_MBUS_FMT_SGRBG12_1X12:
+			case V4L2_MBUS_FMT_SRGGB12_1X12:
+				if(vin->attr->dvp.mode == SENSOR_DVP_SONY_MODE){
+					input_cfg = DVP_RAW12|DVP_SONY_MODE;
+				}else{
+					input_cfg = DVP_RAW12;
+				}
+				break;
+			case V4L2_MBUS_FMT_RGB565_2X8_LE:
+				input_cfg = DVP_RGB565_16BIT;
+				break;
+			case V4L2_MBUS_FMT_BGR565_2X8_LE:
+				input_cfg = DVP_BRG565_16BIT;
+				break;
+			case V4L2_MBUS_FMT_UYVY8_1_5X8 :
+			case V4L2_MBUS_FMT_VYUY8_1_5X8 :
+			case V4L2_MBUS_FMT_YUYV8_1_5X8 :
+			case V4L2_MBUS_FMT_YVYU8_1_5X8 :
+			case V4L2_MBUS_FMT_YUYV8_1X16 :
+				input_cfg = DVP_YUV422_8BIT;
+				break;
+
+		}
+
+		if(vin->attr->dvp.polar.hsync_polar == DVP_POLARITY_LOW){
+			input_cfg |= HSYN_POLAR;
+		}
+
+		if(vin->attr->dvp.polar.vsync_polar == DVP_POLARITY_LOW){
+			input_cfg |= VSYN_POLAR;
+		}
+		tx_isp_vic_writel(vsd,VIC_DB_CFG, input_cfg);
+		if(vin->attr->dvp.blanking.hblanking) {
+			tx_isp_vic_writel(vsd, VIC_INPUT_HSYNC_BLANKING, vin->mbus.width + (vin->attr->dvp.blanking.hblanking << 16));
+		}
+#if defined(CONFIG_SOC_T30)
+		tx_isp_vic_writel(vsd, VIC_INPUT_HSYNC_BLANKING, vin->mbus.width + (vin->attr->dvp.blanking.hblanking << 16));
+		tx_isp_vic_writel(vsd, 0x150, 0x2);
+#endif
+		if(vin->attr->dvp.blanking.vblanking)
+			tx_isp_vic_writel(vsd, VIC_INPUT_VSYNC_BLANKING, vin->attr->dvp.blanking.vblanking);
+
+
+		ret = (vin->mbus.width<< 16) | (vin->mbus.height);
+		tx_isp_vic_writel(vsd,VIC_RESOLUTION, ret);
+		/*printk(" hblanking = %d vblanking = %d \n", vin->attr->dvp.blanking.hblanking, vin->attr->dvp.blanking.vblanking);*/
+		/*printk("************RESOLUTION : %08x***************\n", tx_isp_vic_readl(vsd,VIC_RESOLUTION));*/
+		tx_isp_vic_writel(vsd,VIC_GLOBAL_CFG, ISP_PRESET_MODE1);
+		tx_isp_vic_writel(vsd,VIC_CONTROL, REG_ENABLE);
+		tx_isp_vic_writel(vsd, VIC_CONTROL, VIC_SRART);
+		/*dump_vic_reg(dump_vsd);*/
+	}else{
+		tx_isp_vic_writel(vsd,VIC_DB_CFG, DVP_RAW12);//RAW12
+#if VIC_SUPPORT_MIPI
+		tx_isp_vic_writel(vsd,VIC_INTF_TYPE, INTF_TYPE_DVP);//DVP
+#endif
+		ret = (vin->mbus.width<< 16) | (vin->mbus.height);
+		tx_isp_vic_writel(vsd,VIC_RESOLUTION, ret);
+		tx_isp_vic_writel(vsd,VIC_GLOBAL_CFG, ISP_PRESET_MODE1);
+		tx_isp_vic_writel(vsd,CB_MODE0, 0x80008000);
+		tx_isp_vic_writel(vsd, VIC_CONTROL, VIC_SRART);
+	};
+	return ret;
+}
+
+static int vic_core_reset(struct v4l2_subdev *sd, u32 val)
+{
+/*reset*/
+	printk("functiong:%s, line:%d\n", __func__, __LINE__);
+	return 0;
+}
+static long vic_core_ops_private_ioctl(struct tx_isp_vic_driver *vsd, struct isp_private_ioctl *ctl)
+{
+	long ret = ISP_SUCCESS;
+	switch(ctl->cmd){
+		case TX_ISP_PRIVATE_IOCTL_MODULE_CLK:
+			ret = isp_vic_set_clk(vsd, ctl->value);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SUBDEV_PREPARE_CHANGE:
+			tx_isp_vic_writel(vsd, VIC_CONTROL, VIC_RESET);
+//			memcpy(&vsd->vin, (void *)(ctl->value), sizeof(struct tx_isp_video_in));
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SUBDEV_FINISH_CHANGE:
+			ret = tx_isp_vic_start(vsd);
+			break;
+		case TX_ISP_PRIVATE_IOCTL_SYNC_VIDEO_IN:
+			if(ctl->value)
+				memcpy(&vsd->vin, (void *)(ctl->value), sizeof(struct tx_isp_video_in));
+			else
+				memset(&vsd->vin, 0, sizeof(struct tx_isp_video_in));
+
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+static long vic_core_ops_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct tx_isp_vic_driver *vsd = sd_to_tx_isp_vic_driver(sd);
+	long ret = ISP_SUCCESS;
+	switch(cmd){
+		case VIDIOC_ISP_PRIVATE_IOCTL:
+			ret = vic_core_ops_private_ioctl(vsd, arg);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+
+static void vic_interrupts_enable(struct v4l2_subdev *sd)
+{
+	struct tx_isp_notify_argument arg;
+	/* vic frd interrupt */
+	arg.value = 0x10000 | (0x3 << 19);
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_ENABLE_IRQ, &arg);
+}
+
+static int vic_core_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct tx_isp_vic_driver *vsd = sd_to_tx_isp_vic_driver(sd);
+	int ret = 0;
+	if (enable) {
+		ret = tx_isp_vic_start(vsd);
+		/*printk("vic------------start\n");*/
+	}else {
+		tx_isp_vic_writel(vsd, VIC_CONTROL, GLB_SAFE_RST);
+	//	dump_vic_reg(vsd);
+		/*printk("vic--------------stop\n");*/
+	}
+	return ret;
+}
+
+static int isp_vic_interrupt_service_routine(struct v4l2_subdev *sd, u32 status, bool *handled)
+{
+	struct tx_isp_vic_driver *vd = sd_to_tx_isp_vic_driver(sd);
+	unsigned int tmp = 0;
+
+#ifdef CONFIG_SOC_T10
+	if((0x3 << 19) & status){
+		tmp = tx_isp_vic_readl(vd, VIC_CONTROL);
+		tmp |= VIC_RESET;
+		tx_isp_vic_writel(vd, VIC_CONTROL, tmp);
+		printk("## VIC ERROR status = 0x%08x\n", status);
+		tx_isp_vic_writel(vd, VIC_CONTROL, VIC_SRART);
+	}
+#else
+	if((vd->vic_frd_c < 30) && ((vd->vic_frd_c % 10) == 0)){
+		tmp = tx_isp_vic_readl(vd, VIC_CONTROL);
+		tmp |= VIC_RESET;
+		tx_isp_vic_writel(vd, VIC_CONTROL, tmp);
+	}
+
+	if((0x3 << 19) & status){
+		tmp = tx_isp_vic_readl(vd, VIC_CONTROL);
+		tmp |= VIC_RESET;
+		tx_isp_vic_writel(vd, VIC_CONTROL, tmp);
+		printk("## VIC ERROR status = 0x%08x\n", status);
+	}
+#endif
+
+	/*vic frd interrupt */
+	if (0x10000&status) {
+		vd->vic_frd_c++;
+	}
+
+	return ISP_SUCCESS;
+}
+
+static int vic_core_ops_init(struct v4l2_subdev *sd, u32 on)
+{
+	/* enable vic interrups */
+	vic_interrupts_enable(sd);
+	return ISP_SUCCESS;
+}
+
+static const struct v4l2_subdev_core_ops vic_core_ops = {
+	.init = vic_core_ops_init,
+	.reset = vic_core_reset,
+	.ioctl = vic_core_ops_ioctl,
+	.interrupt_service_routine = isp_vic_interrupt_service_routine,
+};
+
+static const struct v4l2_subdev_video_ops vic_video_ops = {
+	.s_stream = vic_core_s_stream,
+};
+
+static const struct v4l2_subdev_ops vic_subdev_ops = {
+	.core = &vic_core_ops,
+	.video = &vic_video_ops,
+};
+
+
+static int vic_link_setup(struct media_entity *entity,
+			  const struct media_pad *local,
+			  const struct media_pad *remote, u32 flags)
+{
+	return ISP_SUCCESS;
+}
+/* media operations */
+static const struct media_entity_operations vic_media_ops = {
+	.link_setup = vic_link_setup,
+};
+
+/* vic frd info */
+static int isp_vic_frd_show(struct seq_file *m, void *v)
+{
+	int len = 0;
+	struct tx_isp_vic_driver *vd = (struct tx_isp_vic_driver*)(m->private);
+	len += seq_printf(m ," %d\n", vd->vic_frd_c);
+	return len;
+}
+static int dump_isp_vic_frd_open(struct inode *inode, struct file *file)
+{
+	return single_open_size(file, isp_vic_frd_show, PDE_DATA(inode),8192);
+}
+static const struct file_operations isp_vic_frd_fops ={
+	.read = seq_read,
+	.open = dump_isp_vic_frd_open,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+int register_tx_isp_vic_device(struct platform_device *pdev, struct v4l2_device *v4l2_dev)
+{
+	struct tx_isp_subdev_platform_data *pdata = pdev->dev.platform_data;
+	struct tx_isp_vic_driver *vsd = NULL;
+	struct resource *res = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct media_pad *pads = NULL;
+	struct media_entity *me = NULL;
+	struct proc_dir_entry *proc;
+	int ret;
+
+	if(!pdata){
+		v4l2_err(v4l2_dev, "The platform_data of csi is NULL!\n");
+		ret = -ISP_ERROR;
+		goto exit;
+	};
+	vsd = (struct tx_isp_vic_driver *)kzalloc(sizeof(*vsd), GFP_KERNEL);
+	if(!vsd){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor device\n");
+		ret = -ISP_ERROR;
+		goto exit;
+	}
+	vsd->pdata = pdata;
+	vsd->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if(res){
+		res = request_mem_region(res->start,
+				res->end - res->start + 1, dev_name(&pdev->dev));
+		if (!res) {
+			v4l2_err(v4l2_dev, "Not enough memory for resources\n");
+			ret = -EBUSY;
+			goto mem_region_failed;
+		}
+		vsd->base = ioremap(res->start, res->end - res->start + 1);
+		if (!vsd->base) {
+			v4l2_err(v4l2_dev, "Unable to ioremap registers!\n");
+			ret = -ENXIO;
+			goto ioremap_failed;
+		}
+	}
+	vsd->res = res;
+	sd = &vsd->sd;
+	pads = vsd->pads;
+	me = &sd->entity;
+
+	v4l2_subdev_init(sd, &vic_subdev_ops);
+	strlcpy(sd->name, "TX-ISP-VIC-SUBDEV ", sizeof(sd->name));
+
+	sd->grp_id = pdata->grp_id ;	/* group ID for isp subdevs */
+	v4l2_set_subdevdata(sd, vsd);
+
+	pads[TX_ISP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	pads[TX_ISP_PAD_LINK].flags = MEDIA_PAD_FL_SINK;
+
+	me->ops = &vic_media_ops;
+//	me->parent = v4l2_dev->mdev;
+	ret = media_entity_init(me, TX_ISP_PADS_NUM, pads, 0);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to init media entity!\n");
+		ret = -ISP_ERROR;
+		goto entity_init_failed;
+	}
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to register vic-subdev!\n");
+		ret = -ISP_ERROR;
+		goto register_failed;
+	}
+
+	ret = isp_vic_init_clk(vsd);
+	if(ret < 0){
+		v4l2_err(v4l2_dev, "Failed to init isp's clks!\n");
+		ret = -ISP_ERROR;
+	}
+	dump_vsd=vsd;
+
+	/* creat the node of printing isp info */
+	proc = jz_proc_mkdir("vic");
+	if (!proc) {
+		vsd->proc_vic = NULL;
+		v4l2_err(v4l2_dev, "create dev_attr_isp_info failed!\n");
+	} else {
+		vsd->proc_vic = proc;
+	}
+	proc_create_data("isp_vic_frd", S_IRUGO, proc, &isp_vic_frd_fops, (void *)vsd);
+
+	return ISP_SUCCESS;
+register_failed:
+	media_entity_cleanup(me);
+entity_init_failed:
+	if(vsd->base)
+		iounmap(vsd->base);
+ioremap_failed:
+	if(res)
+		release_mem_region(res->start,res->end - res->start + 1);
+mem_region_failed:
+	kfree(vsd);
+exit:
+	return ret;
+}
+
+void release_tx_isp_vic_device(struct v4l2_subdev *sd)
+{
+	struct tx_isp_vic_driver *vsd = v4l2_get_subdevdata(sd);
+	struct resource *res = vsd->res;
+	isp_vic_release_clk(vsd);
+	media_entity_cleanup(&sd->entity);
+
+	v4l2_device_unregister_subdev(sd);
+
+	iounmap(vsd->base);
+	release_mem_region(res->start,res->end - res->start + 1);
+	if (vsd->proc_vic) {
+		proc_remove(vsd->proc_vic);
+	}
+	kfree(vsd);
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-vic.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-vic.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-vic.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-vic.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,33 @@
+#ifndef __TX_ISP_VIC_H__
+#define __TX_ISP_VIC_H__
+
+#include <tx-isp-common.h>
+#include <tx-vic-regs.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <jz_proc.h>
+struct tx_isp_vic_driver {
+	struct device *dev;
+	struct v4l2_subdev sd;
+	struct media_pad pads[TX_ISP_PADS_NUM];
+	struct resource *res;
+	struct tx_isp_video_in vin;
+	void __iomem *base;
+	void * pdata;
+	struct clk **clks;
+	unsigned int clk_num;
+	/* vic frd interrupt cnt */
+	struct proc_dir_entry *proc_vic;
+	unsigned int vic_frd_c;
+
+};
+
+#define tx_isp_vic_readl(port,reg)						\
+	__raw_readl((volatile unsigned int *)(port->base + reg))
+#define tx_isp_vic_writel(port,reg, value)					\
+	__raw_writel((value), (volatile unsigned int *)(port->base + reg))
+#define sd_to_tx_isp_vic_driver(sd) (container_of(sd, struct tx_isp_vic_driver, sd))
+int register_tx_isp_vic_device(struct platform_device *pdev, struct v4l2_device *v4l2_dev);
+void release_tx_isp_vic_device(struct v4l2_subdev *sd);
+void check_vic_error(void);
+#endif /* __TX_ISP_VIC_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-videobuf.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-videobuf.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-videobuf.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-videobuf.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,262 @@
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+#include <media/videobuf2-memops.h>
+#include "tx-isp-debug.h"
+#include "tx-isp-videobuf.h"
+
+static void frame_channel_vb2_put(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	struct vb2_dc_conf *conf = buf->conf;
+
+	if (atomic_dec_and_test(&buf->refcount)) {
+		mutex_lock(&conf->mlock);
+		conf->mmap.used -= PAGE_ALIGN(buf->size);
+		mutex_unlock(&conf->mlock);
+		kfree(buf);
+	}
+}
+
+static void *frame_channel_vb2_alloc(void *alloc_ctx, unsigned long size, gfp_t gfp_flags)
+{
+	struct vb2_dc_conf *conf = alloc_ctx;
+	struct vb2_mmap_conf *mmap = &conf->mmap;
+	struct vb2_dc_buf *buf;
+
+	mutex_lock(&conf->mlock);
+	if(conf->mmap_enable == 0){
+		mutex_unlock(&conf->mlock);
+		return NULL;
+	}
+
+//	printk("~~~~~~~~ %s[%d] size = %d ~~~~~~~~~~\n",__func__,__LINE__,size);
+	if(mmap->used >= mmap->size){
+		mutex_unlock(&conf->mlock);
+		return NULL;
+	}
+	mutex_unlock(&conf->mlock);
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+	mutex_lock(&conf->mlock);
+	buf->vaddr = mmap->vaddr + mmap->used;
+	buf->paddr = mmap->paddr + mmap->used;
+	mmap->used += PAGE_ALIGN(size);
+	mutex_unlock(&conf->mlock);
+
+	buf->conf = conf;
+	buf->size = size;
+	buf->handler.refcount = &buf->refcount;
+	buf->handler.put = frame_channel_vb2_put;
+	buf->handler.arg = buf;
+
+	atomic_inc(&buf->refcount);
+
+	return buf;
+}
+
+static void *frame_channel_vb2_cookie(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+
+	return (void *)buf->paddr;
+}
+
+static void *frame_channel_vb2_vaddr(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	if (!buf)
+		return 0;
+
+	return buf->vaddr;
+}
+
+static unsigned int frame_channel_vb2_num_users(void *buf_priv)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+
+	return atomic_read(&buf->refcount);
+}
+
+static int frame_channel_vb2_mmap(void *buf_priv, struct vm_area_struct *vma)
+{
+	struct vb2_dc_buf *buf = buf_priv;
+	int ret = 0;
+	unsigned long size = min_t(unsigned long, vma->vm_end - vma->vm_start, buf->size);
+	if (!buf) {
+		ISP_PRINT(ISP_ERROR_LEVEL,KERN_ERR "No buffer to map\n");
+		return -EINVAL;
+	}
+#if 0
+	struct vb2_dc_conf *conf = buf->conf;
+	/*
+	 * dma_mmap_* uses vm_pgoff as in-buffer offset, but we want to
+	 * map whole buffer
+	 */
+	vma->vm_pgoff = 0;
+
+	ret = dma_mmap_coherent(conf->dev, vma, buf->vaddr,
+		buf->paddr, buf->size);
+
+	if (ret) {
+		pr_err("Remapping memory failed, error: %d\n", ret);
+		return ret;
+	}
+#else
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	ret = remap_pfn_range(vma, vma->vm_start, ((unsigned long)buf->paddr) >> PAGE_SHIFT,
+					size, vma->vm_page_prot);
+	if(ret){
+		printk(KERN_ERR "Remapping memory failed, error: %d\n", ret);
+		return ret;
+	}
+#endif
+	vma->vm_flags		|= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_private_data	= &buf->handler;
+	vma->vm_ops		= &vb2_common_vm_ops;
+
+	vma->vm_ops->open(vma);
+
+	pr_debug("%s: mapped dma addr 0x%08lx at 0x%08lx, size %ld\n",
+		__func__, (unsigned long)buf->paddr, vma->vm_start,
+		buf->size);
+
+
+//	ret = vb2_mmap_pfn_range(vma, buf->paddr, buf->size,
+//				  &vb2_common_vm_ops, &buf->handler);
+	printk("virtureaddr = 0x%08lx physicaladdr = 0x%08x\n", vma->vm_start,buf->paddr);
+	return ret;
+}
+
+static void *frame_channel_vb2_get_userptr(void *alloc_ctx, unsigned long vaddr,
+					unsigned long size, int write)
+{
+	struct vb2_dc_buf *buf;
+
+	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+#if 0
+	struct vb2_dc_conf *conf = alloc_ctx;
+	struct vm_area_struct *vma;
+	dma_addr_t paddr = 0;
+	int ret = 0;
+	if(conf->tlb_enable){
+		/* tlb mmap ops */
+		buf->vma = NULL;
+	}else{
+		ret = vb2_get_contig_userptr(vaddr, size, &vma, &paddr);
+		if (ret) {
+			ISP_PRINT(ISP_ERROR_LEVEL,KERN_ERR "Failed acquiring VMA for vaddr 0x%08lx\n",
+					vaddr);
+			kfree(buf);
+			return ERR_PTR(ret);
+		}
+		buf->vma = vma;
+	}
+	buf->size = size;
+	buf->paddr = paddr;
+	buf->vaddr = (void *)vaddr;
+#endif
+	buf->size = size;
+	buf->paddr = (dma_addr_t)vaddr;
+	buf->vaddr = (void *)vaddr;
+
+	return buf;
+}
+
+static void frame_channel_vb2_put_userptr(void *mem_priv)
+{
+	struct vb2_dc_buf *buf = mem_priv;
+
+	if (!buf)
+		return;
+#if 0
+	struct vb2_dc_conf *conf = buf->conf;
+	if(conf->tlb_enable != 0)
+		vb2_put_vma(buf->vma);
+#endif
+	kfree(buf);
+}
+
+const struct vb2_mem_ops frame_channel_vb2_memops = {
+	.alloc		= frame_channel_vb2_alloc,
+	.put		= frame_channel_vb2_put,
+	.cookie		= frame_channel_vb2_cookie,
+	.vaddr		= frame_channel_vb2_vaddr,
+	.mmap		= frame_channel_vb2_mmap,
+	.get_userptr	= frame_channel_vb2_get_userptr,
+	.put_userptr	= frame_channel_vb2_put_userptr,
+	.num_users	= frame_channel_vb2_num_users,
+};
+
+#ifdef	CONFIG_ISP_MODULE_USE_MMAP
+static int frame_buffer_mmap_init(struct vb2_mmap_conf *mmap, struct device *dev)
+{
+	mmap->dev = dev;
+	mmap->used = 0;
+	mmap->size = TX_ISP_FRAME_CHANNEL_BUFFER_MAX;
+	mmap->vaddr = dma_alloc_coherent(mmap->dev, mmap->size, &mmap->paddr,
+					GFP_KERNEL);
+	if (!mmap->vaddr) {
+		dev_err(mmap->dev, "dma_alloc_coherent of size %ld failed\n",
+			mmap->size);
+		return -ENOMEM;
+	}
+	memset(mmap->vaddr, 0x2f, mmap->size);
+	printk("~~~~~~~~ %s[%d] vaddr = 0x%08x paddr = 0x%08x ~~~~~~~~~~\n",__func__,__LINE__,
+				(unsigned int)mmap->vaddr, (unsigned int)mmap->paddr);
+	return ISP_SUCCESS;
+}
+#endif
+
+static int frame_buffer_mmap_deinit(struct vb2_mmap_conf *mmap)
+{
+	if(mmap && mmap->vaddr && mmap->used == 0){
+		dma_free_coherent(mmap->dev, mmap->size, mmap->vaddr,mmap->paddr);
+		return ISP_SUCCESS;
+	}
+	return -EPERM;
+}
+void *frame_buffer_manager_create(struct device *dev)
+{
+	struct vb2_dc_conf *conf;
+	int ret = ISP_SUCCESS;
+
+	conf = (struct vb2_dc_conf *)kzalloc(sizeof(*conf), GFP_KERNEL);
+	if (!conf)
+		return ERR_PTR(-ENOMEM);
+	conf->tlb_enable = 0;
+	conf->mmap_enable = 0;
+
+#ifdef	CONFIG_ISP_MODULE_WITH_TLB
+	conf->tlb_enable = 1;
+#endif
+#ifdef	CONFIG_ISP_MODULE_USE_MMAP
+	conf->mmap_enable = 1;
+	ret = frame_buffer_mmap_init(&(conf->mmap), dev);
+#endif
+	if(ret != ISP_SUCCESS)
+		goto exit;
+	conf->dev = dev;
+	mutex_init(&conf->mlock);
+	return conf;
+exit:
+	kfree(conf);
+	return NULL;
+}
+
+int frame_buffer_manager_cleanup(void *alloc_ctx)
+{
+	int ret = ISP_SUCCESS;
+	struct vb2_dc_conf *conf =  (struct vb2_dc_conf *)alloc_ctx;
+	if(conf->mmap_enable)
+		ret = frame_buffer_mmap_deinit(&(conf->mmap));
+	if(ret == ISP_SUCCESS)
+		kfree(alloc_ctx);
+	return ret;
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-videobuf.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-videobuf.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-videobuf.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-videobuf.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,57 @@
+#ifndef __TX_ISP_VIDEOBUF_H__
+#define __TX_ISP_VIDEOBUF_H__
+
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-memops.h>
+#include <linux/dma-mapping.h>
+#include <mach/tx_isp.h>
+
+/*#define TX_ISP_FRAME_CHANNEL_BUFFER_MAX         (26 * 1024 * 1024)*/
+
+// If the system mem is smaller, reserved 4M mem.
+#define TX_ISP_FRAME_CHANNEL_BUFFER_MAX         (4 * 1024 * 1024)
+
+extern const struct vb2_mem_ops frame_channel_vb2_memops;
+
+struct vb2_mmap_conf {
+	struct device			*dev;
+	void				*vaddr;
+	dma_addr_t			paddr;
+	unsigned long			size;
+	unsigned long			used;
+};
+
+
+struct vb2_dc_conf {
+	struct device		*dev;
+
+	/* MMAP related */
+	int mmap_enable;
+	struct vb2_mmap_conf	mmap;
+
+	/* USERPTR related */
+	int tlb_enable;
+	void 			*tlb;
+
+	struct mutex mlock;
+};
+
+struct vb2_dc_buf {
+	struct vb2_dc_conf		*conf;
+	void				*vaddr;
+	dma_addr_t			paddr;
+//	enum dma_data_direction		dma_dir;
+	unsigned long			size;
+
+	/* MMAP related */
+	struct vb2_vmarea_handler	handler;
+	atomic_t			refcount;
+
+	/* USERPTR related */
+	struct vm_area_struct		*vma;
+};
+
+void *frame_buffer_manager_create(struct device *dev);
+int frame_buffer_manager_cleanup(void *alloc_ctx);
+
+#endif/* __TX_ISP_VIDEOBUF_H__ */
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-video-in.c kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-video-in.c
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-video-in.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-video-in.c	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,560 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/v4l2-mediabus.h>
+
+#include "tx-isp-video-in.h"
+/*
+ * Sensor subdevice helper functions
+ */
+static long subdev_core_ops_register_sensor(struct tx_isp_video_in_device *vi, void *arg)
+{
+	struct v4l2_tx_isp_sensor_register_info *info = arg;
+	struct v4l2_device *v4l2_dev = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+	int ret = ISP_SUCCESS;
+
+	if (!vi || !info)
+		return -ISP_ERROR;
+	v4l2_dev = vi->sd.v4l2_dev;
+	if(atomic_read(&vi->state) == TX_ISP_STATE_STOP){
+		v4l2_warn(v4l2_dev, "the devnode does't have been opened.\n");
+		return -ISP_ERROR;
+	}
+#if 0
+	if(atomic_read(&vi->state) == TX_ISP_STATE_RUN){
+		v4l2_warn(v4l2_dev, "the devnode is running,please stop it firstly.\n");
+		return -ISP_ERROR;
+	}
+#endif
+#if 0
+	/* sensor */
+	sensor = (struct tx_isp_sensor_instance *)kzalloc(sizeof(*sensor), GFP_KERNEL);
+	if(!sensor){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor subdev.\n",);
+		return -ENOMEM;
+	}
+#endif
+	if(info->cbus_type == TX_SENSOR_CONTROL_INTERFACE_I2C){
+		struct i2c_adapter *adapter;
+		struct i2c_board_info board_info;
+		adapter = i2c_get_adapter(info->i2c.i2c_adapter_id);
+		if (!adapter) {
+			v4l2_warn(v4l2_dev,
+					"Failed to get I2C adapter %d, deferring probe\n",
+					info->i2c.i2c_adapter_id);
+			return -ISP_ERROR;
+		}
+		memset(&board_info, 0 , sizeof(board_info));
+		memcpy(&board_info.type, &info->i2c.type, I2C_NAME_SIZE);
+		board_info.addr = info->i2c.addr;
+		sd = v4l2_i2c_new_subdev_board(v4l2_dev, adapter,
+				&board_info, NULL);
+		if (IS_ERR_OR_NULL(sd)) {
+			i2c_put_adapter(adapter);
+			v4l2_warn(v4l2_dev,
+					"Failed to acquire subdev %s, deferring probe\n",
+					info->i2c.type);
+			return -ISP_ERROR;
+		}
+	}else if (info->cbus_type == TX_SENSOR_CONTROL_INTERFACE_SPI){
+	}else{
+		v4l2_warn(v4l2_dev, "%s[%d] the type of sensor SBUS hasn't been defined.\n",__func__,__LINE__);
+		return -ISP_ERROR;
+	}
+	/* add private data of sensor */
+	sensor = (struct tx_isp_sensor *)v4l2_get_subdev_hostdata(sd);
+	sensor->info = *info;
+
+	ret = v4l2_subdev_call(sd, core, g_chip_ident, NULL);
+	if(ret != ISP_SUCCESS){
+		if(info->cbus_type == TX_SENSOR_CONTROL_INTERFACE_I2C){
+			struct i2c_client *client = v4l2_get_subdevdata(sd);
+			struct i2c_adapter *adapter = client->adapter;
+			if (adapter)
+				i2c_put_adapter(adapter);
+		//	i2c_unregister_device(client);
+		}else{
+		}
+		v4l2_device_unregister_subdev(sd);
+		return -ISP_ERROR;
+	}
+
+	spin_lock(&vi->slock);
+	list_add_tail(&sensor->list, &vi->sensors);
+	spin_unlock(&vi->slock);
+
+	v4l2_info(v4l2_dev, "Registered sensor subdevice %s\n", sd->name);
+	return ISP_SUCCESS;
+}
+static long subdev_core_ops_release_sensor(struct tx_isp_video_in_device *vi, void *arg)
+{
+	struct v4l2_tx_isp_sensor_register_info *info = arg;
+	struct v4l2_device *v4l2_dev = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+
+	if (!vi || !info)
+		return -ISP_ERROR;
+	v4l2_dev = vi->sd.v4l2_dev;
+	if(atomic_read(&vi->state) == TX_ISP_STATE_STOP){
+		v4l2_warn(v4l2_dev, "the devnode does't have been opened.\n");
+		return -ISP_ERROR;
+	}
+
+	spin_lock(&vi->slock);
+	list_for_each_entry(sensor, &vi->sensors, list) {
+		if(!strcmp(sensor->info.name, info->name)){
+			sd = &sensor->sd;
+			break;
+		}
+	}
+	/* when can't find the matching sensor, do nothing!*/
+	if(!sd){
+		spin_unlock(&vi->slock);
+		return ISP_SUCCESS;
+	}
+	/* when the sensor is active, please stop it firstly.*/
+	if(sensor == vi->active){
+		spin_unlock(&vi->slock);
+		v4l2_warn(v4l2_dev, "the sensor is active, please stop it firstly.\n");
+		return -ISP_ERROR;
+	}
+
+	list_del(&sensor->list);
+	spin_unlock(&vi->slock);
+
+	if(sensor->info.cbus_type == TX_SENSOR_CONTROL_INTERFACE_I2C){
+		struct i2c_client *client = v4l2_get_subdevdata(sd);
+		struct i2c_adapter *adapter = client->adapter;
+		if (adapter)
+			i2c_put_adapter(adapter);
+		i2c_unregister_device(client);
+
+	}else if (sensor->info.cbus_type == TX_SENSOR_CONTROL_INTERFACE_SPI){
+	}else{
+		v4l2_warn(v4l2_dev, "%s[%d] the type of sensor SBUS hasn't been defined.\n",__func__,__LINE__);
+		return -ISP_ERROR;
+	}
+//	v4l2_device_unregister_subdev(sd);
+	return ISP_SUCCESS;
+}
+
+static long subdev_core_ops_release_all_sensor(struct tx_isp_video_in_device *vi)
+{
+	struct v4l2_device *v4l2_dev = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+
+	if (!vi)
+		return -ISP_ERROR;
+	v4l2_dev = vi->sd.v4l2_dev;
+	if(atomic_read(&vi->state) == TX_ISP_STATE_STOP){
+		v4l2_warn(v4l2_dev, "the devnode does't have been opened.\n");
+		return -ISP_ERROR;
+	}
+
+	while(!list_empty(&vi->sensors)){
+		sensor = list_first_entry(&vi->sensors, struct tx_isp_sensor, list);
+		list_del(&sensor->list);
+		sd = &sensor->sd;
+		if(sensor->info.cbus_type == TX_SENSOR_CONTROL_INTERFACE_I2C){
+			struct i2c_client *client = v4l2_get_subdevdata(sd);
+			struct i2c_adapter *adapter = client->adapter;
+			if (adapter)
+				i2c_put_adapter(adapter);
+			i2c_unregister_device(client);
+
+		}else if (sensor->info.cbus_type == TX_SENSOR_CONTROL_INTERFACE_SPI){
+		}else{
+			v4l2_warn(v4l2_dev, "%s[%d] the type of sensor SBUS hasn't been defined.\n",__func__,__LINE__);
+			return -ISP_ERROR;
+		}
+	}
+	return ISP_SUCCESS;
+}
+
+
+
+/*
+* vi->sensorssensorindex
+*/
+static long subdev_core_ops_enum_input(struct tx_isp_video_in_device *vi, void *arg)
+{
+	struct v4l2_input *input = (struct v4l2_input *)arg;
+	struct v4l2_device *v4l2_dev = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+	int i = 0;
+
+	if (!vi || !input){
+		return -ISP_ERROR;
+	}
+	v4l2_dev = vi->sd.v4l2_dev;
+
+	spin_lock(&vi->slock);
+	list_for_each_entry(sensor, &vi->sensors, list) {
+		sensor->index = i++;
+		if(sensor->index == input->index){
+			input->type = sensor->type;
+			strncpy(input->name, sensor->info.name, sizeof(sensor->info.name));
+			break;
+		}
+	}
+	spin_unlock(&vi->slock);
+	if(sensor->index != input->index)
+		return -ISP_ERROR;
+
+	return 0;
+}
+/*
+* vi->active sensor index
+*/
+static long subdev_core_ops_get_input(struct tx_isp_video_in_device *vi, int *index)
+{
+	if (!vi || !index)
+		return -ISP_ERROR;
+	*index = IS_ERR_OR_NULL(vi->active) ? -1 : vi->active->index;
+	return ISP_SUCCESS;
+}
+/*
+*
+*/
+static long subdev_core_ops_set_input(struct tx_isp_video_in_device *vi, int *index)
+{
+	struct v4l2_device *v4l2_dev = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+	struct tx_isp_notify_argument arg;
+	struct v4l2_subdev *sd = NULL;
+	int ret = ISP_SUCCESS;
+	if (!vi || !index)
+		return -ISP_ERROR;
+
+	/*firstly, Determine whether the point to the same sensor */
+	if(vi->active && *index == vi->active->index)
+		return ISP_SUCCESS;
+
+	v4l2_dev = vi->sd.v4l2_dev;
+	sensor = vi->active;
+
+	/* secondly, streamoff, deinit and unprepare previous sensor. */
+	if(sensor){
+		if(atomic_read(&vi->state) == TX_ISP_STATE_RUN){
+			v4l2_warn(v4l2_dev, "Please, streamoff sensor firstly!\n");
+			return -ISP_ERROR;
+		}
+		ret = tx_isp_pipeline_call(vi->p, init, 0);
+		if(ret != ISP_SUCCESS){
+			v4l2_warn(v4l2_dev, "Failed to deinit the pipeline of %s.\n", sensor->attr.name);
+			goto err_exit;
+		}
+		ret = tx_isp_pipeline_call(vi->p, unprepare);
+		if(ret != ISP_SUCCESS){
+			v4l2_warn(v4l2_dev, "Failed to unprepare the pipeline of %s.\n", sensor->attr.name);
+			goto err_exit;
+		}
+		vi->p->subdevs[vi->sd.grp_id] = NULL;
+		vi->active = NULL;
+
+		arg.value = 0;
+		sd = &sensor->sd;
+		sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_SYNC_VIDEO_IN, &arg);
+		if(arg.ret != ISP_SUCCESS)
+			goto err_exit;
+	}
+
+	/* third, s_input NULL .*/
+	if(-1 == *index){
+		return ISP_SUCCESS;
+	}
+	/* fourth, find a corresponding sensor.*/
+	spin_lock(&vi->slock);
+	list_for_each_entry(sensor, &vi->sensors, list) {
+		if(sensor->index == *index){
+			break;
+		}
+	}
+	spin_unlock(&vi->slock);
+
+	/* if the index isn't find in the list of sensors that has been registered.*/
+	if(sensor->index != *index){
+		v4l2_err(v4l2_dev, "Failed to the set input sensor(%d) that .\n", *index);
+		return -ISP_ERROR;
+	}
+
+	/*lastly, prepare, init and streamon active sensor */
+	vi->active = sensor;
+	vi->p->subdevs[vi->sd.grp_id] = &sensor->sd;
+
+	sd = &sensor->sd;
+	arg.value = (int)&sensor->video;
+	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_SYNC_VIDEO_IN, &arg);
+	if(arg.ret != ISP_SUCCESS)
+		goto err_exit;
+
+	ret = tx_isp_pipeline_call(vi->p, prepare); //&sensor->video);
+	if(ret != ISP_SUCCESS){
+		v4l2_warn(v4l2_dev, "Failed to prepare the pipeline of %s.\n", sensor->attr.name);
+		goto err_prepare;
+	}
+	ret = tx_isp_pipeline_call(vi->p, init, 1);
+	if(ret != ISP_SUCCESS){
+		v4l2_warn(v4l2_dev, "Failed to deinit the pipeline of %s.\n", sensor->attr.name);
+		goto err_init;
+	}
+
+	return ISP_SUCCESS;
+err_prepare:
+	tx_isp_pipeline_call(vi->p, unprepare);
+err_init:
+err_exit:
+	return ret;
+}
+
+static long subdev_core_ops_streamon(struct tx_isp_video_in_device *vi, int enable)
+{
+	struct v4l2_device *v4l2_dev = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+	int ret = ISP_SUCCESS;
+	if (!vi)
+		return -ISP_ERROR;
+
+	if(atomic_read(&vi->state) == TX_ISP_STATE_RUN){
+		return ISP_SUCCESS;
+	}
+
+	v4l2_dev = vi->sd.v4l2_dev;
+	sensor = vi->active;
+
+	if(sensor){
+		ret = tx_isp_pipeline_call(vi->p, set_stream, enable);
+		if(ret == ISP_SUCCESS){
+			atomic_set(&vi->state, TX_ISP_STATE_RUN);
+		}else{
+			v4l2_err(v4l2_dev, "Failed to streamon the pipeline of %s.\n",
+							sensor->attr.name);
+		}
+	}else{
+		v4l2_warn(v4l2_dev, "There isn't sensor that has been selected!\n");
+	}
+	return ret;
+}
+
+static long subdev_core_ops_streamoff(struct tx_isp_video_in_device *vi, int enable)
+{
+	struct v4l2_device *v4l2_dev = NULL;
+	struct tx_isp_sensor *sensor = NULL;
+	int ret = ISP_SUCCESS;
+	if (!vi)
+		return -ISP_ERROR;
+
+	if(atomic_read(&vi->state) != TX_ISP_STATE_RUN){
+		return ISP_SUCCESS;
+	}
+
+	v4l2_dev = vi->sd.v4l2_dev;
+	sensor = vi->active;
+
+	if(sensor){
+		ret = tx_isp_pipeline_call(vi->p, set_stream, enable);
+		if(ret == ISP_SUCCESS){
+			atomic_set(&vi->state, TX_ISP_STATE_START);
+		}else{
+			v4l2_err(v4l2_dev, "Failed to streamoff the pipeline of %s.\n",
+							sensor->attr.name);
+		}
+	}else{
+		v4l2_warn(v4l2_dev, "There isn't sensor that has been selected!\n");
+	}
+	return ret;
+}
+
+static long video_in_core_ops_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct tx_isp_video_in_device *vi = sd_to_tx_video_in_device(sd);
+	long ret = 0;
+	switch(cmd){
+		case VIDIOC_ENUMINPUT:
+			ret = subdev_core_ops_enum_input(vi, arg);
+			break;
+		case VIDIOC_G_INPUT:
+			ret = subdev_core_ops_get_input(vi, arg);
+			break;
+		case VIDIOC_S_INPUT:
+			ret = subdev_core_ops_set_input(vi, arg);
+			break;
+		case VIDIOC_REGISTER_SENSOR:
+			ret = subdev_core_ops_register_sensor(vi, arg);
+			break;
+		case VIDIOC_RELEASE_SENSOR:
+			ret = subdev_core_ops_release_sensor(vi, arg);
+			break;
+		case VIDIOC_STREAMON:
+			ret = subdev_core_ops_streamon(vi, 1);
+			break;
+		case VIDIOC_STREAMOFF:
+			ret = subdev_core_ops_streamoff(vi, 0);
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+
+int tx_isp_video_in_subdev_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct tx_isp_video_in_device *vi = sd_to_tx_video_in_device(sd);
+	struct tx_isp_notify_argument arg;
+	if(atomic_read(&vi->state) == TX_ISP_STATE_STOP){
+		atomic_set(&vi->state, TX_ISP_STATE_START);
+		sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_GET_PIPELINE, &arg);
+		if(arg.ret != ISP_SUCCESS)
+			return -ISP_ERROR;
+		vi->p = (struct tx_isp_media_pipeline *)arg.value;
+	}
+	vi->refcnt++;
+	return 0;
+}
+int tx_isp_video_in_subdev_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct tx_isp_video_in_device *vi = sd_to_tx_video_in_device(sd);
+	struct v4l2_device *v4l2_dev = NULL;
+	int ret = ISP_SUCCESS;
+	int index;
+	vi->refcnt--;
+
+	v4l2_dev = vi->sd.v4l2_dev;
+	if(!vi->refcnt){
+		if (atomic_read(&vi->state) == TX_ISP_STATE_RUN){
+			ret = subdev_core_ops_streamoff(vi, 0);
+			if(ret < 0){
+				v4l2_err(v4l2_dev, "%s[%d] the device is running; Failed to stop it!\n",
+					__func__,__LINE__);
+			}else{
+				index = -1;
+				subdev_core_ops_set_input(vi, &index);
+				subdev_core_ops_release_all_sensor(vi);
+			}
+		}
+		if(atomic_read(&vi->state) == TX_ISP_STATE_START)
+			atomic_set(&vi->state, TX_ISP_STATE_STOP);
+	}
+	return ret;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int tx_isp_video_in_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct tx_isp_video_in_device *vi = sd_to_tx_video_in_device(sd);
+	struct tx_isp_sensor *sensor = vi->active;
+	if(sensor){
+		v4l2_subdev_call(&sensor->sd, core, g_register, reg);
+	}
+	return 0;
+}
+static int tx_isp_video_in_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)
+{
+	struct tx_isp_video_in_device *vi = sd_to_tx_video_in_device(sd);
+	struct tx_isp_sensor *sensor = vi->active;
+	if(sensor){
+		v4l2_subdev_call(&sensor->sd, core, s_register, reg);
+	}
+	return 0;
+}
+#endif
+
+static const struct v4l2_subdev_internal_ops video_in_subdev_internal_ops ={
+	.open = tx_isp_video_in_subdev_open,
+	.close = tx_isp_video_in_subdev_close,
+};
+static struct v4l2_subdev_core_ops video_in_subdev_core_ops ={
+	.ioctl = &video_in_core_ops_ioctl,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = tx_isp_video_in_g_register,
+	.s_register = tx_isp_video_in_s_register,
+#endif
+};
+static struct v4l2_subdev_ops video_in_subdev_ops ={
+	.core = &video_in_subdev_core_ops,
+};
+/* media operations */
+static int video_in_link_setup(struct media_entity *entity,
+			  const struct media_pad *local,
+			  const struct media_pad *remote, u32 flags)
+{
+	return ISP_SUCCESS;
+}
+static const struct media_entity_operations video_in_media_ops = {
+	.link_setup = video_in_link_setup,
+};
+int register_tx_isp_video_in_device(void *pdata, struct v4l2_device *v4l2_dev)
+{
+	struct tx_isp_video_in_device *vi = NULL;
+	struct v4l2_subdev *sd = NULL;
+	struct media_pad *pads = NULL;
+	struct media_entity *me = NULL;
+	int ret;
+
+	vi = (struct tx_isp_video_in_device *)kzalloc(sizeof(*vi), GFP_KERNEL);
+	if(!vi){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor subdev\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	spin_lock_init(&vi->slock);
+	INIT_LIST_HEAD(&vi->sensors);
+	vi->refcnt = 0;
+	vi->pdata = pdata;
+	sd = &vi->sd;
+	pads = vi->pads;
+	me = &sd->entity;
+
+	v4l2_subdev_init(sd, &video_in_subdev_ops);
+	sd->internal_ops = &video_in_subdev_internal_ops;
+	strlcpy(sd->name, "tx-isp-video-in", sizeof(sd->name));
+
+	sd->grp_id = vi->pdata->grp_id;	/* group ID for isp subdevs */
+	v4l2_set_subdevdata(sd, vi);
+
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	pads[TX_ISP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	pads[TX_ISP_PAD_LINK].flags = MEDIA_PAD_FL_SINK;
+
+	me->ops = &video_in_media_ops;
+	ret = media_entity_init(me, TX_ISP_PADS_NUM, pads, 0);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to allocate sensor device\n");
+		ret = -ISP_ERROR;
+		goto entity_init_failed;
+	}
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0){
+		v4l2_err(v4l2_dev, "Failed to register sensor-subdev!\n");
+		ret = -ISP_ERROR;
+		goto register_failed;
+	}
+	/* set state of the subdev */
+	atomic_set(&vi->state, TX_ISP_STATE_STOP);
+	return ISP_SUCCESS;
+register_failed:
+	media_entity_cleanup(me);
+entity_init_failed:
+	kfree(vi);
+exit:
+	return ret;
+}
+
+void release_tx_isp_video_in_device(struct v4l2_subdev *sd)
+{
+	struct tx_isp_video_in_device *vi = v4l2_get_subdevdata(sd);
+
+	v4l2_device_unregister_subdev(&vi->sd);
+	kfree(vi);
+}
diff -Nura kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-video-in.h kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-video-in.h
--- kernel-3.10.14/drivers/media/platform/tx-isp/tx-isp-video-in.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-3.10.14_mod/drivers/media/platform/tx-isp/tx-isp-video-in.h	2018-03-20 12:23:26.000000000 +0100
@@ -0,0 +1,21 @@
+#ifndef __TX_ISP_SENSOR_H__
+#define __TX_ISP_SENSOR_H__
+#include <tx-isp-common.h>
+
+struct tx_isp_video_in_device {
+	struct v4l2_subdev sd;
+	struct list_head sensors;
+	struct tx_isp_sensor *active; /* the sensor instance */
+	struct media_pad pads[TX_ISP_PADS_NUM];
+
+	struct tx_isp_media_pipeline *p;
+	spinlock_t slock;
+	atomic_t state;
+	unsigned int refcnt;
+	struct tx_isp_subdev_platform_data *pdata;
+};
+
+#define sd_to_tx_video_in_device(sd) (container_of(sd, struct tx_isp_video_in_device, sd))
+int register_tx_isp_video_in_device(void *pdata, struct v4l2_device *v4l2_dev);
+void release_tx_isp_video_in_device(struct v4l2_subdev *sd);
+#endif /* __TX_ISP_SENSOR_H__ */
